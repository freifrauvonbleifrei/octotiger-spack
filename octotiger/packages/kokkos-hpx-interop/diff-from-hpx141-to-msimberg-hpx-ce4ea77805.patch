diff --git a/.circleci/config.yml b/.circleci/config.yml
index 29bc809d5d..22142f7f33 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -117,7 +117,7 @@ jobs:
           path: /tmp/circular_deps.svg
           destination: /hpx/artifacts/circular_deps.svg
 
-  # Insure that the modules stay clang-formatted
+  # Ensure that the modules stay clang-formatted
   clang_format:
     <<: *defaults
     steps:
@@ -127,7 +127,7 @@ jobs:
           name: Check that the modules are well clang-formatted
           command: |
               cd /hpx/source/libs && shopt -s globstar # to activate the ** globbing
-              clang-format-8 -i **/*.{cpp,hpp}
+              clang-format -i **/*.{cpp,hpp}
               git diff --exit-code > /tmp/modified_format_files.txt
       - store_artifacts:
           path: /tmp/modified_format_files.txt
@@ -249,6 +249,27 @@ jobs:
           paths:
             - ./build/bin/inspect
 
+  # We need a full clone here to be able to compare to master.
+  spellcheck:
+    <<: *defaults
+    steps:
+      - checkout:
+          path: /hpx/source
+      - run:
+          name: Running codespell
+          command: |
+              if [ "$CIRCLE_PR_NUMBER" ]; then
+                  cd /hpx/source
+                  codespell --ignore-words tools/.codespell_whitelist --skip='*.h5,*.png' $(git diff --name-only origin/master) > /tmp/spelling_suggestions.txt
+                  if [ -s /tmp/spelling_suggestions.txt ]; then exit 1; fi
+              else
+                  echo "skipping spellcheck on non-PR build"
+              fi
+          when: always
+      - store_artifacts:
+          path: /tmp/spelling_suggestions.txt
+          destination: /hpx/artifacts/spelling_suggestions.txt
+
   docs:
     <<: *defaults
     steps:
@@ -284,7 +305,7 @@ jobs:
       - run:
           name: Building Core
           command: |
-              ninja -j2 core
+              ninja -j2 -k 0 core
       - persist_to_workspace:
           root: /hpx
           paths:
@@ -531,32 +552,6 @@ jobs:
       - store_artifacts:
           path: tests.unit.parcelset
 
-  tests.unit.performance_counter:
-    <<: *defaults
-    steps:
-      - attach_workspace:
-          at: /hpx
-      - run:
-          name: Building Unit Tests
-          command: |
-              ninja -j2 -k 0 tests.unit.performance_counter
-      - run:
-          name: Running Unit Tests
-          when: always
-          command: |
-              ulimit -c unlimited
-              ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.performance_counter
-      - run:
-          <<: *convert_xml
-      - run:
-          <<: *move_core_dump
-      - run:
-          <<: *move_debug_log
-      - store_test_results:
-          path: tests.unit.performance_counter
-      - store_artifacts:
-          path: tests.unit.performance_counter
-
   tests.unit.resource:
     <<: *defaults
     steps:
@@ -717,6 +712,7 @@ jobs:
               ninja -j2 -k 0 tests.unit.modules.hashing
               ninja -j2 -k 0 tests.unit.modules.iterator_support
               ninja -j2 -k 0 tests.unit.modules.logging
+              ninja -j2 -k 0 tests.unit.modules.performance_counters
               ninja -j2 -k 0 tests.unit.modules.preprocessor
               ninja -j2 -k 0 tests.unit.modules.program_options
               ninja -j2 -k 0 tests.unit.modules.resiliency
@@ -725,6 +721,7 @@ jobs:
               ninja -j2 -k 0 tests.unit.modules.statistics
               ninja -j2 -k 0 tests.unit.modules.testing
               ninja -j2 -k 0 tests.unit.modules.thread_support
+              ninja -j2 -k 0 tests.unit.modules.threading_base
               ninja -j2 -k 0 tests.unit.modules.threadmanager
               ninja -j2 -k 0 tests.unit.modules.timing
               ninja -j2 -k 0 tests.unit.modules.topology
@@ -755,6 +752,7 @@ jobs:
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.hashing
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.iterator_support
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.logging
+              ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.performance_counters
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.preprocessor
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.program_options
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.resiliency
@@ -763,6 +761,7 @@ jobs:
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.statistics
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.testing
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.thread_support
+              ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.threading_base
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.threadmanager
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.timing
               ctest --timeout 60 -T test --no-compress-output --output-on-failure -R tests.unit.modules.topology
@@ -909,7 +908,7 @@ jobs:
       - run:
           name: Building Performance Tests
           command: |
-              ninja -j2 tests.performance
+              ninja -j2 -k 0 tests.performance
 
   examples:
     <<: *defaults
@@ -919,7 +918,7 @@ jobs:
       - run:
           name: Building Examples
           command: |
-              ninja -j2 examples
+              ninja -j2 -k 0 examples
       - persist_to_workspace:
           root: /hpx
           paths:
@@ -1001,7 +1000,7 @@ jobs:
           name: Push stable tag
           command: |
               if [[ -z "$CIRCLE_PR_NUMBER" ]] && [[ "$CIRCLE_BRANCH" == "master" ]]; then
-                  # Tag the commmit
+                  # Tag the commit
                   cd /hpx/source
                   git tag -f stable
                   ##########################################################
@@ -1043,6 +1042,8 @@ workflows:
           requires:
             - configure
           <<: *gh_pages_filter
+      - spellcheck:
+          <<: *gh_pages_filter
       - docs:
           requires:
             - configure
@@ -1076,8 +1077,6 @@ workflows:
           <<: *core_dependency
       - tests.unit.parcelset:
           <<: *core_dependency
-      - tests.unit.performance_counter:
-          <<: *core_dependency
       - tests.unit.resource:
           <<: *core_dependency
       - tests.unit.threads:
@@ -1111,9 +1110,7 @@ workflows:
           <<: *gh_pages_filter
       - install:
           requires:
-            - inspect
             - core
-            - docs
             - tests.examples
             - tests.unit.actions
             - tests.unit.agas
@@ -1123,7 +1120,6 @@ workflows:
             - tests.unit.lcos
             - tests.unit.parallel_block
             - tests.unit.parcelset
-            - tests.unit.performance_counter
             - tests.unit.resource
             - tests.unit.threads
             - tests.unit.topology
diff --git a/.clang-format b/.clang-format
index 9b83ab3de9..4db7d761ec 100644
--- a/.clang-format
+++ b/.clang-format
@@ -42,6 +42,7 @@ AlwaysBreakTemplateDeclarations: true
 BinPackArguments: true
 BinPackParameters: true
 BraceWrapping:
+    AfterCaseLabel: true
     AfterClass: true
     AfterControlStatement: true
     AfterEnum: true
@@ -72,18 +73,20 @@ FixNamespaceComments: true
 IncludeCategories:
   - Regex:           '^<hpx/config\.hpp>'
     Priority:        1
-  - Regex:           '^<hpx/.*/config\.hpp>'
+  - Regex:           '^<hpx/config/.*\.hpp>'
     Priority:        2
-  - Regex:           '^<hpx/.*/config/defines\.hpp>'
+  - Regex:           '^<hpx/.*/config\.hpp>'
     Priority:        3
-  - Regex:           '^<hpx/.*\.hpp>'
+  - Regex:           '^<hpx/.*/config/defines\.hpp>'
     Priority:        4
-  - Regex:           '^<hpx/parallel/.*\.hpp>'
+  - Regex:           '^<hpx/.*\.hpp>'
     Priority:        5
-  - Regex:           '^<.*'
+  - Regex:           '^<hpx/parallel/.*\.hpp>'
     Priority:        6
-  - Regex:           '.*'
+  - Regex:           '^<.*'
     Priority:        7
+  - Regex:           '.*'
+    Priority:        8
 # IncludeIsMainRegex: ''
 IndentCaseLabels: false
 IndentWidth: 4
diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
new file mode 100644
index 0000000000..4e1c30a2ea
--- /dev/null
+++ b/.github/CODEOWNERS
@@ -0,0 +1,13 @@
+# Copyright (c) 2020 STE||AR Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+* @aurianer @biddisco @hkaiser @msimberg
+
+/docs/ @msimberg
+/libs/**/*.txt @aurianer @msimberg
+/libs/**/*.rst @aurianer @msimberg
+/libs/**/*.py @aurianer @msimberg
+/libs/**/*.sh @aurianer @msimberg
diff --git a/.github/SUPPORT.md b/.github/SUPPORT.md
index f780efef53..bf89ae5673 100644
--- a/.github/SUPPORT.md
+++ b/.github/SUPPORT.md
@@ -29,7 +29,7 @@ get support for using HPX.
 
 ### Mailing Lists/Groups
 
-* [hpx-users group](email:hpx-users@stellar.cct.lsu.edu), see
+* [hpx-users group](mailto:hpx-users@stellar-group.org), see
   [here](https://www.mail-archive.com/hpx-users@stellar.cct.lsu.edu) for past
   conversations.
 
diff --git a/.github/workflows/macos.yml b/.github/workflows/macos.yml
new file mode 100644
index 0000000000..3fc5fb534c
--- /dev/null
+++ b/.github/workflows/macos.yml
@@ -0,0 +1,57 @@
+# Copyright (c) 2020 Mikael Simberg
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+name: macOS CI
+
+on: [push]
+
+jobs:
+  build:
+
+    runs-on: macos-latest
+
+    steps:
+    - uses: actions/checkout@v2
+    - name: Install dependencies
+      run: |
+        brew update && \
+            brew install boost hwloc gperftools ninja && \
+            brew upgrade cmake
+    - name: Configure
+      shell: bash
+      run: |
+          cmake \
+              -H. \
+              -Bbuild \
+              -GNinja \
+              -DCMAKE_BUILD_TYPE=Debug \
+              -DHPX_WITH_EXAMPLES=ON \
+              -DHPX_WITH_TESTS=ON
+    - name: Build
+      shell: bash
+      run: |
+          cmake --build build --target all
+          cmake --build build --target tests
+    - name: Test
+      shell: bash
+      run: |
+          cd build
+          ctest --output-on-failure \
+            --exclude-regex \
+          "tests.regressions.modules.collectives.distributed.tcp.broadcast_apply|\
+          tests.regressions.modules.collectives.distributed.tcp.broadcast_unwrap_future_2885|\
+          tests.unit.modules.algorithms.destroy|\
+          tests.unit.modules.algorithms.default_construct|\
+          tests.unit.modules.execution.standalone_thread_pool_executor|\
+          tests.unit.modules.resource_partitioner.used_pus|\
+          tests.unit.modules.segmented_algorithms.distributed.tcp.partitioned_vector|\
+          tests.performance.local.wait_all_timings|\
+          tests.regressions.lcos.wait_all_hang_1946|\
+          tests.regressions.dynamic_counters_loaded_1508|\
+          tests.unit.threads.distributed.tcp.thread_stacksize|\
+          tests.unit.topology.numa_allocator|\
+          tests.examples.quickstart.1d_wave_equation|\
+          tests.examples.transpose.transpose_block_numa"
diff --git a/.github/workflows/windows.yml b/.github/workflows/windows.yml
new file mode 100644
index 0000000000..85b9296912
--- /dev/null
+++ b/.github/workflows/windows.yml
@@ -0,0 +1,71 @@
+# Copyright (c) 2020 Mikael Simberg
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+name: Windows CI
+
+on: [push]
+
+jobs:
+  build:
+
+    runs-on: windows-latest
+
+    steps:
+    - uses: actions/checkout@v2
+    - name: Install dependencies
+      run: |
+        md C:\projects
+        $client = new-object System.Net.WebClient
+        $client.DownloadFile("http://stellar-group.org/files/vcpkg-export-hpx-dependencies.7z","C:\projects\vcpkg-export-hpx-dependencies.7z")
+        7z x C:\projects\vcpkg-export-hpx-dependencies.7z -y -oC:\projects\vcpkg
+    - name: Configure
+      shell: bash
+      run: |
+          cmake . -Bbuild -G'Visual Studio 16 2019' -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE='C:/projects/vcpkg/scripts/buildsystems/vcpkg.cmake' -DHPX_WITH_PSEUDO_DEPENDENCIES=OFF -DHPX_WITH_EXAMPLES=ON -DHPX_WITH_TESTS=ON -DHPX_WITH_DEPRECATION_WARNINGS=OFF -DHPX_WITH_TESTS_MAX_THREADS_PER_LOCALITY=2
+    - name: Build
+      shell: bash
+      run: |
+          cmake --build build --config Debug --target ALL_BUILD -- -maxcpucount -verbosity:minimal -nologo
+    - name: Test
+      shell: bash
+      run: |
+          cd build
+          ctest \
+          --output-on-failure \
+            --build-config Debug \
+            --exclude-regex \
+          "tests.examples.modules.checkpoint.1d_stencil_4_checkpoint|\
+          tests.examples.modules.program_options.config_file_types|\
+          tests.examples.modules.program_options.custom_syntax|\
+          tests.examples.modules.program_options.env_options|\
+          tests.examples.modules.program_options.first|\
+          tests.examples.modules.program_options.multiple_sources|\
+          tests.examples.modules.program_options.option_groups|\
+          tests.examples.modules.program_options.options_description|\
+          tests.examples.modules.program_options.options_hierarchy|\
+          tests.examples.modules.program_options.real|\
+          tests.examples.modules.program_options.regex|\
+          tests.examples.modules.program_options.response_file|\
+          tests.examples.modules.resiliency.1d_stencil_replay_exception|\
+          tests.examples.modules.resiliency.1d_stencil_replay_validate|\
+          tests.examples.modules.resiliency.async_replay|\
+          tests.examples.modules.resiliency.async_replicate|\
+          tests.examples.modules.resiliency.async_replicate_vote|\
+          tests.examples.modules.resiliency.dataflow_replicate|\
+          tests.examples.modules.resiliency.version|\
+          tests.examples.modules.resource_partitioner.simplest_resource_partitioner_1|\
+          tests.examples.modules.resource_partitioner.simplest_resource_partitioner_2|\
+          tests.examples.modules.resource_partitioner.async_customization|\
+          tests.examples.modules.resource_partitioner.oversubscribing_resource_partitioner|\
+          tests.examples.modules.resource_partitioner.simple_resource_partitioner|\
+          tests.examples.modules.resource_partitioner.guided_pool_test|\
+          tests.examples.1d_stencil.1d_stencil_6|\
+          tests.examples.1d_stencil.1d_stencil_7|\
+          tests.examples.quickstart.1d_wave_equation|\
+          tests.examples.quickstart.partitioned_vector_spmd_foreach|\
+          tests.examples.thread_aware_timer.thread_aware_timer|\
+          tests.examples.transpose.transpose_block_numa" \
+            -R tests.examples
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0e243152e2..cae7899789 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,12 +14,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-# We require at least CMake V3.6.3
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
-
-if (HPX_WITH_CUDA AND CMAKE_VERSION VERSION_LESS 3.9)
-  message(FATAL_ERROR "CUDA support requires at least CMake 3.9.")
-endif()
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 # Overrides must go before the project() statement, otherwise they are ignored.
 
@@ -64,10 +59,10 @@ endif()
 # Build all of HPX
 ################################################################################
 set(HPX_VERSION_MAJOR 1)
-set(HPX_VERSION_MINOR 4)
-set(HPX_VERSION_SUBMINOR 1)
-set(HPX_VERSION_DATE 20200219)
-set(HPX_VERSION_TAG "")
+set(HPX_VERSION_MINOR 5)
+set(HPX_VERSION_SUBMINOR 0)
+set(HPX_VERSION_DATE 20200212)
+set(HPX_VERSION_TAG "-trunk")
 
 set(HPX_VERSION "${HPX_VERSION_MAJOR}.${HPX_VERSION_MINOR}.${HPX_VERSION_SUBMINOR}")
 set(HPX_LIBRARY_VERSION "${HPX_VERSION}")
@@ -82,32 +77,20 @@ set(HPX_BINARY_DIR "${PROJECT_BINARY_DIR}")
 ################################################################################
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${PROJECT_SOURCE_DIR}/cmake")
 
-# To fix the windows link bug (need to be included only once!)
-include(HPX_FilterLibrariesMSVC)
-
 include(GNUInstallDirs)
 include(HPX_Utils)
 
 # explicitly set certain policies
-cmake_policy(VERSION 3.6.3)
+cmake_policy(VERSION 3.13)
 hpx_set_cmake_policy(CMP0042 NEW)
-if(${CMAKE_VERSION} VERSION_LESS "3.11.0")
-  # the old behavior not supported for newer cmake versions anymore
-  hpx_set_cmake_policy(CMP0054 OLD)
-endif()
 hpx_set_cmake_policy(CMP0060 NEW)
-
-# If we have a cmake version older than 3.12, we can't rely on CONFIGURE_DEPENDS
-if(${CMAKE_VERSION} VERSION_LESS "3.12")
-  set(DO_CONFIGURE_DEPENDS)
-else()
-  set(DO_CONFIGURE_DEPENDS CONFIGURE_DEPENDS)
-endif()
+hpx_set_cmake_policy(CMP0074 NEW)
 
 # We save the passed compiler flag to a special variable. This is needed for our
 # build system unit tests. Some flags might influence the created symbols
 # (_GLIBCXX_DEBUG i look at you)
 set(CMAKE_CXX_FLAGS_SAFE ${CMAKE_CXX_FLAGS})
+include(HPX_CheckCXXStandard)
 
 include(CheckCXXCompilerFlag)
 include(CMakeDependentOption)
@@ -135,6 +118,11 @@ unset(HPX_EXPORT_MODULES_TARGETS CACHE)
 unset(HPX_LIBS CACHE)
 unset(HPX_STATIC_PARCELPORT_PLUGINS CACHE)
 
+################################################################################
+# Set up dummy compiler flags targets
+################################################################################
+include(HPX_CompilerFlagsTargets)
+
 ################################################################################
 # Fortran compiler detection
 #
@@ -298,10 +286,18 @@ else()
     ON CATEGORY "Build Targets")
 endif()
 
+set(HPX_WITH_DYNAMIC_HPX_MAIN_DEFAULT OFF)
+if("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux" OR APPLE)
+  set(HPX_WITH_DYNAMIC_HPX_MAIN_DEFAULT ON)
+endif()
+
 hpx_option(HPX_WITH_DYNAMIC_HPX_MAIN BOOL
-  "Enable dynamic overload of system ``main()`` (Linux only, default: ON)"
-  ON ADVANCED)
+  "Enable dynamic overload of system ``main()`` (Linux and Apple only, default: ON)"
+  ${HPX_WITH_DYNAMIC_HPX_MAIN_DEFAULT} ADVANCED)
 if(HPX_WITH_DYNAMIC_HPX_MAIN)
+  if(NOT HPX_WITH_DYNAMIC_HPX_MAIN_DEFAULT)
+    hpx_error("HPX_WITH_DYNAMIC_HPX_MAIN was set to ON, but the option is only available on Linux and Apple (this is \"${CMAKE_SYSTEM_NAME}\").")
+  endif()
   hpx_add_config_cond_define(HPX_HAVE_DYNAMIC_HPX_MAIN 1)
 endif()
 
@@ -390,10 +386,6 @@ hpx_option(HPX_WITH_CUDA BOOL
   "Enable CUDA support (default: OFF)" OFF ADVANCED)
 hpx_option(HPX_WITH_CUDA_CLANG BOOL
   "Use clang to compile CUDA code (default: OFF)" OFF ADVANCED)
-hpx_option(HPX_WITH_HCC BOOL
-  "Enable hcc support (default: OFF)" OFF ADVANCED)
-hpx_option(HPX_WITH_SYCL BOOL
-  "Enable sycl support (default: OFF)" OFF ADVANCED)
 
 ################################################################################
 # HPX datapar configuration
@@ -419,18 +411,14 @@ endif()
 ################################################################################
 # Native TLS configuration
 ################################################################################
-set(HPX_WITH_NATIVE_TLS_DEFAULT ON)
-if(APPLE)
-  set(HPX_WITH_NATIVE_TLS_DEFAULT ${HPX_WITH_CXX11_THREAD_LOCAL})
-endif()
 hpx_option(HPX_WITH_NATIVE_TLS BOOL
   "Use native TLS support if available (default: ${HPX_WITH_NATIVE_TLS_DEFAULT})"
-  ${HPX_WITH_NATIVE_TLS_DEFAULT} ADVANCED)
+  ON ADVANCED)
 if(HPX_WITH_NATIVE_TLS)
   hpx_info("Native TLS is enabled.")
   hpx_add_config_define(HPX_HAVE_NATIVE_TLS)
 else()
-  hpx_info("Native TLS is disabled.")
+  hpx_error("Native TLS is disabled. HPX requires native TLS. This option will be removed in a future release.")
 endif()
 
 ################################################################################
@@ -476,7 +464,7 @@ if(HPX_WITH_AUTOMATIC_SERIALIZATION_REGISTRATION)
 endif()
 
 hpx_option(HPX_WITH_ZERO_COPY_SERIALIZATION_THRESHOLD STRING
-  "The threshhold in bytes to when perform zero copy optimizations (default: 128)"
+  "The threshold in bytes to when perform zero copy optimizations (default: 128)"
   "128"
   ADVANCED)
 hpx_add_config_define(HPX_ZERO_COPY_SERIALIZATION_THRESHOLD ${HPX_WITH_ZERO_COPY_SERIALIZATION_THRESHOLD})
@@ -541,6 +529,10 @@ hpx_option(HPX_WITH_THREAD_BACKTRACE_ON_SUSPENSION BOOL
 # global variables
 add_library(hpx_base_libraries INTERFACE)
 
+if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
+  target_link_libraries(hpx_base_libraries INTERFACE imf svml irng intlc)
+endif()
+
 if(HPX_WITH_STACKTRACES OR HPX_WITH_THREAD_BACKTRACE_ON_SUSPENSION)
   hpx_info("Stack traces are enabled.")
   hpx_add_config_define(HPX_HAVE_STACKTRACES)
@@ -549,8 +541,8 @@ if(HPX_WITH_STACKTRACES OR HPX_WITH_THREAD_BACKTRACE_ON_SUSPENSION)
   endif()
 
   hpx_option(HPX_WITH_THREAD_BACKTRACE_DEPTH STRING
-    "Thread stack back trace depth being captured (default: 5)"
-    "5"
+    "Thread stack back trace depth being captured (default: 20)"
+    "20"
     CATEGORY "Thread Manager" ADVANCED)
   hpx_add_config_define(HPX_HAVE_THREAD_BACKTRACE_DEPTH
     ${HPX_WITH_THREAD_BACKTRACE_DEPTH})
@@ -984,6 +976,11 @@ hpx_option(HPX_WITH_TESTS_DEBUG_LOG_DESTINATION STRING
   "cout"
   CATEGORY "Debugging" ADVANCED)
 
+hpx_option(HPX_WITH_TESTS_MAX_THREADS_PER_LOCALITY STRING
+  "Maximum number of threads to use for tests (default: 0, use the number of threads specified by the test)"
+  0
+  CATEGORY "Debugging" ADVANCED)
+
 # If APEX is defined, the action timers need thread debug info.
 if(HPX_WITH_APEX)
     hpx_add_config_define(HPX_HAVE_THREAD_DESCRIPTION)
@@ -1079,8 +1076,8 @@ endif()
 
 # Check if the selected compiler versions are supposed to work with our codebase
 if(CMAKE_COMPILER_IS_GNUCXX AND HPX_WITH_GCC_VERSION_CHECK)
-  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5.0)
-    hpx_error("GCC 5.0 or higher is required. Specify HPX_GCC_VERSION_CHECK=OFF to ignore this error.")
+  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0)
+    hpx_error("GCC 7.0 or higher is required. Specify HPX_GCC_VERSION_CHECK=OFF to ignore this error.")
   endif()
 endif()
 
@@ -1155,43 +1152,12 @@ hpx_add_target_compile_definition(HPX_DISABLE_ASSERTS PUBLIC
 hpx_add_target_compile_definition(BOOST_DISABLE_ASSERTS PUBLIC
   CONFIGURATIONS Release RelWithDebInfo MinSizeRelease)
 
-# Make sure we compile in proper C++xx mode (MSVC uses it automatically)
-include(HPX_DetectCppDialect)
-hpx_detect_cpp_dialect()
-
-# Store option value passed by an user for HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION.
-if(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION)
-  set(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION_ADVANCED )
-  set(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION_GIVEN ON)
-else()
-  set(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION_ADVANCED ADVANCED)
-  set(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION_GIVEN OFF)
-endif()
-
 ################################################################################
 # C++ feature tests
 ################################################################################
 include(HPX_PerformCxxFeatureTests)
 hpx_perform_cxx_feature_tests()
 
-# Exceptional handling for non-clang CUDA.
-if(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION)
-  if(HPX_WITH_CUDA AND NOT HPX_WITH_CUDA_CLANG)
-    # means using default value (given value).
-    unset(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION)
-  endif()
-endif()
-
-# HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION
-# Default value is used only when HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION is not defined.
-hpx_option(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION BOOL
-  "Enable the use of auto as a return value in some places. Overriding this flag is only necessary if the C++ compiler is not standard compliant, e.g. nvcc."
-  ${HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION_GIVEN}
-  ${HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION_ADVANCED})
-if(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION)
-  hpx_add_config_define(HPX_HAVE_CXX14_RETURN_TYPE_DEDUCTION)
-endif()
-
 ################################################################################
 # Set configuration option to use Boost.Context or not. This depends on the
 # platform.
@@ -1355,9 +1321,6 @@ if(WIN32)
   ##############################################################################
 
   hpx_add_config_cond_define(BOOST_USE_WINDOWS_H)
-  if (NOT Boost_USE_STATIC_LIBS)
-    hpx_add_config_cond_define(BOOST_SERIALIZATION_DYN_LINK)
-  endif()
   if(NOT CMAKE_CL_64)
     hpx_add_config_cond_define(BOOST_NO_ALIGNMENT)
   endif()
@@ -1420,6 +1383,10 @@ if(HPX_WITH_COMPILER_WARNINGS)
     hpx_add_compile_flag_if_available(-Wno-attributes LANGUAGES CXX)
     hpx_add_compile_flag_if_available(-Wno-cast-align LANGUAGES CXX)
 
+    # We do not in general guarantee ABI compatibility between C++ standards, so
+    # we ignore this warning
+    hpx_add_compile_flag_if_available(-Wno-noexcept-type LANGUAGES CXX)
+
     # These are usually benign and can't be suppressed because of
     # interface requirements
     hpx_add_compile_flag_if_available(-Wno-unused-parameter)
@@ -1614,7 +1581,7 @@ hpx_option(HPX_FILESYSTEM_WITH_BOOST_FILESYSTEM_COMPATIBILITY
 # Find Our dependencies:
 #   These are all dependencies needed to build the core library. Dependencies
 #   that are only needed by plugins, examples or tests should be found
-#   seperately in the appropriate subdirectory.
+#   separately in the appropriate subdirectory.
 
 # Setup our required Boost libraries.
 include(HPX_SetupBoost)
@@ -1749,11 +1716,6 @@ endif()
 set(CMAKE_DEBUG_POSTFIX "d")
 set(HPX_DEBUG_POSTFIX "d")
 
-################################################################################
-# Set up dummy compiler flags target
-################################################################################
-include(HPX_CompilerFlagsTarget)
-
 if(HPX_WITH_COMPRESSION_BZIP2)
   hpx_add_config_define(HPX_HAVE_COMPRESSION_BZIP2)
 endif()
@@ -1873,52 +1835,6 @@ install( # Install all HPX cmake utility files
   PATTERN "packaging" EXCLUDE
   PATTERN ".git" EXCLUDE)
 
-install( # Install HPX Python scripts
-  DIRECTORY python/scripts/
-  DESTINATION ${CMAKE_INSTALL_BINDIR}
-  FILE_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE
-                   GROUP_READ GROUP_EXECUTE
-                   WORLD_READ WORLD_EXECUTE
-  COMPONENT core
-  FILES_MATCHING PATTERN "*.py"
-  PATTERN ".git" EXCLUDE)
-
-#   if(UNIX)
-#     file(GLOB scripts "${PROJECT_SOURCE_DIR}/python/scripts/*.py")
-#     execute_process(COMMAND "${CMAKE_COMMAND}" -E make_directory
-#       "${PROJECT_BINARY_DIR}/python/scripts" )
-#     foreach(script ${scripts})
-#       get_filename_component(script_name ${script} NAME)
-#       get_filename_component(script_name_we ${script} NAME_WE)
-#
-#       #make copy, so that we have intact symlink in PROJECT_BINARY_DIR
-#       execute_process(
-#         COMMAND "${CMAKE_COMMAND}" -E copy_if_different "${script}" "${script_name}"
-#   WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/python/scripts")
-#
-#       execute_process(
-#         COMMAND "${CMAKE_COMMAND}" -E create_symlink "${script_name}" "${script_name_we}"
-#   WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/python/scripts")
-#
-#       install(FILES "${PROJECT_BINARY_DIR}/python/scripts/${script_name_we}" DESTINATION "${CMAKE_INSTALL_BINDIR}")
-#     endforeach()
-#   endif()
-#
-#   install( # Install HPX Python module (TODO: this is a temporary hack)
-#     DIRECTORY python/hpx
-#     DESTINATION ${CMAKE_INSTALL_DATADIR}/hpx-${HPX_VERSION}/python
-#     COMPONENT core
-#     FILES_MATCHING PATTERN "*.py"
-#     PATTERN ".git" EXCLUDE)
-#
-#   execute_process(COMMAND "${CMAKE_COMMAND}" -E make_directory "${PROJECT_BINARY_DIR}/python" )
-#   #make symlink, so that we have intact hpx symlink in PROJECT_BINARY_DIR
-#   execute_process(COMMAND "${CMAKE_COMMAND}" -E create_symlink "${PROJECT_SOURCE_DIR}/python/hpx"
-#     "hpx-${HPX_VERSION}" WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/python")
-#   # create a symlink in share pointing to the latest HPX installation
-#   execute_process(COMMAND "${CMAKE_COMMAND}" -E create_symlink "hpx-${HPX_VERSION}" "hpx" WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/python")
-#   install(DIRECTORY "${PROJECT_BINARY_DIR}/python/hpx" DESTINATION "${CMAKE_INSTALL_DATADIR}")
-
 if("${HPX_PLATFORM_UC}" STREQUAL "XEONPHI")
   # FIXME: push changes upstream
   install(
diff --git a/README.rst b/README.rst
index 4e280f5853..ee2274bcdc 100644
--- a/README.rst
+++ b/README.rst
@@ -1,5 +1,5 @@
 ..
-    Copyright (c) 2007-2019 Louisiana State University
+    Copyright (c) 2007-2020 Louisiana State University
 
     SPDX-License-Identifier: BSL-1.0
     Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -8,9 +8,9 @@
 |circleci_status| |zenodo_doi| |codacy|
 
 Documentation: `latest
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/index.html>`_,
+<https://stellar-group.github.io/hpx-docs/latest/html/index.html>`_,
 `development (master)
-<https://stellar-group.github.io/hpx/docs/sphinx/branches/master/html/index.html>`_
+<https://stellar-group.github.io/hpx-docs/branches/master/html/index.html>`_
 
 ===
 HPX
@@ -69,16 +69,16 @@ which can be downloaded `here <https://stellar.cct.lsu.edu/downloads/>`_.
 
 To quickly get started with HPX on most Linux distributions you can read the
 quick start guide `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/quickstart.html>`_.
+<https://stellar-group.github.io/hpx-docs/latest/html/quickstart.html>`_.
 Detailed instructions on building and installing HPX on various platforms can be
 found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/manual/building_hpx.html>`_.
+<https://stellar-group.github.io/hpx-docs/latest/html/manual/building_hpx.html>`_.
 The full documentation for the latest release of HPX can always be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/index.html>`_.
+<https://stellar-group.github.io/hpx-docs/latest/html/index.html>`_.
 
 If you would like to work with the cutting edge version of this repository
 (``master`` branch) the documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/branches/master/html/index.html>`_.
+<https://stellar-group.github.io/hpx-docs/branches/master/html/index.html>`_.
 We strongly recommend that you follow the current health status of the master
 branch by looking at our `continuous integration results website
 <http://rostam.cct.lsu.edu/console>`_. While we try to keep the master branch
diff --git a/cmake/HPX_AddCompileFlag.cmake b/cmake/HPX_AddCompileFlag.cmake
index 000f5fc72f..be68afaeb8 100644
--- a/cmake/HPX_AddCompileFlag.cmake
+++ b/cmake/HPX_AddCompileFlag.cmake
@@ -8,10 +8,6 @@ include(CMakeParseArguments)
 include(CheckCCompilerFlag)
 include(CheckCXXCompilerFlag)
 
-# on startup, this is unset, but we'll set it to an empty string anyway
-set_property(GLOBAL PROPERTY HPX_TARGET_COMPILE_DEFINITIONS "")
-set_property(GLOBAL PROPERTY HPX_TARGET_COMPILE_OPTIONS "")
-
 function(hpx_add_target_compile_option FLAG)
   set(options PUBLIC)
   set(one_value_args)
@@ -19,11 +15,11 @@ function(hpx_add_target_compile_option FLAG)
   cmake_parse_arguments(HPX_ADD_TARGET_COMPILE_OPTION "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})
 
   if(HPX_ADD_TARGET_COMPILE_OPTION_PUBLIC)
-    set(_dest HPX_TARGET_COMPILE_OPTIONS_PUBLIC)
+    set(_dest hpx_public_flags)
   else()
-    set(_dest HPX_TARGET_COMPILE_OPTIONS_PRIVATE)
+    set(_dest hpx_private_flags)
   endif()
-  
+
   set(_configurations "none")
   if(HPX_ADD_TARGET_COMPILE_OPTION_CONFIGURATIONS)
     set(_configurations ${HPX_ADD_TARGET_COMPILE_OPTION_CONFIGURATIONS})
@@ -40,7 +36,7 @@ function(hpx_add_target_compile_option FLAG)
       if(NOT _config STREQUAL "none")
         set(_conf "$<$<AND:$<CONFIG:${_config}>,$<COMPILE_LANGUAGE:${_lang}>>:${FLAG}>")
       endif()
-      set_property(GLOBAL APPEND PROPERTY ${_dest} "${_conf}")
+      target_compile_options(${_dest} INTERFACE "${_conf}")
     endforeach()
   endforeach()
 
@@ -138,10 +134,11 @@ function(hpx_add_target_compile_definition FLAG)
   cmake_parse_arguments(HPX_ADD_TARGET_COMPILE_DEFINITION "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})
 
   if(HPX_ADD_TARGET_COMPILE_DEFINITION_PUBLIC)
-    set(_dest HPX_TARGET_COMPILE_DEFINITIONS_PUBLIC)
+    set(_dest hpx_public_flags)
   else()
-    set(_dest HPX_TARGET_COMPILE_DEFINITIONS_PRIVATE)
+    set(_dest hpx_private_flags)
   endif()
+
   set(_configurations "none")
   if(HPX_ADD_TARGET_COMPILE_DEFINITION_CONFIGURATIONS)
     set(_configurations "${HPX_ADD_TARGET_COMPILE_DEFINITION_CONFIGURATIONS}")
@@ -152,7 +149,7 @@ function(hpx_add_target_compile_definition FLAG)
     if(NOT _config STREQUAL "none")
       set(_conf "$<$<CONFIG:${_config}>:${FLAG}>")
     endif()
-    set_property(GLOBAL APPEND PROPERTY ${_dest} "${_conf}")
+    target_compile_definitions(${_dest} INTERFACE "${_conf}")
   endforeach()
 
 #  if(HPX_WITH_CUDA AND (NOT MSVC))
@@ -162,36 +159,7 @@ endfunction()
 
 function(hpx_add_compile_flag)
   set(one_value_args)
-  set(multi_value_args CONFIGURATIONS LANGUAGES)
-  cmake_parse_arguments(HPX_ADD_COMPILE_FLAG "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})
-
-  set(_languages "CXX")
-  if(HPX_ADD_COMPILE_FLAG_LANGUAGES)
-    set(_languages ${HPX_ADD_COMPILE_FLAG_LANGUAGES})
-  endif()
-
-  set(_configurations "none")
-  if(HPX_ADD_COMPILE_FLAG_CONFIGURATIONS)
-    set(_configurations ${HPX_ADD_COMPILE_FLAG_CONFIGURATIONS})
-  endif()
-
-  # convert multiple flags into a list
-  set(_flags ${HPX_ADD_COMPILE_FLAG_UNPARSED_ARGUMENTS})
-  separate_arguments(_flags)
-
-  foreach(_lang ${_languages})
-    foreach(_config ${_configurations})
-      set(_conf)
-      if(NOT _config STREQUAL "none")
-        string(TOUPPER "${_config}" _conf)
-        set(_conf "${_conf}")
-      endif()
-      foreach(_flag ${_flags})
-        set_property(GLOBAL APPEND PROPERTY HPX_CMAKE_FLAGS_${_lang}_${_conf} "${_flag}")
-        get_property(TEMP_VAR GLOBAL PROPERTY HPX_CMAKE_FLAGS_${_lang}_${_conf})
-      endforeach()
-    endforeach()
-  endforeach()
+  hpx_add_target_compile_option(${ARGN} PRIVATE)
 endfunction()
 
 function(hpx_add_compile_flag_if_available FLAG)
diff --git a/cmake/HPX_AddComponent.cmake b/cmake/HPX_AddComponent.cmake
index 50e5e65ec3..ee8e56e14f 100644
--- a/cmake/HPX_AddComponent.cmake
+++ b/cmake/HPX_AddComponent.cmake
@@ -70,12 +70,11 @@ function(add_hpx_component name)
       ROOT ${${name}_HEADER_ROOT}
       TARGETS ${${name}_component_HEADERS})
   else()
-    include(HPX_CMakeUtils)
     if(${name}_PREPEND_SOURCE_ROOT)
-      prepend(${name}_SOURCES ${${name}_SOURCE_ROOT} ${${name}_SOURCES})
+      list(TRANSFORM ${name}_SOURCES PREPEND ${${name}_SOURCE_ROOT}/)
     endif()
     if(${name}_PREPEND_HEADER_ROOT)
-      prepend(${name}_HEADERS ${${name}_HEADER_ROOT} ${${name}_HEADERS})
+      list(TRANSFORM ${name}_HEADERS PREPEND ${${name}_HEADER_ROOT}/)
     endif()
 
     add_hpx_library_sources_noglob(${name}_component
@@ -104,7 +103,6 @@ function(add_hpx_component name)
   hpx_print_list("DEBUG" "Add component ${name}: Configuration files for ${name}" ${name}_INI)
 
   set(exclude_from_all)
-  set(install_options)
   if(${name}_EXCLUDE_FROM_ALL)
     set(exclude_from_all EXCLUDE_FROM_ALL)
   else()
@@ -237,7 +235,6 @@ function(add_hpx_component name)
     DEPENDENCIES ${${name}_DEPENDENCIES}
     COMPONENT_DEPENDENCIES ${${name}_COMPONENT_DEPENDENCIES}
     ${_target_flags}
-    ${install_optional}
   )
 endfunction()
 
diff --git a/cmake/HPX_AddConfigTest.cmake b/cmake/HPX_AddConfigTest.cmake
index e07e40413a..ee131cac95 100644
--- a/cmake/HPX_AddConfigTest.cmake
+++ b/cmake/HPX_AddConfigTest.cmake
@@ -19,7 +19,7 @@ function(add_hpx_config_test variable)
   cmake_parse_arguments(${variable} "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})
 
   set(_run_msg)
-  # Check CMake feature tests iff the user didn't override the value
+  # Check CMake feature tests if the user didn't override the value
   # of this variable:
   if(NOT DEFINED ${variable})
     if(${variable}_CMAKECXXFEATURE)
@@ -85,6 +85,9 @@ function(add_hpx_config_test variable)
             "-DLINK_DIRECTORIES=${CONFIG_TEST_LINK_DIRS}"
             "-DLINK_LIBRARIES=${CONFIG_TEST_LINK_LIBRARIES}"
             "-DCOMPILE_DEFINITIONS=${CONFIG_TEST_COMPILE_DEFINITIONS}"
+          CXX_STANDARD ${HPX_CXX_STANDARD}
+          CXX_STANDARD_REQUIRED ON
+          CXX_EXTENSIONS FALSE
           RUN_OUTPUT_VARIABLE ${variable}_OUTPUT
           ARGS ${${variable}_ARGS})
         if(${variable}_COMPILE_RESULT AND NOT ${variable}_RUN_RESULT)
@@ -105,6 +108,9 @@ function(add_hpx_config_test variable)
           "-DLINK_LIBRARIES=${CONFIG_TEST_LINK_LIBRARIES}"
           "-DCOMPILE_DEFINITIONS=${CONFIG_TEST_COMPILE_DEFINITIONS}"
         OUTPUT_VARIABLE ${variable}_OUTPUT
+        CXX_STANDARD ${HPX_CXX_STANDARD}
+        CXX_STANDARD_REQUIRED ON
+        CXX_EXTENSIONS FALSE
         COPY_FILE ${test_binary})
        hpx_debug("Compile test: ${variable}")
        hpx_debug("Compilation output: ${${variable}_OUTPUT}")
@@ -208,191 +214,9 @@ function(hpx_check_for_unistd_h)
 endfunction()
 
 ###############################################################################
-function(hpx_check_for_cxx11_alias_templates)
-  add_hpx_config_test(HPX_WITH_CXX11_ALIAS_TEMPLATES
-    SOURCE cmake/tests/cxx11_alias_templates.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_alias_templates)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_alignas)
-  add_hpx_config_test(HPX_WITH_CXX11_ALIGNAS
-    SOURCE cmake/tests/cxx11_alignas.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_alignas)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_auto)
-  add_hpx_config_test(HPX_WITH_CXX11_AUTO
-    SOURCE cmake/tests/cxx11_auto.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_auto_type)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_constexpr)
-  add_hpx_config_test(HPX_WITH_CXX11_CONSTEXPR
-    SOURCE cmake/tests/cxx11_constexpr.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_constexpr)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_decltype)
-  add_hpx_config_test(HPX_WITH_CXX11_DECLTYPE
-    SOURCE cmake/tests/cxx11_decltype.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_decltype)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_sfinae_expression)
-  add_hpx_config_test(HPX_WITH_CXX11_SFINAE_EXPRESSION
-    SOURCE cmake/tests/cxx11_sfinae_expression.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_defaulted_functions)
-  add_hpx_config_test(HPX_WITH_CXX11_DEFAULTED_FUNCTIONS
-    SOURCE cmake/tests/cxx11_defaulted_functions.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_defaulted_functions)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_deleted_functions)
-  add_hpx_config_test(HPX_WITH_CXX11_DELETED_FUNCTIONS
-    SOURCE cmake/tests/cxx11_deleted_functions.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_deleted_functions)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_explicit_cvt_ops)
-  add_hpx_config_test(HPX_WITH_CXX11_EXPLICIT_CONVERSION_OPERATORS
-    SOURCE cmake/tests/cxx11_explicit_cvt_ops.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_explicit_conversions)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_explicit_variadic_templates)
-  add_hpx_config_test(HPX_WITH_CXX11_EXPLICIT_VARIADIC_TEMPLATES
-    SOURCE cmake/tests/cxx11_explicit_variadic_templates.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_extended_friend_declarations)
-  add_hpx_config_test(HPX_WITH_CXX11_EXTENDED_FRIEND_DECLARATIONS
-    SOURCE cmake/tests/cxx11_extended_friend_declarations.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_extended_friend_declarations)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_function_template_default_args)
-  add_hpx_config_test(HPX_WITH_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS
-    SOURCE cmake/tests/cxx11_function_template_default_args.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_default_function_template_args)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_inline_namespaces)
-  add_hpx_config_test(HPX_WITH_CXX11_INLINE_NAMESPACES
-    SOURCE cmake/tests/cxx11_inline_namespaces.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_inline_namespaces)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_lambdas)
-  add_hpx_config_test(HPX_WITH_CXX11_LAMBDAS
-    SOURCE cmake/tests/cxx11_lambdas.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_lambdas)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_noexcept)
-  add_hpx_config_test(HPX_WITH_CXX11_NOEXCEPT
-    SOURCE cmake/tests/cxx11_noexcept.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_noexcept)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_nsdmi)
-  add_hpx_config_test(HPX_WITH_CXX11_NSDMI
-    SOURCE cmake/tests/cxx11_non_static_data_member_initialization.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_nonstatic_member_init)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_nullptr)
-  add_hpx_config_test(HPX_WITH_CXX11_NULLPTR
-    SOURCE cmake/tests/cxx11_nullptr.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_nullptr)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_range_based_for)
-  add_hpx_config_test(HPX_WITH_CXX11_RANGE_BASED_FOR
-    SOURCE cmake/tests/cxx11_range_based_for.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_range_for)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_rvalue_references)
-  add_hpx_config_test(HPX_WITH_CXX11_RVALUE_REFERENCES
-    SOURCE cmake/tests/cxx11_rvalue_references.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_rvalue_references)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_scoped_enums)
-  add_hpx_config_test(HPX_WITH_CXX11_SCOPED_ENUMS
-    SOURCE cmake/tests/cxx11_scoped_enums.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_strong_enums)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_static_assert)
-  add_hpx_config_test(HPX_WITH_CXX11_STATIC_ASSERT
-    SOURCE cmake/tests/cxx11_static_assert.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_static_assert)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_variadic_macros)
-  add_hpx_config_test(HPX_WITH_CXX11_VARIADIC_MACROS
-    SOURCE cmake/tests/cxx11_variadic_macros.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_variadic_macros)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_variadic_templates)
-  add_hpx_config_test(HPX_WITH_CXX11_VARIADIC_TEMPLATES
-    SOURCE cmake/tests/cxx11_variadic_templates.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_variadic_templates)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_array)
-  add_hpx_config_test(HPX_WITH_CXX11_ARRAY
-    SOURCE cmake/tests/cxx11_std_array.cpp
+function(hpx_check_for_libfun_std_experimental_optional)
+  add_hpx_config_test(HPX_WITH_LIBFUN_EXPERIMENTAL_OPTIONAL
+    SOURCE cmake/tests/libfun_std_experimental_optional.cpp
     FILE ${ARGN})
 endfunction()
 
@@ -428,104 +252,6 @@ function(hpx_check_for_cxx11_std_atomic_128bit)
     FILE ${ARGN})
 endfunction()
 
-###############################################################################
-function(hpx_check_for_cxx11_std_chrono)
-  add_hpx_config_test(HPX_WITH_CXX11_CHRONO
-    SOURCE cmake/tests/cxx11_std_chrono.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_cstdint)
-  add_hpx_config_test(HPX_WITH_CXX11_CSTDINT
-    SOURCE cmake/tests/cxx11_std_cstdint.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_exception_ptr)
-  add_hpx_config_test(HPX_WITH_CXX11_EXCEPTION_PTR
-    SOURCE cmake/tests/cxx11_std_exception_ptr.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_forward_list)
-  add_hpx_config_test(HPX_WITH_CXX11_FORWARD_LIST
-    SOURCE cmake/tests/cxx11_std_forward_list.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_initializer_list)
-  add_hpx_config_test(HPX_WITH_CXX11_STD_INITIALIZER_LIST
-    SOURCE cmake/tests/cxx11_std_initializer_list.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_is_bind_expression)
-  add_hpx_config_test(HPX_WITH_CXX11_IS_BIND_EXPRESSION
-    SOURCE cmake/tests/cxx11_std_is_bind_expression.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_is_placeholder)
-  add_hpx_config_test(HPX_WITH_CXX11_IS_PLACEHOLDER
-    SOURCE cmake/tests/cxx11_std_is_placeholder.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_is_trivially_copyable)
-  add_hpx_config_test(HPX_WITH_CXX11_IS_TRIVIALLY_COPYABLE
-    SOURCE cmake/tests/cxx11_std_is_trivially_copyable.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_lock_guard)
-  add_hpx_config_test(HPX_WITH_CXX11_LOCK_GUARD
-    SOURCE cmake/tests/cxx11_std_lock_guard.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_random)
-  add_hpx_config_test(HPX_WITH_CXX11_RANDOM
-    SOURCE cmake/tests/cxx11_std_random.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_range_access)
-  add_hpx_config_test(HPX_WITH_CXX11_RANGE_ACCESS
-    SOURCE cmake/tests/cxx11_std_range_access.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_reference_wrapper)
-  add_hpx_config_test(HPX_WITH_CXX11_REFERENCE_WRAPPER
-    SOURCE cmake/tests/cxx11_std_reference_wrapper.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_regex)
-  add_hpx_config_test(HPX_WITH_CXX11_REGEX
-    SOURCE cmake/tests/cxx11_std_regex.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_shared_ptr)
-  add_hpx_config_test(HPX_WITH_CXX11_SHARED_PTR
-    SOURCE cmake/tests/cxx11_std_shared_ptr.cpp
-    FILE ${ARGN})
-endfunction()
-
 ###############################################################################
 function(hpx_check_for_cxx11_std_shared_ptr_lwg3018)
   add_hpx_config_test(HPX_WITH_CXX11_SHARED_PTR_LWG3018
@@ -533,100 +259,6 @@ function(hpx_check_for_cxx11_std_shared_ptr_lwg3018)
     FILE ${ARGN})
 endfunction()
 
-###############################################################################
-function(hpx_check_for_cxx11_std_shuffle)
-  add_hpx_config_test(HPX_WITH_CXX11_SHUFFLE
-    SOURCE cmake/tests/cxx11_std_shuffle.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_thread)
-  add_hpx_config_test(HPX_WITH_CXX11_THREAD
-    SOURCE cmake/tests/cxx11_std_thread.cpp
-    LIBRARIES "-pthread"
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_to_string)
-  add_hpx_config_test(HPX_WITH_CXX11_TO_STRING
-    SOURCE cmake/tests/cxx11_std_to_string.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_unique_lock)
-  add_hpx_config_test(HPX_WITH_CXX11_UNIQUE_LOCK
-    SOURCE cmake/tests/cxx11_std_unique_lock.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_unique_ptr)
-  add_hpx_config_test(HPX_WITH_CXX11_UNIQUE_PTR
-    SOURCE cmake/tests/cxx11_std_unique_ptr.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_unordered_map)
-  add_hpx_config_test(HPX_WITH_CXX11_UNORDERED_MAP
-    SOURCE cmake/tests/cxx11_std_unordered_map.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_std_unordered_set)
-  add_hpx_config_test(HPX_WITH_CXX11_UNORDERED_SET
-    SOURCE cmake/tests/cxx11_std_unordered_set.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_thread_local)
-  add_hpx_config_test(HPX_WITH_CXX11_THREAD_LOCAL
-    SOURCE cmake/tests/cxx11_thread_local.cpp
-    FILE ${ARGN})
-endfunction()
-
-function(hpx_check_for_cxx11_thread_local)
-  add_hpx_config_test(HPX_WITH_CXX11_THREAD_LOCAL
-    SOURCE cmake/tests/cxx11_thread_local.cpp
-    FILE ${ARGN})
-
-  if(NOT HPX_WITH_CXX11_THREAD_LOCAL)
-    unset(HPX_HAVE_LIBSUPCPP CACHE)
-
-    # Clang version < 4 may require libsupc++
-    check_library_exists(supc++ __cxa_thread_atexit "" HPX_HAVE_LIBSUPCPP)
-    if(HPX_HAVE_LIBSUPCPP)
-      set(HPX_CXX11_THREAD_LOCAL_LIBRARIES supc++)
-
-      unset(HPX_WITH_CXX11_THREAD_LOCAL CACHE)
-      add_hpx_config_test(HPX_WITH_CXX11_THREAD_LOCAL
-        SOURCE cmake/tests/cxx11_thread_local.cpp
-        LIBRARIES ${HPX_CXX11_THREAD_LOCAL_LIBRARIES}
-        FILE ${ARGN})
-    endif()
-  endif()
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_noreturn_attribute)
-  add_hpx_config_test(HPX_WITH_CXX11_NORETURN_ATTRIBUTE
-    SOURCE cmake/tests/cxx11_noreturn_attribute.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx11_override)
-  add_hpx_config_test(HPX_WITH_CXX11_OVERRIDE
-    SOURCE cmake/tests/cxx11_override.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_override)
-endfunction()
-
 ###############################################################################
 function(hpx_check_for_cxx11_std_quick_exit)
   add_hpx_config_test(HPX_WITH_CXX11_STD_QUICK_EXIT
@@ -634,79 +266,6 @@ function(hpx_check_for_cxx11_std_quick_exit)
     FILE ${ARGN})
 endfunction()
 
-###############################################################################
-function(hpx_check_for_cxx14_constexpr)
-  add_hpx_config_test(HPX_WITH_CXX14_CONSTEXPR
-    SOURCE cmake/tests/cxx14_constexpr.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_lambdas)
-  add_hpx_config_test(HPX_WITH_CXX14_LAMBDAS
-    SOURCE cmake/tests/cxx14_lambdas.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_lambda_init_captures)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_std_integer_sequence)
-  add_hpx_config_test(HPX_WITH_CXX14_INTEGER_SEQUENCE
-    SOURCE cmake/tests/cxx14_std_integer_sequence.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_std_is_final)
-  add_hpx_config_test(HPX_WITH_CXX14_IS_FINAL
-    SOURCE cmake/tests/cxx14_std_is_final.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_std_is_null_pointer)
-  add_hpx_config_test(HPX_WITH_CXX14_IS_NULL_POINTER
-    SOURCE cmake/tests/cxx14_std_is_null_pointer.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_std_result_of_sfinae)
-  add_hpx_config_test(HPX_WITH_CXX14_RESULT_OF_SFINAE
-    SOURCE cmake/tests/cxx14_std_result_of_sfinae.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_variable_templates)
-  add_hpx_config_test(HPX_WITH_CXX14_VARIABLE_TEMPLATES
-    SOURCE cmake/tests/cxx14_variable_templates.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_variable_templates)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_deprecated_attribute)
-  add_hpx_config_test(HPX_WITH_CXX14_DEPRECATED_ATTRIBUTE
-    SOURCE cmake/tests/cxx14_deprecated_attribute.cpp
-    FILE ${ARGN})
-endfunction()
-
-###############################################################################
-function(hpx_check_for_cxx14_return_type_deduction)
-  add_hpx_config_test(HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION
-    SOURCE cmake/tests/cxx14_return_type_deduction.cpp
-    FILE ${ARGN}
-    CMAKECXXFEATURE cxx_return_type_deduction)
-endfunction()
-
-###############################################################################
-function(hpx_check_for_libfun_std_experimental_optional)
-  add_hpx_config_test(HPX_WITH_LIBFUN_EXPERIMENTAL_OPTIONAL
-    SOURCE cmake/tests/libfun_std_experimental_optional.cpp
-    FILE ${ARGN})
-endfunction()
-
 ###############################################################################
 function(hpx_check_for_cxx17_aligned_new)
   add_hpx_config_test(HPX_WITH_CXX17_ALIGNED_NEW
@@ -771,6 +330,27 @@ function(hpx_check_for_cxx17_noexcept_functions_as_nontype_template_arguments)
     FILE ${ARGN})
 endfunction()
 
+###############################################################################
+function(hpx_check_for_builtin_integer_pack)
+  add_hpx_config_test(HPX_WITH_BUILTIN_INTEGER_PACK
+    SOURCE cmake/tests/builtin_integer_pack.cpp
+    FILE ${ARGN})
+endfunction()
+
+###############################################################################
+function(hpx_check_for_builtin_make_integer_seq)
+  add_hpx_config_test(HPX_WITH_BUILTIN_MAKE_INTEGER_SEQ
+    SOURCE cmake/tests/builtin_make_integer_seq.cpp
+    FILE ${ARGN})
+endfunction()
+
+###############################################################################
+function(hpx_check_for_builtin_type_pack_element)
+  add_hpx_config_test(HPX_WITH_BUILTIN_TYPE_PACK_ELEMENT
+    SOURCE cmake/tests/builtin_type_pack_element.cpp
+    FILE ${ARGN})
+endfunction()
+
 ###############################################################################
 function(hpx_check_for_mm_prefetch)
   add_hpx_config_test(HPX_WITH_MM_PREFETCH
diff --git a/cmake/HPX_AddLibrary.cmake b/cmake/HPX_AddLibrary.cmake
index ca622db58e..09e5f2b769 100644
--- a/cmake/HPX_AddLibrary.cmake
+++ b/cmake/HPX_AddLibrary.cmake
@@ -88,7 +88,6 @@ function(add_hpx_library name)
   hpx_print_list("DEBUG" "add_library.${name}" "Component dependencies for ${name}" ${name}_COMPONENT_DEPENDENCIES)
 
   set(exclude_from_all)
-  set(install_options)
 
   if(${name}_EXCLUDE_FROM_ALL)
     set(exclude_from_all EXCLUDE_FROM_ALL)
@@ -217,7 +216,6 @@ function(add_hpx_library name)
     DEPENDENCIES ${${name}_DEPENDENCIES}
     COMPONENT_DEPENDENCIES ${${name}_COMPONENT_DEPENDENCIES}
     ${_target_flags}
-    ${install_optional}
   )
 
 endfunction()
diff --git a/cmake/HPX_AddModule.cmake b/cmake/HPX_AddModule.cmake
index 50640073d6..7869753033 100644
--- a/cmake/HPX_AddModule.cmake
+++ b/cmake/HPX_AddModule.cmake
@@ -78,11 +78,10 @@ function(add_hpx_module name)
   endif()
 
   # Write full path for the sources files
-  include(HPX_CMakeUtils)
-  prepend(sources ${SOURCE_ROOT} ${${name}_SOURCES})
-  prepend(headers ${HEADER_ROOT} ${${name}_HEADERS})
+  list(TRANSFORM ${name}_SOURCES PREPEND ${SOURCE_ROOT}/ OUTPUT_VARIABLE sources)
+  list(TRANSFORM ${name}_HEADERS PREPEND ${HEADER_ROOT}/ OUTPUT_VARIABLE headers)
   if(HPX_${name_upper}_WITH_COMPATIBILITY_HEADERS)
-    prepend(compat_headers ${COMPAT_HEADER_ROOT} ${${name}_COMPAT_HEADERS})
+    list(TRANSFORM ${name}_COMPAT_HEADERS PREPEND ${COMPAT_HEADER_ROOT}/ OUTPUT_VARIABLE compat_headers)
   endif()
 
   # This header generation is disabled for config module specific generated
@@ -161,7 +160,7 @@ function(add_hpx_module name)
     $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>
     $<INSTALL_INTERFACE:include>)
 
-  target_link_libraries(hpx_${name} PRIVATE hpx_internal_flags)
+  target_link_libraries(hpx_${name} PUBLIC hpx_public_flags PRIVATE hpx_private_flags)
 
   if(HPX_${name_upper}_WITH_COMPATIBILITY_HEADERS)
     target_include_directories(hpx_${name} PUBLIC
diff --git a/cmake/HPX_AddParcelport.cmake b/cmake/HPX_AddParcelport.cmake
index 7a56f92d31..869051fac2 100644
--- a/cmake/HPX_AddParcelport.cmake
+++ b/cmake/HPX_AddParcelport.cmake
@@ -34,7 +34,7 @@ function(add_parcelport name)
 
   target_link_libraries(${parcelport_name} PUBLIC ${${name}_DEPENDENCIES})
   target_include_directories(${parcelport_name} PUBLIC ${${name}_INCLUDE_DIRS})
-  target_link_libraries(${parcelport_name} PRIVATE hpx_internal_flags)
+  target_link_libraries(${parcelport_name} PUBLIC hpx_public_flags PRIVATE hpx_private_flags)
   target_compile_options(${parcelport_name} PUBLIC ${${name}_COMPILE_FLAGS})
   set_target_properties(${parcelport_name} PROPERTIES
     FOLDER "${${name}_FOLDER}"
diff --git a/cmake/HPX_AddTest.cmake b/cmake/HPX_AddTest.cmake
index a7065c6618..ce2c724dc7 100644
--- a/cmake/HPX_AddTest.cmake
+++ b/cmake/HPX_AddTest.cmake
@@ -16,6 +16,9 @@ function(add_hpx_test category name)
 
   if(NOT ${name}_THREADS_PER_LOCALITY)
     set(${name}_THREADS_PER_LOCALITY 1)
+  elseif(HPX_WITH_TESTS_MAX_THREADS_PER_LOCALITY GREATER 0
+      AND ${name}_THREADS_PER_LOCALITY GREATER HPX_WITH_TESTS_MAX_THREADS_PER_LOCALITY)
+    set(${name}_THREADS_PER_LOCALITY ${HPX_WITH_TESTS_MAX_THREADS_PER_LOCALITY})
   endif()
 
   if(NOT ${name}_EXECUTABLE)
diff --git a/cmake/HPX_CMakeUtils.cmake b/cmake/HPX_CMakeUtils.cmake
deleted file mode 100644
index 71aa75266f..0000000000
--- a/cmake/HPX_CMakeUtils.cmake
+++ /dev/null
@@ -1,15 +0,0 @@
-# Copyright (c) 2019 Auriane Reverdell
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-
-# Prepend function cause not handle for cmake < 3.12
-function(prepend res prefix)
-  set(varList "")
-  foreach(f ${ARGN})
-    list(APPEND varList "${prefix}/${f}")
-  endforeach(f)
-  set(${res} "${varList}" PARENT_SCOPE)
-endfunction(prepend)
diff --git a/cmake/HPX_CheckCXXStandard.cmake b/cmake/HPX_CheckCXXStandard.cmake
new file mode 100644
index 0000000000..11d7cc85db
--- /dev/null
+++ b/cmake/HPX_CheckCXXStandard.cmake
@@ -0,0 +1,44 @@
+# Copyright (c) 2020 Mikael Simberg
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+# We require at least C++14. However, if a higher standard is set by the user in
+# CMAKE_CXX_STANDARD that requirement has to be propagated to users of HPX as
+# well (i.e. HPX can't be compiled with C++17 and applications with C++14; the
+# other way around is allowed). Ideally, users should not set CMAKE_CXX_STANDARD
+# when building HPX.
+set(HPX_CXX_STANDARD 14)
+
+# Compatibility for old HPX_WITH_CXXAB options.
+if(HPX_WITH_CXX11)
+  hpx_error("HPX_WITH_CXX11 is deprecated and the minimum C++ standard required by HPX is 14. Avoid setting the standard explicitly or use CMAKE_CXX_STANDARD and HPX_USE_CMAKE_CXX_STANDARD if you must set it.")
+elseif(HPX_WITH_CXX14)
+  hpx_warn("HPX_WITH_CXX14 is deprecated. Avoid setting the standard explicitly or use CMAKE_CXX_STANDARD and HPX_USE_CMAKE_CXX_STANDARD if you must set it.")
+  set(HPX_CXX_STANDARD 14)
+elseif(HPX_WITH_CXX17)
+  hpx_warn("HPX_WITH_CXX17 is deprecated. Avoid setting the standard explicitly or use CMAKE_CXX_STANDARD and HPX_USE_CMAKE_CXX_STANDARD if you must set it.")
+  set(HPX_CXX_STANDARD 17)
+elseif(HPX_WITH_CXX20)
+  hpx_warn("HPX_WITH_CXX20 is deprecated. Avoid setting the standard explicitly or use CMAKE_CXX_STANDARD and HPX_USE_CMAKE_CXX_STANDARD if you must set it.")
+  set(HPX_CXX_STANDARD 20)
+endif()
+
+if(CMAKE_CXX_STANDARD)
+  if(CMAKE_CXX_STANDARD LESS 14)
+    hpx_error("You've set CMAKE_CXX_STANDARD to ${CMAKE_CXX_STANDARD}, which is less than 14 which is the minimum required by HPX")
+  else()
+    if(HPX_USE_CMAKE_CXX_STANDARD)
+      hpx_warn("You've set CMAKE_CXX_STANDARD manually, which is not recommended. However, HPX_USE_CMAKE_CXX_STANDARD=ON so we're taking it into account.")
+      set(HPX_CXX_STANDARD CMAKE_CXX_STANDARD)
+    else()
+      hpx_error("You've set CMAKE_CXX_STANDARD manually, which is not recommended. If you really want to set CMAKE_CXX_STANDARD, set HPX_USE_CMAKE_CXX_STANDARD=ON.")
+    endif()
+  endif()
+endif()
+
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+
+hpx_info("Using C++${HPX_CXX_STANDARD}")
diff --git a/cmake/HPX_CompilerFlagsTarget.cmake b/cmake/HPX_CompilerFlagsTarget.cmake
deleted file mode 100644
index 277501d361..0000000000
--- a/cmake/HPX_CompilerFlagsTarget.cmake
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright (c) 2019 Mikael Simberg
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-# This is a dummy target that we add compile flags to all tests will depend on
-# this target and inherit the flags but user code linking against hpx will not
-add_library(hpx_internal_flags INTERFACE)
-
-# Default unnamed config (not Debug/Release/etc) are in this var
-get_property(_temp_flags GLOBAL PROPERTY HPX_CMAKE_FLAGS_CXX_)
-target_compile_options(hpx_internal_flags INTERFACE ${_temp_flags})
-
-# Could potentially use CMAKE_CONFIGURATION_TYPES in case a user defined config exists
-foreach(_config "DEBUG" "RELEASE" "RELWITHDEBINFO" "MINSIZEREL")
-  get_property(_temp_flags GLOBAL PROPERTY HPX_CMAKE_FLAGS_CXX_${_config})
-  target_compile_options(hpx_internal_flags INTERFACE $<$<CONFIG:${_config}>:${_temp_flags}>)
-endforeach()
-
-foreach(_keyword PUBLIC;PRIVATE)
-  get_property(HPX_TARGET_COMPILE_OPTIONS_VAR
-    GLOBAL PROPERTY HPX_TARGET_COMPILE_OPTIONS_${_keyword})
-  foreach(_flag ${HPX_TARGET_COMPILE_OPTIONS_VAR})
-    target_compile_options(hpx_internal_flags INTERFACE ${_flag})
-  endforeach()
-endforeach()
-
-include(HPX_ExportTargets)
-# Modules can't link to this if not exported
-install(TARGETS hpx_internal_flags EXPORT HPXModulesTargets
-  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-  COMPONENT hpx_internal_flags
-)
-hpx_export_modules_targets(hpx_internal_flags)
diff --git a/cmake/HPX_CompilerFlagsTargets.cmake b/cmake/HPX_CompilerFlagsTargets.cmake
new file mode 100644
index 0000000000..94c11bc60d
--- /dev/null
+++ b/cmake/HPX_CompilerFlagsTargets.cmake
@@ -0,0 +1,37 @@
+# Copyright (c) 2019 Mikael Simberg
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+# These are a dummy targets that we add compile flags to. All HPX targets should
+# link to them.
+add_library(hpx_private_flags INTERFACE)
+add_library(hpx_public_flags INTERFACE)
+
+# Set C++ standard
+target_compile_features(hpx_private_flags INTERFACE cxx_std_${HPX_CXX_STANDARD})
+target_compile_features(hpx_public_flags INTERFACE cxx_std_${HPX_CXX_STANDARD})
+
+# Set other flags that should always be set
+target_compile_definitions(hpx_private_flags INTERFACE $<$<CONFIG:Debug>:HPX_DEBUG>)
+target_compile_definitions(hpx_public_flags INTERFACE $<$<CONFIG:Debug>:HPX_DEBUG>)
+
+# Remaining flags are set through the macros in cmake/HPX_AddCompileFlag.cmake
+
+include(HPX_ExportTargets)
+# Modules can't link to this if not exported
+install(TARGETS hpx_private_flags EXPORT HPXModulesTargets
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+  COMPONENT hpx_private_flags
+)
+install(TARGETS hpx_public_flags EXPORT HPXModulesTargets
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+  COMPONENT hpx_public_flags
+)
+hpx_export_modules_targets(hpx_private_flags)
+hpx_export_modules_targets(hpx_public_flags)
diff --git a/cmake/HPX_DetectCppDialect.cmake b/cmake/HPX_DetectCppDialect.cmake
deleted file mode 100644
index a40c492341..0000000000
--- a/cmake/HPX_DetectCppDialect.cmake
+++ /dev/null
@@ -1,175 +0,0 @@
-# Copyright (c) 2007-2017 Hartmut Kaiser
-# Copyright (c) 2011-2017 Thomas Heller
-# Copyright (c) 2017 Anton Bikineev
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-function(hpx_detect_cpp_dialect_non_msvc)
-
-  if(HPX_WITH_CUDA AND NOT HPX_WITH_CUDA_CLANG)
-    set(CXX_FLAG -std=c++11)
-    set(HPX_CXX_STANDARD 11)
-    hpx_info("C++ mode used: C++11")
-  else()
-
-    # Try -std=c++17 first
-    if(HPX_WITH_CXX17 OR NOT (("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-                              AND (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 17)))
-      check_cxx_compiler_flag(-std=c++17 HPX_WITH_CXX17)
-    endif()
-
-    if(HPX_WITH_CXX17)
-      set(CXX_FLAG -std=c++17)
-      hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-      set(HPX_CXX_STANDARD 17)
-    else()
-      # ... otherwise try -std=c++1z
-      if(HPX_WITH_CXX1Z OR NOT (("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-                                AND (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 17)))
-        check_cxx_compiler_flag(-std=c++1z HPX_WITH_CXX1Z)
-      endif()
-
-      if(HPX_WITH_CXX1Z)
-        set(CXX_FLAG -std=c++1z)
-        hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-        set(HPX_CXX_STANDARD 1z)
-      else()
-        # ... otherwise try -std=c++14
-        if(HPX_WITH_CXX14 OR NOT (("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-                                  AND (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 17)))
-          check_cxx_compiler_flag(-std=c++14 HPX_WITH_CXX14)
-        endif()
-
-        if(HPX_WITH_CXX14)
-          set(CXX_FLAG -std=c++14)
-          # The Intel compiler doesn't appear to have a fully functional
-          # implementation of C++14 constexpr. It's fine with our C++14 constexpr
-          # usage in HPX but chokes on Boost.
-          # FIXME: This should be replaced with a version-based check in the future
-          # when the Intel compiler is able to build Boost with -std=c++14.
-          if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-            hpx_add_config_cond_define(BOOST_NO_CXX14_CONSTEXPR)
-          endif()
-          set(HPX_CXX_STANDARD 14)
-        else()
-          # ... otherwise try -std=c++1y
-          if(HPX_WITH_CXX1Y OR NOT (("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-                                    AND (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 17)))
-            check_cxx_compiler_flag(-std=c++1y HPX_WITH_CXX1Y)
-          endif()
-
-          if(HPX_WITH_CXX1Y)
-            set(CXX_FLAG -std=c++1y)
-            set(HPX_CXX_STANDARD 1y)
-          else()
-            # ... otherwise try -std=c++11
-            check_cxx_compiler_flag(-std=c++11 HPX_WITH_CXX11)
-            if(HPX_WITH_CXX11)
-              set(CXX_FLAG -std=c++11)
-              set(HPX_CXX_STANDARD 11)
-              hpx_warn("Compiling in C++11 mode is deprecated. HPX will require C++14 support in future releases. Set HPX_WITH_CXX14 (or newer) to ON during CMake configuration to enable C++14 support.")
-            else()
-              # ... otherwise try -std=c++0x
-              check_cxx_compiler_flag(-std=c++0x HPX_WITH_CXX0X)
-              if(HPX_WITH_CXX0X)
-                hpx_error("HPX requires at least C++11 while C+0x was enforced")
-              endif()
-            endif()
-          endif()
-        endif()
-      endif()
-    endif()
-  endif()
-  set(HPX_CXX_STANDARD ${HPX_CXX_STANDARD} PARENT_SCOPE)
-  set(CXX_FLAG ${CXX_FLAG} PARENT_SCOPE)
-endfunction()
-
-function(hpx_detect_cpp_dialect)
-
-  if(MSVC)
-    set(CXX_FLAG)
-
-    # enable enforcing a particular C++ mode
-    if(HPX_WITH_CXX2A)
-      set(CXX_FLAG -std:c++latest)
-      set(HPX_CXX_STANDARD 2a)
-      hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-      hpx_add_config_cond_define(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
-    elseif(HPX_WITH_CXX17)
-      set(CXX_FLAG -std:c++17)
-      set(HPX_CXX_STANDARD 17)
-      hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-      hpx_add_config_cond_define(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
-    elseif(HPX_WITH_CXX1Z)
-      set(HPX_CXX_STANDARD 1z)
-      set(CXX_FLAG -std:c++latest)
-      hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-      hpx_add_config_cond_define(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
-    elseif(HPX_WITH_CXX14)
-      set(CXX_FLAG -std:c++14)
-      if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-        hpx_add_config_cond_define(BOOST_NO_CXX14_CONSTEXPR)
-      endif()
-      set(HPX_CXX_STANDARD 14)
-    elseif(HPX_WITH_CXX1Y)
-      set(CXX_FLAG -std:c++14)
-      set(HPX_CXX_STANDARD 1y)
-    elseif(HPX_WITH_CXX11)
-      set(HPX_CXX_STANDARD 11)
-      hpx_warn("Compiling in C++11 mode is deprecated. HPX will require C++14 support in future releases. Set HPX_WITH_CXX14 (or newer) to ON during CMake configuration to enable C++14 support.")
-    elseif(HPX_WITH_CXX0X)
-      hpx_error("HPX requires at least C++11 while C+0x was enforced")
-    endif()
-
-    hpx_add_config_cond_define(_HAS_AUTO_PTR_ETC 1)
-
-  else(MSVC)
-
-    # enable enforcing a particular C++ mode
-    if(HPX_WITH_CXX2A)
-      set(CXX_FLAG -std=c++2a)
-      set(HPX_CXX_STANDARD 2a)
-      hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-    elseif(HPX_WITH_CXX17)
-      set(CXX_FLAG -std=c++17)
-      set(HPX_CXX_STANDARD 17)
-      hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-    elseif(HPX_WITH_CXX1Z)
-      set(CXX_FLAG -std=c++1z)
-      set(HPX_CXX_STANDARD 1z)
-      hpx_add_config_cond_define(BOOST_NO_AUTO_PTR)
-    elseif(HPX_WITH_CXX14)
-      set(CXX_FLAG -std=c++14)
-      set(HPX_CXX_STANDARD 14)
-      if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-        hpx_add_config_cond_define(BOOST_NO_CXX14_CONSTEXPR)
-      endif()
-    elseif(HPX_WITH_CXX1Y)
-      set(CXX_FLAG -std=c++1y)
-      set(HPX_CXX_STANDARD 1y)
-    elseif(HPX_WITH_CXX11)
-      set(CXX_FLAG -std=c++11)
-      set(HPX_CXX_STANDARD 11)
-      hpx_warn("Compiling in C++11 mode is deprecated. HPX will require C++14 support in future releases. Set HPX_WITH_CXX14 (or newer) to ON during CMake configuration to enable C++14 support.")
-    elseif(HPX_WITH_CXX0X)
-      hpx_error("HPX requires at least C++11 while C+0x was enforced")
-    else()
-      # if no C++ mode is enforced, try to detect which one to use
-      hpx_detect_cpp_dialect_non_msvc()
-    endif()
-
-  endif(MSVC)
-
-  set(HPX_CXX_STANDARD ${HPX_CXX_STANDARD} PARENT_SCOPE)
-  hpx_info("C++ mode used: C++${HPX_CXX_STANDARD}")
-
-  if(CXX_FLAG)
-    hpx_add_target_compile_option(${CXX_FLAG} PUBLIC)
-  endif()
-
-  # Re-export the local CXX_FLAG varaible.
-  set(CXX_FLAG ${CXX_FLAG} PARENT_SCOPE)
-
-endfunction()
diff --git a/cmake/HPX_FilterLibrariesMSVC.cmake b/cmake/HPX_FilterLibrariesMSVC.cmake
deleted file mode 100644
index fb6ea2d019..0000000000
--- a/cmake/HPX_FilterLibrariesMSVC.cmake
+++ /dev/null
@@ -1,67 +0,0 @@
-# Copyright (c) 2019 Ste||ar Group
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-# To solve a cmake error when invoking set_property with
-# set_property(INTERFACE_LINK_LIBRARIES), this error doesn't appear with
-# target_link_libraries(INTERFACE) but this function is not supported for
-# imported libraries with CMake < 3.11
-# example of the error:
-# https://github.com/PointCloudLibrary/pcl/issues/2989
-# So we use the following workaround, which can be removed as soon as we upgrade
-# our required cmake version to 3.11
-
-function(parse_libraries libraries name)
-  if (MSVC)
-    # Parse MSVC libraries to avoid cmake bug
-    if ("${CMAKE_BUILD_TYPE}" MATCHES "Rel")
-      set(_release true)
-    else()
-      set(_debug true)
-    endif()
-    foreach (lib IN LISTS libraries)
-      # We add the current process lib if it has a flag and it matches the
-      # build_type or if it has no flags
-      if ("${lib}" MATCHES "^(optimized|general|debug)$")
-        set(_build_flag_specified true)
-      endif()
-      if (NOT _build_flag_specified AND (NOT "${lib}" MATCHES "^(optimized|general|debug)$"))
-        # If this is a basic library/target
-        set(_output_libraries ${_output_libraries} ${lib})
-      endif()
-      if ((_release AND ("${lib}" MATCHES "^(optimized|general)$")) OR (_debug AND ("${lib}" MATCHES "^(debug|general)$")))
-        set(_get_next true)
-      else()
-        if (_get_next)
-          set(_output_libraries ${_output_libraries} ${lib})
-          set(_get_next false)
-          set(_build_flag_specified false)
-        endif()
-      endif()
-    endforeach()
-    set(${name} "${_output_libraries}" PARENT_SCOPE)
-  else()
-    set(${name} "${libraries}" PARENT_SCOPE)
-  endif()
-endfunction(parse_libraries)
-
-# In order to fix the cmake bug, in case interface_link_libraries, we filter the
-# libraries and then we call the old set_property with the filtered libraries
-function(set_property)
-  # Parse arguments
-  set(options APPEND PROPERTY)
-  set(one_value_args TARGET)
-  set(multi_value_args INTERFACE_LINK_LIBRARIES)
-  cmake_parse_arguments(my_props "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})
-  if (NOT my_props_INTERFACE_LINK_LIBRARIES)
-    # No bug, we directly call the old function
-    _set_property(${ARGN})
-  else()
-    parse_libraries("${my_props_INTERFACE_LINK_LIBRARIES}" filtered_libraries)
-    if (my_props_APPEND)
-      set(_append APPEND)
-    endif()
-    _set_property(TARGET ${my_props_TARGET} ${_append} PROPERTY INTERFACE_LINK_LIBRARIES ${filtered_libraries})
-  endif()
-endfunction(set_property)
diff --git a/cmake/HPX_ForwardCacheVariables.cmake b/cmake/HPX_ForwardCacheVariables.cmake
index b64ea3f54f..15d389d3f7 100644
--- a/cmake/HPX_ForwardCacheVariables.cmake
+++ b/cmake/HPX_ForwardCacheVariables.cmake
@@ -8,36 +8,29 @@
 # be forwarded to projects using HPX (the file is included in the
 # HPXConfig.cmake)
 
-function(write_license_header filename)
-  file(WRITE ${filename}
-"# Copyright (c) 2019 Ste||ar Group\n\
-#\n\
-# SPDX-License-Identifier: BSL-1.0\n\
-# Distributed under the Boost Software License, Version 1.0. (See accompanying\n\
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n"
-    )
-endfunction(write_license_header)
-
 get_cmake_property(cache_vars CACHE_VARIABLES)
 
 # Keep only the HPX_* like variables
 list(FILTER cache_vars INCLUDE REGEX HPX_)
 list(FILTER cache_vars EXCLUDE REGEX "Category$")
 
-# Write the HPXCacheVariables.cmake in the BUILD directory
+# Generate HPXCacheVariables.cmake in the BUILD directory
 set(_cache_var_file
   ${CMAKE_CURRENT_BINARY_DIR}/lib/cmake/${HPX_PACKAGE_NAME}/${HPX_PACKAGE_NAME}CacheVariables.cmake)
-write_license_header(${_cache_var_file})
-file(APPEND ${_cache_var_file} "# File to store the HPX_* cache variables\n")
+set(_cache_var_file_template
+  "${HPX_SOURCE_DIR}/cmake/templates/${HPX_PACKAGE_NAME}CacheVariables.cmake.in")
+set(_cache_variables)
 foreach(_var IN LISTS cache_vars)
-  file(APPEND ${_cache_var_file} "set(${_var} ${${_var}})\n")
+  set(_cache_variables "${_cache_variables}set(${_var} ${${_var}})\n")
 endforeach()
-file(INSTALL ${_cache_var_file}
-  DESTINATION ${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY})
+
+configure_file(
+  ${_cache_var_file_template}
+  ${_cache_var_file})
 
 # Install the HPXCacheVariables.cmake in the INSTALL directory
 install(
-  FILES ${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/${HPX_PACKAGE_NAME}CacheVariables.cmake
+  FILES ${_cache_var_file}
   DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${HPX_PACKAGE_NAME}
   COMPONENT cmake
   )
diff --git a/cmake/HPX_GeneratePackage.cmake b/cmake/HPX_GeneratePackage.cmake
index 3361ae922f..26826a7d2b 100644
--- a/cmake/HPX_GeneratePackage.cmake
+++ b/cmake/HPX_GeneratePackage.cmake
@@ -19,33 +19,37 @@ write_basic_package_version_file(
 
 # Export HPXModulesTargets in the build directory
 export(TARGETS ${HPX_EXPORT_MODULES_TARGETS}
+  NAMESPACE HPX::
   FILE "${CMAKE_CURRENT_BINARY_DIR}/lib/cmake/${HPX_PACKAGE_NAME}/HPXModulesTargets.cmake"
 )
 
-# Export HPXTargets in the install directory
+# Export HPXModulesTargets in the install directory
 install(EXPORT HPXModulesTargets
+  NAMESPACE HPX::
   FILE HPXModulesTargets.cmake
   DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${HPX_PACKAGE_NAME}
 )
 
 # Export HPXTargets in the build directory
 export(TARGETS ${HPX_EXPORT_TARGETS}
+  NAMESPACE HPX::
   FILE "${CMAKE_CURRENT_BINARY_DIR}/lib/cmake/${HPX_PACKAGE_NAME}/HPXTargets.cmake"
 )
 
 # Export HPXTargets in the install directory
 install(EXPORT HPXTargets
+  NAMESPACE HPX::
   FILE HPXTargets.cmake
   DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${HPX_PACKAGE_NAME}
 )
 
 if (NOT MSVC)
   # Generate the pkconfig files for HPX_APPLICATION (both for build and install)
-  hpx_generate_pkgconfig_from_target(hpx::application hpx_application TRUE)
-  hpx_generate_pkgconfig_from_target(hpx::application hpx_application FALSE)
+  hpx_generate_pkgconfig_from_target(hpx_pkgconfig_application hpx_application TRUE EXCLUDE hpx_interface)
+  hpx_generate_pkgconfig_from_target(hpx_pkgconfig_application hpx_application FALSE EXCLUDE hpx_interface)
   # Generate the pkconfig files for HPX_COMPONENT (both for build and install)
-  hpx_generate_pkgconfig_from_target(hpx::component hpx_component TRUE)
-  hpx_generate_pkgconfig_from_target(hpx::component hpx_component FALSE)
+  hpx_generate_pkgconfig_from_target(hpx_pkgconfig_component hpx_component TRUE EXCLUDE hpx_interface)
+  hpx_generate_pkgconfig_from_target(hpx_pkgconfig_component hpx_component FALSE EXCLUDE hpx_interface)
 endif()
 
 # Install dir
diff --git a/cmake/HPX_GeneratePackageUtils.cmake b/cmake/HPX_GeneratePackageUtils.cmake
index f02beb5391..eb6c9f77bd 100644
--- a/cmake/HPX_GeneratePackageUtils.cmake
+++ b/cmake/HPX_GeneratePackageUtils.cmake
@@ -18,6 +18,11 @@ endmacro(get_target_property)
 function(hpx_collect_usage_requirements target compile_definitions compile_options
     pic_option include_directories system_include_directories link_libraries
     link_options already_processed_targets is_component)
+  cmake_parse_arguments(collect "" "" "EXCLUDE" ${ARGN})
+
+  if(${target} IN_LIST collect_EXCLUDE)
+    return()
+  endif()
 
   # Check if the target has already been processed
   list(FIND ${already_processed_targets} ${target} _found)
@@ -77,7 +82,8 @@ function(hpx_collect_usage_requirements target compile_definitions compile_optio
           # This is not put inside a function in order not to hide the recursivity
           hpx_collect_usage_requirements(${dep} dep_compile_definitions dep_compile_options
              dep_pic_option dep_include_directories dep_system_include_directories
-             dep_link_libraries dep_link_options _already_processed_targets ${is_component})
+             dep_link_libraries dep_link_options _already_processed_targets ${is_component}
+             EXCLUDE ${collect_EXCLUDE})
           list(APPEND _target_compile_definitions "${dep_compile_definitions}")
           list(APPEND _target_compile_options "${dep_compile_options}")
           list(APPEND _target_include_directories "${dep_include_directories}")
@@ -179,8 +185,10 @@ function(hpx_construct_library_list link_libraries link_options library_list)
 endfunction(hpx_construct_library_list)
 
 
-# Configure the correponding package config template for the specified ${template}
+# Configure the corresponding package config template for the specified
+# ${template}
 function(hpx_generate_pkgconfig_from_target target template is_build)
+  cmake_parse_arguments(pkgconfig "" "" "EXCLUDE" ${ARGN})
 
   if(${is_build})
     set(OUTPUT_DIR ${CMAKE_CURRENT_BINARY_DIR}/lib/pkgconfig/)
@@ -200,7 +208,8 @@ function(hpx_generate_pkgconfig_from_target target template is_build)
     hpx_link_libraries
     hpx_link_options
     processed_targets
-    ${is_component})
+    ${is_component}
+    EXCLUDE ${pkgconfig_EXCLUDE})
 
   # Add all the components which aren't linked to hpx
   set(_component_list ${HPX_COMPONENTS})
diff --git a/cmake/HPX_HandleComponentDependencies.cmake b/cmake/HPX_HandleComponentDependencies.cmake
index af39cb39b9..9e118ab8a1 100644
--- a/cmake/HPX_HandleComponentDependencies.cmake
+++ b/cmake/HPX_HandleComponentDependencies.cmake
@@ -11,6 +11,8 @@ function(hpx_handle_component_dependencies components)
   foreach(component ${${components}})
     if(TARGET ${component}_component)
       set(tmp ${tmp} ${component}_component)
+    elseif(TARGET HPX::${component}_component)
+      set(tmp ${tmp} HPX::${component}_component)
     else()
       set(tmp ${tmp} hpx_${component})
     endif()
diff --git a/cmake/HPX_PerformCxxFeatureTests.cmake b/cmake/HPX_PerformCxxFeatureTests.cmake
index e176cf7973..17f84304fd 100644
--- a/cmake/HPX_PerformCxxFeatureTests.cmake
+++ b/cmake/HPX_PerformCxxFeatureTests.cmake
@@ -11,85 +11,6 @@
 # C++ feature tests
 ################################################################################
 function(hpx_perform_cxx_feature_tests)
-
-  # Check the availability of certain C++11 language features
-  hpx_check_for_cxx11_alias_templates(
-    REQUIRED "HPX needs support for C++11 alias templates")
-
-  hpx_check_for_cxx11_alignas(
-    DEFINITIONS HPX_HAVE_CXX11_ALIGNAS)
-
-  hpx_check_for_cxx11_auto(
-    REQUIRED "HPX needs support for C++11 auto")
-
-  hpx_check_for_cxx11_constexpr(
-    DEFINITIONS HPX_HAVE_CXX11_CONSTEXPR)
-
-  hpx_check_for_cxx11_decltype(
-    REQUIRED "HPX needs support for C++11 decltype")
-  hpx_add_config_cond_define(BOOST_RESULT_OF_USE_DECLTYPE)
-
-  hpx_check_for_cxx11_sfinae_expression(
-    DEFINITIONS HPX_HAVE_CXX11_SFINAE_EXPRESSION)
-
-  hpx_check_for_cxx11_defaulted_functions(
-    REQUIRED "HPX needs support for C++11 defaulted functions")
-
-  hpx_check_for_cxx11_deleted_functions(
-    REQUIRED "HPX needs support for C++11 deleted functions")
-
-  hpx_check_for_cxx11_explicit_cvt_ops(
-    REQUIRED "HPX needs support for C++11 explicit conversion operators")
-
-  hpx_check_for_cxx11_explicit_variadic_templates(
-    DEFINITIONS HPX_HAVE_CXX11_EXPLICIT_VARIADIC_TEMPLATES)
-
-  hpx_check_for_cxx11_extended_friend_declarations(
-    DEFINITIONS HPX_HAVE_CXX11_EXTENDED_FRIEND_DECLARATIONS)
-
-  hpx_check_for_cxx11_function_template_default_args(
-    REQUIRED "HPX needs support for C++11 defaulted function template arguments")
-
-  hpx_check_for_cxx11_inline_namespaces(
-    REQUIRED "HPX needs support for C++11 inline namespaces")
-
-  hpx_check_for_cxx11_lambdas(
-    REQUIRED "HPX needs support for C++11 lambdas")
-
-  hpx_check_for_cxx11_noexcept(
-    REQUIRED "HPX needs support for C++11 noexcept")
-
-  hpx_check_for_cxx11_nullptr(
-    REQUIRED "HPX needs support for C++11 nullptr")
-
-  hpx_check_for_cxx11_nsdmi(
-    DEFINITIONS HPX_HAVE_CXX11_NSDMI)
-
-  hpx_check_for_cxx11_range_based_for(
-    REQUIRED "HPX needs support for C++11 range-based for-loop")
-
-  hpx_check_for_cxx11_rvalue_references(
-    REQUIRED "HPX needs support for C++11 rvalue references")
-
-  hpx_check_for_cxx11_scoped_enums(
-    REQUIRED "HPX needs support for C++11 scoped enums")
-
-  hpx_check_for_cxx11_static_assert(
-    REQUIRED "HPX needs support for C++11 static_assert")
-
-  hpx_check_for_cxx11_variadic_macros(
-    REQUIRED "HPX needs support for C++11 variadic macros")
-
-  hpx_check_for_cxx11_variadic_templates(
-    REQUIRED "HPX needs support for C++11 variadic templates")
-
-  hpx_check_for_cxx11_override(
-    REQUIRED "HPX needs support for C++11 override")
-
-  # Check the availability of certain C++11 library features
-  hpx_check_for_cxx11_std_array(
-    REQUIRED "HPX needs support for C++11 std::array")
-
   hpx_check_for_cxx11_std_atomic(
     REQUIRED "HPX needs support for C++11 std::atomic")
 
@@ -97,138 +18,35 @@ function(hpx_perform_cxx_feature_tests)
   hpx_check_for_cxx11_std_atomic_128bit(
     DEFINITIONS HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
 
-  hpx_check_for_cxx11_std_chrono(
-    REQUIRED "HPX needs support for C++11 std::chrono")
-
-  hpx_check_for_cxx11_std_cstdint(
-    REQUIRED "HPX needs support for C++11 std::[u]intX_t")
-
-  hpx_check_for_cxx11_std_exception_ptr(
-    REQUIRED "HPX needs support for C++11 std::exception_ptr")
-
-  hpx_check_for_cxx11_std_forward_list(
-    REQUIRED "HPX needs support for C++11 std::forward_list")
-
-  hpx_check_for_cxx11_std_initializer_list(
-    REQUIRED "HPX needs support for C++11 std::initializer_list")
-
-  hpx_check_for_cxx11_std_is_bind_expression(
-    DEFINITIONS HPX_HAVE_CXX11_STD_IS_BIND_EXPRESSION)
-
-  hpx_check_for_cxx11_std_is_placeholder(
-    DEFINITIONS HPX_HAVE_CXX11_STD_IS_PLACEHOLDER)
-
-  hpx_check_for_cxx11_std_is_trivially_copyable(
-    DEFINITIONS HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
-
-  hpx_check_for_cxx11_std_lock_guard(
-    REQUIRED "HPX needs support for C++11 std::lock_guard")
-
   hpx_check_for_cxx11_std_quick_exit(
     DEFINITIONS HPX_HAVE_CXX11_STD_QUICK_EXIT)
 
-  hpx_check_for_cxx11_std_random(
-    DEFINITIONS HPX_HAVE_CXX11_STD_RANDOM)
-
-  hpx_check_for_cxx11_std_range_access(
-    REQUIRED "HPX needs support for C++11 std::begin/end")
-
-  hpx_check_for_cxx11_std_reference_wrapper(
-    REQUIRED "HPX needs support for C++11 std::ref and std::reference_wrapper")
-
-  hpx_check_for_cxx11_std_regex(
-    REQUIRED "HPX needs support for C++11 std::regex")
-
-  hpx_check_for_cxx11_std_shared_ptr(
-    REQUIRED "HPX needs support for C++11 std::shared_ptr")
-
   hpx_check_for_cxx11_std_shared_ptr_lwg3018(
-    DEFINITIONS HPX_HAVE_CXX11_SHARED_PTR_LWG3018)
-
-  hpx_check_for_cxx11_std_shuffle(
-    DEFINITIONS HPX_HAVE_CXX11_STD_SHUFFLE)
-
-  hpx_check_for_cxx11_std_thread(
-    DEFINITIONS HPX_HAVE_CXX11_STD_THREAD)
-
-  hpx_check_for_cxx11_std_to_string(
-    REQUIRED "HPX needs support for C++11 std::to_string")
-
-  hpx_check_for_cxx11_std_unique_lock(
-    REQUIRED "HPX needs support for C++11 std::unique_lock")
-
-  hpx_check_for_cxx11_std_unique_ptr(
-    REQUIRED "HPX needs support for C++11 std::unique_ptr")
-
-  hpx_check_for_cxx11_std_unordered_map(
-    REQUIRED "HPX needs support for C++11 std::unordered_map")
-
-  hpx_check_for_cxx11_std_unordered_set(
-    REQUIRED "HPX needs support for C++11 std::unordered_set")
+    DEFINITIONS HPX_HAVE_CXX11_STD_SHARED_PTR_LWG3018)
 
-  hpx_check_for_cxx11_thread_local(
-    DEFINITIONS HPX_HAVE_CXX11_THREAD_LOCAL)
+  hpx_check_for_cxx17_filesystem(
+    DEFINITIONS HPX_HAVE_CXX17_FILESYSTEM)
 
-  hpx_check_for_cxx11_noreturn_attribute(
-    DEFINITIONS HPX_HAVE_CXX11_NORETURN_ATTRIBUTE)
+  hpx_check_for_cxx17_fold_expressions(
+    DEFINITIONS HPX_HAVE_CXX17_FOLD_EXPRESSIONS)
 
-  if(HPX_WITH_CXX1Y OR HPX_WITH_CXX14 OR HPX_WITH_CXX1Z OR HPX_WITH_CXX17 OR HPX_WITH_CXX2A)
-    # Check the availability of certain C++14 language features
-    hpx_check_for_cxx14_constexpr(
-      DEFINITIONS HPX_HAVE_CXX14_CONSTEXPR)
+  hpx_check_for_cxx17_fallthrough_attribute(
+    DEFINITIONS HPX_HAVE_CXX17_FALLTHROUGH_ATTRIBUTE)
 
-    hpx_check_for_cxx14_lambdas(
-      DEFINITIONS HPX_HAVE_CXX14_LAMBDAS)
+  hpx_check_for_cxx17_hardware_destructive_interference_size(
+    DEFINITIONS HPX_HAVE_CXX17_HARDWARE_DESTRUCTIVE_INTERFERENCE_SIZE)
 
-    # Check the availability of certain C++14 library features
-    hpx_check_for_cxx14_std_integer_sequence(
-      DEFINITIONS HPX_HAVE_CXX14_STD_INTEGER_SEQUENCE)
+  hpx_check_for_cxx17_structured_bindings(
+    DEFINITIONS HPX_HAVE_CXX17_STRUCTURED_BINDINGS)
 
-    hpx_check_for_cxx14_std_is_final(
-      DEFINITIONS HPX_HAVE_CXX14_STD_IS_FINAL)
+  hpx_check_for_cxx17_if_constexpr(
+    DEFINITIONS HPX_HAVE_CXX17_IF_CONSTEXPR)
 
-    hpx_check_for_cxx14_std_is_null_pointer(
-      DEFINITIONS HPX_HAVE_CXX14_STD_IS_NULL_POINTER)
+  hpx_check_for_cxx17_aligned_new(
+    DEFINITIONS HPX_HAVE_CXX17_ALIGNED_NEW)
 
-    hpx_check_for_cxx14_std_result_of_sfinae(
-      DEFINITIONS HPX_HAVE_CXX14_STD_RESULT_OF_SFINAE)
-
-    hpx_check_for_cxx14_variable_templates(
-      DEFINITIONS HPX_HAVE_CXX14_VARIABLE_TEMPLATES)
-
-    hpx_check_for_cxx14_deprecated_attribute(
-      DEFINITIONS HPX_HAVE_CXX14_DEPRECATED_ATTRIBUTE)
-
-    hpx_check_for_cxx14_return_type_deduction()
-  endif()
-
-  if(HPX_WITH_CXX1Z OR HPX_WITH_CXX17 OR HPX_WITH_CXX2A)
-    # Check the availability of certain C++17 language features
-    hpx_check_for_cxx17_filesystem(
-      DEFINITIONS HPX_HAVE_CXX17_FILESYSTEM)
-
-    hpx_check_for_cxx17_fold_expressions(
-      DEFINITIONS HPX_HAVE_CXX17_FOLD_EXPRESSIONS)
-
-    hpx_check_for_cxx17_fallthrough_attribute(
-      DEFINITIONS HPX_HAVE_CXX17_FALLTHROUGH_ATTRIBUTE)
-
-    hpx_check_for_cxx17_hardware_destructive_interference_size(
-      DEFINITIONS HPX_HAVE_CXX17_HARDWARE_DESTRUCTIVE_INTERFERENCE_SIZE)
-
-    hpx_check_for_cxx17_structured_bindings(
-      DEFINITIONS HPX_HAVE_CXX17_STRUCTURED_BINDINGS)
-
-    hpx_check_for_cxx17_if_constexpr(
-      DEFINITIONS HPX_HAVE_CXX17_IF_CONSTEXPR)
-
-    hpx_check_for_cxx17_aligned_new(
-      DEFINITIONS HPX_HAVE_CXX17_ALIGNED_NEW)
-
-    hpx_check_for_cxx17_std_in_place_type_t(
-      DEFINITIONS HPX_HAVE_CXX17_STD_IN_PLACE_TYPE_T)
-
-  endif()
+  hpx_check_for_cxx17_std_in_place_type_t(
+    DEFINITIONS HPX_HAVE_CXX17_STD_IN_PLACE_TYPE_T)
 
   # we deliberately check for this functionality even for non-C++17
   # configurations as some compilers (notable gcc V7.x) require for noexcept
@@ -236,4 +54,14 @@ function(hpx_perform_cxx_feature_tests)
   hpx_check_for_cxx17_noexcept_functions_as_nontype_template_arguments(
     DEFINITIONS HPX_HAVE_CXX17_NOEXCEPT_FUNCTIONS_AS_NONTYPE_TEMPLATE_ARGUMENTS)
 
+  # Check the availability of certain C++ builtins
+  hpx_check_for_builtin_integer_pack(
+    DEFINITIONS HPX_HAVE_BUILTIN_INTEGER_PACK)
+
+  hpx_check_for_builtin_make_integer_seq(
+    DEFINITIONS HPX_HAVE_BUILTIN_MAKE_INTEGER_SEQ)
+
+  hpx_check_for_builtin_type_pack_element(
+    DEFINITIONS HPX_HAVE_BUILTIN_TYPE_PACK_ELEMENT)
+
 endfunction()
diff --git a/cmake/HPX_PrintSummary.cmake b/cmake/HPX_PrintSummary.cmake
index 4c0ca34280..3fa52c19ab 100644
--- a/cmake/HPX_PrintSummary.cmake
+++ b/cmake/HPX_PrintSummary.cmake
@@ -62,12 +62,16 @@ function(create_configuration_summary message module_name)
     string(REPLACE ";" "" hpx_config_information ${hpx_config_information})
   endif()
 
-  if("${module_name}x" STREQUAL "hpxx")
+  if("${module_name}" STREQUAL "hpx")
     set(_base_dir_local "hpx/config")
     set(_base_dir "hpx/config")
     set(_template "config_defines_strings.hpp.in")
   else()
-    set(_base_dir_local "libs/${module_name}/include/hpx/${module_name}/config/")
+    # NOTE: We generate the config_strings.hpp files for each module into the
+    # config module directory. This ensures that modules like version can access
+    # the config strings of all modules, instead of making the version module
+    # depend on all other modules.
+    set(_base_dir_local "libs/config/include/hpx/${module_name}/config/")
     set(_base_dir "hpx/${module_name}/config/")
     set(_template "config_defines_strings_for_modules.hpp.in")
   endif()
diff --git a/cmake/HPX_SetupAllocator.cmake b/cmake/HPX_SetupAllocator.cmake
index e8cb6fdd4a..42f75d627c 100644
--- a/cmake/HPX_SetupAllocator.cmake
+++ b/cmake/HPX_SetupAllocator.cmake
@@ -42,12 +42,7 @@ if (NOT TARGET hpx::allocator)
         hpx_error(${allocator_error})
       endif()
 
-      if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-        set_property(TARGET hpx::allocator PROPERTY
-          INTERFACE_LINK_LIBRARIES ${TCMALLOC_LIBRARIES})
-      else()
-          target_link_libraries(hpx::allocator INTERFACE ${TCMALLOC_LIBRARIES})
-      endif()
+      target_link_libraries(hpx::allocator INTERFACE ${TCMALLOC_LIBRARIES})
 
       if(MSVC)
         hpx_add_link_flag_if_available(/INCLUDE:__tcmalloc)
@@ -62,15 +57,9 @@ if (NOT TARGET hpx::allocator)
       if(NOT JEMALLOC_LIBRARIES)
         hpx_error(${allocator_error})
       endif()
-      set_property(TARGET hpx::allocator PROPERTY
-        INTERFACE_INCLUDE_DIRECTORIES ${JEMALLOC_INCLUDE_DIR}
-        ${JEMALLOC_ADDITIONAL_INCLUDE_DIR})
-      if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-        set_property(TARGET hpx::allocator PROPERTY
-          INTERFACE_LINK_LIBRARIES ${JEMALLOC_LIBRARIES})
-      else()
-        target_link_libraries(hpx::allocator INTERFACE ${JEMALLOC_LIBRARIES})
-      endif()
+      target_include_directories(hpx::allocator INTERFACE
+          ${JEMALLOC_INCLUDE_DIR} ${JEMALLOC_ADDITIONAL_INCLUDE_DIR})
+      target_link_libraries(hpx::allocator INTERFACE ${JEMALLOC_LIBRARIES})
     endif()
 
     ##################################################
@@ -80,12 +69,7 @@ if (NOT TARGET hpx::allocator)
       if(NOT mimalloc_FOUND)
         hpx_error(${allocator_error})
       endif()
-      if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-        set_property(TARGET hpx::allocator PROPERTY
-          INTERFACE_LINK_LIBRARIES mimalloc)
-      else()
-        target_link_libraries(hpx::allocator INTERFACE mimalloc)
-      endif()
+      target_link_libraries(hpx::allocator INTERFACE mimalloc)
       set(hpx_MALLOC_LIBRARY mimalloc)
       if(MSVC)
         hpx_add_link_flag_if_available(/INCLUDE:mi_version)
@@ -103,13 +87,8 @@ if (NOT TARGET hpx::allocator)
       if(MSVC)
         hpx_add_link_flag_if_available(/INCLUDE:__TBB_malloc_proxy)
       endif()
-      if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-        set_property(TARGET hpx::allocator PROPERTY
-          INTERFACE_LINK_LIBRARIES ${TBBMALLOC_LIBRARY} ${TBBMALLOC_PROXY_LIBRARY})
-      else()
-        target_link_libraries(hpx::allocator INTERFACE
-          ${TBBMALLOC_LIBRARY} ${TBBMALLOC_PROXY_LIBRARY})
-      endif()
+      target_link_libraries(hpx::allocator INTERFACE
+        ${TBBMALLOC_LIBRARY} ${TBBMALLOC_PROXY_LIBRARY})
     endif()
 
     if("${HPX_WITH_MALLOC_UPPER}" STREQUAL "CUSTOM")
@@ -140,14 +119,8 @@ if (NOT TARGET hpx::allocator)
     endif()
 
     add_library(hpx::amplifier INTERFACE IMPORTED)
-    set_property(TARGET hpx::amplifier PROPERTY
-      INTERFACE_INCLUDE_DIRECTORIES ${AMPLIFIER_INCLUDE_DIR})
-    if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-      set_property(TARGET hpx::amplifier PROPERTY
-        INTERFACE_LINK_LIBRARIES ${AMPLIFIER_LIBRARIES})
-    else()
-      target_link_libraries(hpx::allocator INTERFACE ${AMPLIFIER_LIBRARIES})
-    endif()
+    target_include_directories(hpx::amplifier INTERFACE ${AMPLIFIER_INCLUDE_DIR})
+    target_link_libraries(hpx::amplifier INTERFACE ${AMPLIFIER_LIBRARIES})
 
     hpx_add_config_define(HPX_HAVE_ITTNOTIFY 1)
     hpx_add_config_define(HPX_HAVE_THREAD_DESCRIPTION)
diff --git a/cmake/HPX_SetupApex.cmake b/cmake/HPX_SetupApex.cmake
index 2ea24d6f72..6b3166cd88 100644
--- a/cmake/HPX_SetupApex.cmake
+++ b/cmake/HPX_SetupApex.cmake
@@ -49,12 +49,9 @@ if(HPX_WITH_APEX AND NOT TARGET hpx::apex)
   endif()
 
   add_library(hpx::apex INTERFACE IMPORTED)
-  # System has been removed when passing at set_property for cmake < 3.11
-  get_target_property(_apex_include_directories apex INTERFACE_INCLUDE_DIRECTORIES)
-  set_property(TARGET hpx::apex PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${_apex_include_directories})
-  set_property(TARGET hpx::apex PROPERTY INTERFACE_LINK_LIBRARIES apex)
+  target_link_libraries(hpx::apex INTERFACE apex)
   if(UNIX AND NOT APPLE)
-    set_property(TARGET hpx::apex PROPERTY INTERFACE_LINK_OPTIONS "-Wl,-no-as-needed")
+    target_link_options(hpx::apex INTERFACE "-Wl,-no-as-needed")
   endif()
 
   # handle optional ITTNotify library (private dependency, skip when called in find_package(HPX))
@@ -65,9 +62,8 @@ if(HPX_WITH_APEX AND NOT TARGET hpx::apex)
     endif()
 
     add_library(hpx::ittnotify INTERFACE IMPORTED)
-    # System has been removed when passing at set_property for cmake < 3.11
-    set_property(TARGET hpx::ittnotify PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${ITTNOTIFY_SOURCE_DIR})
-    set_property(TARGET hpx::apex APPEND PROPERTY INTERFACE_LINK_LIBRARIES hpx::ittnotify)
+    target_include_directories(hpx::ittnotify INTERFACE ${ITTNOTIFY_SOURCE_DIR})
+    target_link_libraries(hpx::apex INTERFACE hpx::ittnotify)
     hpx_add_config_define(HPX_HAVE_ITTNOTIFY 1)
   endif()
 endif()
diff --git a/cmake/HPX_SetupBoost.cmake b/cmake/HPX_SetupBoost.cmake
index 0ddf8e2153..810f15fcf0 100644
--- a/cmake/HPX_SetupBoost.cmake
+++ b/cmake/HPX_SetupBoost.cmake
@@ -58,10 +58,6 @@ if (NOT TARGET hpx::boost)
   endif()
 
   if(HPX_WITH_GENERIC_CONTEXT_COROUTINES)
-    if(CMAKE_VERSION VERSION_LESS 3.12)
-      hpx_error("The Boost.context component needs at least CMake 3.12.3 to be \
-      found.")
-    endif()
     # if context is needed, we should still link with boost thread and chrono
     set(__boost_libraries ${__boost_libraries} context thread chrono)
   endif()
@@ -89,30 +85,20 @@ if (NOT TARGET hpx::boost)
   # Boost headers
   # FIXME: push changes upstream
   if(HPX_PLATFORM_UC STREQUAL "XEONPHI")
-    # Before flag remove when passing at set_property for cmake < 3.11 instead of target_include_directories
-    # so should be added first
-    if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-      set_property(TARGET hpx::boost PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/external/asio)
-    else()
-      target_include_directories(hpx::boost BEFORE INTERFACE ${PROJECT_SOURCE_DIR}/external/asio)
-    endif()
+    target_include_directories(hpx::boost BEFORE INTERFACE ${PROJECT_SOURCE_DIR}/external/asio)
   endif()
 
-  set_property(TARGET hpx::boost APPEND PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${Boost_INCLUDE_DIRS})
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::boost APPEND PROPERTY INTERFACE_LINK_LIBRARIES ${Boost_LIBRARIES})
-  else()
-    target_link_libraries(hpx::boost INTERFACE ${Boost_LIBRARIES})
-  endif()
+  target_include_directories(hpx::boost INTERFACE ${Boost_INCLUDE_DIRS})
+  target_link_libraries(hpx::boost INTERFACE ${Boost_LIBRARIES})
+
+  include(HPX_AddDefinitions)
+
+  # Boost Asio should not use Boost exceptions
+  hpx_add_config_cond_define(BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION 0)
 
   find_package(Threads QUIET REQUIRED)
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::boost APPEND PROPERTY INTERFACE_LINK_LIBRARIES Threads::Threads)
-  else()
-    target_link_libraries(hpx::boost INTERFACE Threads::Threads)
-  endif()
+  target_link_libraries(hpx::boost INTERFACE Threads::Threads)
 
-  include(HPX_AddDefinitions)
   # Boost preprocessor definitions
   if(NOT Boost_USE_STATIC_LIBS)
     hpx_add_config_cond_define(BOOST_ALL_DYN_LINK)
@@ -121,6 +107,6 @@ if (NOT TARGET hpx::boost)
     hpx_add_config_define(HPX_COROUTINE_NO_SEPARATE_CALL_SITES)
   endif()
   hpx_add_config_cond_define(BOOST_BIGINT_HAS_NATIVE_INT64)
-  set_property(TARGET hpx::boost APPEND PROPERTY INTERFACE_COMPILE_DEFINITIONS BOOST_ALL_NO_LIB) # disable auto-linking
+  target_link_libraries(hpx::boost INTERFACE Boost::disable_autolinking)
 
 endif()
diff --git a/cmake/HPX_SetupBoostFilesystem.cmake b/cmake/HPX_SetupBoostFilesystem.cmake
index 030163134a..db3f269cea 100644
--- a/cmake/HPX_SetupBoostFilesystem.cmake
+++ b/cmake/HPX_SetupBoostFilesystem.cmake
@@ -19,16 +19,8 @@ if(HPX_FILESYSTEM_WITH_BOOST_FILESYSTEM_COMPATIBILITY)
       COMPONENTS filesystem)
 
     add_library(hpx::boost::filesystem INTERFACE IMPORTED)
-
-    set_property(TARGET hpx::boost::filesystem APPEND PROPERTY
-      INTERFACE_INCLUDE_DIRECTORIES ${Boost_INCLUDE_DIRS})
-    if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-      set_property(TARGET hpx::boost::filesystem PROPERTY INTERFACE_LINK_LIBRARIES
-        ${Boost_FILESYSTEM_LIBRARIES})
-    else()
-      target_link_libraries(hpx::boost::filesystem INTERFACE
-        ${Boost_FILESYSTEM_LIBRARIES})
-    endif()
+    target_include_directories(hpx::boost::filesystem INTERFACE ${Boost_INCLUDE_DIRS})
+    target_link_libraries(hpx::boost::filesystem INTERFACE ${Boost_FILESYSTEM_LIBRARIES})
 
   endif()
 
diff --git a/cmake/HPX_SetupBoostIostreams.cmake b/cmake/HPX_SetupBoostIostreams.cmake
index 185776ae88..0897b82176 100644
--- a/cmake/HPX_SetupBoostIostreams.cmake
+++ b/cmake/HPX_SetupBoostIostreams.cmake
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-if((HPX_WITH_COMPRESSION_BZIP2 OR HPX_WITH_COMPRESSION_ZLIB) AND NOT TARGET hpx::boost::iostreams)
+if(NOT TARGET hpx::boost::iostreams)
 
   find_package(Boost ${Boost_MINIMUM_VERSION} QUIET MODULE COMPONENTS iostreams)
 
@@ -18,16 +18,7 @@ if((HPX_WITH_COMPRESSION_BZIP2 OR HPX_WITH_COMPRESSION_ZLIB) AND NOT TARGET hpx:
 
   add_library(hpx::boost::iostreams INTERFACE IMPORTED)
 
-  # Can't directly link to "iostreams" target in set_property, can change is when using target_link_libraries
-
-  set_property(TARGET hpx::boost::iostreams APPEND PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${Boost_INCLUDE_DIRS})
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::boost::iostreams APPEND PROPERTY
-      INTERFACE_LINK_LIBRARIES ${Boost_IOSTREAMS_LIBRARIES})
-  else()
-    target_link_libraries(hpx::boost::iostreams INTERFACE
-      ${Boost_IOSTREAMS_LIBRARIES})
-  endif()
+  target_include_directories(hpx::boost::iostreams INTERFACE ${Boost_INCLUDE_DIRS})
+  target_link_libraries(hpx::boost::iostreams INTERFACE ${Boost_IOSTREAMS_LIBRARIES})
 
 endif()
diff --git a/cmake/HPX_SetupBoostProgramOptions.cmake b/cmake/HPX_SetupBoostProgramOptions.cmake
index 5a2e411a47..c83a355b68 100644
--- a/cmake/HPX_SetupBoostProgramOptions.cmake
+++ b/cmake/HPX_SetupBoostProgramOptions.cmake
@@ -25,15 +25,8 @@ if(HPX_PROGRAM_OPTIONS_WITH_BOOST_PROGRAM_OPTIONS_COMPATIBILITY AND NOT TARGET
   endif()
 
   add_library(hpx::boost::program_options INTERFACE IMPORTED)
-
-  set_property(TARGET hpx::boost::program_options APPEND PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${Boost_INCLUDE_DIRS})
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::boost::program_options PROPERTY INTERFACE_LINK_LIBRARIES
-      ${Boost_PROGRAM_OPTIONS_LIBRARIES})
-  else()
-    target_link_libraries(hpx::boost::program_options INTERFACE
-      ${Boost_PROGRAM_OPTIONS_LIBRARIES})
-  endif()
+  target_include_directories(hpx::boost::program_options INTERFACE ${Boost_INCLUDE_DIRS})
+  target_link_libraries(hpx::boost::program_options INTERFACE
+    ${Boost_PROGRAM_OPTIONS_LIBRARIES})
 
 endif()
diff --git a/cmake/HPX_SetupBoostRegex.cmake b/cmake/HPX_SetupBoostRegex.cmake
index 5be12aa735..7ca4ba225e 100644
--- a/cmake/HPX_SetupBoostRegex.cmake
+++ b/cmake/HPX_SetupBoostRegex.cmake
@@ -18,13 +18,6 @@ if(NOT TARGET hpx::boost::regex)
   endif()
 
   add_library(hpx::boost::regex INTERFACE IMPORTED)
-
-  set_property(TARGET hpx::boost::regex APPEND PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${Boost_INCLUDE_DIRS})
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::boost::regex PROPERTY INTERFACE_LINK_LIBRARIES
-      ${Boost_REGEX_LIBRARIES})
-  else()
-    target_link_libraries(hpx::boost::regex INTERFACE ${Boost_REGEX_LIBRARIES})
-  endif()
+  target_include_directories(hpx::boost::regex INTERFACE ${Boost_INCLUDE_DIRS})
+  target_link_libraries(hpx::boost::regex INTERFACE ${Boost_REGEX_LIBRARIES})
 endif()
diff --git a/cmake/HPX_SetupCUDA.cmake b/cmake/HPX_SetupCUDA.cmake
index ad8680004f..c6809f6d6f 100644
--- a/cmake/HPX_SetupCUDA.cmake
+++ b/cmake/HPX_SetupCUDA.cmake
@@ -22,12 +22,7 @@ if(HPX_WITH_CUDA AND NOT TARGET hpx::cuda)
 
   if(NOT HPX_WITH_CUDA_CLANG)
     if(NOT MSVC)
-      if(${CMAKE_VERSION} VERSION_LESS "3.13.0")
-        set_property(TARGET hpx::cuda PROPERTY
-          INTERFACE_LINK_DIRECTORIES ${CUDA_TOOLKIT_ROOT_DIR}/lib64)
-      else()
-        target_link_directories(hpx::cuda INTERFACE ${CUDA_TOOLKIT_ROOT_DIR}/lib64)
-      endif()
+      target_link_directories(hpx::cuda INTERFACE ${CUDA_TOOLKIT_ROOT_DIR}/lib64)
       #set(CUDA_NVCC_FLAGS_DEBUG ${CUDA_NVCC_FLAGS_DEBUG};-D_DEBUG;-O0;-g;-G)
       #set(CUDA_NVCC_FLAGS_RELWITHDEBINFO ${CUDA_NVCC_FLAGS_RELWITHDEBINFO};-DNDEBUG;-O3;-g)
       #set(CUDA_NVCC_FLAGS_MINSIZEREL ${CUDA_NVCC_FLAGS_MINSIZEREL};-DNDEBUG;-O1)
@@ -35,30 +30,19 @@ if(HPX_WITH_CUDA AND NOT TARGET hpx::cuda)
       set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-w)
     else()
       set(CUDA_PROPAGATE_HOST_FLAGS OFF)
-      if(${CMAKE_VERSION} VERSION_LESS "3.13.0")
-        set_property(TARGET hpx::cuda PROPERTY
-          INTERFACE_LINK_DIRECTORIES ${CUDA_TOOLKIT_ROOT_DIR}/lib/x64)
-      else()
-        target_link_directories(hpx::cuda INTERFACE ${CUDA_TOOLKIT_ROOT_DIR}/lib/x64)
-      endif()
+      target_link_directories(hpx::cuda INTERFACE ${CUDA_TOOLKIT_ROOT_DIR}/lib/x64)
       set(CUDA_NVCC_FLAGS_DEBUG ${CUDA_NVCC_FLAGS_DEBUG};-D_DEBUG;-O0;-g;-G;-Xcompiler=-MDd;-Xcompiler=-Od;-Xcompiler=-Zi;-Xcompiler=-bigobj)
       set(CUDA_NVCC_FLAGS_RELWITHDEBINFO ${CUDA_NVCC_FLAGS_RELWITHDEBINFO};-DNDEBUG;-O2;-g;-Xcompiler=-MD,-O2,-Zi;-Xcompiler=-bigobj)
       set(CUDA_NVCC_FLAGS_MINSIZEREL ${CUDA_NVCC_FLAGS_MINSIZEREL};-DNDEBUG;-O1;-Xcompiler=-MD,-O1;-Xcompiler=-bigobj)
       set(CUDA_NVCC_FLAGS_RELEASE ${CUDA_NVCC_FLAGS_RELEASE};-DNDEBUG;-O2;-Xcompiler=-MD,-Ox;-Xcompiler=-bigobj)
     endif()
     set(CUDA_SEPARABLE_COMPILATION ON)
-    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};${CXX_FLAG})
     set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};--expt-relaxed-constexpr)
     set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};--expt-extended-lambda)
     set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};--default-stream per-thread)
   else()
     hpx_add_target_compile_option(-DBOOST_THREAD_USES_MOVE PUBLIC)
-    if(${CMAKE_VERSION} VERSION_LESS "3.13.0")
-      set_property(TARGET hpx::cuda PROPERTY
-        INTERFACE_LINK_DIRECTORIES ${CUDA_TOOLKIT_ROOT_DIR}/lib64)
-    else()
-      target_link_directories(hpx::cuda INTERFACE ${CUDA_TOOLKIT_ROOT_DIR}/lib64)
-    endif()
+    target_link_directories(hpx::cuda INTERFACE ${CUDA_TOOLKIT_ROOT_DIR}/lib64)
     target_link_libraries(hpx::cuda INTERFACE cudart)
   endif()
 
diff --git a/cmake/HPX_SetupGooglePerfTools.cmake b/cmake/HPX_SetupGooglePerfTools.cmake
index 316202d511..ef3baa2e2c 100644
--- a/cmake/HPX_SetupGooglePerfTools.cmake
+++ b/cmake/HPX_SetupGooglePerfTools.cmake
@@ -23,13 +23,7 @@ if(HPX_WITH_GOOGLE_PERFTOOLS AND NOT TARGET hpx::gperftools)
   endif()
 
   add_library(hpx::gperftools INTERFACE IMPORTED)
-  set_property(TARGET hpx::gperftools PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${GOOGLE_PERFTOOLS_INCLUDE_DIR})
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::gperftools PROPERTY
-      INTERFACE_LINK_LIBRARIES ${GOOGLE_PERFTOOLS_LIBRARIES})
-  else()
-    target_link_libraries(hpx::gperftools INTERFACE ${GOOGLE_PERFTOOLS_LIBRARIES})
-  endif()
+  target_include_directories(hpx::gperftools INTERFACE ${GOOGLE_PERFTOOLS_INCLUDE_DIR})
+  target_link_libraries(hpx::gperftools INTERFACE ${GOOGLE_PERFTOOLS_LIBRARIES})
 
 endif()
diff --git a/cmake/HPX_SetupHwloc.cmake b/cmake/HPX_SetupHwloc.cmake
index 8f212042f6..a7df3221e5 100644
--- a/cmake/HPX_SetupHwloc.cmake
+++ b/cmake/HPX_SetupHwloc.cmake
@@ -21,13 +21,7 @@ if (NOT TARGET hpx::hwloc)
   endif()
 
   add_library(hpx::hwloc INTERFACE IMPORTED)
-  # System has been removed when passing at set_property for cmake < 3.11
-  # instead of target_include_directories
-  set_property(TARGET hpx::hwloc PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${HWLOC_INCLUDE_DIR})
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::hwloc PROPERTY INTERFACE_LINK_LIBRARIES ${HWLOC_LIBRARIES})
-  else()
-    target_link_libraries(hpx::hwloc INTERFACE ${HWLOC_LIBRARIES})
-  endif()
+  target_include_directories(hpx::hwloc INTERFACE ${HWLOC_INCLUDE_DIR})
+  target_link_libraries(hpx::hwloc INTERFACE ${HWLOC_LIBRARIES})
 
 endif()
diff --git a/cmake/HPX_SetupLibfabric.cmake b/cmake/HPX_SetupLibfabric.cmake
index fcf891cf28..b5f48de0f6 100644
--- a/cmake/HPX_SetupLibfabric.cmake
+++ b/cmake/HPX_SetupLibfabric.cmake
@@ -23,15 +23,8 @@ if (HPX_WITH_PARCELPORT_LIBFABRIC AND NOT TARGET hpx::libfabric)
   endif()
   # Setup Libfabric imported target
   add_library(hpx::libfabric INTERFACE IMPORTED)
-  set_property(TARGET hpx::libfabric PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${LIBFABRIC_INCLUDE_DIR})
-
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::libfabric PROPERTY INTERFACE_LINK_LIBRARIES ${LIBFABRIC_LIBRARY})
-  else()
-    target_link_libraries(hpx::libfabric INTERFACE ${LIBFABRIC_LIBRARY})
-  endif()
-
+  target_include_directories(hpx::libfabric INTERFACE ${LIBFABRIC_INCLUDE_DIR})
+  target_link_libraries(hpx::libfabric INTERFACE ${LIBFABRIC_LIBRARY})
 
   # Setup PMI imported target
   find_package(PMI)
@@ -42,10 +35,8 @@ if (HPX_WITH_PARCELPORT_LIBFABRIC AND NOT TARGET hpx::libfabric)
   endif()
 
   add_library(hpx::pmi INTERFACE IMPORTED)
-  set_property(TARGET hpx::pmi PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${PMI_INCLUDE_DIR})
-  set_property(TARGET hpx::pmi PROPERTY
-    INTERFACE_LINK_LIBRARIES ${PMI_LIBRARY})
+  target_include_directories(hpx::pmi INTERFACE ${PMI_INCLUDE_DIR})
+  target_link_libraries(hpx::pmi INTERFACE ${PMI_LIBRARY})
 
   #------------------------------------------------------------------------------
   # Logging
diff --git a/cmake/HPX_SetupMPI.cmake b/cmake/HPX_SetupMPI.cmake
index 2b525da50b..37ef6c11ab 100644
--- a/cmake/HPX_SetupMPI.cmake
+++ b/cmake/HPX_SetupMPI.cmake
@@ -19,36 +19,20 @@ if(HPX_WITH_NETWORKING AND HPX_WITH_PARCELPORT_MPI AND NOT TARGET hpx::mpi)
     MPI_ROOT to point to the root of your MPI installation")
   endif()
   add_library(hpx::mpi INTERFACE IMPORTED)
-  set_property(TARGET hpx::mpi PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${MPI_INCLUDE_PATH} ${MPI_CXX_INCLUDE_DIRS})
+  target_include_directories(hpx::mpi INTERFACE ${MPI_INCLUDE_PATH} ${MPI_CXX_INCLUDE_DIRS})
   # MPI_LIBRARY and EXTRA is deprecated but still linked for older MPI versions
   if (MPI_CXX_LIBRARIES)
-    if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-      set_property(TARGET hpx::mpi APPEND PROPERTY
-        INTERFACE_LINK_LIBRARIES ${MPI_CXX_LIBRARIES})
-    else()
-      target_link_libraries(hpx::mpi INTERFACE ${MPI_CXX_LIBRARIES})
-    endif()
+    target_link_libraries(hpx::mpi INTERFACE ${MPI_CXX_LIBRARIES})
   endif()
   # Ensure compatibility with older versions
   if (MPI_LIBRARY)
-    if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-      set_property(TARGET hpx::mpi APPEND PROPERTY
-        INTERFACE_LINK_LIBRARIES ${MPI_LIBRARY})
-    else()
-      target_link_libraries(hpx::mpi INTERFACE ${MPI_LIBRARY})
-    endif()
+    target_link_libraries(hpx::mpi INTERFACE ${MPI_LIBRARY})
   endif()
   if (MPI_EXTRA_LIBRARY)
-    if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-      set_property(TARGET hpx::mpi APPEND PROPERTY
-        INTERFACE_LINK_LIBRARIES ${MPI_EXTRA_LIBRARY})
-    else()
-      target_link_libraries(hpx::mpi INTERFACE ${MPI_EXTRA_LIBRARY})
-    endif()
+    target_link_libraries(hpx::mpi INTERFACE ${MPI_EXTRA_LIBRARY})
   endif()
-  set_property(TARGET hpx::mpi PROPERTY INTERFACE_COMPILE_OPTIONS ${MPI_CXX_COMPILE_FLAGS})
-  set_property(TARGET hpx::mpi PROPERTY INTERFACE_COMPILE_DEFINITIONS ${MPI_CXX_COMPILE_DEFINITIONS})
+  target_compile_options(hpx::mpi INTERFACE ${MPI_CXX_COMPILE_FLAGS})
+  target_compile_definitions(hpx::mpi INTERFACE ${MPI_CXX_COMPILE_DEFINITIONS})
   if(MPI_CXX_LINK_FLAGS)
     #hpx_add_link_flag_if_available(${MPI_CXX_LINK_FLAGS})
   endif()
diff --git a/cmake/HPX_SetupPapi.cmake b/cmake/HPX_SetupPapi.cmake
index ac86ded159..334bbfeded 100644
--- a/cmake/HPX_SetupPapi.cmake
+++ b/cmake/HPX_SetupPapi.cmake
@@ -21,11 +21,6 @@ if(HPX_WITH_PAPI AND NOT TARGET hpx::papi)
     PAPI_ROOT to point to the root of your PAPI installation")
   endif()
   add_library(hpx::papi INTERFACE IMPORTED)
-  set_property(TARGET hpx::papi PROPERTY
-    INTERFACE_INCLUDE_DIRECTORIES ${PAPI_INCLUDE_DIR})
-  if(${CMAKE_VERSION} VERSION_LESS "3.12.0")
-    set_property(TARGET hpx::papi PROPERTY INTERFACE_LINK_LIBRARIES ${PAPI_LIBRARY})
-  else()
-    target_link_libraries(hpx::papi INTERFACE ${PAPI_LIBRARY})
-  endif()
+  target_include_directories(hpx::papi INTERFACE ${PAPI_INCLUDE_DIR})
+  target_link_libraries(hpx::papi INTERFACE ${PAPI_LIBRARY})
 endif()
diff --git a/cmake/HPX_SetupTarget.cmake b/cmake/HPX_SetupTarget.cmake
index 0c9c8eb62b..eb71a5c7f3 100644
--- a/cmake/HPX_SetupTarget.cmake
+++ b/cmake/HPX_SetupTarget.cmake
@@ -13,7 +13,7 @@ hpx_set_cmake_policy(CMP0060 NEW)
 
 function(hpx_setup_target target)
   # retrieve arguments
-  set(options EXPORT NOHPX_INIT INSTALL INSTALL_HEADERS INTERNAL_FLAGS NOLIBS PLUGIN
+  set(options EXPORT INSTALL INSTALL_HEADERS INTERNAL_FLAGS NOLIBS PLUGIN
     NONAMEPREFIX NOTLLKEYWORD)
   set(one_value_args TYPE FOLDER NAME SOVERSION VERSION HPX_PREFIX HEADER_ROOT)
   set(multi_value_args DEPENDENCIES COMPONENT_DEPENDENCIES COMPILE_FLAGS LINK_FLAGS INSTALL_FLAGS INSTALL_PDB)
@@ -81,11 +81,6 @@ function(hpx_setup_target target)
     set(__tll_public PUBLIC)
   endif()
 
-  set(nohpxinit FALSE)
-  if(target_NOHPX_INIT)
-    set(nohpxinit TRUE)
-  endif()
-
   set(target_STATIC_LINKING OFF)
   if(HPX_WITH_STATIC_LINKING)
     set(target_STATIC_LINKING ON)
@@ -100,63 +95,25 @@ function(hpx_setup_target target)
     endif()
   endif()
 
-  if(HPX_INCLUDE_DIRS)
-    set_property(TARGET ${target} APPEND
-      PROPERTY INCLUDE_DIRECTORIES
-      "${HPX_INCLUDE_DIRS}"
-    )
-  endif()
-
   if("${_type}" STREQUAL "EXECUTABLE")
+    target_compile_definitions(${target}
+      PRIVATE
+      "HPX_APPLICATION_NAME=${name}"
+      "HPX_APPLICATION_STRING=\"${name}\"")
+
     if(target_HPX_PREFIX)
       set(_prefix ${target_HPX_PREFIX})
-    else()
-      set(_prefix ${HPX_PREFIX})
-    endif()
 
-    if(MSVC)
-      string(REPLACE ";" ":" _prefix "${_prefix}")
-    endif()
-
-    set_property(TARGET ${target} APPEND
-                 PROPERTY COMPILE_DEFINITIONS
-                 "HPX_APPLICATION_NAME=${name}"
-                 "HPX_APPLICATION_STRING=\"${name}\""
-                 "HPX_PREFIX=\"${_prefix}\""
-                 "HPX_APPLICATION_EXPORTS")
-  endif()
+      if(MSVC)
+        string(REPLACE ";" ":" _prefix "${_prefix}")
+      endif()
 
-  if("${_type}" STREQUAL "LIBRARY")
-    set(nohpxinit FALSE)
-    if(DEFINED HPX_LIBRARY_VERSION AND DEFINED HPX_SOVERSION)
-      # set properties of generated shared library
-      set_target_properties(${target}
-        PROPERTIES
-        VERSION ${HPX_LIBRARY_VERSION}
-        SOVERSION ${HPX_SOVERSION})
-    endif()
-    if(NOT target_NONAMEPREFIX)
-      hpx_set_lib_name(${target} ${name})
+      target_compile_definitions(${target} PRIVATE
+        "HPX_PREFIX=\"${_prefix}\"")
     endif()
-    set_target_properties(${target}
-      PROPERTIES
-      # create *nix style library versions + symbolic links
-      # allow creating static and shared libs without conflicts
-      CLEAN_DIRECT_OUTPUT 1
-      OUTPUT_NAME ${name})
-    if(target_PLUGIN)
-      set(plugin_name "HPX_PLUGIN_NAME=hpx_${name}")
-    endif()
-    set(nohpxinit TRUE)
-
-    set_property(TARGET ${target} APPEND
-                 PROPERTY COMPILE_DEFINITIONS
-                 "HPX_LIBRARY_EXPORTS"
-                 ${plugin_name})
   endif()
 
-  if("${_type}" STREQUAL "COMPONENT")
-    set(nohpxinit FALSE)
+  if("${_type}" STREQUAL "LIBRARY" OR "${_type}" STREQUAL "COMPONENT")
     if(DEFINED HPX_LIBRARY_VERSION AND DEFINED HPX_SOVERSION)
     # set properties of generated shared library
       set_target_properties(${target}
@@ -173,55 +130,37 @@ function(hpx_setup_target target)
       # allow creating static and shared libs without conflicts
       CLEAN_DIRECT_OUTPUT 1
       OUTPUT_NAME ${name})
-    set(nohpxinit TRUE)
-
-    set_property(TARGET ${target} APPEND
-                 PROPERTY COMPILE_DEFINITIONS
-                 "HPX_COMPONENT_NAME=hpx_${name}"
-                 "HPX_COMPONENT_STRING=\"hpx_${name}\""
-                 "HPX_COMPONENT_EXPORTS")
   endif()
 
-  # We force the -DDEBUG and -D_DEBUG defines in debug mode to avoid
-  # ABI differences
-  # if hpx is an imported target, get the config debug/release
-  set(HPX_IMPORT_CONFIG "NOTFOUND")
-  if (TARGET "hpx")
-    get_target_property(HPX_IMPORT_CONFIG "hpx" IMPORTED_CONFIGURATIONS)
+  if("${_type}" STREQUAL "LIBRARY" AND target_PLUGIN)
+    set(plugin_name "HPX_PLUGIN_NAME=hpx_${name}")
+    target_link_libraries(${target} ${__tll_private}
+      $<TARGET_NAME_IF_EXISTS:plugin>
+      $<TARGET_NAME_IF_EXISTS:HPX::plugin>)
   endif()
-  if(HPX_IMPORT_CONFIG MATCHES NOTFOUND)
-    # we are building HPX not importing, so we should use the $<CONFIG:variable
-    set(_USE_CONFIG 1)
-  else()
-    # hpx is an imported target, so set HPX_DEBUG based on build config of hpx library
-    set(_USE_CONFIG 0)
+
+  if("${_type}" STREQUAL "COMPONENT")
+    target_compile_definitions(${target}
+      PRIVATE
+      "HPX_COMPONENT_NAME=hpx_${name}"
+      "HPX_COMPONENT_STRING=\"hpx_${name}\"")
+    target_link_libraries(${target} ${__tll_private}
+      $<TARGET_NAME_IF_EXISTS:component>
+      $<TARGET_NAME_IF_EXISTS:HPX::component>)
   endif()
 
   if(NOT target_NOLIBS)
-    if(HPX_WITH_DYNAMIC_HPX_MAIN AND ("${_type}" STREQUAL "EXECUTABLE") AND
-       (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (APPLE)))
-      set(hpx_libs hpx_wrap)
-    endif()
-    set(hpx_libs ${hpx_libs} hpx)
-    if(NOT target_STATIC_LINKING)
-      set(hpx_libs ${hpx_libs})
-      if(NOT nohpxinit)
-        set(hpx_libs hpx_init ${hpx_libs})
-      endif()
-    endif()
+    target_link_libraries(${target} ${__tll_public}
+      $<TARGET_NAME_IF_EXISTS:hpx>
+      $<TARGET_NAME_IF_EXISTS:HPX::hpx>)
     hpx_handle_component_dependencies(target_COMPONENT_DEPENDENCIES)
-    set(hpx_libs ${hpx_libs} ${target_COMPONENT_DEPENDENCIES})
-    if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel")
-      set(hpx_libs ${hpx_libs} imf svml irng intlc)
-    endif()
-  else()
-    target_compile_options(${target} ${__tll_public} ${CXX_FLAG})
+    target_link_libraries(${target} ${__tll_public} ${target_COMPONENT_DEPENDENCIES})
   endif()
 
-  target_link_libraries(${target} ${__tll_public} ${hpx_libs} ${target_DEPENDENCIES})
+  target_link_libraries(${target} ${__tll_public} ${target_DEPENDENCIES})
 
-  if(target_INTERNAL_FLAGS AND TARGET hpx_internal_flags)
-    target_link_libraries(${target} ${__tll_private} hpx_internal_flags)
+  if(target_INTERNAL_FLAGS AND TARGET hpx_private_flags)
+    target_link_libraries(${target} ${__tll_private} hpx_private_flags)
   endif()
 
   get_target_property(target_EXCLUDE_FROM_ALL ${target} EXCLUDE_FROM_ALL)
diff --git a/cmake/HPX_SetupValgrind.cmake b/cmake/HPX_SetupValgrind.cmake
index 720b77e1e4..0590384e93 100644
--- a/cmake/HPX_SetupValgrind.cmake
+++ b/cmake/HPX_SetupValgrind.cmake
@@ -22,8 +22,7 @@ if(HPX_WITH_VALGRIND AND NOT TARGET hpx::valgrind)
   endif()
 
   add_library(hpx::valgrind INTERFACE IMPORTED)
-  # FIXME : specify the SYSTEM flag when passing to target_include_directories
-  set_property(TARGET hpx::valgrind PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${VALGRIND_INCLUDE_DIR})
+  target_include_directories(hpx::valgrind INTERFACE ${VALGRIND_INCLUDE_DIR})
 
   hpx_add_config_define(HPX_HAVE_VALGRIND)
 endif()
diff --git a/cmake/HPX_SetupVc.cmake b/cmake/HPX_SetupVc.cmake
index 60d2dda0e2..09988d0e41 100644
--- a/cmake/HPX_SetupVc.cmake
+++ b/cmake/HPX_SetupVc.cmake
@@ -56,16 +56,11 @@ if(HPX_WITH_DATAPAR_VC AND NOT TARGET hpx::vc)
   endif()
 
   add_library(hpx::vc INTERFACE IMPORTED)
-  set_property(TARGET hpx::vc PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${Vc_INCLUDE_DIR})
+  target_include_directories(hpx::vc INTERFACE ${Vc_INCLUDE_DIR})
 
   if(NOT HPX_WITH_DATAPAR_VC_NO_LIBRARY)
-    if(${CMAKE_VERSION} VERSION_LESS "3.13.0")
-      set_property(TARGET hpx::vc PROPERTY INTERFACE_LINK_LIBRARIES ${Vc_LIBRARIES})
-      set_property(TARGET hpx::vc PROPERTY INTERFACE_LINK_DIRECTORIES ${Vc_LIB_DIR})
-    else()
-      target_link_libraries(hpx::vc INTERFACE ${Vc_LIBRARIES})
-      target_link_directories(hpx::vc INTERFACE ${Vc_LIB_DIR})
-    endif()
+    target_link_libraries(hpx::vc INTERFACE ${Vc_LIBRARIES})
+    target_link_directories(hpx::vc INTERFACE ${Vc_LIB_DIR})
   endif()
 
   foreach(_flag ${Vc_DEFINITIONS})
@@ -76,7 +71,7 @@ if(HPX_WITH_DATAPAR_VC AND NOT TARGET hpx::vc)
       string(SUBSTRING ${_flag} 2 -1 _flag)
     endif()
 
-    set_property(TARGET hpx::vc APPEND PROPERTY INTERFACE_COMPILE_DEFINITIONS ${_flag})
+    target_compile_definitions(hpx::vc INTERFACE ${_flag})
   endforeach()
 
   include(HPX_AddDefinitions)
@@ -84,7 +79,7 @@ if(HPX_WITH_DATAPAR_VC AND NOT TARGET hpx::vc)
   # do not include Vc build flags for MSVC builds as this breaks building the
   # core HPX libraries itself
   if(NOT MSVC)
-    set_property(TARGET hpx::vc PROPERTY INTERFACE_COMPILE_OPTIONS ${Vc_COMPILE_FLAGS} ${Vc_ARCHITECTURE_FLAGS})
+    target_compile_options(hpx::vc INTERFACE ${Vc_COMPILE_FLAGS} ${Vc_ARCHITECTURE_FLAGS})
   else()
     hpx_add_config_cond_define(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
   endif()
diff --git a/cmake/HPX_UpdateGitDocs.cmake b/cmake/HPX_UpdateGitDocs.cmake
index 7dea4f063a..62cc45ac9a 100644
--- a/cmake/HPX_UpdateGitDocs.cmake
+++ b/cmake/HPX_UpdateGitDocs.cmake
@@ -1,10 +1,11 @@
+# Copyright (c)      2020 Mikael Simberg
 # Copyright (c) 2011-2013 Thomas Heller
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 find_package(Git)
 
@@ -13,7 +14,7 @@ if(NOT GIT_FOUND)
 endif()
 
 if(NOT GIT_REPOSITORY)
-  set(GIT_REPOSITORY git@github.com:STEllAR-GROUP/hpx.git --branch gh-pages)
+  set(GIT_REPOSITORY git@github.com:STEllAR-GROUP/hpx-docs.git --branch master)
 endif()
 
 if(EXISTS "${HPX_BINARY_DIR}/docs/gh-pages")
@@ -46,7 +47,7 @@ string(REGEX REPLACE " " ";"
 message("HPX_WITH_GIT_BRANCH=\"${HPX_WITH_GIT_BRANCH}\"")
 if(HPX_WITH_GIT_BRANCH)
   message("Updating branch directory")
-  set(DOCS_BRANCH_DEST "${HPX_BINARY_DIR}/docs/gh-pages/docs/sphinx/branches/${HPX_WITH_GIT_BRANCH}")
+  set(DOCS_BRANCH_DEST "${HPX_BINARY_DIR}/docs/gh-pages/branches/${HPX_WITH_GIT_BRANCH}")
   file(REMOVE_RECURSE "${DOCS_BRANCH_DEST}")
   if("html" IN_LIST HPX_WITH_DOCUMENTATION_OUTPUT_FORMATS)
     file(
@@ -72,7 +73,7 @@ endif()
 message("HPX_WITH_GIT_TAG=\"${HPX_WITH_GIT_TAG}\"")
 if(HPX_WITH_GIT_TAG)
   message("Updating tag directory")
-  set(DOCS_TAG_DEST "${HPX_BINARY_DIR}/docs/gh-pages/docs/sphinx/tags/${HPX_WITH_GIT_TAG}")
+  set(DOCS_TAG_DEST "${HPX_BINARY_DIR}/docs/gh-pages/tags/${HPX_WITH_GIT_TAG}")
   file(REMOVE_RECURSE "${DOCS_TAG_DEST}")
   if("html" IN_LIST HPX_WITH_DOCUMENTATION_OUTPUT_FORMATS)
     file(
@@ -99,7 +100,7 @@ if(HPX_WITH_GIT_TAG)
   # candidates or other non-version tag names.
   if("${HPX_WITH_GIT_TAG}" MATCHES "^[0-9]+\\.[0-9]+\\.[0-9]+$")
     message("Updating latest directory")
-    set(DOCS_LATEST_DEST "${HPX_BINARY_DIR}/docs/gh-pages/docs/sphinx/latest")
+    set(DOCS_LATEST_DEST "${HPX_BINARY_DIR}/docs/gh-pages/latest")
     file(REMOVE_RECURSE "${DOCS_LATEST_DEST}")
     if("html" IN_LIST HPX_WITH_DOCUMENTATION_OUTPUT_FORMATS)
       file(
@@ -125,7 +126,7 @@ endif()
 # add all newly generated files
 execute_process(
   COMMAND "${GIT_EXECUTABLE}" add *
-  WORKING_DIRECTORY "${HPX_BINARY_DIR}/docs/gh-pages/docs/sphinx"
+  WORKING_DIRECTORY "${HPX_BINARY_DIR}/docs/gh-pages"
   RESULT_VARIABLE git_add_result)
 if(NOT "${git_add_result}" EQUAL "0")
   message(FATAL_ERROR "Adding files to the GitHub pages branch failed.")
@@ -143,7 +144,7 @@ if(NOT "${git_diff_index_result}" EQUAL "0")
     WORKING_DIRECTORY "${HPX_BINARY_DIR}/docs/gh-pages"
     RESULT_VARIABLE git_commit_result)
   if(NOT "${git_commit_result}" EQUAL "0")
-    message(FATAL_ERROR "Commiting to the GitHub pages branch failed.")
+    message(FATAL_ERROR "Committing to the GitHub pages branch failed.")
   endif()
 
   # push everything up to github
diff --git a/cmake/packaging/rpm/Changelog.txt b/cmake/packaging/rpm/Changelog.txt
index bceff30a64..9d2c8e78f1 100644
--- a/cmake/packaging/rpm/Changelog.txt
+++ b/cmake/packaging/rpm/Changelog.txt
@@ -1,14 +1,14 @@
-* Wed Feb 13 2020 STE||AR Group <contact@stellar-group.org> 1.4.1-1
+* Wed Feb 12 2020 STE||AR Group <contact@stellar-group.org> 1.4.1-1
 - HPX Release 1.4.1 (https://stellar-group.github.io/hpx-docs/tags/1.4.1/html/releases/whats_new_1_4_1.html)
 
 * Wed Jan 15 2020 STE||AR Group <contact@stellar-group.org> 1.4.0-1
-- HPX Release 1.4.0 (https://stellar-group.github.io/hpx/docs/sphinx/tags/1.4.0/html/releases/whats_new_1_4_0.html)
+- HPX Release 1.4.0 (https://stellar-group.github.io/hpx-docs/tags/1.4.0/html/releases/whats_new_1_4_0.html)
 
 * Wed May 23 2019 STE||AR Group <contact@stellar-group.org> 1.3.0-1
-- HPX Release 1.3.0 (https://stellar-group.github.io/hpx/docs/sphinx/tags/1.3.0/html/releases/whats_new_1_3_0.html)
+- HPX Release 1.3.0 (https://stellar-group.github.io/hpx-docs/tags/1.3.0/html/releases/whats_new_1_3_0.html)
 
 * Wed Feb 19 2019 STE||AR Group <contact@stellar-group.org> 1.2.1-1
-- HPX Release 1.2.1 (https://stellar-group.github.io/hpx/docs/sphinx/tags/1.2.1/html/releases/whats_new_1_2_1.html)
+- HPX Release 1.2.1 (https://stellar-group.github.io/hpx-docs/tags/1.2.1/html/releases/whats_new_1_2_1.html)
 
 * Wed Nov 12 2018 STE||AR Group <contact@stellar-group.org> 1.2.0-1
-- HPX Release 1.2 (https://stellar-group.github.io/hpx/docs/sphinx/tags/1.2.0/html/releases/whats_new_1_2_0.html)
+- HPX Release 1.2 (https://stellar-group.github.io/hpx-docs/tags/1.2.0/html/releases/whats_new_1_2_0.html)
diff --git a/cmake/templates/HPXCacheVariables.cmake.in b/cmake/templates/HPXCacheVariables.cmake.in
new file mode 100644
index 0000000000..d8d62649ba
--- /dev/null
+++ b/cmake/templates/HPXCacheVariables.cmake.in
@@ -0,0 +1,9 @@
+# Copyright (c) 2019 Ste||ar Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+# File to store the HPX_* cache variables
+
+@_cache_variables@
diff --git a/cmake/templates/HPXConfig.cmake.in b/cmake/templates/HPXConfig.cmake.in
index 2cfb4caf0b..1c73e0b33b 100644
--- a/cmake/templates/HPXConfig.cmake.in
+++ b/cmake/templates/HPXConfig.cmake.in
@@ -121,13 +121,9 @@ if(NOT DEFINED ${CMAKE_FIND_PACKAGE_NAME}_FOUND)
 endif()
 
 # Set legacy variables for linking and include directories
-set(HPX_LIBRARIES "hpx;hpx_init;")
+set(HPX_LIBRARIES "HPX::hpx;")
+# All properties are propagated from HPX::hpx, so the following can be empty
 set(HPX_INCLUDE_DIRS "")
 set(HPX_LIBRARY_DIR "")
-if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (APPLE)))
-  set(HPX_LINK_LIBRARIES "hpx_wrap;")
-else()
-  set(HPX_LINK_LIBRARIES "")
-endif()
-# The flags required by hpx_wrap are propagated from its interface options.
+set(HPX_LINK_LIBRARIES "")
 set(HPX_LINKER_FLAGS "")
diff --git a/cmake/templates/conf.py.in b/cmake/templates/conf.py.in
index c94f046bdf..d145e59fea 100644
--- a/cmake/templates/conf.py.in
+++ b/cmake/templates/conf.py.in
@@ -76,8 +76,8 @@ for subdir_full, dirs, files in os.walk(hpx_libs_dir):
         # We only scan the include subdir...
         if not '/include' in subdir:
             continue
-        # ... but omit anything in detail directories
-        if '/detail' in subdir:
+        # ... but omit anything in detail and include_compatibility directories
+        if '/detail' in subdir or '/include_compatibility' in subdir:
             continue
 
         # strip the name of the library... the base path is already
diff --git a/cmake/templates/hpxrun.py.in b/cmake/templates/hpxrun.py.in
index 0e9f04a604..56c193e57d 100755
--- a/cmake/templates/hpxrun.py.in
+++ b/cmake/templates/hpxrun.py.in
@@ -119,7 +119,7 @@ def build_cmd(options, args):
         cmd += [arg]
 
     if options.localities > 1:
-        # Selecting the parcelport for hpx via hpx ini confifuration
+        # Selecting the parcelport for hpx via hpx ini configuration
         select_parcelport = (lambda pp:
             ['--hpx:ini=hpx.parcel.verbs.enable=1'] if pp == 'verbs'
             else ['--hpx:ini=hpx.parcel.ipc.enable=1'] if pp == 'ipc'
diff --git a/cmake/tests/builtin_integer_pack.cpp b/cmake/tests/builtin_integer_pack.cpp
new file mode 100644
index 0000000000..0ab481aca1
--- /dev/null
+++ b/cmake/tests/builtin_integer_pack.cpp
@@ -0,0 +1,34 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2020 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#include <cstddef>
+#include <type_traits>
+
+template <typename T, T... Vs>
+struct pack_c
+{
+};
+
+template <typename = void>
+void test()
+{
+    static_assert(std::is_same<pack_c<std::size_t, __integer_pack(0)...>,
+                      pack_c<std::size_t>>::value,
+        "");
+    static_assert(std::is_same<pack_c<std::size_t, __integer_pack(1)...>,
+                      pack_c<std::size_t, 0>>::value,
+        "");
+    static_assert(std::is_same<pack_c<std::size_t, __integer_pack(2)...>,
+                      pack_c<std::size_t, 0, 1>>::value,
+        "");
+}
+
+int main()
+{
+    test();
+}
diff --git a/cmake/tests/builtin_make_integer_seq.cpp b/cmake/tests/builtin_make_integer_seq.cpp
new file mode 100644
index 0000000000..fdee116f7b
--- /dev/null
+++ b/cmake/tests/builtin_make_integer_seq.cpp
@@ -0,0 +1,34 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2020 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#include <cstddef>
+#include <type_traits>
+
+template <typename T, T... Vs>
+struct pack_c
+{
+};
+
+template <typename = void>
+void test()
+{
+    static_assert(std::is_same<__make_integer_seq<pack_c, std::size_t, 0>,
+                      pack_c<std::size_t>>::value,
+        "");
+    static_assert(std::is_same<__make_integer_seq<pack_c, std::size_t, 1>,
+                      pack_c<std::size_t, 0>>::value,
+        "");
+    static_assert(std::is_same<__make_integer_seq<pack_c, std::size_t, 2>,
+                      pack_c<std::size_t, 0, 1>>::value,
+        "");
+}
+
+int main()
+{
+    test();
+}
diff --git a/cmake/tests/builtin_type_pack_element.cpp b/cmake/tests/builtin_type_pack_element.cpp
new file mode 100644
index 0000000000..44448b2e05
--- /dev/null
+++ b/cmake/tests/builtin_type_pack_element.cpp
@@ -0,0 +1,32 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2020 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#include <tuple>
+#include <type_traits>
+
+template <typename... Ts>
+void test()
+{
+    static_assert(
+        std::is_same<__type_pack_element<0, Ts...>,
+            typename std::tuple_element<0, std::tuple<Ts...>>::type>::value,
+        "");
+    static_assert(
+        std::is_same<__type_pack_element<1, Ts...>,
+            typename std::tuple_element<1, std::tuple<Ts...>>::type>::value,
+        "");
+    static_assert(
+        std::is_same<__type_pack_element<2, Ts...>,
+            typename std::tuple_element<2, std::tuple<Ts...>>::type>::value,
+        "");
+}
+
+int main()
+{
+    test<int, float, double>();
+}
diff --git a/cmake/tests/cxx11_alias_templates.cpp b/cmake/tests/cxx11_alias_templates.cpp
deleted file mode 100644
index feb748c853..0000000000
--- a/cmake/tests/cxx11_alias_templates.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2009 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-using PINT = void (*)(int);             // using plus C-style type
-
-template <typename Arg>
-using PFUN = void (*)(Arg);
-
-void check_f(PINT) {}
-
-int main()
-{
-    PFUN<int> x;
-    check_f(x);
-}
diff --git a/cmake/tests/cxx11_alignas.cpp b/cmake/tests/cxx11_alignas.cpp
deleted file mode 100644
index 893cdf5a8f..0000000000
--- a/cmake/tests/cxx11_alignas.cpp
+++ /dev/null
@@ -1,13 +0,0 @@
-//  Copyright (c) 2019 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-struct alignas(64) spinlock {};
-
-int main()
-{
-    static spinlock pool[32];
-    return 0;
-}
diff --git a/cmake/tests/cxx11_auto.cpp b/cmake/tests/cxx11_auto.cpp
deleted file mode 100644
index b9c1dbb566..0000000000
--- a/cmake/tests/cxx11_auto.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2009 Andrey Semashev
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-void check_f(int&) {}
-
-int main()
-{
-    auto x = 10;
-    check_f(x);
-}
diff --git a/cmake/tests/cxx11_constexpr.cpp b/cmake/tests/cxx11_constexpr.cpp
deleted file mode 100644
index e22bc007e1..0000000000
--- a/cmake/tests/cxx11_constexpr.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2008 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-constexpr int square(int x) { return x * x; }  // from N2235
-
-struct A
-{
-   constexpr A(int i) : val(i) { }
-private:
-   int val;
-};
-
-constexpr A a = 42;
-
-int main()
-{
-    constexpr int i = square(5);
-}
diff --git a/cmake/tests/cxx11_decltype.cpp b/cmake/tests/cxx11_decltype.cpp
deleted file mode 100644
index 979031dc97..0000000000
--- a/cmake/tests/cxx11_decltype.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2008 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-struct test_class { test_class() {} };
-
-test_class get_test_class() { return test_class(); }
-
-// N3276
-template <typename T> struct is_int { static const bool value = false; };
-template <> struct is_int<int> { static const bool value = true; };
-
-template <typename T>
-struct instantiation_guard
-{
-    int check_not_instantiated[!is_int<T>::value ? 1 : -1];
-};
-
-template <typename T>
-instantiation_guard<T> f(T) { return instantiation_guard<T>{}; }
-
-int main()
-{
-    int i;
-    decltype(i) j(0);
-    decltype(get_test_class()) k;
-
-    // N2376
-    typedef decltype(f(0)) result_type;
-}
diff --git a/cmake/tests/cxx11_defaulted_functions.cpp b/cmake/tests/cxx11_defaulted_functions.cpp
deleted file mode 100644
index 11ac33db5e..0000000000
--- a/cmake/tests/cxx11_defaulted_functions.cpp
+++ /dev/null
@@ -1,18 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2013-2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-struct foo {
-    foo() = delete;
-    foo(const foo&) = default;
-    foo(foo&&) = default;
-    foo& operator=(const foo&) = default;
-    foo& operator=(foo&&) = default;
-    ~foo() = default;
-};
-
-int main() {}
diff --git a/cmake/tests/cxx11_deleted_functions.cpp b/cmake/tests/cxx11_deleted_functions.cpp
deleted file mode 100644
index ac73038e27..0000000000
--- a/cmake/tests/cxx11_deleted_functions.cpp
+++ /dev/null
@@ -1,13 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2013-2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-struct foo {
-    foo() = delete;
-};
-
-int main() {}
diff --git a/cmake/tests/cxx11_explicit_cvt_ops.cpp b/cmake/tests/cxx11_explicit_cvt_ops.cpp
deleted file mode 100644
index 4c20d72430..0000000000
--- a/cmake/tests/cxx11_explicit_cvt_ops.cpp
+++ /dev/null
@@ -1,18 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2008 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-struct foo {
-    explicit operator int() const { return 1; }
-};
-
-int main()
-{
-    foo f;
-    int i = int(f);
-}
diff --git a/cmake/tests/cxx11_explicit_variadic_templates.cpp b/cmake/tests/cxx11_explicit_variadic_templates.cpp
deleted file mode 100644
index 365ff28192..0000000000
--- a/cmake/tests/cxx11_explicit_variadic_templates.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-//  Copyright (C) 2016 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-template <typename  ... Ts>
-struct tuple
-{
-    template <typename  ... Args>
-    tuple(Args && ...) {}
-};
-
-struct tag1 {};
-struct tag2 {};
-struct tag3 {};
-
-template <typename T>
-struct identity
-{
-    typedef T type;
-};
-
-template <typename Tag, typename T>
-struct tagged_type
-{
-    typedef typename identity<Tag(T)>::type type;
-};
-
-template <typename ... Tags, typename ... Ts>
-tuple<typename tagged_type<Tags, Ts>::type...>
-foo(Ts && ...)
-{
-    return tuple<typename tagged_type<Tags, Ts>::type...>();
-}
-
-template <typename ... Tags, typename ... Ts>
-tuple<typename tagged_type<Tags, Ts>::type...>
-foo(tuple<Ts...> && t)
-{
-    return tuple<typename tagged_type<Tags, Ts>::type...>();
-}
-
-int main()
-{
-    auto t1 = foo<tag1, tag2, tag3>(42, 43, 44);
-    auto t2 = foo<tag1, tag2, tag3>(tuple<int, int, int>(42, 43, 44));
-}
-
diff --git a/cmake/tests/cxx11_extended_friend_declarations.cpp b/cmake/tests/cxx11_extended_friend_declarations.cpp
deleted file mode 100644
index 5fefdb9500..0000000000
--- a/cmake/tests/cxx11_extended_friend_declarations.cpp
+++ /dev/null
@@ -1,17 +0,0 @@
-//  Copyright (c) 2015 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-template <typename T>
-struct foo
-{
-    friend T;
-};
-
-int main()
-{
-    foo<int> f;
-    (void)f;
-}
diff --git a/cmake/tests/cxx11_function_template_default_args.cpp b/cmake/tests/cxx11_function_template_default_args.cpp
deleted file mode 100644
index 9dc61bbd82..0000000000
--- a/cmake/tests/cxx11_function_template_default_args.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2008 Beman Dawes
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-template <typename T = int>
-T foo() { return 0; }
-
-template <typename T, typename U>
-bool is_same(T, U) { return false; }
-
-template <typename T>
-bool is_same(T, T) { return true; }
-
-template <typename T = int>
-T bar(T v = T()) { return v; }
-
-int main()
-{
-    bool b = !is_same(foo<>(), 0) || is_same(foo<>(), 0L);
-    bar(0) == bar();
-}
diff --git a/cmake/tests/cxx11_inline_namespaces.cpp b/cmake/tests/cxx11_inline_namespaces.cpp
deleted file mode 100644
index 312f2c2fe1..0000000000
--- a/cmake/tests/cxx11_inline_namespaces.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2013 Andrey Semashev
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-inline namespace my_ns {
-
-    int data = 0;
-}
-
-int main()
-{
-    data = 1;
-    my_ns::data = 1;
-}
diff --git a/cmake/tests/cxx11_lambdas.cpp b/cmake/tests/cxx11_lambdas.cpp
deleted file mode 100644
index 31cd336032..0000000000
--- a/cmake/tests/cxx11_lambdas.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2009 Beman Dawes
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-template <class Func>
-int f(Func f) { return f(); }
-
-int main()
-{
-    f([](){ return 0; });
-}
diff --git a/cmake/tests/cxx11_noexcept.cpp b/cmake/tests/cxx11_noexcept.cpp
deleted file mode 100644
index ed850eac4b..0000000000
--- a/cmake/tests/cxx11_noexcept.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2011 Takaya Saito
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-int f() noexcept;
-int g() noexcept(noexcept(f()));
-
-int main()
-{
-    bool b = noexcept(g());
-}
diff --git a/cmake/tests/cxx11_non_static_data_member_initialization.cpp b/cmake/tests/cxx11_non_static_data_member_initialization.cpp
deleted file mode 100644
index 9efa4a416c..0000000000
--- a/cmake/tests/cxx11_non_static_data_member_initialization.cpp
+++ /dev/null
@@ -1,17 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-class A
-{
-    int m = 42;
-};
-
-int main()
-{
-    A a;
-}
diff --git a/cmake/tests/cxx11_noreturn_attribute.cpp b/cmake/tests/cxx11_noreturn_attribute.cpp
deleted file mode 100644
index b68cbd7a2f..0000000000
--- a/cmake/tests/cxx11_noreturn_attribute.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#if !defined(__has_cpp_attribute)
-#  error "__has_cpp_attribute not supported, assume [[noreturn]] is not supported"
-#else
-#  if !__has_cpp_attribute(noreturn)
-#    error "__has_cpp_attribute(noreturn) not supported"
-#  endif
-#endif
-
-int main()
-{
-    return 0;
-}
diff --git a/cmake/tests/cxx11_nullptr.cpp b/cmake/tests/cxx11_nullptr.cpp
deleted file mode 100644
index 88149b0591..0000000000
--- a/cmake/tests/cxx11_nullptr.cpp
+++ /dev/null
@@ -1,13 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2009 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-int main()
-{
-    int* p = nullptr;
-}
diff --git a/cmake/tests/cxx11_override.cpp b/cmake/tests/cxx11_override.cpp
deleted file mode 100644
index 43d0dcb0e6..0000000000
--- a/cmake/tests/cxx11_override.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Denis Blank
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-class my_base
-{
-  public:
-    my_base() { }
-    virtual ~my_base() { }
-
-    virtual void do_sth() { }
-};
-
-class my_inh : public my_base
-{
-  public:
-    my_inh() { }
-
-    void do_sth() override { }
-};
-
-int main()
-{
-    my_base* obj = new my_inh();
-    delete obj;
-}
diff --git a/cmake/tests/cxx11_range_based_for.cpp b/cmake/tests/cxx11_range_based_for.cpp
deleted file mode 100644
index 672d517218..0000000000
--- a/cmake/tests/cxx11_range_based_for.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2012 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-int main()
-{
-    // example from 6.5.4 The range-based for statement [stmt.ranged]
-    int array[5] = { 1, 2, 3, 4, 5 };
-    for (int& x : array)
-    x *= 2;
-}
diff --git a/cmake/tests/cxx11_rvalue_references.cpp b/cmake/tests/cxx11_rvalue_references.cpp
deleted file mode 100644
index 6f814bba1d..0000000000
--- a/cmake/tests/cxx11_rvalue_references.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2007 Douglas Gregor
-//  Copyright (c) 2011 Bryce Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-void g(int&) {}
-
-template<typename F, typename T>
-void forward(F f, T&& t){ f(static_cast<T&&>(t)); }
-
-int main()
-{
-   int x;
-   forward(g, x);
-}
diff --git a/cmake/tests/cxx11_scoped_enums.cpp b/cmake/tests/cxx11_scoped_enums.cpp
deleted file mode 100644
index 77fb6cdb33..0000000000
--- a/cmake/tests/cxx11_scoped_enums.cpp
+++ /dev/null
@@ -1,12 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2008 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-enum class scoped_enum { yes, no, maybe };
-
-int main() {}
diff --git a/cmake/tests/cxx11_sfinae_expression.cpp b/cmake/tests/cxx11_sfinae_expression.cpp
deleted file mode 100644
index 7b9df156fb..0000000000
--- a/cmake/tests/cxx11_sfinae_expression.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Thomas Heller
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <utility>
-
-struct test_class1 { void foo() {} };
-struct test_class2 { void bar() {} };
-
-template <typename T>
-decltype(std::declval<T>().foo()) foo()
-{}
-
-template <typename T>
-decltype(std::declval<T>().bar()) foo()
-{}
-
-int main()
-{
-    foo<test_class1>();
-    foo<test_class2>();
-}
diff --git a/cmake/tests/cxx11_static_assert.cpp b/cmake/tests/cxx11_static_assert.cpp
deleted file mode 100644
index e6138a0256..0000000000
--- a/cmake/tests/cxx11_static_assert.cpp
+++ /dev/null
@@ -1,13 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2007 Douglas Gregor
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-int main()
-{
-   static_assert(true, "OK");
-}
diff --git a/cmake/tests/cxx11_std_array.cpp b/cmake/tests/cxx11_std_array.cpp
deleted file mode 100644
index 14ab9d5a16..0000000000
--- a/cmake/tests/cxx11_std_array.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2001 John Maddock
-//  Copyright (c) 2011 Bryce Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <array>
-
-int main()
-{
-    std::array<int, 10> arr;
-}
diff --git a/cmake/tests/cxx11_std_chrono.cpp b/cmake/tests/cxx11_std_chrono.cpp
deleted file mode 100644
index b79b1cc27f..0000000000
--- a/cmake/tests/cxx11_std_chrono.cpp
+++ /dev/null
@@ -1,17 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2014 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <chrono>
-
-int main()
-{
-    using namespace std::chrono;
-
-    seconds s(1);
-    nanoseconds ns = duration_cast<seconds>(s);
-}
diff --git a/cmake/tests/cxx11_std_cstdint.cpp b/cmake/tests/cxx11_std_cstdint.cpp
deleted file mode 100644
index a07c420b11..0000000000
--- a/cmake/tests/cxx11_std_cstdint.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Thomas Heller
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <cstdint>
-
-int main()
-{
-    std::int16_t i1;
-    std::int32_t i2;
-    std::int64_t i3;
-
-    std::uint16_t ui1;
-    std::uint32_t ui2;
-    std::uint64_t ui3;
-}
diff --git a/cmake/tests/cxx11_std_exception_ptr.cpp b/cmake/tests/cxx11_std_exception_ptr.cpp
deleted file mode 100644
index caf10481c1..0000000000
--- a/cmake/tests/cxx11_std_exception_ptr.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <exception>
-
-struct exception {};
-
-int main()
-{
-    std::exception_ptr p;
-
-    // check make_exception_ptr
-    {
-        exception e;
-        std::exception_ptr p = std::make_exception_ptr(e);
-    }
-
-    // check current_exception
-    {
-        try
-        {
-            throw exception();
-        } catch (...) {
-            std::exception_ptr p = std::current_exception();
-        }
-    }
-
-    // check rethrow_exception
-    {
-        std::exception_ptr p;
-        try
-        {
-            throw exception();
-        } catch (...) {
-            p = std::current_exception();
-        }
-
-        try
-        {
-            std::rethrow_exception(p);
-        } catch (exception) {}
-    }
-}
diff --git a/cmake/tests/cxx11_std_forward_list.cpp b/cmake/tests/cxx11_std_forward_list.cpp
deleted file mode 100644
index 19710d33b9..0000000000
--- a/cmake/tests/cxx11_std_forward_list.cpp
+++ /dev/null
@@ -1,12 +0,0 @@
-//  Copyright (c) 2018 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <forward_list>
-
-int main()
-{
-    std::forward_list<int> l;
-}
diff --git a/cmake/tests/cxx11_std_initializer_list.cpp b/cmake/tests/cxx11_std_initializer_list.cpp
deleted file mode 100644
index 84547d128a..0000000000
--- a/cmake/tests/cxx11_std_initializer_list.cpp
+++ /dev/null
@@ -1,33 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2008 Beman Dawes
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <initializer_list>
-#include <vector>
-
-void test_aggregate_initializer_list() {
-  int ail[] = {1, 2, 3};
-}
-
-struct ctor {
-  ctor(std::initializer_list<int>) {}
-};
-
-void test_ctor_initializer_list() {
-  ctor cil{1, 2, 3};
-}
-
-void test_vector_initializer_list() {
-  std::vector<int> vil = {1, 2, 3};
-}
-
-int main() {
-  test_aggregate_initializer_list();
-  test_ctor_initializer_list();
-  test_vector_initializer_list();
-}
diff --git a/cmake/tests/cxx11_std_is_bind_expression.cpp b/cmake/tests/cxx11_std_is_bind_expression.cpp
deleted file mode 100644
index f90386c563..0000000000
--- a/cmake/tests/cxx11_std_is_bind_expression.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <functional>
-
-int main()
-{
-    int check_is_bind_expression[!std::is_bind_expression<int>::value ? 1 : -1];
-}
diff --git a/cmake/tests/cxx11_std_is_placeholder.cpp b/cmake/tests/cxx11_std_is_placeholder.cpp
deleted file mode 100644
index 60d80f786a..0000000000
--- a/cmake/tests/cxx11_std_is_placeholder.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <functional>
-
-int main()
-{
-    using namespace std::placeholders;
-    int check_is_placeholder[std::is_placeholder<int>::value == 0 ? 1 : -1];
-}
diff --git a/cmake/tests/cxx11_std_is_trivially_copyable.cpp b/cmake/tests/cxx11_std_is_trivially_copyable.cpp
deleted file mode 100644
index 0ccde72e28..0000000000
--- a/cmake/tests/cxx11_std_is_trivially_copyable.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <type_traits>
-
-int main()
-{
-    int check_trivially_copyable[std::is_trivially_copyable<int>::value ? 1 : -1];
-}
diff --git a/cmake/tests/cxx11_std_lock_guard.cpp b/cmake/tests/cxx11_std_lock_guard.cpp
deleted file mode 100644
index 7c36ba63a4..0000000000
--- a/cmake/tests/cxx11_std_lock_guard.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <mutex>
-
-struct BasicLockable {
-    void lock() {}
-    void unlock() {}
-};
-
-int main()
-{
-    BasicLockable basic_lockable;
-    std::lock_guard<BasicLockable> lk(basic_lockable);
-
-    std::lock_guard<BasicLockable> kl_adopt(basic_lockable, std::adopt_lock);
-}
diff --git a/cmake/tests/cxx11_std_random.cpp b/cmake/tests/cxx11_std_random.cpp
deleted file mode 100644
index 8d37b05083..0000000000
--- a/cmake/tests/cxx11_std_random.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <random>
-
-int main()
-{
-    // engines
-    {
-        std::random_device random_device;
-        std::mt19937 mt19937;
-        std::mt19937_64 mt19937_64;
-    }
-
-    // distributions
-    {
-        std::uniform_int_distribution<> uniform_int_distribution;
-        std::uniform_real_distribution<> uniform_real_distribution;
-    }
-}
diff --git a/cmake/tests/cxx11_std_range_access.cpp b/cmake/tests/cxx11_std_range_access.cpp
deleted file mode 100644
index 30f2eef3bb..0000000000
--- a/cmake/tests/cxx11_std_range_access.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <iterator>
-#include <vector>
-
-int main()
-{
-    int array[3] = { 0, 1, 2 };
-    int* array_begin = std::begin(array);
-    int* array_end = std::begin(array);
-
-    std::vector<int> vector(3);
-    std::vector<int>::iterator vector_begin = std::begin(vector);
-    std::vector<int>::iterator vector_end = std::begin(vector);
-};
diff --git a/cmake/tests/cxx11_std_reference_wrapper.cpp b/cmake/tests/cxx11_std_reference_wrapper.cpp
deleted file mode 100644
index cecdf7dd3b..0000000000
--- a/cmake/tests/cxx11_std_reference_wrapper.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <functional>
-
-int main()
-{
-    int lvalue = 0;
-    std::reference_wrapper<int> wrapper = std::ref(lvalue);
-}
diff --git a/cmake/tests/cxx11_std_regex.cpp b/cmake/tests/cxx11_std_regex.cpp
deleted file mode 100644
index 23f3a1fe82..0000000000
--- a/cmake/tests/cxx11_std_regex.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <regex>
-#include <string>
-
-int main()
-{
-    std::string text = "Lorem ipsum dolor sit amet";
-
-    std::regex re("[a-z]+");
-    std::smatch match;
-    if (std::regex_match(text, match, re))
-    {
-        std::ssub_match smatch = match[0];
-    }
-}
diff --git a/cmake/tests/cxx11_std_shared_ptr.cpp b/cmake/tests/cxx11_std_shared_ptr.cpp
deleted file mode 100644
index 1b99773dbc..0000000000
--- a/cmake/tests/cxx11_std_shared_ptr.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <memory>
-
-struct base
-{};
-
-struct derived
-  : public base
-  , std::enable_shared_from_this<derived>
-{};
-
-
-int main()
-{
-    std::shared_ptr<base> pb = std::make_shared<derived>();
-    std::shared_ptr<derived> pd = std::static_pointer_cast<derived>(pb);
-    std::shared_ptr<derived> sft = pd->shared_from_this();
-}
diff --git a/cmake/tests/cxx11_std_shuffle.cpp b/cmake/tests/cxx11_std_shuffle.cpp
deleted file mode 100644
index 240a285b92..0000000000
--- a/cmake/tests/cxx11_std_shuffle.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Anton Bikineev
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <algorithm>
-#include <random>
-#include <vector>
-
-int main()
-{
-    std::vector<int> v = {1, 2, 3};
-    std::random_device rd;
-    std::mt19937 g(rd());
-    std::shuffle(v.begin(), v.end(), g);
-
-    return 0;
-}
diff --git a/cmake/tests/cxx11_std_thread.cpp b/cmake/tests/cxx11_std_thread.cpp
deleted file mode 100644
index 3ab15f5a8e..0000000000
--- a/cmake/tests/cxx11_std_thread.cpp
+++ /dev/null
@@ -1,83 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <chrono>
-#include <condition_variable>
-#include <cstddef>
-#include <mutex>
-#include <thread>
-
-void f(int, float, double) {}
-
-bool pred() { return true; }
-
-int main()
-{
-    std::chrono::seconds rel_time;
-    std::chrono::system_clock::time_point abs_time;
-
-    // check thread
-    {
-        std::thread t;
-        t = std::thread(&f, 1, 2.0f, 3.);
-
-        if (t.joinable())
-            t.join();
-
-        std::size_t hwc = std::thread::hardware_concurrency();
-    }
-
-    // check thread::id
-    {
-        std::thread::id const id;
-        id < id; // as map keys
-    }
-
-    // check this_thread namespace
-    {
-        std::thread::id const id = std::this_thread::get_id();
-
-        std::this_thread::yield();
-
-        std::this_thread::sleep_for(rel_time);
-        std::this_thread::sleep_until(abs_time);
-    }
-
-    // check mutex
-    {
-        std::mutex mut;
-        mut.lock();
-        bool c = mut.try_lock();
-        mut.unlock();
-    }
-
-    // check recursive_mutex
-    {
-        std::recursive_mutex mut;
-        mut.lock();
-        bool c = mut.try_lock();
-        mut.unlock();
-    }
-
-    // check condition_variable
-    {
-        std::condition_variable cv;
-
-        cv.notify_one();
-        cv.notify_all();
-
-        std::mutex mut;
-        std::unique_lock<std::mutex> lock(mut);
-        cv.wait(lock);
-        cv.wait(lock, pred);
-        cv.wait_for(lock, rel_time);
-        cv.wait_for(lock, rel_time, pred);
-        cv.wait_until(lock, abs_time);
-        cv.wait_until(lock, abs_time, pred);
-    }
-}
diff --git a/cmake/tests/cxx11_std_to_string.cpp b/cmake/tests/cxx11_std_to_string.cpp
deleted file mode 100644
index 5878a4fffe..0000000000
--- a/cmake/tests/cxx11_std_to_string.cpp
+++ /dev/null
@@ -1,17 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <string>
-
-int main()
-{
-    std::string s1 = std::to_string(42);
-    std::string s2 = std::to_string(42l);
-    std::string s3 = std::to_string(42.f);
-    std::string s4 = std::to_string(42.0);
-}
diff --git a/cmake/tests/cxx11_std_tuple.cpp b/cmake/tests/cxx11_std_tuple.cpp
deleted file mode 100644
index ca940c8bd6..0000000000
--- a/cmake/tests/cxx11_std_tuple.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Anton Bikineev
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <tuple>
-
-int main()
-{
-    std::tuple<int, char, double> tuple;
-}
diff --git a/cmake/tests/cxx11_std_unique_lock.cpp b/cmake/tests/cxx11_std_unique_lock.cpp
deleted file mode 100644
index 5981cdd107..0000000000
--- a/cmake/tests/cxx11_std_unique_lock.cpp
+++ /dev/null
@@ -1,33 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <mutex>
-#include <utility>
-
-struct Lockable {
-    void lock() {}
-    bool try_lock() { return true; }
-    void unlock() {}
-};
-
-int main()
-{
-    Lockable lockable;
-    std::unique_lock<Lockable> lk(lockable);
-    lk.lock();
-    lk.try_lock();
-    lk.owns_lock();
-    lk.unlock();
-    lk.release();
-
-    std::unique_lock<Lockable> mlk(std::move(lk));
-
-    std::unique_lock<Lockable> kl_adopt(lockable, std::adopt_lock);
-    std::unique_lock<Lockable> kl_defer(lockable, std::defer_lock);
-    std::unique_lock<Lockable> kl_try(lockable, std::try_to_lock);
-}
diff --git a/cmake/tests/cxx11_std_unique_ptr.cpp b/cmake/tests/cxx11_std_unique_ptr.cpp
deleted file mode 100644
index b6616cda6c..0000000000
--- a/cmake/tests/cxx11_std_unique_ptr.cpp
+++ /dev/null
@@ -1,43 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2001 John Maddock
-//  Copyright (c) 2011 Bryce Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <memory>
-
-template <typename T>
-struct ptr
-{
-private:
-    T* p;
-
-public:
-    ptr(std::unique_ptr<T>& r)
-    {
-        p = r.release();
-    }
-
-    ptr& operator=(std::unique_ptr<T>& r)
-    {
-        delete p;
-        p = r.release();
-        return *this;
-    }
-
-    ~ptr()
-    {
-        delete p;
-    }
-};
-
-int main()
-{
-    std::unique_ptr<int> up1(new int);
-    ptr<int> mp(up1);
-    std::unique_ptr<int> up2(new int);
-    mp = up2;
-}
diff --git a/cmake/tests/cxx11_std_unordered_map.cpp b/cmake/tests/cxx11_std_unordered_map.cpp
deleted file mode 100644
index 3d5d65cde3..0000000000
--- a/cmake/tests/cxx11_std_unordered_map.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <unordered_map>
-#include <string>
-#include <utility>
-
-int main()
-{
-    std::unordered_map<std::string, unsigned> u;
-    u.insert(std::make_pair("RED", 0xFF0000));
-    u.insert(std::make_pair("GREEN", 0x00FF00));
-    u.insert(std::make_pair("BLUE", 0x0000FF));
-
-    std::unordered_multimap<std::string, unsigned> um;
-    um.insert(std::make_pair("RED", 0xFF0000));
-    um.insert(std::make_pair("GREEN", 0x00FF00));
-    um.insert(std::make_pair("BLUE", 0x0000FF));
-}
diff --git a/cmake/tests/cxx11_std_unordered_set.cpp b/cmake/tests/cxx11_std_unordered_set.cpp
deleted file mode 100644
index 8242e4ff5a..0000000000
--- a/cmake/tests/cxx11_std_unordered_set.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <unordered_set>
-
-int main()
-{
-    std::unordered_set<unsigned> u;
-    u.insert(0xFF0000);
-    u.insert(0x00FF00);
-    u.insert(0x0000FF);
-
-    std::unordered_multiset<unsigned> um;
-    um.insert(0xFF0000);
-    um.insert(0x00FF00);
-    um.insert(0x0000FF);
-}
diff --git a/cmake/tests/cxx11_thread_local.cpp b/cmake/tests/cxx11_thread_local.cpp
deleted file mode 100644
index fe27731c0c..0000000000
--- a/cmake/tests/cxx11_thread_local.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-struct dummy_type
-{
-    ~dummy_type(){};
-};
-
-thread_local dummy_type dummy;
-
-int main()
-{
-    return 0;
-}
diff --git a/cmake/tests/cxx11_variadic_macros.cpp b/cmake/tests/cxx11_variadic_macros.cpp
deleted file mode 100644
index 9d97c84de9..0000000000
--- a/cmake/tests/cxx11_variadic_macros.cpp
+++ /dev/null
@@ -1,12 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (C) 2010 Edward Diener
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#define TEST_VARIADIC_MACRO_SIMPLE(avalue,...) __VA_ARGS__
-
-int main() {}
diff --git a/cmake/tests/cxx11_variadic_templates.cpp b/cmake/tests/cxx11_variadic_templates.cpp
deleted file mode 100644
index 6a9521be8a..0000000000
--- a/cmake/tests/cxx11_variadic_templates.cpp
+++ /dev/null
@@ -1,13 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (C) 2007 Douglas Gregor
-//  Copyright (c) 2011 Bryce Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-template <typename... Elements>
-struct tuple {};
-
-int main() {}
diff --git a/cmake/tests/cxx14_constexpr.cpp b/cmake/tests/cxx14_constexpr.cpp
deleted file mode 100644
index 93b5ef76e5..0000000000
--- a/cmake/tests/cxx14_constexpr.cpp
+++ /dev/null
@@ -1,36 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2014 Kohei Takahashi
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-constexpr void decrement(int& value) { --value; }
-
-struct S
-{
-    constexpr S() : ptr(nullptr) {}
-    constexpr void reset() { ptr = nullptr; }
-    constexpr void reset() const { }
-    void * ptr;
-};
-
-constexpr int zero()
-{
-    int ret = 1;
-    decrement(ret);
-
-    S s;
-    s.reset();
-
-    return ret;
-}
-
-int main()
-{
-    constexpr int i = zero();
-    S s;
-    s.reset();
-}
diff --git a/cmake/tests/cxx14_deprecated_attribute.cpp b/cmake/tests/cxx14_deprecated_attribute.cpp
deleted file mode 100644
index 2f487e64f6..0000000000
--- a/cmake/tests/cxx14_deprecated_attribute.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#if !defined(__has_cpp_attribute)
-#  error "__has_cpp_attribute not supported, assume [[deprecated]] is not supported"
-#else
-#  if !__has_cpp_attribute(deprecated)
-#    error "__has_cpp_attribute(deprecated) not supported"
-#  endif
-#endif
-
-int main()
-{
-    return 0;
-}
diff --git a/cmake/tests/cxx14_lambdas.cpp b/cmake/tests/cxx14_lambdas.cpp
deleted file mode 100644
index 1141243c72..0000000000
--- a/cmake/tests/cxx14_lambdas.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2014 Kohei Takahashi
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-template <class Func>
-int f(Func f) { return f(0); }
-
-int main()
-{
-    f([x = 0](auto ret) { return ret; });
-}
diff --git a/cmake/tests/cxx14_return_type_deduction.cpp b/cmake/tests/cxx14_return_type_deduction.cpp
deleted file mode 100644
index b1283d6a40..0000000000
--- a/cmake/tests/cxx14_return_type_deduction.cpp
+++ /dev/null
@@ -1,31 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2017 Taeguk Kwon
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-auto check1(int a, int b)
-{
-    int c = a + b;
-    return c;
-}
-
-template <typename T>
-auto check2(T num);
-
-template <typename T>
-auto check2(T num)
-{
-    return num * num;
-}
-
-int main()
-{
-    int a = 10;
-    int b = 20;
-    check1(a, b);
-    double c = check2(30.0);
-}
-
diff --git a/cmake/tests/cxx14_std_integer_sequence.cpp b/cmake/tests/cxx14_std_integer_sequence.cpp
deleted file mode 100644
index cd517c3e3d..0000000000
--- a/cmake/tests/cxx14_std_integer_sequence.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <cstddef>
-#include <utility>
-
-int main()
-{
-    std::integer_sequence<std::size_t, 0, 1, 2>* is = 0;
-    std::index_sequence<0, 1, 2>* ss = 0;
-    std::make_integer_sequence<std::size_t, 3>* mis = 0;
-    std::make_index_sequence<3>* mss = 0;
-    std::index_sequence_for<int, int, int>* misf = 0;
-
-    is = ss = mis = mss = misf;
-}
diff --git a/cmake/tests/cxx14_std_is_final.cpp b/cmake/tests/cxx14_std_is_final.cpp
deleted file mode 100644
index ba81f0f938..0000000000
--- a/cmake/tests/cxx14_std_is_final.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <type_traits>
-
-struct x final {};
-
-int main()
-{
-    int check_final[std::is_final<x>::value ? 1 : -1];
-}
diff --git a/cmake/tests/cxx14_std_is_null_pointer.cpp b/cmake/tests/cxx14_std_is_null_pointer.cpp
deleted file mode 100644
index 759bee1c90..0000000000
--- a/cmake/tests/cxx14_std_is_null_pointer.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <cstddef>
-#include <type_traits>
-
-int main()
-{
-    int check_nullptr[std::is_null_pointer<std::nullptr_t>::value ? 1 : -1];
-}
diff --git a/cmake/tests/cxx14_std_result_of_sfinae.cpp b/cmake/tests/cxx14_std_result_of_sfinae.cpp
deleted file mode 100644
index 5e1f608d68..0000000000
--- a/cmake/tests/cxx14_std_result_of_sfinae.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2015 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <functional>
-#include <type_traits>
-
-struct callable
-{
-    int operator()(){ return 0; }
-};
-
-template <typename T>
-void test_result_of_sfinae(T&&, ...) {}
-
-template <typename T>
-void test_result_of_sfinae(T&&, typename std::result_of<T(int)>::type) {}
-
-int main()
-{
-    test_result_of_sfinae(callable(), 0);
-}
diff --git a/cmake/tests/cxx14_variable_templates.cpp b/cmake/tests/cxx14_variable_templates.cpp
deleted file mode 100644
index 375f564cea..0000000000
--- a/cmake/tests/cxx14_variable_templates.cpp
+++ /dev/null
@@ -1,18 +0,0 @@
-//  Copyright (C) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-struct true_type
-{
-    enum { value = 1; }
-}
-
-template <typename T>
-struct is_foobar : true_type {};
-
-template <typename T>
-constexpr bool is_foobar_v = is_foobar<T>::value;
-
-int main() {}
diff --git a/cmake/toolchains/Cray.cmake b/cmake/toolchains/Cray.cmake
index 6062a1f0fe..b8d73824cf 100644
--- a/cmake/toolchains/Cray.cmake
+++ b/cmake/toolchains/Cray.cmake
@@ -22,14 +22,10 @@ set(CMAKE_CXX_COMPILER CC)
 set(CMAKE_C_COMPILER cc)
 set(CMAKE_Fortran_COMPILER ftn)
 
-if (CMAKE_VERSION VERSION_GREATER 3.3.9)
-  set(__includes "<INCLUDES>")
-endif()
-
 set(CMAKE_C_FLAGS_INIT "" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_C_FLAGS "-fPIC -shared" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS "-fPIC -shared" CACHE STRING "")
-set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -shared -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -shared -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_C_LINK_EXECUTABLE "<CMAKE_C_COMPILER> -fPIC -dynamic <FLAGS> <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 set(CMAKE_C_CREATE_SHARED_LIBRARY "<CMAKE_C_COMPILER> -fPIC -shared <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <SONAME_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES> " CACHE STRING "")
 
@@ -37,14 +33,14 @@ set(CMAKE_CXX_FLAGS_INIT "" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CXX_FLAGS "-fPIC -shared" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS "-fPIC -shared" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS "-fPIC -shared" CACHE STRING "")
-set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -shared -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -shared -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_CXX_LINK_EXECUTABLE "<CMAKE_CXX_COMPILER> -fPIC -dynamic <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 set(CMAKE_CXX_CREATE_SHARED_LIBRARY "<CMAKE_CXX_COMPILER> -fPIC -shared <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <SONAME_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" CACHE STRING "")
 
 set(CMAKE_Fortran_FLAGS_INIT "" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_Fortran_FLAGS "-fPIC" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_Fortran_FLAGS "-shared" CACHE STRING "")
-set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -shared -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -shared -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_Fortran_LINK_EXECUTABLE "<CMAKE_Fortran_COMPILER> -fPIC -dynamic <FLAGS> <CMAKE_Fortran_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>")
 set(CMAKE_Fortran_CREATE_SHARED_LIBRARY "<CMAKE_Fortran_COMPILER> -fPIC -shared <CMAKE_SHARED_LIBRARY_Fortran_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_Fortran_FLAGS> <SONAME_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES> " CACHE STRING "")
 
@@ -69,7 +65,7 @@ set(HPX_PARCELPORT_LIBFABRIC_WITH_DEV_MODE OFF CACHE BOOL
 set(HPX_PARCELPORT_LIBFABRIC_WITH_LOGGING  OFF CACHE BOOL
   "Libfabric parcelport logging on/off flag")
 set(HPX_WITH_ZERO_COPY_SERIALIZATION_THRESHOLD "4096" CACHE STRING
-  "The threshhold in bytes to when perform zero copy optimizations (default: 128)")
+  "The threshold in bytes to when perform zero copy optimizations (default: 128)")
 
 # We do a cross compilation here ...
 set(CMAKE_CROSSCOMPILING ON CACHE BOOL "")
diff --git a/cmake/toolchains/CrayKNL.cmake b/cmake/toolchains/CrayKNL.cmake
index da7e38936c..5dda67f46b 100644
--- a/cmake/toolchains/CrayKNL.cmake
+++ b/cmake/toolchains/CrayKNL.cmake
@@ -20,14 +20,10 @@ set(CMAKE_CXX_COMPILER CC)
 set(CMAKE_C_COMPILER cc)
 set(CMAKE_Fortran_COMPILER ftn)
 
-if (CMAKE_VERSION VERSION_GREATER 3.3.9)
-  set(__includes "<INCLUDES>")
-endif()
-
 set(CMAKE_C_FLAGS_INIT "" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_C_FLAGS "-fPIC -shared" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS "-fPIC -shared" CACHE STRING "")
-set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -shared -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -shared -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_C_LINK_EXECUTABLE "<CMAKE_C_COMPILER> -fPIC <FLAGS> <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 set(CMAKE_C_CREATE_SHARED_LIBRARY "<CMAKE_C_COMPILER> -fPIC -shared <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <SONAME_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES> " CACHE STRING "")
 #
@@ -35,14 +31,14 @@ set(CMAKE_CXX_FLAGS_INIT "" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CXX_FLAGS "-fPIC -shared" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS "-fPIC -shared" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS "-fPIC -shared" CACHE STRING "")
-set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -shared -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -shared -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_CXX_LINK_EXECUTABLE "<CMAKE_CXX_COMPILER> -fPIC -dynamic <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 set(CMAKE_CXX_CREATE_SHARED_LIBRARY "<CMAKE_CXX_COMPILER> -fPIC -shared <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <SONAME_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" CACHE STRING "")
 #
 set(CMAKE_Fortran_FLAGS_INIT "" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_Fortran_FLAGS "-fPIC" CACHE STRING "")
 set(CMAKE_SHARED_LIBRARY_CREATE_Fortran_FLAGS "-shared" CACHE STRING "")
-set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -shared -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -shared -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_Fortran_LINK_EXECUTABLE "<CMAKE_Fortran_COMPILER> -fPIC <FLAGS> <CMAKE_Fortran_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>")
 set(CMAKE_Fortran_CREATE_SHARED_LIBRARY "<CMAKE_Fortran_COMPILER> -fPIC -shared <CMAKE_SHARED_LIBRARY_Fortran_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_Fortran_FLAGS> <SONAME_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES> " CACHE STRING "")
 #
@@ -67,7 +63,7 @@ set(HPX_PARCELPORT_LIBFABRIC_WITH_DEV_MODE OFF CACHE BOOL
 set(HPX_PARCELPORT_LIBFABRIC_WITH_LOGGING  OFF CACHE BOOL
   "Libfabric parcelport logging on/off flag")
 set(HPX_WITH_ZERO_COPY_SERIALIZATION_THRESHOLD "4096" CACHE STRING
-  "The threshhold in bytes to when perform zero copy optimizations (default: 128)")
+  "The threshold in bytes to when perform zero copy optimizations (default: 128)")
 
 # Set the TBBMALLOC_PLATFORM correctly so that find_package(TBBMalloc) sets the
 # right hints
diff --git a/cmake/toolchains/CrayKNLStatic.cmake b/cmake/toolchains/CrayKNLStatic.cmake
index 6d067dcfdc..ed1aad0b2e 100644
--- a/cmake/toolchains/CrayKNLStatic.cmake
+++ b/cmake/toolchains/CrayKNLStatic.cmake
@@ -1,5 +1,5 @@
 # Copyright (c) 2014-2017 Thomas Heller
-# Copyright (c) 2017      Bryce Adelstein Lelbach 
+# Copyright (c) 2017      Bryce Adelstein Lelbach
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -14,20 +14,16 @@ set(CMAKE_CXX_COMPILER CC)
 set(CMAKE_C_COMPILER cc)
 set(CMAKE_Fortran_COMPILER ftn)
 
-if (CMAKE_VERSION VERSION_GREATER 3.3.9)
-  set(__includes "<INCLUDES>")
-endif()
-
 set(CMAKE_C_FLAGS_INIT "" CACHE STRING "")
-set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -static -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -static -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_C_LINK_EXECUTABLE "<CMAKE_C_COMPILER> -fPIC <FLAGS> <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 
 set(CMAKE_CXX_FLAGS_INIT "" CACHE STRING "")
-set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -static -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -static -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_CXX_LINK_EXECUTABLE "<CMAKE_CXX_COMPILER> -fPIC <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 
 set(CMAKE_Fortran_FLAGS_INIT "" CACHE STRING "")
-set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -static -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -static -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_Fortran_LINK_EXECUTABLE "<CMAKE_Fortran_COMPILER> -fPIC <FLAGS> <CMAKE_Fortran_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>")
 
 # Disable searches in the default system paths. We are cross compiling after all
@@ -52,7 +48,7 @@ set(HPX_PARCELPORT_LIBFABRIC_WITH_DEV_MODE OFF CACHE BOOL
 set(HPX_PARCELPORT_LIBFABRIC_WITH_LOGGING  OFF CACHE BOOL
   "Libfabric parcelport logging on/off flag")
 set(HPX_WITH_ZERO_COPY_SERIALIZATION_THRESHOLD "4096" CACHE STRING
-  "The threshhold in bytes to when perform zero copy optimizations (default: 128)")
+  "The threshold in bytes to when perform zero copy optimizations (default: 128)")
 
 # Set the TBBMALLOC_PLATFORM correctly so that find_package(TBBMalloc) sets the
 # right hints
diff --git a/cmake/toolchains/CrayStatic.cmake b/cmake/toolchains/CrayStatic.cmake
index f2bc530ded..b817805fda 100644
--- a/cmake/toolchains/CrayStatic.cmake
+++ b/cmake/toolchains/CrayStatic.cmake
@@ -14,20 +14,16 @@ set(CMAKE_CXX_COMPILER CC)
 set(CMAKE_C_COMPILER cc)
 set(CMAKE_Fortran_COMPILER ftn)
 
-if (CMAKE_VERSION VERSION_GREATER 3.3.9)
-  set(__includes "<INCLUDES>")
-endif()
-
 set(CMAKE_C_FLAGS_INIT "" CACHE STRING "")
-set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -static -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_C_COMPILE_OBJECT "<CMAKE_C_COMPILER> -static -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_C_LINK_EXECUTABLE "<CMAKE_C_COMPILER> -fPIC <FLAGS> <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 
 set(CMAKE_CXX_FLAGS_INIT "" CACHE STRING "")
-set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -static -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_CXX_COMPILE_OBJECT "<CMAKE_CXX_COMPILER> -static -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 set(CMAKE_CXX_LINK_EXECUTABLE "<CMAKE_CXX_COMPILER> -fPIC <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" CACHE STRING "")
 
 set(CMAKE_Fortran_FLAGS_INIT "" CACHE STRING "")
-set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -static -fPIC <DEFINES> ${__includes} <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
+set(CMAKE_Fortran_COMPILE_OBJECT "<CMAKE_Fortran_COMPILER> -static -fPIC <DEFINES> <INCLUDES> <FLAGS> -o <OBJECT> -c <SOURCE>" CACHE STRING "")
 
 set(CMAKE_Fortran_LINK_EXECUTABLE "<CMAKE_Fortran_COMPILER> -fPIC <FLAGS> <CMAKE_Fortran_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>")
 
@@ -58,4 +54,4 @@ set(HPX_PARCELPORT_LIBFABRIC_WITH_DEV_MODE OFF CACHE BOOL
 set(HPX_PARCELPORT_LIBFABRIC_WITH_LOGGING  OFF CACHE BOOL
   "Libfabric parcelport logging on/off flag")
 set(HPX_WITH_ZERO_COPY_SERIALIZATION_THRESHOLD "4096" CACHE STRING
-  "The threshhold in bytes to when perform zero copy optimizations (default: 128)")
+  "The threshold in bytes to when perform zero copy optimizations (default: 128)")
diff --git a/components/containers/partitioned_vector/include/hpx/components/containers/coarray/coarray.hpp b/components/containers/partitioned_vector/include/hpx/components/containers/coarray/coarray.hpp
index 1fde501fd2..d9f4ab3bf1 100644
--- a/components/containers/partitioned_vector/include/hpx/components/containers/coarray/coarray.hpp
+++ b/components/containers/partitioned_vector/include/hpx/components/containers/coarray/coarray.hpp
@@ -13,7 +13,7 @@
 #include <hpx/components/containers/partitioned_vector/partitioned_vector.hpp>
 #include <hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp>
 #include <hpx/collectives/spmd_block.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <algorithm>
 #include <array>
@@ -73,7 +73,7 @@ namespace hpx
               : sizes_({{i...}})
             {
                 using last_element =
-                    typename util::detail::at_index<sizeof...(I) - 1, I...>::type;
+                    typename util::at_index<sizeof...(I) - 1, I...>::type;
                 using condition =
                     typename std::is_same<last_element, detail::auto_subscript>;
 
@@ -85,7 +85,7 @@ namespace hpx
                     "equal to its dimension");
 
                 static_assert(
-                    util::detail::all_of<typename std::is_integral<
+                    util::all_of<typename std::is_integral<
                         typename detail::cast_if_autosubscript<I>::type>::
                             type...>::value,
                     "One or more elements in sizes given to hpx::coarray() "
@@ -128,7 +128,7 @@ namespace hpx
     {
     private:
         using base_type = partitioned_vector_view<T, N, Data>;
-        using indices = typename hpx::util::detail::make_index_pack<N>::type;
+        using indices = typename hpx::util::make_index_pack<N>::type;
 
         std::vector<hpx::naming::id_type> get_unrolled_localities(
             std::vector<hpx::naming::id_type> const& in,
@@ -159,7 +159,7 @@ namespace hpx
         template <typename Iterator, std::size_t... I>
         base_type update_view(hpx::detail::coarray_sizes<N> const& cosizes,
             std::size_t num_images,
-            hpx::util::detail::pack_c<std::size_t, I...>,
+            hpx::util::index_pack<I...>,
             hpx::lcos::spmd_block const& block,
             Iterator&& begin,
             Iterator&& last) const
@@ -216,7 +216,7 @@ namespace hpx
         template<typename... I,
             typename = typename std::enable_if<
                 ! std::is_same<
-                    typename util::detail::at_index<sizeof...(I) - 1, I...>::type,
+                    typename util::at_index<sizeof...(I) - 1, I...>::type,
                     detail::auto_subscript
                 >::value
             >::type
@@ -232,7 +232,7 @@ namespace hpx
         template<typename... I,
             typename = typename std::enable_if<
                 std::is_same<
-                    typename util::detail::at_index<sizeof...(I) - 1, I...>::type,
+                    typename util::at_index<sizeof...(I) - 1, I...>::type,
                     detail::auto_subscript
                 >::value
             >::type
diff --git a/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_local_view_iterator.hpp b/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_local_view_iterator.hpp
index 9a641984b4..83952cea25 100644
--- a/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_local_view_iterator.hpp
+++ b/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_local_view_iterator.hpp
@@ -11,8 +11,7 @@
 
 #include <hpx/assertion.hpp>
 #include <hpx/components/containers/partitioned_vector/detail/view_element.hpp>
-
-#include <boost/iterator/iterator_adaptor.hpp>
+#include <hpx/iterator_support/iterator_adaptor.hpp>
 
 #include <utility>
 
@@ -20,7 +19,7 @@ namespace hpx {
 
     template <typename DataType, typename BaseIter>
     class partitioned_vector_local_view_iterator
-      : public boost::iterator_adaptor<
+      : public hpx::util::iterator_adaptor<
             partitioned_vector_local_view_iterator<DataType, BaseIter>,
             BaseIter,
             DataType,
@@ -29,7 +28,7 @@ namespace hpx {
     {
     private:
         using base_type
-            = boost::iterator_adaptor<
+            = hpx::util::iterator_adaptor<
                 partitioned_vector_local_view_iterator<DataType, BaseIter>,
                 BaseIter,
                 DataType,
@@ -54,7 +53,7 @@ namespace hpx {
         }
 
     private:
-        friend class boost::iterator_core_access;
+        friend class hpx::util::iterator_core_access;
 
         template <typename, typename>
         friend class const_partitioned_vector_local_view_iterator;
@@ -86,7 +85,7 @@ namespace hpx {
 
     template <typename DataType, typename BaseIter>
     class const_partitioned_vector_local_view_iterator
-      : public boost::iterator_adaptor<
+      : public hpx::util::iterator_adaptor<
             const_partitioned_vector_local_view_iterator<DataType, BaseIter>,
             BaseIter,
             DataType,
@@ -95,7 +94,7 @@ namespace hpx {
     {
     private:
         using base_type
-            = boost::iterator_adaptor<
+            = hpx::util::iterator_adaptor<
                 const_partitioned_vector_local_view_iterator<DataType, BaseIter>,
                 BaseIter,
                 DataType,
@@ -127,7 +126,7 @@ namespace hpx {
         }
 
     private:
-        friend class boost::iterator_core_access;
+        friend class hpx::util::iterator_core_access;
 
         DataType const & dereference() const
         {
diff --git a/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp b/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp
index 3c1bedffb7..7903db6e78 100644
--- a/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp
+++ b/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view.hpp
@@ -14,8 +14,8 @@
 #include <hpx/components/containers/partitioned_vector/partitioned_vector.hpp>
 #include <hpx/components/containers/partitioned_vector/partitioned_vector_segmented_iterator.hpp>
 #include <hpx/components/containers/partitioned_vector/partitioned_vector_view_iterator.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/runtime/launch_policy.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <array>
 #include <cstddef>
@@ -77,7 +77,7 @@ namespace hpx
             list_type hw_sizes = {})
         : begin_( begin ), end_( begin ), cbegin_(begin), cend_(begin), block_(block)
         {
-            using indices = typename hpx::util::detail::make_index_pack<N>::type;
+            using indices = typename hpx::util::make_index_pack<N>::type;
 
             // Physical sizes is equal to logical sizes if physical sizes are
             // not defined
@@ -117,7 +117,7 @@ namespace hpx
         void fill_basis(
             list_type const & sizes,
             std::array<std::size_t,N+1> & basis,
-            hpx::util::detail::pack_c<std::size_t, I...>) const
+            hpx::util::index_pack<I...>) const
         {
             basis[0] = 1;
 
@@ -139,8 +139,7 @@ namespace hpx
 
             // Check that all the elements are of integral type
             static_assert(
-                util::detail::all_of<
-                    typename std::is_integral<I>::type ... >::value,
+                util::all_of<typename std::is_integral<I>::type...>::value,
                 "One or more elements in subscript is not integral");
 
             std::size_t  offset = 0;
diff --git a/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view_iterator.hpp b/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view_iterator.hpp
index db271724d1..e15d24d1cd 100644
--- a/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view_iterator.hpp
+++ b/components/containers/partitioned_vector/include/hpx/components/containers/partitioned_vector/partitioned_vector_view_iterator.hpp
@@ -11,9 +11,8 @@
 
 #include <hpx/components/containers/partitioned_vector/detail/view_element.hpp>
 #include <hpx/components/containers/partitioned_vector/partitioned_vector_segmented_iterator.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
-
-#include <boost/iterator/iterator_facade.hpp>
+#include <hpx/iterator_support/iterator_facade.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <array>
 #include <cstddef>
@@ -24,7 +23,7 @@ namespace hpx {
 
     template<typename T, std::size_t N, typename Data>
     class partitioned_vector_view_iterator
-    : public boost::iterator_facade<
+    : public hpx::util::iterator_facade<
                 partitioned_vector_view_iterator<T,N,Data>,
                 hpx::detail::view_element<T,Data>,
                 std::random_access_iterator_tag,
@@ -33,11 +32,11 @@ namespace hpx {
     private:
         using pvector_iterator = hpx::vector_iterator<T,Data>;
         using segment_iterator = typename pvector_iterator::segment_iterator;
-        using indices = typename hpx::util::detail::make_index_pack<N>::type;
+        using indices = typename hpx::util::make_index_pack<N>::type;
 
     template<std::size_t... I>
     std::size_t  increment_solver( std::size_t dist,
-        hpx::util::detail::pack_c<std::size_t, I...> ) const
+        hpx::util::index_pack<I...> ) const
     {
         std::size_t max = N-1;
         std::size_t offset = 0;
@@ -89,7 +88,7 @@ namespace hpx {
         template<typename, std::size_t, typename>
         friend class const_partitioned_vector_view_iterator;
 
-        friend class boost::iterator_core_access;
+        friend class hpx::util::iterator_core_access;
 
         void increment()
         {
@@ -134,22 +133,21 @@ namespace hpx {
 
     template<typename T, std::size_t N, typename Data>
     class const_partitioned_vector_view_iterator
-    : public boost::iterator_facade<
+    : public hpx::util::iterator_facade<
                 const_partitioned_vector_view_iterator<T,N,Data>,
                 hpx::detail::const_view_element<T,Data>,
                 std::random_access_iterator_tag,
                 hpx::detail::const_view_element<T,Data> >
     {
     private:
-        using const_pvector_iterator = hpx::const_vector_iterator<T,Data>;
+        using const_pvector_iterator = hpx::const_vector_iterator<T, Data>;
         using const_segment_iterator =
             typename const_pvector_iterator::segment_iterator;
-        using indices =
-            typename hpx::util::detail::make_index_pack<N>::type;
+        using indices = typename hpx::util::make_index_pack<N>::type;
 
     template<std::size_t... I>
     std::size_t  increment_solver( std::size_t dist,
-        hpx::util::detail::pack_c<std::size_t, I...> ) const
+        hpx::util::index_pack<I...> ) const
     {
         std::size_t max = N-1;
         std::size_t offset = 0;
@@ -212,7 +210,7 @@ namespace hpx {
         operator=(const_partitioned_vector_view_iterator &&) = delete;
 
     private:
-        friend class boost::iterator_core_access;
+        friend class hpx::util::iterator_core_access;
 
         void increment()
         {
diff --git a/components/containers/partitioned_vector/tests/unit/coarray.cpp b/components/containers/partitioned_vector/tests/unit/coarray.cpp
index 76481f922d..9ec0238a31 100644
--- a/components/containers/partitioned_vector/tests/unit/coarray.cpp
+++ b/components/containers/partitioned_vector/tests/unit/coarray.cpp
@@ -34,7 +34,7 @@ void bulk_test( hpx::lcos::spmd_block block,
 
     hpx::coarray<double,3> a(block, name, {height,width,_}, elt_size);
 
-    int idx = block.this_image() * height * width;
+    std::size_t idx = block.this_image() * height * width;
 
     for (std::size_t j = 0; j<width; j++)
     for (std::size_t i = 0; i<height; i++)
@@ -48,7 +48,7 @@ void bulk_test( hpx::lcos::spmd_block block,
 
     if(block.this_image() == 0)
     {
-        int idx = 0;
+        std::size_t idx = 0;
 
         for (std::size_t k = 0; k<numlocs; k++)
         for (std::size_t j = 0; j<width; j++)
diff --git a/components/containers/partitioned_vector/tests/unit/partitioned_vector_view.cpp b/components/containers/partitioned_vector/tests/unit/partitioned_vector_view.cpp
index c138775a4c..9d039c5648 100644
--- a/components/containers/partitioned_vector/tests/unit/partitioned_vector_view.cpp
+++ b/components/containers/partitioned_vector/tests/unit/partitioned_vector_view.cpp
@@ -10,7 +10,7 @@
 #include <hpx/include/partitioned_vector_predef.hpp>
 #include <hpx/include/partitioned_vector_view.hpp>
 #include <hpx/collectives/spmd_block.hpp>
-#include <hpx/parallel/execution_policy.hpp>
+#include <hpx/execution/execution_policy.hpp>
 
 #include <hpx/testing.hpp>
 
diff --git a/components/containers/unordered/tests/unit/unordered_map.cpp b/components/containers/unordered/tests/unit/unordered_map.cpp
index 4abe92dc82..4bd937e7f1 100644
--- a/components/containers/unordered/tests/unit/unordered_map.cpp
+++ b/components/containers/unordered/tests/unit/unordered_map.cpp
@@ -73,7 +73,7 @@ void fill_unordered_map(hpx::unordered_map<Key, Value, Hash, KeyEqual>& m,
         std::string idx = std::to_string(i);
         m[idx] = val;
     }
-    HPX_TEST(m.size() == count);
+    HPX_TEST_EQ(m.size(), count);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/components/create_component_skeleton.py b/components/create_component_skeleton.py
index 44c880fca9..bcc64587b0 100755
--- a/components/create_component_skeleton.py
+++ b/components/create_component_skeleton.py
@@ -21,7 +21,7 @@ component_name_upper = component_name.upper()
 header_str = '=' * len(component_name)
 
 # CMake minimum version
-cmake_version = '3.3.2'
+cmake_version = '3.13'
 
 cmake_header = f'''# Copyright (c) 2019 The STE||AR-Group
 #
diff --git a/components/iostreams/include/hpx/components/iostreams/ostream.hpp b/components/iostreams/include/hpx/components/iostreams/ostream.hpp
index 39bbc33ca4..a4b817e494 100644
--- a/components/iostreams/include/hpx/components/iostreams/ostream.hpp
+++ b/components/iostreams/include/hpx/components/iostreams/ostream.hpp
@@ -1,5 +1,5 @@
 //  Copyright (c) 2011 Bryce Lelbach
-//  Copyright (c) 2011-2016 Hartmut Kaiser
+//  Copyright (c) 2011-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/components/iostreams/include/hpx/components/iostreams/server/buffer.hpp b/components/iostreams/include/hpx/components/iostreams/server/buffer.hpp
index dc030d7bfd..e31ad192dd 100644
--- a/components/iostreams/include/hpx/components/iostreams/server/buffer.hpp
+++ b/components/iostreams/include/hpx/components/iostreams/server/buffer.hpp
@@ -14,8 +14,6 @@
 #include <hpx/components/iostreams/export_definitions.hpp>
 #include <hpx/components/iostreams/write_functions.hpp>
 
-#include <boost/swap.hpp>
-
 #include <iosfwd>
 #include <memory>
 #include <mutex>
@@ -85,7 +83,7 @@ namespace hpx { namespace iostreams { namespace detail
         buffer init_locked()
         {
             buffer b;
-            boost::swap(b.data_, data_);
+            std::swap(b.data_, data_);
             return b;
         }
 
diff --git a/components/iostreams/src/server/output_stream.cpp b/components/iostreams/src/server/output_stream.cpp
index 7ae434a41a..740df2b068 100644
--- a/components/iostreams/src/server/output_stream.cpp
+++ b/components/iostreams/src/server/output_stream.cpp
@@ -10,7 +10,7 @@
 #include <hpx/functional/bind_front.hpp>
 
 #include <hpx/runtime_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/serialization/shared_ptr.hpp>
 #include <hpx/serialization/vector.hpp>
@@ -18,7 +18,7 @@
 #include <hpx/components/iostreams/server/buffer.hpp>
 #include <hpx/components/iostreams/server/output_stream.hpp>
 
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 
 #include <cstdint>
 #include <functional>
diff --git a/components/iostreams/tests/regressions/lost_output_2236.cpp b/components/iostreams/tests/regressions/lost_output_2236.cpp
index 7b52c7d75c..95d024aec5 100644
--- a/components/iostreams/tests/regressions/lost_output_2236.cpp
+++ b/components/iostreams/tests/regressions/lost_output_2236.cpp
@@ -299,12 +299,12 @@ namespace gc { namespace server {
         state();
         if (w < weight)
         {
-            HPX_TEST(strong_count > 0);
+            HPX_TEST_LT(std::size_t(0), strong_count);
             strong_count--;
         }
         else
         {
-            HPX_TEST(weak_count > 0);
+            HPX_TEST_LT(std::size_t(0), weak_count);
             weak_count--;
         }
         cd->phantom_count++;
@@ -367,12 +367,12 @@ namespace gc { namespace server {
     void collectable::recover_done()
     {
         cd->wc--;
-        HPX_TEST(cd->wc > 0);
+        HPX_TEST_LT(std::size_t(0), cd->wc);
         check_recover_done();
     }
     void collectable::done(hpx::id_type child)
     {
-        HPX_TEST(cd->wc > 0);
+        HPX_TEST_LT(std::size_t(0), cd->wc);
         cd->wc--;
         if (cd->wc == 0 && cd->cid == this->get_id())
         {
@@ -422,7 +422,7 @@ namespace gc { namespace server {
         }
         else
         {
-            HPX_TEST(weak_count > 0);
+            HPX_TEST_LT(std::size_t(0), weak_count);
             weak_count--;
             if (weak_count == 0 && strong_count == 0)
             {
diff --git a/components/performance_counters/papi/src/util/papi.cpp b/components/performance_counters/papi/src/util/papi.cpp
index efb828de88..960d53ec9c 100644
--- a/components/performance_counters/papi/src/util/papi.cpp
+++ b/components/performance_counters/papi/src/util/papi.cpp
@@ -12,7 +12,7 @@
 #include <hpx/errors.hpp>
 #include <hpx/runtime.hpp>
 #include <hpx/format.hpp>
-#include <hpx/util/parse_command_line.hpp>
+#include <hpx/command_line_handling/parse_command_line.hpp>
 #include <hpx/util/thread_mapper.hpp>
 #include <hpx/components/performance_counters/papi/util/papi.hpp>
 
diff --git a/components/performance_counters/papi/tests/regressions/papi_counters_active_interface.cpp b/components/performance_counters/papi/tests/regressions/papi_counters_active_interface.cpp
index 3c294ce901..32ad5db9e4 100644
--- a/components/performance_counters/papi/tests/regressions/papi_counters_active_interface.cpp
+++ b/components/performance_counters/papi/tests/regressions/papi_counters_active_interface.cpp
@@ -13,9 +13,8 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/hpx_start.hpp>
-
-#include <boost/lexical_cast.hpp>
 #include <hpx/program_options.hpp>
+#include <hpx/util/from_string.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
 const char *counter_name = "/papi{locality#0/worker-thread#0}/PAPI_SR_INS";
@@ -90,7 +89,7 @@ int check_(int fd)
                     }
                     else
                     {
-                        cnt.push_back(boost::lexical_cast<double>(value));
+                        cnt.push_back(hpx::util::from_string<double>(value));
                     }
                     if (cnt.size() == 5) break;
                     out.erase(0, pos+1);
diff --git a/components/performance_counters/papi/tests/regressions/papi_counters_segfault_1890.cpp b/components/performance_counters/papi/tests/regressions/papi_counters_segfault_1890.cpp
index 7bff71611f..e91923893c 100644
--- a/components/performance_counters/papi/tests/regressions/papi_counters_segfault_1890.cpp
+++ b/components/performance_counters/papi/tests/regressions/papi_counters_segfault_1890.cpp
@@ -30,8 +30,8 @@ int hpx_main(int argc, char ** argv)
     std::int64_t val1 = total_cycles.get_value<std::int64_t>(hpx::launch::sync);
     std::int64_t val2 = cycles.get_value<std::int64_t>(hpx::launch::sync);
 
-    HPX_TEST(val1 != 0);
-    HPX_TEST(val2 != 0);
+    HPX_TEST_NEQ(val1, 0);
+    HPX_TEST_NEQ(val2, 0);
 #endif
 
     return hpx::finalize();
diff --git a/components/process/include/hpx/components/process/util/posix/initializers/close_fds_if.hpp b/components/process/include/hpx/components/process/util/posix/initializers/close_fds_if.hpp
index dbc2db4cf8..d1dc8fab51 100644
--- a/components/process/include/hpx/components/process/util/posix/initializers/close_fds_if.hpp
+++ b/components/process/include/hpx/components/process/util/posix/initializers/close_fds_if.hpp
@@ -15,10 +15,11 @@
 
 #if !defined(HPX_WINDOWS)
 #include <hpx/components/process/util/posix/initializers/initializer_base.hpp>
-#include <boost/iterator/counting_iterator.hpp>
+
 #include <boost/range/adaptor/filtered.hpp>
 #include <boost/range/algorithm/for_each.hpp>
 #include <boost/range/counting_range.hpp>
+
 #include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -66,7 +67,7 @@ private:
         } while (up == -1 && errno == EINTR);
         if (up == -1)
 #endif
-            up = ::sysconf(_SC_OPEN_MAX);
+            up = static_cast<int>(::sysconf(_SC_OPEN_MAX));
         if (up == -1)
             up = HPX_PROCESS_POSIX_MAX_FD;
         return up;
diff --git a/components/process/include/hpx/components/process/util/windows/initializers/set_args.hpp b/components/process/include/hpx/components/process/util/windows/initializers/set_args.hpp
index f29228de86..aa499f1427 100644
--- a/components/process/include/hpx/components/process/util/windows/initializers/set_args.hpp
+++ b/components/process/include/hpx/components/process/util/windows/initializers/set_args.hpp
@@ -17,8 +17,8 @@
 #if defined(HPX_WINDOWS)
 #include <hpx/components/process/util/windows/initializers/initializer_base.hpp>
 #include <hpx/serialization/string.hpp>
+#include <hpx/string_util/predicate.hpp>
 
-#include <boost/algorithm/string/predicate.hpp>
 #include <boost/range/algorithm/copy.hpp>
 #include <boost/range/begin.hpp>
 #include <boost/range/end.hpp>
diff --git a/docs/CMakeLists.txt b/docs/CMakeLists.txt
index dc3bc0a938..7f67acff10 100644
--- a/docs/CMakeLists.txt
+++ b/docs/CMakeLists.txt
@@ -13,7 +13,6 @@ set(doxygen_dependencies
     "${PROJECT_SOURCE_DIR}/hpx/hpx_finalize.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/hpx_suspend.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/parallel/task_block.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/performance_counters/manage_counter_type.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime_fwd.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/applier_fwd.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/basename_registration_fwd.hpp"
@@ -29,7 +28,6 @@ set(doxygen_dependencies
     "${PROJECT_SOURCE_DIR}/hpx/runtime/get_worker_thread_num.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/launch_policy.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/report_error.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/runtime/runtime_mode.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/set_parcel_write_handler.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/shutdown_function.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/startup_function.hpp"
@@ -45,10 +43,6 @@ set(doxygen_dependencies
     "${PROJECT_SOURCE_DIR}/hpx/runtime/components/migrate_component.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/components/new.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/runtime/naming/unmanaged.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/runtime/threads/policies/scheduler_mode.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/runtime/threads/thread_data_fwd.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/runtime/threads/thread_helpers.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/runtime/threads/thread_pool_base.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/lcos/split_future.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/lcos/wait_all.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/lcos/when_all.hpp"
@@ -61,8 +55,7 @@ set(doxygen_dependencies
     "${PROJECT_SOURCE_DIR}/hpx/util/debugging.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/util/pack_traversal.hpp"
     "${PROJECT_SOURCE_DIR}/hpx/util/pack_traversal_async.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/util/unwrap.hpp"
-    "${PROJECT_SOURCE_DIR}/hpx/performance_counters/manage_counter_type.hpp")
+    "${PROJECT_SOURCE_DIR}/hpx/util/unwrap.hpp")
 
 foreach(doxygen_input ${doxygen_dependencies})
   set(doxygen_inputs "${doxygen_inputs} ${doxygen_input}")
@@ -79,10 +72,7 @@ set(doxygen_definition_list
     "HPX_API_EXPORT="
     "HPX_ALWAYS_EXPORT="
     "extern="
-    "HPX_NOEXCEPT="
-    "HPX_CONSTEXPR="
     "HPX_FORCEINLINE="
-    "HPX_INLINE_NAMESPACE(x)=namespace x"
     "HPX_CONCEPT_REQUIRES_(...)=")
 
 # Definitions for autodoc.doxy.in
diff --git a/docs/sphinx/contributing/modules.rst b/docs/sphinx/contributing/modules.rst
index 42aac682b0..fa7f634937 100644
--- a/docs/sphinx/contributing/modules.rst
+++ b/docs/sphinx/contributing/modules.rst
@@ -93,7 +93,7 @@ Optional multi-value arguments-are:
 The ``include`` directory should contain only headers that other libraries need.
 For each of those headers, an automatic header test to check for self
 containment will be generated. Private headers should be placed under the
-``src`` directory. This allows for clear seperation. The ``cmake`` subdirectory
+``src`` directory. This allows for clear separation. The ``cmake`` subdirectory
 may include additional |cmake|_ scripts needed to generate the respective build
 configurations.
 
diff --git a/docs/sphinx/contributing/release_procedure.rst b/docs/sphinx/contributing/release_procedure.rst
index 1cd78513b9..7d431c0349 100644
--- a/docs/sphinx/contributing/release_procedure.rst
+++ b/docs/sphinx/contributing/release_procedure.rst
@@ -84,9 +84,6 @@ are completed to avoid confusion.
 #. Make sure ``HPX_VERSION_MAJOR/MINOR/SUBMINOR`` in ``CMakeLists.txt`` contain
    the correct values. Change them if needed.
 
-#. Remove the examples and benchmarks that will not go into the release from the
-   release branch.
-
 #. This step does not apply to patch releases. Remove features which have been
    deprecated for at least 2 releases. This involves removing build options
    which enable those features from the main CMakeLists.txt and also deleting
@@ -103,6 +100,9 @@ are completed to avoid confusion.
    The main CMakeLists.txt contains a comment indicating for which version
    the breaking change was introduced first.
 
+#. Update the minimum required versions if necessary (compilers, dependencies,
+   etc.).
+
 #. Switch Buildbot over to test the release branch.
 
    * ``https://github.com/STEllAR-GROUP/hermione-buildbot/blob/rostam/master/master.cfg``
@@ -160,25 +160,12 @@ are completed to avoid confusion.
 
 #. Merge release branch into master.
 
-#. This step does not apply to patch releases. Bump version numbers on master.
-
-   #. Create a new branch from master, and check that branch out (name it, for
-      example, by the next version number).
-
-   #. Bump the |hpx| version to the next release target. The following files
-      contain version info:
-
-      * ``CMakeLists.txt``
-      * Grep for old version number
-
-   #. Create a new "What's New" section for the docs of the next anticipated
-      release. Set the date to "unreleased". Make sure you add it to the table
-      of contents in ``docs/sphinx/releases.rst``.
+#. Post-release cleanup. Create a new pull request against master with the
+   following changes:
 
-   #. Modify the the release procedure if necessary.
+   #. Modify the release procedure if necessary.
 
-   #. Merge new branch containing next version numbers to master; resolve conflicts
-      if necessary.
+   #. Change ``HPX_VERSION_TAG`` in ``CMakeLists.txt`` back to ``-trunk``.
 
 #. Switch Buildbot back to test the main branch
 
diff --git a/docs/sphinx/examples/1d_stencil.rst b/docs/sphinx/examples/1d_stencil.rst
index ca668b7ef4..dc605db457 100644
--- a/docs/sphinx/examples/1d_stencil.rst
+++ b/docs/sphinx/examples/1d_stencil.rst
@@ -162,7 +162,7 @@ functions to run on.
 
 In example 6, we begin to distribute the partition data on different nodes. This
 is accomplished in ``stepper::do_work()`` by passing the GID of the
-:term:`locality` where we wish to create the partition to the the partition
+:term:`locality` where we wish to create the partition to the partition
 constructor.
 
 .. literalinclude:: ../../examples/1d_stencil/1d_stencil_6.cpp
diff --git a/docs/sphinx/examples/accumulator.rst b/docs/sphinx/examples/accumulator.rst
index 6789a9a908..ae16c8d56c 100644
--- a/docs/sphinx/examples/accumulator.rst
+++ b/docs/sphinx/examples/accumulator.rst
@@ -18,8 +18,8 @@ classes that expose methods as a type of |hpx| action. These actions are called
 component actions.
 
 Components are globally named, meaning that a component action can be called
-remotely (e.g.  from another machine). There are two accumulator examples in
-|hpx|;.
+remotely (e.g.,  from another machine). There are two accumulator examples in
+|hpx|.
 
 In the :ref:`examples_fibonacci` and the :ref:`examples_hello_world`, we
 introduced plain actions, which wrapped global functions. The target of a plain
@@ -93,11 +93,11 @@ application can be found here: :download:`accumulator_client.cpp
 
 An |hpx| component is represented by two C++ classes:
 
-* **A server class** - The implementation of the components functionality.
+* **A server class** - The implementation of the component's functionality.
 * **A client class** - A high-level interface that acts as a proxy for an
   instance of the component.
 
-Typically, these two classes all have the same name, but the server class
+Typically, these two classes both have the same name, but the server class
 usually lives in different sub-namespaces (``server``). For example, the full
 names of the two classes in accumulator are:
 
@@ -118,7 +118,7 @@ The accumulator component inherits from
 ensure that all action invocations are serialized. That means that the system
 ensures that no two actions are invoked at the same time on a given component
 instance. This makes the component thread safe and no additional locking has to
-be implemented by the user. Moreover, accumulator component is a component,
+be implemented by the user. Moreover, an accumulator component is a component
 because it also inherits from :cpp:class:`hpx::components::component_base` (the
 template argument passed to locking_hook is used as its base class). The
 following snippet shows the corresponding code:
@@ -201,7 +201,7 @@ Here are examples of how to expose actions through a client class:
 
 There are a few different ways of invoking actions:
 
-* **Non-blocking**: For actions which don't have return types, or when we do not
+* **Non-blocking**: For actions that don't have return types, or when we do not
   care about the result of an action, we can invoke the action using
   fire-and-forget semantics. This means that once we have asked |hpx| to compute
   the action, we forget about it completely and continue with our computation.
@@ -219,7 +219,7 @@ There are a few different ways of invoking actions:
    :lines: 115-121
 
 * **Synchronous**: To invoke an action in a fully synchronous manner, we can
-  simply call :cpp:func:`hpx::async`\ ``().get()`` (e.g., create a future and
+  simply call :cpp:func:`hpx::async`\ ``().get()`` (i.e., create a future and
   immediately wait on it to be ready). Here's an example from the accumulator
   client class:
 
diff --git a/docs/sphinx/examples/interest_calculator.rst b/docs/sphinx/examples/interest_calculator.rst
index bc6260e321..ba8580d9fc 100644
--- a/docs/sphinx/examples/interest_calculator.rst
+++ b/docs/sphinx/examples/interest_calculator.rst
@@ -17,19 +17,19 @@ Dataflow: Interest calculator
 concepts. One of these tools is a :term:`local control object` (:term:`LCO`)
 called dataflow. An :term:`LCO` is a type of component that can spawn a new
 thread when triggered. They are also distinguished from other components by a
-standard interface which allow users to understand and use them easily.
+standard interface that allow users to understand and use them easily.
 A Dataflow, being an :term:`LCO`, is triggered when the values it depends on
 become available. For instance, if you have a calculation X that depends on the
 results of three other calculations, you could set up a dataflow that would begin
 the calculation X as soon as the other three calculations have returned their
 values. Dataflows are set up to depend on other dataflows. It is this property
 that makes dataflow a powerful parallelization tool. If you understand the
-dependencies of your calculation, you can devise a simple algorithm which sets
+dependencies of your calculation, you can devise a simple algorithm that sets
 up a dependency tree to be executed. In this example, we calculate compound
 interest. To calculate compound interest, one must calculate the interest made
 in each compound period, and then add that interest back to the principal before
-calculating the interest made in the next period. A practical person would of
-course use the formula for compound interest:
+calculating the interest made in the next period. A practical person would, of
+course, use the formula for compound interest:
 
 .. math::
 
@@ -38,7 +38,7 @@ course use the formula for compound interest:
 where :math:`F` is the future value, :math:`P` is the principal value, :math:`i`
 is the interest rate, and :math:`n` is the number of compound periods.
 
-Nevertheless, we have chosen for the sake of example to manually calculate the
+However, for the sake of this example, we have chosen to manually calculate the
 future value by iterating:
 
 .. math::
@@ -82,7 +82,7 @@ This should print:
 Walkthrough
 ===========
 
-Let us begin with main, here we can see that we again are using
+Let us begin with main. Here we can see that we again are using
 |boost_program_options| to set our command line variables (see
 :ref:`examples_fibonacci` for more details). These options set the principal,
 rate, compound period, and time. It is important to note that the units of time
@@ -111,7 +111,7 @@ reassignment of ``principal`` using a :cpp:class:`hpx::dataflow`. A dataflow
 will first wait for its arguments to be ready before launching any callbacks, so
 ``add`` in this case will not begin until both ``principal`` and ``interest``
 are ready. This loop continues for each compound period that must be calculated.
-To see how ``interest`` and ``principal`` are calculated in the loop let us look
+To see how ``interest`` and ``principal`` are calculated in the loop, let us look
 at ``calc_action`` and ``add_action``:
 
 .. literalinclude:: ../../examples/quickstart/interest_calculator.cpp
diff --git a/docs/sphinx/manual/building_hpx.rst b/docs/sphinx/manual/building_hpx.rst
index 19e9da755c..323b7dd9ef 100644
--- a/docs/sphinx/manual/building_hpx.rst
+++ b/docs/sphinx/manual/building_hpx.rst
@@ -34,7 +34,7 @@ on how to write CMake-based projects.
 Basic CMake usage
 -----------------
 
-This section explains basic aspects of |cmake|, specifically options needed for     
+This section explains basic aspects of |cmake|, specifically options needed for
 day-to-day usage.
 
 CMake comes with extensive documentation in the form of html files and on the
@@ -71,8 +71,8 @@ Quick start
 
 Here, you will use the command-line, non-interactive CMake interface.
 
-#. Download and install CMake here: |cmake_download|_. Version 3.3.2 is the
-   minimally required version for |hpx|.
+#. Download and install CMake here: |cmake_download|_. Version 3.13 is the
+   minimum required version for |hpx|.
 
 #. Open a shell. Your development tools must be reachable from this shell
    through the ``PATH`` environment variable.
@@ -130,7 +130,7 @@ value. You can also undefine a variable:
 Variables are stored on the CMake cache. This is a file named ``CMakeCache.txt``
 on the root of the build directory. Do not hand-edit it.
 
-Variables are listed here appending its type after a colon. You should write the 
+Variables are listed here appending its type after a colon. You should write the
 variable and the type on the CMake command line:
 
 .. code-block:: bash
@@ -153,14 +153,14 @@ work, but we do not test |hpx| with other platforms, so please be warned.
 
 .. table:: Supported Platforms for |hpx|
 
-   ========= =================== ================== ====================
-   Name      Recommended Version Minimum Version    Architectures
-   ========= =================== ================== ====================
-   Linux     3.2                 2.6                x86-32, x86-64, k1om
-   BlueGeneQ V1R2M0              V1R2M0             PowerPC A2
-   Windows   7, Server 2008 R2   Any Windows system x86-32, x86-64
-   Mac OSX                       Any OSX system     x86-64
-   ========= =================== ================== ====================
+   ========= ================== ====================
+   Name      Minimum Version    Architectures
+   ========= ================== ====================
+   Linux     2.6                x86-32, x86-64, k1om
+   BlueGeneQ V1R2M0             PowerPC A2
+   Windows   Any Windows system x86-32, x86-64
+   Mac OSX   Any OSX system     x86-64
+   ========= ================== ====================
 
 Software and libraries
 ----------------------
@@ -196,7 +196,6 @@ favorite compiler with |hpx| visit |hpx_buildbot|_.
 .. list-table:: Software prerequisites for |hpx| on Linux systems.
 
    * * Name
-     * Recommended version
      * Minimum version
      * Notes
    * * **Compilers**
@@ -204,94 +203,72 @@ favorite compiler with |hpx| visit |hpx_buildbot|_.
      *
      *
    * * |gcc|_
-     * 4.9 or newer
-     * 4.9
+     * 7.0
      *
    * * |icpc|_
-     * 2014 or newer
      * 2014
      *
    * * |clang|_
-     * 3.8 or newer
-     * 3.8
+     * 4.0
      *
    * * **Build System**
      *
      *
      *
    * * |cmake|_
-     * 3.9.0
-     * 3.3.2
+     * 3.13
      * Cuda support 3.9
    * * **Required Libraries**
      *
      *
      *
    * * |boost_libraries|_
-     * 1.67.0 or newer
      * 1.61.0
      *
    * * |hwloc|_
-     * 1.11
      * 1.2 (Xeon Phi: 1.6)
      *
 
 .. note::
 
-   When compiling with the Intel Compiler on Linux systems, we only support C++
-   Standard Libraries provided by gcc 4.8 and upwards. If the ``g++`` in your
-   path is older than 4.8, please specify the path of a newer ``g++`` by setting
-   ``CMAKE_CXX_FLAGS='-gxx-name=/path/to/g++'`` via |cmake|_.
-
-.. note::
-
-   When building Boost using gcc, please note that it is always a good idea to
-   specify a ``cxxflags=-std=c++11`` command line argument to ``b2`` (``bjam``).
-   Note, however, that this is absolutely necessary when using gcc V5.2 and
-   above.
+   When building Boost using gcc, please note that it is required to specify a
+   ``cxxflags=-std=c++14`` command line argument to ``b2`` (``bjam``).
 
 .. list-table:: Software prerequisites for |hpx| on Windows systems
 
    * * Name
-     * Recommended version
      * Minimum version
      * Notes
    * * **Compilers**
      *
      *
-     *
    * * |visual_cxx|_ (x64)
-     * 2015
      * 2015
      *
    * * **Build System**
      *
      *
-     *
    * * |cmake|_
-     * 3.9.0
-     * 3.3.2
+     * 3.13
      *
    * * **Required Libraries**
      *
      *
      *
    * * |boost|_
-     * 1.67.0 or newer
      * 1.61.0
      *
    * * |hwloc|_
-     * 1.11
      * 1.5
      *
 
 .. note::
 
    You need to build the following Boost libraries for |hpx|:
-   Boost.Filesystem, Boost.ProgramOptions, Boost.Regex, and Boost.System. The
+   Boost.Filesystem, Boost.ProgramOptions, and Boost.System. The
    following are not needed by default, but are required in certain
-   configurations: Boost.Chrono, Boost.DateTime, Boost.Log, Boost.LogSetup, and
-   Boost.Thread.
+   configurations: Boost.Chrono, Boost.DateTime, Boost.Log, Boost.LogSetup,
+   Boost.Regex, and Boost.Thread.
 
 Depending on the options you chose while building and installing |hpx|,
 you will find that |hpx| may depend on several other libraries such as those
@@ -308,20 +285,16 @@ listed below.
    Linux systems
 
    * * Name
-     * Recommended version
      * Minimum version
      * Notes
    * * |google_perftools|_
-     * 1.7.1
      * 1.7.1
      * Used as a replacement for the system allocator, and for allocation
        diagnostics.
    * * |libunwind|_
-     * 0.99
      * 0.97
      * Dependency of google-perftools on x86-64, used for stack unwinding.
    * * |openmpi|_
-     * 1.10.1
      * 1.8.0
      * Can be used as a highspeed communication library backend for the
        parcelport.
@@ -335,34 +308,27 @@ listed below.
 .. list-table:: Optional software prerequisites for |hpx| on Linux systems
 
    * * Name
-     * Recommended version
      * Minimum version
      * Notes
    * * |papi|
-     * 
      *
      * Used for accessing hardware performance data.
    * * |jemalloc|_
-     * 2.1.2
      * 2.1.0
      * Used as a replacement for the system allocator.
    * * |mimalloc|_
-     * latest
      * 1.0.0
      * Used as a replacement for the system allocator.
    * * |hdf5|_
-     * 1.8.7
      * 1.6.7
      * Used for data I/O in some example applications. See important note below.
 
 .. list-table:: Optional software prerequisites for |hpx| on Windows systems
 
    * * Name
-     * Recommended version
      * Minimum version
      * Notes
    * * |hdf5|_
-     * 1.8.7
      * 1.6.7
      * Used for data I/O in some example applications. See important note below.
 
@@ -422,9 +388,8 @@ Installing Boost
 
 .. important::
 
-   When building Boost using gcc, please note that it is always a good idea to
-   specify a ``cxxflags=-std=c++11`` command line argument to ``b2`` (``bjam``).
-   Doint so is absolutely necessary when using gcc V5.2 and above.
+   When building Boost using gcc, please note that it is required to specify a
+   ``cxxflags=-std=c++14`` command line argument to ``b2`` (``bjam``).
 
 .. important::
 
@@ -570,10 +535,7 @@ of those features. That is, the default will be the highest C++ standard version
 available. If you want to force |hpx| to use a specific C++ standard version, you
 can use the following CMake variables:
 
-* ``HPX_WITH_CXX0X``: Enables Pre-C++11 support (This is the minimum required
-  mode on older gcc versions).
-* ``HPX_WITH_CXX11``: Enables C++11 support
-* ``HPX_WITH_CXX14``: Enables C++14 support
+* ``HPX_WITH_CXX14``: Enables C++14 support (this is the minimum requirement)
 * ``HPX_WITH_CXX17``: Enables C++17 support
 * ``HPX_WITH_CXX2A``: Enables (experimental) C++20 support
 
@@ -589,7 +551,7 @@ support). The |cmake| variable used to set the build type is
 <https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html>`_).
 Available build types are:
 
-* **Debug**: Full debug symbols are available as well as additional assertions to 
+* **Debug**: Full debug symbols are available as well as additional assertions to
   help debugging. To enable the debug build type for the |hpx| API, the C++ Macro
   ``HPX_DEBUG`` is defined.
 * **RelWithDebInfo**: Release build with debugging symbols. This is most useful
@@ -1225,7 +1187,7 @@ Building |hpx|
 ..............
 
 After all the prerequisites have been successfully installed, we can now start
-building and installing |hpx|. The build procedure is almost the same as the one 
+building and installing |hpx|. The build procedure is almost the same as the one
 for :ref:`unix_installation` with the sole difference that you have to enable the
 Xeon Phi in the CMake Build system. This is achieved by invoking CMake in the
 following way:
diff --git a/docs/sphinx/manual/creating_hpx_projects.rst b/docs/sphinx/manual/creating_hpx_projects.rst
index 447016e9f5..c1b824e7a3 100644
--- a/docs/sphinx/manual/creating_hpx_projects.rst
+++ b/docs/sphinx/manual/creating_hpx_projects.rst
@@ -185,7 +185,7 @@ The basic structure to include |hpx| into your CMakeLists.txt is shown here:
 .. code-block:: cmake
 
    # Require a recent version of cmake
-   cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+   cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
    # This project is C++ based.
    project(your_app CXX)
@@ -217,7 +217,7 @@ used by ``find_package(HPX)`` to set up all the necessary macros needed to use
 
   The difference between ``CMAKE_PREFIX_PATH`` and ``HPX_DIR`` is that CMake
   will add common postfixes, such as ``lib/cmake/<project``, to the
-  ``MAKE_PREFIX_PATH`` and search in these locations too. Note that if your
+  ``CMAKE_PREFIX_PATH`` and search in these locations too. Note that if your
   project uses |hpx| as well as other CMake-managed projects, the paths to the
   locations of these multiple projects may be concatenated in the
   ``CMAKE_PREFIX_PATH``.
@@ -230,8 +230,66 @@ Additionally, if you wish to require |hpx| for your project, replace the
 
 You can check if |hpx| was successfully found with the ``HPX_FOUND`` CMake variable.
 
-The simplest way to add the |hpx| component is to use the ``add_hpx_component``
-macro and add it to the ``CMakeLists.txt`` file:
+Using |hpx| targets
+-------------------
+
+The recommended way of setting up your targets to use |hpx| is to link to the
+``HPX::hpx`` target:
+
+.. code-block:: cmake
+
+   target_link_libraries(hello_world_component PUBLIC HPX::hpx)
+
+This requires that you have already created the target like this:
+
+.. code-block:: cmake
+
+   add_library(hello_world_component SHARED hello_world_component.cpp)
+   target_include_directories(hello_world_component PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
+
+When you link your library to ``HPX::hpx`` you will be able use |hpx|
+functionality in your library. To create a component, however, requires setting
+two additional compile definitions:
+
+.. code-block:: cmake
+
+   target_compile_options(hello_world_component
+     HPX_COMPONENT_NAME=hello_world
+     HPX_COMPONENT_EXPORTS)
+
+Instead of setting these definitions manually you may link to the
+``HPX::component`` target, which sets ``HPX_COMPONENT_NAME`` to
+``hpx_<target_name>``, where ``<target_name>`` is the target name of your
+library. Note that these definitions should be ``PRIVATE`` to make sure these
+definitions are not propagated transitively to dependent targets.
+
+In addition to making your library a component you can make it a plugin. To do
+so link to the ``HPX::plugin`` target. Similarly to ``HPX::component`` this will
+set ``HPX_PLUGIN_NAME`` to ``hpx_<target_name>``. This definition should also be
+``PRIVATE``. Unlike regular shared libraries, plugins are loaded at runtime from
+certain directories and will not be found without additional configuration.
+Plugins should be installed into a directory containing only plugins. For
+example, the plugins created by |hpx| itself are installed into the ``hpx``
+subdirectory in the library install directory (typically ``lib`` or ``lib64``).
+When using the ``HPX::plugin`` target you need to install your plugins into an
+appropriate directory. You may also want to set the location of your plugin in
+the build directory with the ``*_OUTPUT_DIRECTORY*`` CMake target properties to
+be able to load the plugins in the build directory. Once you've set the install
+or output directory of your plugin you need to tell your executable where to
+find it at runtime. You can do this either by setting the environment variable
+``HPX_COMPONENT_PATHS`` or the ini setting ``hpx.component_paths`` (see
+:option:`--hpx:ini`) to the directory containing your plugin.
+
+Using macros to create new targets
+----------------------------------
+
+In addition to the targets described above, |hpx| provides convenience macros
+to hide optional boilerplate code that may be useful for your project. The link
+to the targets described above. We recommend that you use the targets directly
+whenever possible as they tend to compose better with other targets.
+
+The macro for adding an |hpx| component is ``add_hpx_component``. It can be
+used in your ``CMakeLists.txt`` file like this:
 
 .. code-block:: cmake
 
@@ -299,8 +357,8 @@ variable to point to the installation of |hpx|.
 
 .. _cmake_integrate_hpx:
 
-CMake macros to integrate |hpx| into existing applications
-----------------------------------------------------------
+Using macros to set up existing targets to use |hpx|
+----------------------------------------------------
 
 In addition to the ``add_hpx_component`` and ``add_hpx_executable``, you can use
 the ``hpx_setup_target`` macro to have an already existing target to be used
@@ -402,7 +460,7 @@ To build the program, type:
 
    make
 
-A successfull build should result in hello_world binary. To test, type:
+A successful build should result in hello_world binary. To test, type:
 
 .. code-block:: bash
 
@@ -470,7 +528,7 @@ To build the program, type:
 
    make
 
-A successfull build should result in hello_world binary. To test, type:
+A successful build should result in hello_world binary. To test, type:
 
 .. code-block:: bash
 
diff --git a/docs/sphinx/manual/hpx_runtime_and_resources.rst b/docs/sphinx/manual/hpx_runtime_and_resources.rst
index 60a9c4f78f..b4e13f74a2 100644
--- a/docs/sphinx/manual/hpx_runtime_and_resources.rst
+++ b/docs/sphinx/manual/hpx_runtime_and_resources.rst
@@ -176,7 +176,7 @@ thread pool.
 
 .. note::
 
-   It is simpler in some situations to to schedule important tasks with high
+   It is simpler in some situations to schedule important tasks with high
    priority instead of using a separate thread pool.
 
 Using the resource partitioner
diff --git a/docs/sphinx/manual/launching_and_configuring_hpx_applications.rst b/docs/sphinx/manual/launching_and_configuring_hpx_applications.rst
index 70fd2aac2c..4252bdcf89 100644
--- a/docs/sphinx/manual/launching_and_configuring_hpx_applications.rst
+++ b/docs/sphinx/manual/launching_and_configuring_hpx_applications.rst
@@ -366,8 +366,8 @@ The ``hpx.thread_queue`` configuration section
        converted into |hpx| threads whenever the thread queues for a core have
        run empty.
    * * ``hpx.thread_queue.max_delete_count``
-     * The value of this property defines the number number of terminated |hpx|
-       threads to discard during each invocation of the corresponding function.
+     * The value of this property defines the number of terminated |hpx| threads
+       to discard during each invocation of the corresponding function.
 
 The ``hpx.components`` configuration section
 ............................................
@@ -598,7 +598,7 @@ equivalent cmake variable is ``HPX_WITH_PARCELPORT_MPI`` and has to be set to
    * * ``hpx.parcel.mpi.enable``
      * Enable the use of the MPI parcelport. HPX tries to detect if the
        application was started within a parallel MPI environment. If the
-       detection was succesful, the MPI parcelport is enabled by default. To
+       detection was successful, the MPI parcelport is enabled by default. To
        explicitly disable the MPI parcelport, set to 0. Note that the initial
        bootstrap of the overall |hpx| application will be performed using MPI as
        well.
@@ -1497,8 +1497,8 @@ The predefined command line options for any application using
    makes the scheduler NUMA sensitive
 
 
-|hpx| configuraton options
---------------------------
+|hpx| configuration options
+---------------------------
 
 .. option:: --hpx:app-config arg
 
diff --git a/docs/sphinx/manual/miscellaneous.rst b/docs/sphinx/manual/miscellaneous.rst
index e968453697..3e0dbf8a87 100644
--- a/docs/sphinx/manual/miscellaneous.rst
+++ b/docs/sphinx/manual/miscellaneous.rst
@@ -15,12 +15,12 @@ Miscellaneous
 Error handling
 ==============
 
-Like in any other asynchronous invocation scheme it is important to be able to
+Like in any other asynchronous invocation scheme, it is important to be able to
 handle error conditions occurring while the asynchronous (and possibly remote)
 operation is executed. In |hpx| all error handling is based on standard C++
 exception handling. Any exception thrown during the execution of an asynchronous
 operation will be transferred back to the original invocation :term:`locality`,
-where it is rethrown during synchronization with the calling thread.
+where it will be rethrown during synchronization with the calling thread.
 
 The source code for this example can be found here:
 :download:`error_handling.cpp <../../examples/quickstart/error_handling.cpp>`.
@@ -30,7 +30,7 @@ The source code for this example can be found here:
 Working with exceptions
 -----------------------
 
-For the following description we assume that the function ``raise_exception()``
+For the following description assume that the function ``raise_exception()``
 is executed by invoking the plain action ``raise_exception_type``.
 
 .. literalinclude:: ../../examples/quickstart/error_handling.cpp
@@ -59,15 +59,15 @@ calling thread tries to wait for the result of the action by invoking either
 
 Additionally, this example demonstrates how an exception thrown by an (possibly
 remote) action can be handled. It shows the use of
-:cpp:func:`hpx::diagnostic_information` which retrieves all available diagnostic
+:cpp:func:`hpx::diagnostic_information`, which retrieves all available diagnostic
 information from the exception as a formatted string. This includes, for
 instance, the name of the source file and line number, the sequence number of
-the OS-thread and the |hpx|-thread id, the :term:`locality` id and the stack
+the OS thread and the |hpx| thread id, the :term:`locality` id and the stack
 backtrace of the point where the original exception was thrown.
 
 Under certain circumstances it is desirable to output only some of the
 diagnostics, or to output those using different formatting. For this case, |hpx|
-exposes a set of lower level functions as demonstrated in the following code
+exposes a set of lower-level functions as demonstrated in the following code
 snippet:
 
 .. literalinclude:: ../../examples/quickstart/error_handling.cpp
@@ -83,7 +83,7 @@ Most of the API functions exposed by |hpx| can be invoked in two different
 modes. By default those will throw an exception on error as described above.
 However, sometimes it is desirable not to throw an exception in case of an error
 condition. In this case an object instance of the :cpp:class:`hpx::error_code`
-type can be passed as the last argument to the API function. In case of an error
+type can be passed as the last argument to the API function. In case of an error,
 the error condition will be returned in that :cpp:class:`hpx::error_code`
 instance. The following example demonstrates extracting the full diagnostic
 information without exception handling:
@@ -100,14 +100,14 @@ information without exception handling:
 This example show how an error can be handled without having to resolve to
 exceptions and that the returned :cpp:class:`hpx::error_code` instance can be
 used in a very similar way as the :cpp:class:`hpx::exception` type above. Simply
-pass it to the :cpp:func:`hpx::diagnostic_information` which retrieves all
+pass it to the :cpp:func:`hpx::diagnostic_information`, which retrieves all
 available diagnostic information from the error code instance as a formatted
 string.
 
 As for handling exceptions, when working with error codes, under certain
 circumstances it is desirable to output only some of the diagnostics, or to
 output those using different formatting. For this case, |hpx| exposes a set of
-lower level functions usable with error codes as demonstrated in the following
+lower-level functions usable with error codes as demonstrated in the following
 code snippet:
 
 .. literalinclude:: ../../examples/quickstart/error_handling.cpp
@@ -132,13 +132,13 @@ Lightweight error codes
 Sometimes it is not desirable to collect all the ambient information about the
 error at the point where it happened as this might impose too much overhead for
 simple scenarios. In this case, |hpx| provides a lightweight error code facility
-which will hold the error code only. The following snippet demonstrates its use:
+that will hold the error code only. The following snippet demonstrates its use:
 
 .. literalinclude:: ../../examples/quickstart/error_handling.cpp
    :language: c++
    :lines: 146-166
 
-All functions which retrieve other diagnostic elements from the
+All functions that retrieve other diagnostic elements from the
 :cpp:class:`hpx::error_code` will fail if called with a lightweight error_code
 instance.
 
@@ -147,9 +147,16 @@ instance.
 Utilities in |hpx|
 ==================
 
-In order to ease the burden of programming in |hpx| we have provided several
+In order to ease the burden of programming, |hpx| provides several
 utilities to users. The following section documents those facilies.
 
+.. _checkpoint:
+
+Checkpoint
+----------
+
+See :ref:`libs_checkpoint`.
+
 .. _iostreams:
 
 The |hpx| I/O-streams component
@@ -169,16 +176,16 @@ from ``hpx::cerr`` will be dispatched to ``std::cerr`` on the console
    ``hpx::endl`` and ``hpx::flush`` but those are just aliases for the
    corresponding standard manipulators.
 
-In order to use either ``hpx::cout`` or ``hpx::cerr`` application codes need to
+In order to use either ``hpx::cout`` or ``hpx::cerr``, application codes need to
 ``#include <hpx/include/iostreams.hpp>``. For an example, please see the
-simplest possible 'Hello world' program as included as an example with |hpx|:
+following 'Hello world' program:
 
 .. literalinclude:: ../../examples/quickstart/hello_world_1.cpp
    :language: c++
 
-Additionally those applications need to link with the iostreams component. When
-using cmake this can be achieved by using the ``COMPONENT_DEPENDENCIES``
-parameter, for instance:
+Additionally, those applications need to link with the iostreams component. When
+using CMake this can be achieved by using the ``COMPONENT_DEPENDENCIES``
+parameter; for instance:
 
 .. code-block:: cmake
 
@@ -194,4 +201,4 @@ parameter, for instance:
 
    The ``hpx::cout`` and ``hpx::cerr`` streams buffer all output locally until a
    ``std::endl`` or ``std::flush`` is encountered. That means that no output
-   will appear on the console as long as either of those is explicitly used.
+   will appear on the console as long as either of these is explicitly used.
diff --git a/docs/sphinx/manual/optimizing_hpx_applications.rst b/docs/sphinx/manual/optimizing_hpx_applications.rst
index adc018bce1..dbd0a3d9ee 100644
--- a/docs/sphinx/manual/optimizing_hpx_applications.rst
+++ b/docs/sphinx/manual/optimizing_hpx_applications.rst
@@ -1021,9 +1021,9 @@ system and application performance.
 
        Please see :ref:`cmake_variables` for more details.
      * If the configure-time option ``-DHPX_WITH_PARCELPORT_ACTION_COUNTERS=On``
-       was specified, this counter allows to specify an optional action name as
-       its parameter. In this case the counter will report the number of bytes
-       transmitted for the given action only.
+       was specified, this counter allows one to specify an optional action name
+       as its parameter. In this case the counter will report the number of
+       bytes transmitted for the given action only.
    * * ``/serialize/time/<connection_type>/<operation>``
 
        where:
@@ -1050,8 +1050,8 @@ system and application performance.
 
        Please see :ref:`cmake_variables` for more details.
      * If the configure-time option ``-DHPX_WITH_PARCELPORT_ACTION_COUNTERS=On``
-       was specified, this counter allows to specify an optional action name as
-       its parameter. In this case the counter will report the serialization
+       was specified, this counter allows one to specify an optional action name
+       as its parameter. In this case the counter will report the serialization
        time for the given action only.
    * * ``/parcels/count/routed``
      * ``locality#*/total``
@@ -1072,9 +1072,9 @@ system and application performance.
        :term:`AGAS` service component will deliver the parcel to its final
        target.
      * If the configure-time option ``-DHPX_WITH_PARCELPORT_ACTION_COUNTERS=On``
-       was specified, this counter allows to specify an optional action name as
-       its parameter. In this case the counter will report the number of parcels
-       for the given action only.
+       was specified, this counter allows one to specify an optional action name
+       as its parameter. In this case the counter will report the number of
+       parcels for the given action only.
    * * ``/parcels/count/<connection_type>/<operation>``
 
        where:
diff --git a/docs/sphinx/manual/writing_distributed_hpx_applications.rst b/docs/sphinx/manual/writing_distributed_hpx_applications.rst
index 371702887a..afc8b95012 100644
--- a/docs/sphinx/manual/writing_distributed_hpx_applications.rst
+++ b/docs/sphinx/manual/writing_distributed_hpx_applications.rst
@@ -1129,7 +1129,7 @@ number of images per :term:`locality` to create::
         bulk_action act;
         std::size_t images_per_locality = 4;
 
-        // Instanciate the parallel section
+        // Instantiate the parallel section
         hpx::lcos::define_spmd_block(
             "some_name", images_per_locality, std::move(act) /*, arg0, arg1, ... */);
 
@@ -1216,7 +1216,7 @@ Here are some examples of using subscripts in the 2-D view case::
     {
         std::size_t height, width;
 
-        // Instanciate the view
+        // Instantiate the view
         View_2D vv(block, v.begin(), v.end(), {height,width});
 
         // The l-value is a view subscript, the image that owns vv(1,0)
@@ -1255,7 +1255,7 @@ Here are some examples of using iterators in the 3-D view case::
     {
         std::size_t sixe_x, size_y, size_z;
 
-        // Instanciate the views
+        // Instantiate the views
         View_3D vv1(block, v1.begin(), v1.end(), {sixe_x,size_y,size_z});
         View_3D vv2(block, v2.begin(), v2.end(), {sixe_x,size_y,size_z});
 
@@ -1310,10 +1310,10 @@ owned by the current image::
     {
         std::size_t num_segments;
 
-        // Instanciate the view
+        // Instantiate the view
         View_1D vv(block, v.begin(), v.end(), {num_segments});
 
-        // Instanciate the local view from the view
+        // Instantiate the local view from the view
         auto local_vv = hpx::local_view(vv);
 
         for ( auto i = localvv.begin(); i != localvv.end(); i++ )
@@ -1327,7 +1327,7 @@ owned by the current image::
 
 .. _sub_views:
 
-Instanciating sub-views
+Instantiating sub-views
 ,,,,,,,,,,,,,,,,,,,,,,,
 
 It is possible to construct views from other views: we call it sub-views. The
@@ -1355,10 +1355,10 @@ sub-view::
         std::size_t N = 20;
         std::size_t tilesize = 5;
 
-        // Instanciate the view
+        // Instantiate the view
         View_2D vv(block, v.begin(), v.end(), {N,N});
 
-        // Instanciate the subview
+        // Instantiate the subview
         View_2D svv(
             block,&vv(tilesize,0),&vv(2*tilesize-1,tilesize-1),{tilesize,tilesize},{N,N});
 
@@ -1397,7 +1397,7 @@ Preface: co-array, a segmented container tied to a SPMD multidimensional views
 As mentioned before, a co-array is a distributed array whose segments are
 accessible through an array-inspired access mode. We have previously seen that
 it is possible to reproduce such access mode using the concept of views.
-Nevertheless, the user must pre-create a segmented container to instanciate this
+Nevertheless, the user must pre-create a segmented container to instantiate this
 view. We illustrate below how a single constructor call can perform those two
 operations::
 
diff --git a/docs/sphinx/quickstart.rst b/docs/sphinx/quickstart.rst
index 463c952a2b..437e74d5f8 100644
--- a/docs/sphinx/quickstart.rst
+++ b/docs/sphinx/quickstart.rst
@@ -157,12 +157,11 @@ build an executable using |cmake|_ and |hpx|:
 
 .. code-block:: cmake
 
-   cmake_minimum_required(VERSION 3.3.2)
+   cmake_minimum_required(VERSION 3.13)
    project(my_hpx_project CXX)
    find_package(HPX REQUIRED)
-   add_hpx_executable(my_hpx_program
-       SOURCES main.cpp
-       COMPONENT_DEPENDENCIES iostreams)
+   add_executable(my_hpx_program main.cpp)
+   target_link_libraries(my_hpx_program HPX::hpx HPX::iostreams_component)
 
 .. note::
 
@@ -172,9 +171,9 @@ build an executable using |cmake|_ and |hpx|:
 
 .. note::
 
-   ``COMPONENT_DEPENDENCIES iostreams`` is optional for a minimal project but
-   lets us use the |hpx| equivalent of ``std::cout``, i.e. the |hpx|
-   :ref:`iostreams` functionality in our application.
+   ``HPX::iostreams_component`` is optional for a minimal project but lets us
+   use the |hpx| equivalent of ``std::cout``, i.e. the |hpx| :ref:`iostreams`
+   functionality in our application.
 
 Create a new project directory and a ``CMakeLists.txt`` with the contents above.
 Also create a ``main.cpp`` with the contents below.
diff --git a/docs/sphinx/releases.rst b/docs/sphinx/releases.rst
index 03c4787f4c..c9aca34dc8 100644
--- a/docs/sphinx/releases.rst
+++ b/docs/sphinx/releases.rst
@@ -14,6 +14,7 @@ Releases
 .. toctree::
    :maxdepth: 1
 
+   releases/whats_new_1_5_0
    releases/whats_new_1_4_1
    releases/whats_new_1_4_0
    releases/whats_new_1_3_0
diff --git a/docs/sphinx/releases/whats_new_0_9_11.rst b/docs/sphinx/releases/whats_new_0_9_11.rst
index eb2be575b1..624e952a87 100644
--- a/docs/sphinx/releases/whats_new_0_9_11.rst
+++ b/docs/sphinx/releases/whats_new_0_9_11.rst
@@ -51,9 +51,9 @@ General changes
   supported by the used compiler.
 * The API for creating instances of components has been consolidated. All
   component instances should be created using the :cpp:func:`hpx::new_` only. It
-  allows to instantiate both, single component instances and multiple component
-  instances. The placement of the created components can be controlled by
-  special distribution policies. Please see the corresponding documentation
+  allows one to instantiate both, single component instances and multiple
+  component instances. The placement of the created components can be controlled
+  by special distribution policies. Please see the corresponding documentation
   outlining the use of :cpp:func:`hpx::new_`.
 * Introduced four new distribution policies which can be used with many API
   functions which traditionally expected to be used with a locality id. The new
@@ -66,7 +66,7 @@ General changes
   * :cpp:class:`hpx::components::binpacking_distribution_policy` which will
     place multiple component instances as evenly as possible based on any
     performance counter.
-  * :cpp:class:`hpx::components::target_distribution_policy` which allows to
+  * :cpp:class:`hpx::components::target_distribution_policy` which allows one to
     represent a given locality in the context of a distrwibution policy.
 * The new distribution policies can now be also used with ``hpx::async``. This
   change also deprecates ``hpx::async_colocated(id, ...)`` which now is replaced
@@ -119,7 +119,7 @@ Breaking changes
   performance benefit when using stackless threads. As such, we decided to clean
   up our codebase. This feature was not documented.
 * The CMake project name has changed from 'hpx' to 'HPX' for consistency and
-  compatibilty with naming conventions and other CMake projects. Generated
+  compatibility with naming conventions and other CMake projects. Generated
   config files go into <prefix>/lib/cmake/HPX and not <prefix>/lib/cmake/hpx.
 * The macro ``HPX_REGISTER_MINIMAL_COMPONENT_FACTORY`` has been deprecated.
   Please use :c:macro:`HPX_REGISTER_COMPONENT`.
@@ -196,7 +196,7 @@ Here is a list of the important tickets we closed for this release.
   implementation
 * :hpx-pr:`1838` - Update version rc1
 * :hpx-pr:`1837` - Removing broken lcos::local::channel
-* :hpx-pr:`1835` - Adding exlicit move constructor and assignment operator to
+* :hpx-pr:`1835` - Adding explicit move constructor and assignment operator to
   hpx::lcos::promise
 * :hpx-pr:`1834` - Making hpx::lcos::promise move-only
 * :hpx-pr:`1833` - Adding fedora docs
@@ -583,7 +583,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-issue:`1481` - Sync primitives safe destruction
 * :hpx-issue:`1480` - Move external/boost/endian into hpx/util
 * :hpx-issue:`1478` - Boost inspect violations
-* :hpx-pr:`1479` - Adds serialization for arrays; some futher/minor fixes
+* :hpx-pr:`1479` - Adds serialization for arrays; some further/minor fixes
 * :hpx-pr:`1477` - Fixing problems with the Intel compiler using a GCC 4.4 std
   library
 * :hpx-pr:`1476` - Adding ``hpx::lcos::latch`` and ``hpx::lcos::local::latch``
diff --git a/docs/sphinx/releases/whats_new_0_9_5.rst b/docs/sphinx/releases/whats_new_0_9_5.rst
index 1c121f597e..7cd788a4c5 100644
--- a/docs/sphinx/releases/whats_new_0_9_5.rst
+++ b/docs/sphinx/releases/whats_new_0_9_5.rst
@@ -160,7 +160,7 @@ HPX' releases so far.
 * :hpx-issue:`545` - ``AUTOGLOB`` broken for add_hpx_component
 * :hpx-issue:`542` - FindHPX_HDF5 still searches multiple times
 * :hpx-issue:`541` - Quotes around application name in hpx::init
-* :hpx-issue:`539` - Race conditition occuring with new lightweight threads
+* :hpx-issue:`539` - Race conditition occurring with new lightweight threads
 * :hpx-issue:`535` - hpx_run_tests.py exits with no error code when tests are
   missing
 * :hpx-issue:`530` - Thread description(<unknown>) in logs
diff --git a/docs/sphinx/releases/whats_new_0_9_6.rst b/docs/sphinx/releases/whats_new_0_9_6.rst
index 6188a186a1..e4b0798178 100644
--- a/docs/sphinx/releases/whats_new_0_9_6.rst
+++ b/docs/sphinx/releases/whats_new_0_9_6.rst
@@ -31,7 +31,7 @@ The major new fetures in this release are:
 * Major efforts have been dedicated to improving the performance counter
   framework, numerous new counters were implemented and new APIs were added.
 * We added a modular parcel compression system allowing to improve bandwidth
-  utilization (by reducing the overall size of the tranferred data).
+  utilization (by reducing the overall size of the transferred data).
 * We added a modular parcel coalescing system allowing to combine several
   parcels into larger messages. This reduces latencies introduced by the
   communication layer.
diff --git a/docs/sphinx/releases/whats_new_0_9_7.rst b/docs/sphinx/releases/whats_new_0_9_7.rst
index 254d881e52..7aedfc81f9 100644
--- a/docs/sphinx/releases/whats_new_0_9_7.rst
+++ b/docs/sphinx/releases/whats_new_0_9_7.rst
@@ -48,7 +48,7 @@ Bug fixes (closed tickets)
 
 Here is a list of the important tickets we closed for this release.
 
-* :hpx-issue:`1005` - Allow to disable array optimizations and zero copy
+* :hpx-issue:`1005` - Allow one to disable array optimizations and zero copy
   optimizations for each parcelport
 * :hpx-issue:`1004` - Generate new HPX logo image for the docs
 * :hpx-issue:`1002` - If MPI parcelport is not available, running HPX under
diff --git a/docs/sphinx/releases/whats_new_0_9_8.rst b/docs/sphinx/releases/whats_new_0_9_8.rst
index f150461271..11c6393197 100644
--- a/docs/sphinx/releases/whats_new_0_9_8.rst
+++ b/docs/sphinx/releases/whats_new_0_9_8.rst
@@ -31,8 +31,8 @@ of using |hpx|:
   programmers know about the concurrency primitives of the standard C++ library
   is still valid in the context of |hpx|.
 * It provides a competitive, high performance implementation of modern,
-  future-proof ideas which gives an smooth migration path from todays mainstream
-  techniques
+  future-proof ideas which gives an smooth migration path from today's
+  mainstream techniques
 * There is no need for the programmer to worry about lower level parallelization
   paradigms like threads or message passing; no need to understand pthreads,
   MPI, OpenMP, or Windows threads, etc.
@@ -115,7 +115,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-issue:`1065` - AGAS cache isn't used/populated on worker localities
 * :hpx-issue:`1064` - Reorder includes to ensure ws2 includes early
 * :hpx-issue:`1063` - Add ``hpx::runtime::suspend`` and ``hpx::runtime::resume``
-* :hpx-issue:`1062` - Fix ``async_continue`` to propery handle return types
+* :hpx-issue:`1062` - Fix ``async_continue`` to properly handle return types
 * :hpx-issue:`1061` - Implement ``async_colocated`` and ``apply_colocated``
 * :hpx-issue:`1060` - Implement minimal component migration
 * :hpx-issue:`1058` - Remove ``HPX_UTIL_TUPLE`` from code base
diff --git a/docs/sphinx/releases/whats_new_0_9_9.rst b/docs/sphinx/releases/whats_new_0_9_9.rst
index 77b94606a4..005d9196af 100644
--- a/docs/sphinx/releases/whats_new_0_9_9.rst
+++ b/docs/sphinx/releases/whats_new_0_9_9.rst
@@ -201,7 +201,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-issue:`1153` - Standard manipulators (like std::endl) do not work with
   hpx::ostream
 * :hpx-issue:`1152` - Functions revamp
-* :hpx-issue:`1151` - Supressing cmake 3.0 policy warning for CMP0026
+* :hpx-issue:`1151` - Suppressing cmake 3.0 policy warning for CMP0026
 * :hpx-issue:`1150` - Client Serialization error
 * :hpx-issue:`1149` - Segfault on Stampede
 * :hpx-issue:`1148` - Refactoring mini-ghost
diff --git a/docs/sphinx/releases/whats_new_0_9_99.rst b/docs/sphinx/releases/whats_new_0_9_99.rst
index 82e9faa589..721f3d039c 100644
--- a/docs/sphinx/releases/whats_new_0_9_99.rst
+++ b/docs/sphinx/releases/whats_new_0_9_99.rst
@@ -498,7 +498,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-pr:`1927` - Using ninja for circle-ci builds
 * :hpx-pr:`1926` - Fixing serialization of std::array
 * :hpx-issue:`1925` - Issues with static HPX libraries
-* :hpx-issue:`1924` - Peformance degrading over time
+* :hpx-issue:`1924` - Performance degrading over time
 * :hpx-issue:`1923` - serialization of std::array appears broken in latest
   commit
 * :hpx-pr:`1922` - Container algorithms
diff --git a/docs/sphinx/releases/whats_new_1_0_0.rst b/docs/sphinx/releases/whats_new_1_0_0.rst
index d1224deecb..b575079823 100644
--- a/docs/sphinx/releases/whats_new_1_0_0.rst
+++ b/docs/sphinx/releases/whats_new_1_0_0.rst
@@ -17,10 +17,10 @@ General changes
 Here are some of the main highlights and changes for this release (in no
 particular order):
 
-* Added the facility ``hpx::split_future`` which allows to convert a
+* Added the facility ``hpx::split_future`` which allows one to convert a
   ``future<tuple<Ts...>>`` into a ``tuple<future<Ts>...>``. This functionality
   is not available when compiling |hpx| with VS2012.
-* Added a new type of performance counter which allows to return a list of
+* Added a new type of performance counter which allows one to return a list of
   values for each invocation. We also added a first counter of this type which
   collects a histogram of the times between parcels being created.
 * Added new LCOs: ``hpx::lcos::channel`` and ``hpx::lcos::local::channel`` which
@@ -67,8 +67,8 @@ particular order):
   those.
 * We have consolidated all of the code in HPX.Compute related to the integration
   of CUDA. ``hpx::partitioned_vector`` has been enabled to be usable with
-  ``hpx::compute::vector`` which allows to place the partitions on one or more
-  GPU devices.
+  ``hpx::compute::vector`` which allows one to place the partitions on one or
+  more GPU devices.
 * Added new performance counters exposing various internals of the thread
   scheduling subsystem, such as the current idle- and busy-loop counters and
   instantaneous scheduler utilization.
@@ -109,7 +109,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-pr:`2588` - Daint fixes
 * :hpx-pr:`2587` - Fixing transfer_(continuation)_action::schedule
 * :hpx-pr:`2585` - Work around MSVC having an ICE when compiling with -Ob2
-* :hpx-pr:`2583` - chaning 7zip command to 7za in roll_release.sh
+* :hpx-pr:`2583` - changing 7zip command to 7za in roll_release.sh
 * :hpx-pr:`2582` - First attempt to introduce spmd_block in hpx
 * :hpx-pr:`2581` - Enable annotated function for parallel algorithms
 * :hpx-pr:`2580` - First attempt to introduce spmd_block in hpx
diff --git a/docs/sphinx/releases/whats_new_1_1_0.rst b/docs/sphinx/releases/whats_new_1_1_0.rst
index 6ed4a70aea..2bb2b9a728 100644
--- a/docs/sphinx/releases/whats_new_1_1_0.rst
+++ b/docs/sphinx/releases/whats_new_1_1_0.rst
@@ -60,7 +60,7 @@ particular order):
   parallel algorithms was supporting input iterators (and output iterators) as
   well by simply falling back to sequential execution. We have now made our
   implementations conforming by requiring at least forward iterators. In order
-  to enable the old behavior use the the compatibility option
+  to enable the old behavior use the compatibility option
   ``-DHPX_WITH_ALGORITHM_INPUT_ITERATOR_SUPPORT=On`` on the |cmake|_ command
   line.
 * We have added the functionalities allowing for LCOs being implemented using
@@ -69,9 +69,9 @@ particular order):
 * User defined components don't have to be default-constructible anymore. Return
   types from actions don't have to be default-constructible anymore either. Our
   serialization layer now in general supports non-default-constructible types.
-* We have added a new launch policy ``hpx::launch::lazy`` that allows to defer
-  the decision on what launch policy to use to the point of execution. This
-  policy is initialized with a function (object) that -- when invoked -- is
+* We have added a new launch policy ``hpx::launch::lazy`` that allows oneto
+  defer the decision on what launch policy to use to the point of execution.
+  This policy is initialized with a function (object) that -- when invoked -- is
   expected to produce the desired launch policy.
 
 Breaking changes
@@ -120,7 +120,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-pr:`3245` - Apex refactoring with guids
 * :hpx-pr:`3242` - Modify task counting in thread_queue.hpp
 * :hpx-pr:`3240` - Fixed typos
-* :hpx-pr:`3238` - Readding accidently removed std::abort
+* :hpx-pr:`3238` - Readding accidentally removed std::abort
 * :hpx-pr:`3237` - Adding Pipeline example
 * :hpx-pr:`3236` - Fixing memory_block
 * :hpx-pr:`3233` - Make schedule_thread take suspended threads into account
@@ -470,7 +470,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-pr:`2909` - Fix typo in include path
 * :hpx-pr:`2908` - Use proper container according to iterator tag in benchmarks
   of parallel algorithms
-* :hpx-pr:`2907` - Optionaly force-delete remaining channel items on close
+* :hpx-pr:`2907` - Optionally force-delete remaining channel items on close
 * :hpx-pr:`2906` - Making sure generated performance counter names are correct
 * :hpx-issue:`2905` - collecting idle-rate performance counters on multiple
   localities produces an error
@@ -513,7 +513,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-pr:`2870` - Disambiguate use of base_lco_with_value macros with channel
 * :hpx-issue:`2869` - Difficulty compiling
   ``HPX_REGISTER_CHANNEL_DECLARATION(double)``
-* :hpx-pr:`2868` - Removing uneeded assert
+* :hpx-pr:`2868` - Removing unneeded assert
 * :hpx-pr:`2867` - Implement parallel::unique
 * :hpx-issue:`2866` - The chunk_size_iterator violates multipass guarantee
 * :hpx-pr:`2865` - Only use sched_getcpu on linux machines
@@ -651,7 +651,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-issue:`2746` - HPX segfaulting with valgrind
 * :hpx-pr:`2745` - Adding extended arithmetic performance counters
 * :hpx-pr:`2744` - Adding ability to statistics counters to reset base counter
-* :hpx-issue:`2743` - Statistics counter does not support reseting
+* :hpx-issue:`2743` - Statistics counter does not support resetting
 * :hpx-pr:`2742` - Making sure Vc V2 builds without additional HPX configuration
   flags
 * :hpx-pr:`2741` - Deprecate unwrapped and implement unwrap and unwrapping
@@ -660,7 +660,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-pr:`2739` - Add files via upload
 * :hpx-pr:`2738` - Appveyor support
 * :hpx-pr:`2737` - Fixing 2735
-* :hpx-issue:`2736` - 1d_hydro example does't work
+* :hpx-issue:`2736` - 1d_hydro example doesn't work
 * :hpx-issue:`2735` - partitioned_vector_subview test failing
 * :hpx-pr:`2734` - Add C++11 range utilities
 * :hpx-pr:`2733` - Adapting iterator requirements for parallel algorithms
@@ -735,7 +735,7 @@ Here is a list of the important tickets we closed for this release.
 * :hpx-pr:`2672` - C++17 invoke forms
 * :hpx-pr:`2671` - Adding uninitialized_value_construct and
   uninitialized_value_construct_n
-* :hpx-pr:`2670` - Integrate spmd multidimensionnal views for
+* :hpx-pr:`2670` - Integrate spmd multidimensional views for
   partitioned_vectors
 * :hpx-pr:`2669` - Adding uninitialized_default_construct and
   uninitialized_default_construct_n
@@ -763,7 +763,7 @@ Here is a list of the important tickets we closed for this release.
   properly handled
 * :hpx-pr:`2649` - Update docs (Table 18) - move transform to end
 * :hpx-issue:`2647` - hpx::parcelset::detail::parcel_data::has_continuation_ is
-  unitialized
+  uninitialized
 * :hpx-issue:`2644` - Some .vcxproj in the HPX.sln fail to build
 * :hpx-issue:`2641` - ``hpx::lcos::queue`` should be deprecated
 * :hpx-pr:`2640` - A new throttling policy with public APIs to suspend/resume
diff --git a/docs/sphinx/releases/whats_new_1_2_0.rst b/docs/sphinx/releases/whats_new_1_2_0.rst
index 41a524d68d..68af2b4145 100644
--- a/docs/sphinx/releases/whats_new_1_2_0.rst
+++ b/docs/sphinx/releases/whats_new_1_2_0.rst
@@ -181,7 +181,7 @@ Closed pull requests
 * :hpx-pr:`3485` - Use BUILD_INTERFACE generator expression to fix cmake flag exports
 * :hpx-pr:`3483` - Fixing type attribute warning for transfer_action
 * :hpx-pr:`3481` - Remove unused variables
-* :hpx-pr:`3480` - Towards a more lightweigh transfer action
+* :hpx-pr:`3480` - Towards a more lightweight transfer action
 * :hpx-pr:`3479` - Fix FLAGS - Use correct version of target_compile_options
 * :hpx-pr:`3478` - Making sure the application's exit code is properly propagated back to the OS
 * :hpx-pr:`3476` - Don't print docker credentials as part of the environment.
@@ -231,7 +231,7 @@ Closed pull requests
 * :hpx-pr:`3407` - Fix unused param and extra ; warnings emitted by gcc 8.x
 * :hpx-pr:`3406` - Adding thread local allocator and use it for future shared states
 * :hpx-pr:`3405` - Adding DHPX_HAVE_THREAD_LOCAL_STORAGE=ON to builds
-* :hpx-pr:`3404` - fixing multiple difinition of main() in linux
+* :hpx-pr:`3404` - fixing multiple definition of main() in linux
 * :hpx-pr:`3402` - Allow debug option to be enabled only for Linux systems with dynamic main on
 * :hpx-pr:`3401` - Fix cuda_future_helper.h when compiling with C++11
 * :hpx-pr:`3400` - Fix floating point exception scheduler_base idle backoff
diff --git a/docs/sphinx/releases/whats_new_1_3_0.rst b/docs/sphinx/releases/whats_new_1_3_0.rst
index 71f1b4adcf..0d77131bc4 100644
--- a/docs/sphinx/releases/whats_new_1_3_0.rst
+++ b/docs/sphinx/releases/whats_new_1_3_0.rst
@@ -97,7 +97,7 @@ Closed issues
 * :hpx-issue:`3676` - HPX master built from source, cmake fails to link main.cpp
   example in docs
 * :hpx-issue:`3673` - HPX build fails with ``std::atomic`` missing error
-* :hpx-issue:`3670` - Generate PDF again from documention (with Sphinx)
+* :hpx-issue:`3670` - Generate PDF again from documentation (with Sphinx)
 * :hpx-issue:`3643` - Warnings when compiling HPX 1.2.1 with gcc 9
 * :hpx-issue:`3641` - Trouble with using ranges-v3 and ``hpx::parallel::reduce``
 * :hpx-issue:`3639` - ``util::unwrapping`` does not work well with member
@@ -108,7 +108,7 @@ Closed issues
 * :hpx-issue:`3616` - HPX Fails to Build with CUDA 10
 * :hpx-issue:`3612` - False sharing of scheduling counters
 * :hpx-issue:`3609` - executor_parameters timeout with gcc <= 7 and Debug mode
-* :hpx-issue:`3601` - Missleading error message on power pc for rdtsc and rdtscp
+* :hpx-issue:`3601` - Misleading error message on power pc for rdtsc and rdtscp
 * :hpx-issue:`3598` - Build of some examples fails when using Vc
 * :hpx-issue:`3594` - Error: The number of OS threads requested (20) does not
   match the number of threads to bind (12): HPX(bad_parameter)
@@ -290,8 +290,8 @@ Closed pull requests
 * :hpx-pr:`3685` - Revise quickstart CMakeLists.txt explanation
 * :hpx-pr:`3684` - Provide concept emulation for Ranges-TS concepts
 * :hpx-pr:`3683` - Ignore uninitialized chunks
-* :hpx-pr:`3682` - Ignore unitialized chunks. Check proper indices.
-* :hpx-pr:`3680` - Ignore unitialized chunks. Check proper range indices
+* :hpx-pr:`3682` - Ignore uninitialized chunks. Check proper indices.
+* :hpx-pr:`3680` - Ignore uninitialized chunks. Check proper range indices
 * :hpx-pr:`3679` - Simplify basic action implementations
 * :hpx-pr:`3678` - Making sure ``HPX_HAVE_LIBATOMIC`` is unset before checking
 * :hpx-pr:`3677` - Fix generated full version number to be usable in expressions
@@ -344,7 +344,7 @@ Closed pull requests
 * :hpx-pr:`3610` - Don't wait for ``stop_condition`` in main thread
 * :hpx-pr:`3608` - Add inline keyword to ``invalid_thread_id`` definition for
   nvcc
-* :hpx-pr:`3607` - Adding configuration key that allows to explicitly add a
+* :hpx-pr:`3607` - Adding configuration key that allows one to explicitly add a
   directory to the component search path
 * :hpx-pr:`3606` - Add nvcc to exclude constexpress since is it not supported by
   nvcc
diff --git a/docs/sphinx/releases/whats_new_1_4_0.rst b/docs/sphinx/releases/whats_new_1_4_0.rst
index 05a0e2553c..d0aac34d1c 100644
--- a/docs/sphinx/releases/whats_new_1_4_0.rst
+++ b/docs/sphinx/releases/whats_new_1_4_0.rst
@@ -115,7 +115,7 @@ Closed issues
   ``invalid_thread_id``
 * :hpx-issue:`4151` - build error with MPI code
 * :hpx-issue:`4150` - hpx won't build on POWER9 with clang 8
-* :hpx-issue:`4148` - ``cacheline_data`` delivers poor perfomance with C++17
+* :hpx-issue:`4148` - ``cacheline_data`` delivers poor performance with C++17
   compared to C++14
 * :hpx-issue:`4144` - target general in ``HPX_LIBRARIES`` does not exist
 * :hpx-issue:`4134` - CMake Error when ``-DHPX_WITH_HPXMP=ON``
@@ -184,7 +184,7 @@ Closed pull requests
 * :hpx-pr:`4272` - Fix pushing of documentation
 * :hpx-pr:`4271` - Updating APEX tag, don't create new task_wrapper on
   ``operator=`` of hpx_thread object
-* :hpx-pr:`4268` - Testing for noexcept function specializations in in C++11/14
+* :hpx-pr:`4268` - Testing for noexcept function specializations in C++11/14
   mode
 * :hpx-pr:`4267` - Fixing MSVC warning
 * :hpx-pr:`4266` - Make sure macOS Travis CI fails if build step fails
@@ -201,7 +201,7 @@ Closed pull requests
 * :hpx-pr:`4253` - Move ``partlit.hpp`` to affinity module
 * :hpx-pr:`4252` - Make mismatching build types a hard error in CMake
 * :hpx-pr:`4249` - Scheduler improvement
-* :hpx-pr:`4248` - update hpxmp tage to v0.3.0
+* :hpx-pr:`4248` - update hpxmp tag to v0.3.0
 * :hpx-pr:`4245` - Adding high performance channels
 * :hpx-pr:`4244` - Ignore lock in ignore_while_locked_1485 test
 * :hpx-pr:`4243` - Fix PAPI command line option documentation
@@ -422,7 +422,7 @@ Closed pull requests
 * :hpx-pr:`3996` - Attempt to solve issue where ``-latomic`` does not support
   128bit atomics
 * :hpx-pr:`3993` - Make sure ``__LINE__`` is an unsigned
-* :hpx-pr:`3991` - Fix dependencies and flags for for header tests
+* :hpx-pr:`3991` - Fix dependencies and flags for header tests
 * :hpx-pr:`3990` - Documentation tags fixes
 * :hpx-pr:`3988` - Adding missing solution folder for format module test
 * :hpx-pr:`3987` - Move runtime-dependent functions out of command line handling
@@ -513,8 +513,8 @@ Closed pull requests
 * :hpx-pr:`3877` - Documentation
 * :hpx-pr:`3876` - Module hardware
 * :hpx-pr:`3875` - Converted typedefs in actions submodule to using directives
-* :hpx-pr:`3874` - Allow to suppress target keywords in ``hpx_setup_target`` for
-  backwards compatibility
+* :hpx-pr:`3874` - Allow one to suppress target keywords in ``hpx_setup_target``
+  for backwards compatibility
 * :hpx-pr:`3873` - Add scripts to create releases and generate lists of PRs and
   issues
 * :hpx-pr:`3872` - Fix latest HTML docs location
diff --git a/docs/sphinx/releases/whats_new_1_4_1.rst b/docs/sphinx/releases/whats_new_1_4_1.rst
index b89335ae44..d3ea227b4b 100644
--- a/docs/sphinx/releases/whats_new_1_4_1.rst
+++ b/docs/sphinx/releases/whats_new_1_4_1.rst
@@ -8,7 +8,7 @@
 .. _hpx_1_4_1:
 
 ===========================
-|hpx| V1.4.1 (Feb 19, 2020)
+|hpx| V1.4.1 (Feb 12, 2020)
 ===========================
 
 General changes
@@ -21,11 +21,6 @@ This is a bugfix release. It contains the following changes:
 * Allow running tests using an installed version of |hpx|
 * Skip MPI finalization if HPX has not initialized MPI
 * Give a hard error when attempting to use IO counters on Windows
-* Fix |cmake| configuration using older |cmake| versions with CUDA enabled
-* Fix installation of pkgconfig files when build type is typed in unexpected
-  case
-* Add ``jsrun`` option to ``hpxrun.py``
-* Fix cases of scheduling hints not being taken into account
 
 Closed issues
 =============
@@ -42,8 +37,6 @@ Closed issues
 Closed pull requests
 ====================
 
-* :hpx-pr:`4396` - Relax build type matching when generating pkgconfig files
-* :hpx-pr:`4389` - Add jsrun in hpx run wrapper
 * :hpx-pr:`4376` - Attempt to fix some test build errors on Windows
 * :hpx-pr:`4357` - Adding missing ``#include``\ s to fix gcc V10 linker problems
 * :hpx-pr:`4353` - Skip ``MPI_Finalize`` if ``MPI_Init`` is not called from HPX
@@ -55,4 +48,3 @@ Closed pull requests
 * :hpx-pr:`4315` - Forcing exported symbols from composable_guard to be linked
   into core library
 * :hpx-pr:`4310` - Remove environment handling from ``exception.cpp``
-* :hpx-pr:`4306` - Fix schedule hint not being taken from executor
diff --git a/docs/sphinx/releases/whats_new_1_5_0.rst b/docs/sphinx/releases/whats_new_1_5_0.rst
new file mode 100644
index 0000000000..d2c1a133e7
--- /dev/null
+++ b/docs/sphinx/releases/whats_new_1_5_0.rst
@@ -0,0 +1,24 @@
+..
+    Copyright (C) 2007-2020 Hartmut Kaiser
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _hpx_1_5_0:
+
+===========================
+|hpx| V1.5.0 (TBD)
+===========================
+
+General changes
+===============
+
+
+Closed issues
+=============
+
+
+Closed pull requests
+====================
+
diff --git a/examples/1d_stencil/1d_stencil_4_parallel.cpp b/examples/1d_stencil/1d_stencil_4_parallel.cpp
index 4d3e7f2932..89af67a9a5 100644
--- a/examples/1d_stencil/1d_stencil_4_parallel.cpp
+++ b/examples/1d_stencil/1d_stencil_4_parallel.cpp
@@ -17,8 +17,7 @@
 #include <hpx/hpx_init.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/include/parallel_algorithm.hpp>
-
-#include <boost/iterator/counting_iterator.hpp>
+#include <hpx/iterator_support.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -98,7 +97,7 @@ struct stepper
         std::size_t size = middle.size();
         partition_data next(size);
 
-        typedef boost::counting_iterator<std::size_t> iterator;
+        typedef hpx::util::counting_iterator<std::size_t> iterator;
 
         next[0] = heat(left[size-1], middle[0], middle[1]);
 
@@ -140,7 +139,7 @@ struct stepper
             space const& current = U[t % 2];
             space& next = U[(t + 1) % 2];
 
-            typedef boost::counting_iterator<std::size_t> iterator;
+            typedef hpx::util::counting_iterator<std::size_t> iterator;
 
             for_each(par, iterator(0), iterator(np),
                 [&next, &current, np, &Op](std::size_t i)
diff --git a/examples/1d_stencil/CMakeLists.txt b/examples/1d_stencil/CMakeLists.txt
index 4b9d4ee666..ca63967428 100644
--- a/examples/1d_stencil/CMakeLists.txt
+++ b/examples/1d_stencil/CMakeLists.txt
@@ -57,6 +57,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/1D Stencil/${example_program}")
diff --git a/examples/accumulators/CMakeLists.txt b/examples/accumulators/CMakeLists.txt
index 4d328ccc03..17edeb35f7 100644
--- a/examples/accumulators/CMakeLists.txt
+++ b/examples/accumulators/CMakeLists.txt
@@ -23,12 +23,14 @@ foreach(example_program ${example_programs})
 
   # add example components
   add_hpx_component(${example_program}
+    INTERNAL_FLAGS
     SOURCES ${component_sources}
     HEADERS ${component_headers}
     FOLDER "Examples/Quickstart/Accumulators/${example_program}")
 
   # add example executable
   add_hpx_executable(${example_program}
+    INTERNAL_FLAGS
     SOURCES ${client_sources}
     DEPENDENCIES ${example_program}_component
     FOLDER "Examples/Quickstart/Accumulators/${example_program}")
diff --git a/examples/accumulators/accumulator_client.cpp b/examples/accumulators/accumulator_client.cpp
index d216b8f60b..9fd5376148 100644
--- a/examples/accumulators/accumulator_client.cpp
+++ b/examples/accumulators/accumulator_client.cpp
@@ -7,14 +7,13 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/hpx_init.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/string_util/trim.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include "accumulator.hpp"
 
-#include <boost/lexical_cast.hpp>
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/trim.hpp>
-#include <boost/algorithm/string/classification.hpp>
-
 #include <iostream>
 #include <string>
 #include <vector>
@@ -44,12 +43,12 @@ int hpx_main()
         std::string line;
         while (std::getline(std::cin, line))
         {
-            boost::algorithm::trim(line);
+            hpx::string_util::trim(line);
 
             std::vector<std::string> cmd;
-            boost::algorithm::split(cmd, line,
-                boost::algorithm::is_any_of(" \t\n"),
-                boost::algorithm::token_compress_on);
+            hpx::string_util::split(cmd, line,
+                hpx::string_util::is_any_of(" \t\n"),
+                hpx::string_util::token_compress_mode::on);
 
             if (!cmd.empty() && !cmd[0].empty())
             {
@@ -59,7 +58,7 @@ int hpx_main()
                 }
                 else if (cmd[0] == "add") {
                     if (cmd.size() == 2) {
-                        accu.add(boost::lexical_cast<argument_type>(cmd[1]));
+                        accu.add(hpx::util::from_string<argument_type>(cmd[1]));
                     }
                     else {
                         std::cout << "error: invalid command '"
diff --git a/examples/accumulators/server/template_function_accumulator.hpp b/examples/accumulators/server/template_function_accumulator.hpp
index 07fbeeb536..9948c67bde 100644
--- a/examples/accumulators/server/template_function_accumulator.hpp
+++ b/examples/accumulators/server/template_function_accumulator.hpp
@@ -12,8 +12,6 @@
 #include <hpx/include/components.hpp>
 #include <hpx/include/local_lcos.hpp>
 
-#include <boost/lexical_cast.hpp>
-
 #include <mutex>
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -64,7 +62,7 @@ namespace examples { namespace server
         {
             // Atomically add value_ to arg, and store the result in value_.
             std::lock_guard<mutex_type> l(mtx_);
-            value_ += boost::lexical_cast<double>(arg);
+            value_ += static_cast<double>(arg);
         }
 
         /// Return the current value to the caller.
diff --git a/examples/accumulators/template_accumulator_client.cpp b/examples/accumulators/template_accumulator_client.cpp
index 256bf6a308..6c07cbe21e 100644
--- a/examples/accumulators/template_accumulator_client.cpp
+++ b/examples/accumulators/template_accumulator_client.cpp
@@ -5,14 +5,13 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/hpx_init.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/string_util/trim.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include "template_accumulator.hpp"
 
-#include <boost/lexical_cast.hpp>
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/trim.hpp>
-#include <boost/algorithm/string/classification.hpp>
-
 #include <iostream>
 #include <string>
 #include <vector>
@@ -49,12 +48,12 @@ void run_template_accumulator(char const* type)
     std::string line;
     while (std::getline(std::cin, line))
     {
-        boost::algorithm::trim(line);
+        hpx::string_util::trim(line);
 
         std::vector<std::string> cmd;
-        boost::algorithm::split(cmd, line,
-            boost::algorithm::is_any_of(" \t\n"),
-            boost::algorithm::token_compress_on);
+        hpx::string_util::split(cmd, line,
+            hpx::string_util::is_any_of(" \t\n"),
+            hpx::string_util::token_compress_mode::on);
 
         if (!cmd.empty() && !cmd[0].empty())
         {
@@ -65,10 +64,10 @@ void run_template_accumulator(char const* type)
             else if (cmd[0] == "add") {
                 if (cmd.size() == 2) {
                     try {
-                        double val = boost::lexical_cast<double>(cmd[1]);
+                        double val = hpx::util::from_string<double>(cmd[1]);
                         accu.add(argument_type(val));
                     }
-                    catch (boost::bad_lexical_cast const&) {
+                    catch (hpx::util::bad_lexical_cast const&) {
                         std::cout << "error: invalid argument for add: '"
                                     << cmd[1] << "'" << std::endl;
                     }
diff --git a/examples/accumulators/template_function_accumulator_client.cpp b/examples/accumulators/template_function_accumulator_client.cpp
index e69b364ec9..5d83629aab 100644
--- a/examples/accumulators/template_function_accumulator_client.cpp
+++ b/examples/accumulators/template_function_accumulator_client.cpp
@@ -7,14 +7,13 @@
 
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/actions.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/string_util/trim.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include "template_function_accumulator.hpp"
 
-#include <boost/lexical_cast.hpp>
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/trim.hpp>
-#include <boost/algorithm/string/classification.hpp>
-
 #include <iostream>
 #include <string>
 #include <vector>
@@ -49,11 +48,11 @@ int hpx_main()
         {
             std::vector<std::string> cmd;
 
-            boost::algorithm::trim(line);
+            hpx::string_util::trim(line);
 
-            boost::algorithm::split(cmd, line,
-                boost::algorithm::is_any_of(" \t\n"),
-                boost::algorithm::token_compress_on);
+            hpx::string_util::split(cmd, line,
+                hpx::string_util::is_any_of(" \t\n"),
+                hpx::string_util::token_compress_mode::on);
 
             if (!cmd.empty() && !cmd[0].empty())
             {
@@ -67,7 +66,7 @@ int hpx_main()
                                   << line << "'" << std::endl
                                   << help << std::endl;
                     else
-                        accu.add(boost::lexical_cast<int>(cmd[1]));
+                        accu.add(hpx::util::from_string<int>(cmd[1]));
                 }
 
                 else if (cmd[0] == "addfloat")
@@ -77,7 +76,7 @@ int hpx_main()
                                   << line << "'" << std::endl
                                   << help << std::endl;
                     else
-                        accu.add(boost::lexical_cast<double>(cmd[1]));
+                        accu.add(hpx::util::from_string<double>(cmd[1]));
                 }
 
                 else if (cmd[0] == "query")
diff --git a/examples/apex/CMakeLists.txt b/examples/apex/CMakeLists.txt
index 3c5da6bd44..c505ecfe76 100644
--- a/examples/apex/CMakeLists.txt
+++ b/examples/apex/CMakeLists.txt
@@ -23,6 +23,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/Apex/${example_program}")
diff --git a/examples/async_io/CMakeLists.txt b/examples/async_io/CMakeLists.txt
index 80dee1fab7..e8fc388a38 100644
--- a/examples/async_io/CMakeLists.txt
+++ b/examples/async_io/CMakeLists.txt
@@ -25,6 +25,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/AsyncIO/${example_program}")
diff --git a/examples/async_io/async_io_low_level.cpp b/examples/async_io/async_io_low_level.cpp
index 558f81fd11..ae10f3e1a9 100644
--- a/examples/async_io/async_io_low_level.cpp
+++ b/examples/async_io/async_io_low_level.cpp
@@ -12,7 +12,7 @@
 #include <hpx/include/runtime.hpp>
 #include <hpx/include/iostreams.hpp>
 #include <hpx/include/util.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 
 #include <iostream>
 #include <memory>
diff --git a/examples/async_io/async_io_simple.cpp b/examples/async_io/async_io_simple.cpp
index 70ad3ed83c..a879965ec2 100644
--- a/examples/async_io/async_io_simple.cpp
+++ b/examples/async_io/async_io_simple.cpp
@@ -41,8 +41,8 @@ int async_io(char const* string_to_write)
 
     // Note that the destructor of the scheduler object will wait for
     // the scheduled task to finish executing. This might be
-    // undesireable, in which case the technique demonstrated in
-    // the example async_io_low_level.cpp is preferrable.
+    // undesirable, in which case the technique demonstrated in
+    // the example async_io_low_level.cpp is preferable.
     }
 
     return result;   // this will be executed only after result has been set
diff --git a/examples/balancing/CMakeLists.txt b/examples/balancing/CMakeLists.txt
index 7bbca466df..57459c2e9b 100644
--- a/examples/balancing/CMakeLists.txt
+++ b/examples/balancing/CMakeLists.txt
@@ -20,6 +20,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/Balancing/${example_program}")
diff --git a/examples/balancing/hpx_thread_phase.cpp b/examples/balancing/hpx_thread_phase.cpp
index 4c0d027278..8fae4bbd44 100644
--- a/examples/balancing/hpx_thread_phase.cpp
+++ b/examples/balancing/hpx_thread_phase.cpp
@@ -6,7 +6,7 @@
 
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/synchronization/barrier.hpp>
 #include <hpx/synchronization/mutex.hpp>
 #include <hpx/functional/bind.hpp>
diff --git a/examples/cancelable_action/CMakeLists.txt b/examples/cancelable_action/CMakeLists.txt
index d56b33a0f4..4a297417f8 100644
--- a/examples/cancelable_action/CMakeLists.txt
+++ b/examples/cancelable_action/CMakeLists.txt
@@ -14,6 +14,7 @@ source_group("Source Files" FILES ${sources})
 
 # add example executable
 add_hpx_executable(cancelable_action_client
+    INTERNAL_FLAGS
     SOURCES ${sources}
     DEPENDENCIES cancelable_action_component
     FOLDER "Examples/CancelableAction")
diff --git a/examples/cancelable_action/cancelable_action/CMakeLists.txt b/examples/cancelable_action/cancelable_action/CMakeLists.txt
index 81e2ab5363..d67db3ac13 100644
--- a/examples/cancelable_action/cancelable_action/CMakeLists.txt
+++ b/examples/cancelable_action/cancelable_action/CMakeLists.txt
@@ -5,6 +5,7 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 add_hpx_component(cancelable_action
+    INTERNAL_FLAGS
     AUTOGLOB
     HEADER_GLOB "cancelable_action.h*"
     SOURCE_GLOB "cancelable_action.c*"
diff --git a/examples/future_reduce/CMakeLists.txt b/examples/future_reduce/CMakeLists.txt
index a7f9919f06..47c117052a 100644
--- a/examples/future_reduce/CMakeLists.txt
+++ b/examples/future_reduce/CMakeLists.txt
@@ -5,15 +5,10 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 set(example_programs
-   )
+    rnd_future_reduce)
 
-if(HPX_HAVE_CXX11_STD_RANDOM)
-  set(example_programs
-      ${example_programs}
-      rnd_future_reduce)
-  set(rnd_future_reduce_FLAGS DEPENDENCIES iostreams_component)
-  set(rnd_future_reduce_PARAMETERS THREADS_PER_LOCALITY 4)
-endif()
+set(rnd_future_reduce_FLAGS DEPENDENCIES iostreams_component)
+set(rnd_future_reduce_PARAMETERS THREADS_PER_LOCALITY 4)
 
 foreach(example_program ${example_programs})
   set(sources
@@ -23,6 +18,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/FutureReduce")
diff --git a/examples/heartbeat/CMakeLists.txt b/examples/heartbeat/CMakeLists.txt
index aff4f536b3..6f9220bbd3 100644
--- a/examples/heartbeat/CMakeLists.txt
+++ b/examples/heartbeat/CMakeLists.txt
@@ -24,6 +24,7 @@ if(MSVC)
 endif()
 
 add_hpx_executable(heartbeat
+                   INTERNAL_FLAGS
                    SOURCES ${heartbeat_SOURCES}
                    HEADERS ${heartbeat_HEADERS}
                    FOLDER "Examples/HeartBeat"
@@ -34,6 +35,7 @@ add_hpx_pseudo_dependencies(examples.heartbeat heartbeat)
 
 ###############################################################################
 add_hpx_executable(heartbeat_console
+                   INTERNAL_FLAGS
                    SOURCES heartbeat_console.cpp
                    FOLDER "Examples/HeartBeat"
                    DEPENDENCIES iostreams_component)
diff --git a/examples/heartbeat/heartbeat.cpp b/examples/heartbeat/heartbeat.cpp
index 698afd3b6d..0c29337d99 100644
--- a/examples/heartbeat/heartbeat.cpp
+++ b/examples/heartbeat/heartbeat.cpp
@@ -12,7 +12,7 @@
 #include <hpx/include/performance_counters.hpp>
 #include <hpx/include/lcos.hpp>
 #include <hpx/runtime/actions/plain_action.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/state.hpp>
 #include <hpx/format.hpp>
@@ -87,11 +87,9 @@ int monitor(double runfor, std::string const& name, std::uint64_t pause)
             if (!zero_time)
                 zero_time = value.time_;
 
-            hpx::util::format_to(std::cout,
-                "  {},{},{}[s],{}\n",
-                name,
+            hpx::util::format_to(std::cout, "  {},{},{}[s],{}\n", name,
                 value.count_,
-                double((value.time_ - zero_time) * 1e-9),
+                double(static_cast<double>(value.time_ - zero_time) * 1e-9),
                 value.value_);
 
 #if defined(HPX_WINDOWS) && HPX_USE_WINDOWS_PERFORMANCE_COUNTERS != 0
diff --git a/examples/hello_world_component/CMakeLists.txt b/examples/hello_world_component/CMakeLists.txt
index 0bdf6b546e..f3c2c4fff5 100644
--- a/examples/hello_world_component/CMakeLists.txt
+++ b/examples/hello_world_component/CMakeLists.txt
@@ -4,31 +4,34 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2)
+cmake_minimum_required(VERSION 3.13)
 
 project(hello_world_client CXX)
 
 if(EXISTS "${HPX_DIR}")
-
   find_package(HPX REQUIRED)
 
-  if(NOT HPX_FOUND)
-    message(FATAL_ERROR "HPX could not be found")
-  endif()
-
   add_library(hello_world_component SHARED hello_world_component.cpp)
-  hpx_setup_target(
-    hello_world_component
-    DEPENDENCIES iostreams_component
-    TYPE COMPONENT
-  )
 
   add_executable(hello_world_client hello_world_client.cpp)
   target_include_directories(hello_world_client PRIVATE ${test_SOURCE_DIR})
-  target_compile_definitions(hello_world_client PUBLIC -DHPX_DEBUG)
-  hpx_setup_target(hello_world_client
-    DEPENDENCIES hello_world_component
-    )
+  target_include_directories(hello_world_client PRIVATE HPX_DEBUG)
+
+  if("${SETUP_TYPE}" STREQUAL "TARGETS")
+    target_link_libraries(hello_world_component PUBLIC HPX::hpx HPX::iostreams_component)
+    target_link_libraries(hello_world_component PRIVATE HPX::component)
+
+    target_link_libraries(hello_world_client PRIVATE hello_world_component)
+  elseif("${SETUP_TYPE}" STREQUAL "MACROS")
+    hpx_setup_target(hello_world_component
+      COMPONENT_DEPENDENCIES iostreams
+      TYPE COMPONENT)
+
+    hpx_setup_target( hello_world_client
+      DEPENDENCIES hello_world_component)
+  else()
+    message(FATAL_ERROR "Unknown SETUP_TYPE=\"${SETUP_TYPE}\"")
+  endif()
 else()
   message(WARNING "HPX_DIR=${HPX_DIR} does not exist. Did you forget to run the install rule?")
 endif()
diff --git a/examples/interpolate1d/CMakeLists.txt b/examples/interpolate1d/CMakeLists.txt
index 184b469662..f190970a4c 100644
--- a/examples/interpolate1d/CMakeLists.txt
+++ b/examples/interpolate1d/CMakeLists.txt
@@ -27,6 +27,7 @@ if(HPX_WITH_EXAMPLES_HDF5)
 
     # add example executable
     add_hpx_executable(${subdir}_client
+      INTERNAL_FLAGS
       SOURCES ${sources}
       DEPENDENCIES ${subdir}_component
       FOLDER "Examples/Interpolate1D")
@@ -39,6 +40,7 @@ if(HPX_WITH_EXAMPLES_HDF5)
   endforeach()
 
   add_hpx_executable(create_1d_testdata
+    INTERNAL_FLAGS
     SOURCES create_testdata.cpp
     NOLIBS
     FOLDER "Examples/Interpolate1D")
diff --git a/examples/interpolate1d/interpolate1d/CMakeLists.txt b/examples/interpolate1d/interpolate1d/CMakeLists.txt
index 2a6f453aec..bfc2c3b93b 100644
--- a/examples/interpolate1d/interpolate1d/CMakeLists.txt
+++ b/examples/interpolate1d/interpolate1d/CMakeLists.txt
@@ -5,6 +5,7 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 add_hpx_component(interpolate1d
+  INTERNAL_FLAGS
   FOLDER "Examples/Interpolate1D"
   AUTOGLOB)
 
diff --git a/examples/jacobi/CMakeLists.txt b/examples/jacobi/CMakeLists.txt
index 591e0b8064..7b155f59d4 100644
--- a/examples/jacobi/CMakeLists.txt
+++ b/examples/jacobi/CMakeLists.txt
@@ -11,14 +11,15 @@ set(jacobi_sources
 
 set(jacobi_FLAGS
     COMPONENT_DEPENDENCIES
-    iostreams jacobi_component)
+    iostreams jacobi)
 
 # add jacobi executable
 add_hpx_executable(jacobi_simple
-MODULE jacobi
-SOURCES ${jacobi_sources}
-${jacobi_FLAGS}
-FOLDER "Examples/Jacobi")
+  INTERNAL_FLAGS
+  MODULE jacobi
+  SOURCES ${jacobi_sources}
+  ${jacobi_FLAGS}
+  FOLDER "Examples/Jacobi")
 
 add_hpx_example_target_dependencies("jacobi" jacobi_simple)
 
diff --git a/examples/jacobi/jacobi_component/CMakeLists.txt b/examples/jacobi/jacobi_component/CMakeLists.txt
index 8d14963016..bf6986a7f1 100644
--- a/examples/jacobi/jacobi_component/CMakeLists.txt
+++ b/examples/jacobi/jacobi_component/CMakeLists.txt
@@ -4,7 +4,8 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-add_hpx_component(jacobi_component
+add_hpx_component(jacobi
+    INTERNAL_FLAGS
     AUTOGLOB
     SOURCE_GLOB "*.c*"
     HEADER_GLOB "*.h*"
diff --git a/examples/jacobi_smp/CMakeLists.txt b/examples/jacobi_smp/CMakeLists.txt
index 41ed566db7..c66bd79e51 100644
--- a/examples/jacobi_smp/CMakeLists.txt
+++ b/examples/jacobi_smp/CMakeLists.txt
@@ -46,6 +46,7 @@ foreach(jacobi_smp_application ${jacobi_smp_applications})
 
     # add jacobi_smp executable
     add_hpx_executable(${jacobi_smp_application}
+        INTERNAL_FLAGS
         MODULE jacobi_smp
         SOURCES ${sources}
         ${${jacobi_smp_application}_FLAGS}
diff --git a/examples/jacobi_smp/jacobi_nonuniform.cpp b/examples/jacobi_smp/jacobi_nonuniform.cpp
index 4e30e7321d..9e2b7e92f8 100644
--- a/examples/jacobi_smp/jacobi_nonuniform.cpp
+++ b/examples/jacobi_smp/jacobi_nonuniform.cpp
@@ -187,7 +187,7 @@ int hpx_main(variables_map &vm)
         }
         else
         {
-                std::cout << "Unkown mode " << mode << "\n";
+                std::cout << "Unknown mode " << mode << "\n";
 #if !defined(JACOBI_SMP_NO_HPX)
                 hpx::finalize();
 #endif
diff --git a/examples/nqueen/CMakeLists.txt b/examples/nqueen/CMakeLists.txt
index 1417c3858e..2649c1be3a 100644
--- a/examples/nqueen/CMakeLists.txt
+++ b/examples/nqueen/CMakeLists.txt
@@ -7,12 +7,14 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 add_hpx_component(nqueen
+  INTERNAL_FLAGS
   SOURCE_GLOB "nqueen.cp*"
   HEADER_GLOB "nqueen.hp*"
   FOLDER "Examples/Applications/NQueen"
   AUTOGLOB)
 
 add_hpx_executable(nqueen_client_example
+  INTERNAL_FLAGS
   SOURCES nqueen_client.cpp
   DEPENDENCIES nqueen_component
   FOLDER "Examples/Applications/NQueen")
diff --git a/examples/nqueen/nqueen_client.cpp b/examples/nqueen/nqueen_client.cpp
index 30ee525bc8..274214180e 100644
--- a/examples/nqueen/nqueen_client.cpp
+++ b/examples/nqueen/nqueen_client.cpp
@@ -11,8 +11,7 @@
 
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-
-#include <boost/lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <iostream>
@@ -43,7 +42,7 @@ int hpx_main(hpx::program_options::variables_map&)
             soln_count_total = 0;
             std::string arg;
             std::cin >> arg;
-            std::size_t sz = boost::lexical_cast<std::size_t>(arg);
+            std::size_t sz = hpx::util::from_string<std::size_t>(arg);
 
             std::size_t i = 0;
             std::list<nqueen::board> b;
diff --git a/examples/performance_counters/CMakeLists.txt b/examples/performance_counters/CMakeLists.txt
index 1759d48291..16d94b1ce5 100644
--- a/examples/performance_counters/CMakeLists.txt
+++ b/examples/performance_counters/CMakeLists.txt
@@ -26,6 +26,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/PerformanceCounters/${example_program}")
diff --git a/examples/performance_counters/sine/CMakeLists.txt b/examples/performance_counters/sine/CMakeLists.txt
index 4296180db7..51fb3d3d28 100644
--- a/examples/performance_counters/sine/CMakeLists.txt
+++ b/examples/performance_counters/sine/CMakeLists.txt
@@ -9,6 +9,7 @@ set(root "${PROJECT_SOURCE_DIR}/examples/performance_counters/sine")
 ###############################################################################
 # add component
 add_hpx_component(sine
+  INTERNAL_FLAGS
   FOLDER "Examples/PerformanceCounters/Sine"
   HEADER_GLOB "${root}/*.h*"
   SOURCE_GLOB "${root}/sine.c*"
@@ -18,6 +19,7 @@ add_hpx_component(sine
 ###############################################################################
 # add example executable
 add_hpx_executable(sine_client
+  INTERNAL_FLAGS
   SOURCES sine_client.cpp
   DEPENDENCIES sine_component
   FOLDER "Examples/PerformanceCounters/Sine")
diff --git a/examples/performance_counters/sine/sine_client.cpp b/examples/performance_counters/sine/sine_client.cpp
index a704f5acab..46e2efb86b 100644
--- a/examples/performance_counters/sine/sine_client.cpp
+++ b/examples/performance_counters/sine/sine_client.cpp
@@ -94,7 +94,7 @@ int monitor(std::uint64_t pause, std::uint64_t values)
                 start_time = value2.time_;
 
             hpx::util::format_to(std::cout, "{:.3}: {:.4}, {:.4}, {:.4}\n",
-                (value2.time_ - start_time) * 1e-9,
+                static_cast<double>(value2.time_ - start_time) * 1e-9,
                 value1.get_value<double>(),
                 value2.get_value<double>() / 100000.,
                 value3.get_value<double>());
@@ -103,8 +103,11 @@ int monitor(std::uint64_t pause, std::uint64_t values)
         // stop/restart the sine_explicit counter after every 5 seconds of
         // evaluation
         bool should_run =
-            (int((value2.time_ - start_time) * 1e-9) / 5) % 2 != 0;
-        if (should_run == started) {
+            (int(static_cast<double>(value2.time_ - start_time) * 1e-9) / 5) %
+                2 !=
+            0;
+        if (should_run == started)
+        {
             if (started) {
                 sine_explicit.stop();
                 started = false;
diff --git a/examples/pipeline/CMakeLists.txt b/examples/pipeline/CMakeLists.txt
index 6802630c27..6ec25c67f6 100644
--- a/examples/pipeline/CMakeLists.txt
+++ b/examples/pipeline/CMakeLists.txt
@@ -7,6 +7,9 @@
 set(pipeline emitter worker collector)
 
 foreach(app ${pipeline})
-  add_hpx_executable(${app} SOURCES ${app}.cpp FOLDER "Examples/Pipeline")
+  add_hpx_executable(${app}
+    INTERNAL_FLAGS
+    SOURCES ${app}.cpp
+    FOLDER "Examples/Pipeline")
   add_hpx_example_target_dependencies("pipeline" ${app})
 endforeach()
diff --git a/examples/qt/CMakeLists.txt b/examples/qt/CMakeLists.txt
index d96ad62c99..b36548b589 100644
--- a/examples/qt/CMakeLists.txt
+++ b/examples/qt/CMakeLists.txt
@@ -16,6 +16,7 @@ if(HPX_WITH_EXAMPLES_QT4)
         ${QT_MOC_SOURCES})
 
     add_hpx_executable(qt
+        INTERNAL_FLAGS
         MODULE qt
         SOURCES ${qt_sources}
         ${qt_FLAGS}
diff --git a/examples/quickstart/1d_wave_equation.cpp b/examples/quickstart/1d_wave_equation.cpp
index c26ec35f84..9f294889f7 100644
--- a/examples/quickstart/1d_wave_equation.cpp
+++ b/examples/quickstart/1d_wave_equation.cpp
@@ -206,8 +206,8 @@ int hpx_main(variables_map& vm)
 
     c = 1.0;
 
-    dt = 1.0 / (nt - 1);
-    dx = 1.0 / (nx - 1);
+    dt = 1.0 / static_cast<double>(nt - 1);
+    dx = 1.0 / static_cast<double>(nx - 1);
     alpha_squared = (c * dt / dx) * (c * dt / dx);
 
     // check that alpha_squared satisfies the stability condition
diff --git a/examples/quickstart/CMakeLists.txt b/examples/quickstart/CMakeLists.txt
index a2784bade5..9b072a8ce2 100644
--- a/examples/quickstart/CMakeLists.txt
+++ b/examples/quickstart/CMakeLists.txt
@@ -150,6 +150,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/Quickstart")
diff --git a/examples/quickstart/EasyBMP/EasyBMP.cpp b/examples/quickstart/EasyBMP/EasyBMP.cpp
index 0927882fd9..4035873268 100644
--- a/examples/quickstart/EasyBMP/EasyBMP.cpp
+++ b/examples/quickstart/EasyBMP/EasyBMP.cpp
@@ -889,7 +889,7 @@ bool BMP::ReadFromFile( const char* FileName )
 
  // skip blank data if bfOffBits so indicates
 
- int BytesToSkip = bmfh.bfOffBits - 54;;
+ int BytesToSkip = static_cast<int>(bmfh.bfOffBits) - 54;;
  if( BitDepth < 16 )
  { BytesToSkip -= 4*IntPow(2,BitDepth); }
  if( BitDepth == 16 && bmih.biCompression == 3 )
diff --git a/examples/quickstart/component_with_custom_heap.cpp b/examples/quickstart/component_with_custom_heap.cpp
index caeef17d00..87d853d3bb 100644
--- a/examples/quickstart/component_with_custom_heap.cpp
+++ b/examples/quickstart/component_with_custom_heap.cpp
@@ -35,15 +35,15 @@
 namespace allocator
 {
     ///////////////////////////////////////////////////////////////////////////
-    HPX_CONSTEXPR std::size_t BLOCK_ALIGNMENT = 8;
-    HPX_CONSTEXPR std::size_t PAGE_SIZE_ = 16384;
+    constexpr std::size_t BLOCK_ALIGNMENT = 8;
+    constexpr std::size_t PAGE_SIZE_ = 16384;
 
     struct alloc_page;
 
     ///////////////////////////////////////////////////////////////////////////
     struct alloc_block_header
     {
-        HPX_CONSTEXPR HPX_FORCEINLINE alloc_block_header(
+        constexpr HPX_FORCEINLINE alloc_block_header(
                 alloc_page* p = nullptr) noexcept
           : page(p)
         {}
@@ -66,7 +66,7 @@ namespace allocator
             ((sizeof(T) + BLOCK_ALIGNMENT - 1) & ~(BLOCK_ALIGNMENT - 1)) +
             sizeof(alloc_block_header);
 
-        HPX_CONSTEXPR HPX_FORCEINLINE alloc_block(
+        constexpr HPX_FORCEINLINE alloc_block(
                 alloc_page* page = nullptr) noexcept
           : alloc_block_header(page)
           , next_free(nullptr)
@@ -117,7 +117,7 @@ namespace allocator
 
         HPX_FORCEINLINE static free_list_allocator& get_allocator();
 
-        HPX_CONSTEXPR HPX_FORCEINLINE alloc_page const* first_page() const
+        constexpr HPX_FORCEINLINE alloc_page const* first_page() const
         {
             return pages;
         }
@@ -215,13 +215,13 @@ namespace allocator
     };
 
     template <typename T>
-    HPX_CXX14_CONSTEXPR HPX_FORCEINLINE T& get(
+    constexpr HPX_FORCEINLINE T& get(
         alloc_page* page, std::size_t i) noexcept
     {
         return page->template get<T>(i);
     }
     template <typename T>
-    HPX_CXX14_CONSTEXPR HPX_FORCEINLINE T const& get(
+    constexpr HPX_FORCEINLINE T const& get(
         alloc_page const* page, std::size_t i) noexcept
     {
         return page->template get<T>(i);
diff --git a/examples/quickstart/fibonacci_futures_distributed.cpp b/examples/quickstart/fibonacci_futures_distributed.cpp
index 0fd906ea2e..44a9a9fb3d 100644
--- a/examples/quickstart/fibonacci_futures_distributed.cpp
+++ b/examples/quickstart/fibonacci_futures_distributed.cpp
@@ -7,6 +7,7 @@
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/actions.hpp>
 #include <hpx/include/lcos.hpp>
+#include <hpx/include/runtime.hpp>
 #include <hpx/include/util.hpp>
 #include <hpx/util/unwrap.hpp>
 
diff --git a/examples/quickstart/pingpong.cpp b/examples/quickstart/pingpong.cpp
index 75960aa401..1f358eb244 100644
--- a/examples/quickstart/pingpong.cpp
+++ b/examples/quickstart/pingpong.cpp
@@ -93,26 +93,25 @@ int hpx_main(hpx::program_options::variables_map &b_arg)
         }
 
         double time = timer1.elapsed();
-
+        double bandwidth =
+            ((static_cast<double>(vsize * sizeof(double) * numiter) / time) /
+                1024) /
+            1024;
         if (verbose) {
             std::cout << "[hpx_pingpong]" << std::endl
-                    << "total_time(secs)=" << time << std::endl
-                    << "vsize=" << vsize << " = " << vsize * sizeof(double)
-                    << " Bytes" << std::endl
-                    << "bandwidth(MiB/s)="
-                    << (((vsize * sizeof(double) * numiter) / time) / 1024) / 1024
-                    << std::endl
-                    << "localities=" << localities.size() << std::endl
-                    << "numiter=" << numiter << std::endl;
+                      << "total_time(secs)=" << time << std::endl
+                      << "vsize=" << vsize << " = " << vsize * sizeof(double)
+                      << " Bytes" << std::endl
+                      << "bandwidth(MiB/s)=" << bandwidth << std::endl
+                      << "localities=" << localities.size() << std::endl
+                      << "numiter=" << numiter << std::endl;
         }
         else {
             std::cout << "[hpx_pingpong]"
-                    << ":total_time(secs)=" << time
-                    << ":vsize=" << vsize
-                    << ":bandwidth(MiB/s)="
-                    << (((vsize * sizeof(double) * numiter) / time) / 1024) / 1024
-                    << ":localities=" << localities.size()
-                    << ":numiter=" << numiter << std::endl;
+                      << ":total_time(secs)=" << time << ":vsize=" << vsize
+                      << ":bandwidth(MiB/s)=" << bandwidth
+                      << ":localities=" << localities.size()
+                      << ":numiter=" << numiter << std::endl;
         }
     }
 
diff --git a/examples/quickstart/pipeline1.cpp b/examples/quickstart/pipeline1.cpp
index a39b933054..807c8112dc 100644
--- a/examples/quickstart/pipeline1.cpp
+++ b/examples/quickstart/pipeline1.cpp
@@ -6,6 +6,7 @@
 
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_main.hpp>
+#include <hpx/string_util/trim.hpp>
 
 #include <iostream>
 #include <iterator>
@@ -14,8 +15,6 @@
 #include <utility>
 #include <vector>
 
-#include <boost/algorithm/string/trim.hpp>
-
 struct pipeline
 {
     static void process(std::vector<std::string> const& input)
@@ -28,7 +27,7 @@ struct pipeline
             {
                 auto trim = [](std::string const& s)
                 {
-                    return boost::algorithm::trim_copy(s);
+                    return hpx::string_util::trim_copy(s);
                 };
 
                 hpx::async(trim, std::move(item))
diff --git a/examples/quickstart/timed_wake.cpp b/examples/quickstart/timed_wake.cpp
index c0c2f4c0b5..60f7890fbc 100644
--- a/examples/quickstart/timed_wake.cpp
+++ b/examples/quickstart/timed_wake.cpp
@@ -7,7 +7,7 @@
 #include <hpx/config.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/timing.hpp>
 
 #include <chrono>
diff --git a/examples/quickstart/vector_counting_dotproduct.cpp b/examples/quickstart/vector_counting_dotproduct.cpp
index 0e81acc530..aa26bf8260 100644
--- a/examples/quickstart/vector_counting_dotproduct.cpp
+++ b/examples/quickstart/vector_counting_dotproduct.cpp
@@ -9,8 +9,7 @@
 #include <hpx/include/parallel_numeric.hpp>
 #include <hpx/include/parallel_algorithm.hpp>
 #include <hpx/include/iostreams.hpp>
-
-#include <boost/iterator/counting_iterator.hpp>
+#include <hpx/iterator_support.hpp>
 
 #include <algorithm>
 #include <iterator>
@@ -29,8 +28,8 @@ int hpx_main()
     double result =
         hpx::parallel::transform_reduce(
             hpx::parallel::execution::par,
-            boost::counting_iterator<size_t>(0),
-            boost::counting_iterator<size_t>(10007),
+            hpx::util::counting_iterator<size_t>(0),
+            hpx::util::counting_iterator<size_t>(10007),
             0.0,
             std::plus<double>(),
             [&xvalues, &yvalues](size_t i)
diff --git a/examples/random_mem_access/CMakeLists.txt b/examples/random_mem_access/CMakeLists.txt
index 2608768e5e..0332080e28 100644
--- a/examples/random_mem_access/CMakeLists.txt
+++ b/examples/random_mem_access/CMakeLists.txt
@@ -21,6 +21,7 @@ foreach(subdir ${subdirs})
 
   # add example executable
   add_hpx_executable(${subdir}_client
+    INTERNAL_FLAGS
     MODULE random_mem_access
     SOURCES ${sources}
     DEPENDENCIES ${subdir}_component
diff --git a/examples/random_mem_access/random_mem_access/CMakeLists.txt b/examples/random_mem_access/random_mem_access/CMakeLists.txt
index 12bd497f0a..c32119e7f7 100644
--- a/examples/random_mem_access/random_mem_access/CMakeLists.txt
+++ b/examples/random_mem_access/random_mem_access/CMakeLists.txt
@@ -28,6 +28,7 @@ source_group("Header Files\\Server" FILES ${server_headers})
 
 ###############################################################################
 add_hpx_component(random_mem_access
+  INTERNAL_FLAGS
   MODULE random_mem_access
   SOURCES ${client_sources}
   HEADERS ${headers}
diff --git a/examples/sheneos/CMakeLists.txt b/examples/sheneos/CMakeLists.txt
index b26ef741d9..c58b7088d0 100644
--- a/examples/sheneos/CMakeLists.txt
+++ b/examples/sheneos/CMakeLists.txt
@@ -21,6 +21,7 @@ if(HPX_WITH_EXAMPLES_HDF5)
   ###############################################################################
   # add example executable
   add_hpx_executable(sheneos_client
+    INTERNAL_FLAGS
     SOURCES sheneos_client.cpp
     DEPENDENCIES sheneos_component
     FOLDER "Examples/ShenEOS")
@@ -29,6 +30,7 @@ if(HPX_WITH_EXAMPLES_HDF5)
   add_hpx_pseudo_dependencies(examples.sheneos sheneos_client)
 
   add_hpx_executable(sheneos_test
+    INTERNAL_FLAGS
     SOURCES sheneos_test.cpp
     DEPENDENCIES sheneos_component
     FOLDER "Examples/ShenEOS")
@@ -41,6 +43,7 @@ if(HPX_WITH_EXAMPLES_HDF5)
   if(HPX_WITH_FORTRAN)
     if(CMAKE_Fortran_COMPILER AND HDF5_FORTRAN_FOUND)
       add_hpx_executable(sheneos_compare
+        INTERNAL_FLAGS
         SOURCES
             sheneos_compare.cpp
             eos_driver/read_nuc_table.F90
diff --git a/examples/sheneos/README.rst b/examples/sheneos/README.rst
index fd44e495b2..470c06979a 100644
--- a/examples/sheneos/README.rst
+++ b/examples/sheneos/README.rst
@@ -57,7 +57,7 @@ Options
     The number of worker/measurement threads to create per locality.
 
 --seed : std::size_t : 0
-    The seed for the pseudo random number generator (if 0, a seed is choosen
+    The seed for the pseudo random number generator (if 0, a seed is chosen
     based on the current system time).
 
 Input File Format
diff --git a/examples/sheneos/sheneos/interpolator.cpp b/examples/sheneos/sheneos/interpolator.cpp
index e143ada4c6..66a0214cef 100644
--- a/examples/sheneos/sheneos/interpolator.cpp
+++ b/examples/sheneos/sheneos/interpolator.cpp
@@ -311,7 +311,7 @@ namespace sheneos
     // context data and callback function for asynchronous bulk operations
     struct context_data
     {
-        std::vector<std::size_t> indicies_;
+        std::vector<std::size_t> indices_;
         std::vector<sheneos_coord> coords_;
     };
 
@@ -331,17 +331,17 @@ namespace sheneos
         void operator()(hpx::future<std::vector<double> > f)
         {
             std::vector<double> result = f.get();
-            std::vector<std::size_t> const& indicies = data_.get().indicies_;
+            std::vector<std::size_t> const& indices = data_.get().indices_;
 
-            if (result.size() != indicies.size()) {
+            if (result.size() != indices.size()) {
                 HPX_THROW_EXCEPTION(hpx::bad_parameter,
                     "interpolator::on_completed_bulk_one",
                     "inconsistent sizes of result and index arrays");
             }
 
             std::vector<double>& overall_result = overall_result_.get();
-            for (std::size_t i = 0; i < indicies.size(); ++i)
-                overall_result[indicies[i]] = result[i];
+            for (std::size_t i = 0; i < indices.size(); ++i)
+                overall_result[indices[i]] = result[i];
         }
 
         std::reference_wrapper<context_data const> data_;
@@ -412,7 +412,7 @@ namespace sheneos
         {
             context_data& d = parts[get_partition(c).get_id()];
 
-            d.indicies_.push_back(index++);
+            d.indices_.push_back(index++);
             d.coords_.push_back(c);
         }
 
@@ -435,9 +435,9 @@ namespace sheneos
         void operator()(hpx::future<std::vector<std::vector<double> > > f)
         {
             std::vector<std::vector<double> > result = f.get();
-            std::vector<std::size_t> const& indicies = data_.get().indicies_;
+            std::vector<std::size_t> const& indices = data_.get().indices_;
 
-            if (result.size() != indicies.size()) {
+            if (result.size() != indices.size()) {
                 HPX_THROW_EXCEPTION(hpx::bad_parameter,
                     "interpolator::on_completed_bulk",
                     "inconsistent sizes of result and index arrays");
@@ -445,8 +445,8 @@ namespace sheneos
 
             std::vector<std::vector<double> >& overall_results =
                 overall_results_.get();
-            for (std::size_t i = 0; i < indicies.size(); ++i)
-                overall_results[indicies[i]] = result[i];
+            for (std::size_t i = 0; i < indices.size(); ++i)
+                overall_results[indices[i]] = result[i];
         }
 
         std::reference_wrapper<context_data const> data_;
@@ -519,7 +519,7 @@ namespace sheneos
         {
             context_data& d = parts[get_partition(c).get_id()];
 
-            d.indicies_.push_back(index++);
+            d.indices_.push_back(index++);
             d.coords_.push_back(c);
         }
 
diff --git a/examples/spell_check/CMakeLists.txt b/examples/spell_check/CMakeLists.txt
index 7fbddf2793..cfe69ca276 100644
--- a/examples/spell_check/CMakeLists.txt
+++ b/examples/spell_check/CMakeLists.txt
@@ -21,6 +21,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/SpellCheck")
diff --git a/examples/spell_check/spell_check_file.cpp b/examples/spell_check/spell_check_file.cpp
index afacac73f2..489a8aafb7 100644
--- a/examples/spell_check/spell_check_file.cpp
+++ b/examples/spell_check/spell_check_file.cpp
@@ -6,20 +6,17 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 ////////////////////////////////////////////////////////////////////////////////
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/actions.hpp>
 #include <hpx/include/util.hpp>
 #include <hpx/include/lcos.hpp>
+#include <hpx/string_util.hpp>
 
 #include <fstream>
 #include <iostream>
 #include <string>
 #include <vector>
 
-#include <boost/algorithm/string.hpp>
-
 std::vector<std::string> words;
 
 std::string search(int start, int end, std::string const &word);
@@ -51,7 +48,7 @@ std::string search(int start, int end, std::string const &word)
             bool sub = true;
             for (int i = 0; i < size; i++)
             {
-                char check_char = tolower(check[i]);
+                char check_char = static_cast<char>(tolower(check[i]));
                 char word_char = word[i];
                 if (word_char != check_char)
                 {
@@ -83,7 +80,7 @@ std::string search(int start, int end, std::string const &word)
         size = word.length();
     for (int i = 0; i < size; i++)
     {
-        char check_char = tolower(check[i]);
+        char check_char = static_cast<char>(tolower(check[i]));
         char word_char = word[i];
         if (check_char != word_char)
         {
@@ -146,7 +143,7 @@ int hpx_main()
         vector<string> strs;
         {
             vector<string> temp;
-            boost::split(temp, word, boost::is_any_of("\n\t -"));
+            hpx::string_util::split(temp, word, hpx::string_util::is_any_of("\n\t -"));
             for (string::size_type i = 0; i < temp.size(); i++)
             {
                 bool isContraction = false;
@@ -166,7 +163,7 @@ int hpx_main()
                     }
                     //remove any garbage characters
                     if (toupper(temp[i][j]) >= 'A' && toupper(temp[i][j]) <= 'Z')
-                        holder.push_back(tolower(temp[i][j]));
+                        holder.push_back(static_cast<char>(tolower(temp[i][j])));
                 }
                 if (holder.size() > 0)
                 {
@@ -188,7 +185,7 @@ int hpx_main()
             {
                 getline(fin, temp);
                 for (string::size_type i = 0; i < temp.length(); i++)
-                temp[i] = tolower(temp[i]);
+                temp[i] = static_cast<char>(tolower(temp[i]));
                 words.push_back(temp);
                 wordcount++;
             }
diff --git a/examples/spell_check/spell_check_simple.cpp b/examples/spell_check/spell_check_simple.cpp
index e1116caf82..f20927d93e 100644
--- a/examples/spell_check/spell_check_simple.cpp
+++ b/examples/spell_check/spell_check_simple.cpp
@@ -6,20 +6,17 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 ////////////////////////////////////////////////////////////////////////////////
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/actions.hpp>
 #include <hpx/include/util.hpp>
 #include <hpx/include/lcos.hpp>
+#include <hpx/string_util.hpp>
 
 #include <fstream>
 #include <iostream>
 #include <string>
 #include <vector>
 
-#include <boost/algorithm/string.hpp>
-
 std::vector<std::string> words;
 
 std::string search(int start, int end, std::string const &word);
@@ -51,7 +48,7 @@ std::string search(int start, int end, std::string const &word)
             bool sub = true;
             for (int i = 0; i < size; i++)
             {
-                char check_char = tolower(check[i]);
+                char check_char = static_cast<char>(tolower(check[i]));
                 char word_char = word[i];
                 if (word_char != check_char)
                 {
@@ -84,7 +81,7 @@ std::string search(int start, int end, std::string const &word)
         size = word.length();
     for (int i = 0; i < size; i++)
     {
-        char check_char = tolower(check[i]);
+        char check_char = static_cast<char>(tolower(check[i]));
         char word_char = word[i];
         if (check_char != word_char)
         {
@@ -129,7 +126,7 @@ int hpx_main()
             {
                 getline(fin, temp);
                 for (string::size_type i = 0; i < temp.length(); i++)
-                temp[i] = tolower(temp[i]);
+                temp[i] = static_cast<char>(tolower(temp[i]));
                 words.push_back(temp);
                 wordcount++;
             }
@@ -149,7 +146,7 @@ int hpx_main()
         vector<string> strs;
         {
             vector<string> temp;
-            boost::split(temp, word, boost::is_any_of("\n\t -"));
+            hpx::string_util::split(temp, word, hpx::string_util::is_any_of("\n\t -"));
             for (string::size_type i = 0; i < temp.size(); i++)
             {
                 bool isContraction = false;
@@ -170,7 +167,7 @@ int hpx_main()
                     }
                     //remove any garbage characters
                     if (toupper(temp[i][j]) >= 'A' && toupper(temp[i][j]) <= 'Z')
-                        holder.push_back(tolower(temp[i][j]));
+                        holder.push_back(static_cast<char>(tolower(temp[i][j])));
                 }
                 if (holder.size() > 0)
                 {
diff --git a/examples/startup_shutdown/CMakeLists.txt b/examples/startup_shutdown/CMakeLists.txt
index 3eff0d034a..27889542f2 100644
--- a/examples/startup_shutdown/CMakeLists.txt
+++ b/examples/startup_shutdown/CMakeLists.txt
@@ -5,6 +5,7 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 add_hpx_component(startup_shutdown
+  INTERNAL_FLAGS
   FOLDER "Examples/StartupShutdown"
   AUTOGLOB)
 
diff --git a/examples/startup_shutdown/startup_shutdown.cpp b/examples/startup_shutdown/startup_shutdown.cpp
index 27c3283b02..d4adfaff0a 100644
--- a/examples/startup_shutdown/startup_shutdown.cpp
+++ b/examples/startup_shutdown/startup_shutdown.cpp
@@ -13,7 +13,7 @@
 // is guaranteed to be executed before hpx_main() is invoked.
 //
 // The HPX API function retrieve_commandline_arguments() demonstrated below
-// expectes 2 arguments: a) an options_description object describing any
+// expects 2 arguments: a) an options_description object describing any
 // special options to be recognized by this component and b) a variables_map
 // object which on return will be initialized with all found command line
 // options and arguments passed while invoking the application on the locality
@@ -26,7 +26,7 @@
 
 #include <hpx/hpx.hpp>
 #include <hpx/runtime/startup_function.hpp>
-#include <hpx/util/parse_command_line.hpp>
+#include <hpx/command_line_handling/parse_command_line.hpp>
 
 #include <hpx/program_options.hpp>
 
diff --git a/examples/thread_aware_timer/CMakeLists.txt b/examples/thread_aware_timer/CMakeLists.txt
index b3a3848e27..4a20a2c56f 100644
--- a/examples/thread_aware_timer/CMakeLists.txt
+++ b/examples/thread_aware_timer/CMakeLists.txt
@@ -5,6 +5,7 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 add_hpx_executable(thread_aware_timer
+  INTERNAL_FLAGS
   SOURCES thread_aware_timer.cpp
   FOLDER "Examples/ThreadAwareTimer"
   DEPENDENCIES iostreams_component)
diff --git a/examples/throttle/CMakeLists.txt b/examples/throttle/CMakeLists.txt
index 3d2ace9939..893acfe9b8 100644
--- a/examples/throttle/CMakeLists.txt
+++ b/examples/throttle/CMakeLists.txt
@@ -22,6 +22,7 @@ foreach(subdir ${subdirs})
 
   # add example executable
   add_hpx_executable(${subdir}_client
+    INTERNAL_FLAGS
     SOURCES ${sources}
     DEPENDENCIES ${subdir}_component
     FOLDER "Examples/Throttle")
@@ -31,6 +32,7 @@ foreach(subdir ${subdirs})
 endforeach()
 
 add_hpx_executable(spin
+  INTERNAL_FLAGS
   SOURCES spin.cpp
   FOLDER "Examples/Throttle")
 
diff --git a/examples/throttle/throttle/CMakeLists.txt b/examples/throttle/throttle/CMakeLists.txt
index 5de40f2a5d..edde15df60 100644
--- a/examples/throttle/throttle/CMakeLists.txt
+++ b/examples/throttle/throttle/CMakeLists.txt
@@ -35,6 +35,7 @@ source_group("Header Files\\Server" FILES ${server_headers})
 
 ###############################################################################
 add_hpx_component(throttle
+  INTERNAL_FLAGS
   SOURCES ${client_sources} ${server_sources}
   HEADERS ${headers}
   FOLDER "Examples/Throttle")
diff --git a/examples/throttle/throttle_client.cpp b/examples/throttle/throttle_client.cpp
index 4aa6bd8fa5..a970a3a04f 100644
--- a/examples/throttle/throttle_client.cpp
+++ b/examples/throttle/throttle_client.cpp
@@ -9,12 +9,11 @@
 #include <hpx/include/components.hpp>
 #include <hpx/runtime/agas/interface.hpp>
 #include <hpx/format.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
 
 #include "throttle/throttle.hpp"
 
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
-
 #include <iostream>
 #include <sstream>
 #include <string>
@@ -22,8 +21,8 @@
 
 using hpx::program_options::variables_map;
 
-using boost::algorithm::is_space;
-using boost::algorithm::split;
+using hpx::string_util::is_space;
+using hpx::string_util::split;
 
 using hpx::naming::get_agas_client;
 
diff --git a/examples/transpose/CMakeLists.txt b/examples/transpose/CMakeLists.txt
index f45ae8595e..d417cdf86e 100644
--- a/examples/transpose/CMakeLists.txt
+++ b/examples/transpose/CMakeLists.txt
@@ -37,6 +37,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/Transpose")
diff --git a/examples/transpose/transpose_await.cpp b/examples/transpose/transpose_await.cpp
index f03bb33fe7..559147b69a 100644
--- a/examples/transpose/transpose_await.cpp
+++ b/examples/transpose/transpose_await.cpp
@@ -295,8 +295,10 @@ int hpx_main(hpx::program_options::variables_map& vm)
                 {
                     for(std::uint64_t j = 0; j != block_order; ++j)
                     {
-                        double col_val = COL_SHIFT * (b*block_order + j);
-                        A_ptr->data_[i * block_order + j] = col_val + ROW_SHIFT * i;
+                        double col_val = COL_SHIFT *
+                            static_cast<double>(b * block_order + j);
+                        A_ptr->data_[i * block_order + j] =
+                            col_val + ROW_SHIFT * i;
                         B_ptr->data_[i * block_order + j] = -1.0;
                     }
                 }
@@ -453,7 +455,9 @@ double test_results(std::uint64_t order, std::uint64_t block_order,
                     for(std::uint64_t j = 0; j < block_order; ++j)
                     {
                         double diff = trans_block[i * block_order + j] -
-                            (col_val + ROW_SHIFT * (b * block_order + j));
+                            (col_val +
+                                ROW_SHIFT *
+                                    static_cast<double>(b * block_order + j));
                         errsq += diff * diff;
                     }
                 }
diff --git a/examples/transpose/transpose_block.cpp b/examples/transpose/transpose_block.cpp
index b3b12a64df..21a9621af7 100644
--- a/examples/transpose/transpose_block.cpp
+++ b/examples/transpose/transpose_block.cpp
@@ -260,8 +260,10 @@ int hpx_main(hpx::program_options::variables_map& vm)
                 {
                     for(std::uint64_t j = 0; j != block_order; ++j)
                     {
-                        double col_val = COL_SHIFT * (b*block_order + j);
-                        A_ptr->data_[i * block_order + j] = col_val + ROW_SHIFT * i;
+                        double col_val = COL_SHIFT *
+                            static_cast<double>(b * block_order + j);
+                        A_ptr->data_[i * block_order + j] =
+                            col_val + ROW_SHIFT * i;
                         B_ptr->data_[i * block_order + j] = -1.0;
                     }
                 }
@@ -474,7 +476,9 @@ double test_results(std::uint64_t order, std::uint64_t block_order,
                     for(std::uint64_t j = 0; j < block_order; ++j)
                     {
                         double diff = trans_block[i * block_order + j] -
-                            (col_val + ROW_SHIFT * (b * block_order + j));
+                            (col_val +
+                                ROW_SHIFT *
+                                    static_cast<double>(b * block_order + j));
                         errsq += diff * diff;
                     }
                 }
diff --git a/examples/transpose/transpose_block_numa.cpp b/examples/transpose/transpose_block_numa.cpp
index e3f43a4a8e..8c576e5bc3 100644
--- a/examples/transpose/transpose_block_numa.cpp
+++ b/examples/transpose/transpose_block_numa.cpp
@@ -13,7 +13,7 @@
 #include <hpx/include/parallel_numeric.hpp>
 #include <hpx/include/serialization.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <hpx/parallel/util/numa_allocator.hpp>
 
@@ -230,7 +230,7 @@ std::size_t get_num_numa_nodes(hpx::threads::topology const& topo,
 
     if (num_numa_domains_str != "all")
     {
-        numa_nodes = hpx::util::safe_lexical_cast<std::size_t>(num_numa_domains_str);
+        numa_nodes = hpx::util::from_string<std::size_t>(num_numa_domains_str);
     }
 
     return numa_nodes;
@@ -247,7 +247,7 @@ std::pair<std::size_t, std::size_t> get_num_numa_pus(
 
     if(num_threads_str != "all")
     {
-        pus = hpx::util::safe_lexical_cast<std::size_t>(num_threads_str);
+        pus = hpx::util::from_string<std::size_t>(num_threads_str);
     }
 
     return std::make_pair(numa_pus, pus);
@@ -371,8 +371,10 @@ int hpx_main(hpx::program_options::variables_map& vm)
                 {
                     for(std::uint64_t j = 0; j != block_order; ++j)
                     {
-                        double col_val = COL_SHIFT * (b*block_order + j);
-                        A_ptr->data_[i * block_order + j] = col_val + ROW_SHIFT * i;
+                        double col_val = COL_SHIFT *
+                            static_cast<double>(b * block_order + j);
+                        A_ptr->data_[i * block_order + j] =
+                            col_val + ROW_SHIFT * i;
                         B_ptr->data_[i * block_order + j] = -1.0;
                     }
                 }
@@ -676,7 +678,9 @@ double test_results(std::uint64_t order, std::uint64_t block_order,
                     for(std::uint64_t j = 0; j < block_order; ++j)
                     {
                         double diff = trans_block[i * block_order + j] -
-                            (col_val + ROW_SHIFT * (b * block_order + j));
+                            (col_val +
+                                ROW_SHIFT *
+                                    static_cast<double>(b * block_order + j));
                         errsq += diff * diff;
                     }
                 }
diff --git a/examples/transpose/transpose_serial.cpp b/examples/transpose/transpose_serial.cpp
index b230dc9afe..737fd2f8ee 100644
--- a/examples/transpose/transpose_serial.cpp
+++ b/examples/transpose/transpose_serial.cpp
@@ -152,8 +152,8 @@ int main(int argc, char* argv[])
         ( "verbose", "Verbose output")
     ;
 
-    // Initialize and run HPX, this example is serial and therefor only needs on thread,
-    // We just use hpx::init to parse our command line arguments
+    // Initialize and run HPX, this example is serial and therefore only needs
+    // one thread, We just use hpx::init to parse our command line arguments
     std::vector<std::string> const cfg = {
         "hpx.os_threads!=1"
     };
diff --git a/examples/transpose/transpose_serial_block.cpp b/examples/transpose/transpose_serial_block.cpp
index 65c50f6c51..b7c4a26bd9 100644
--- a/examples/transpose/transpose_serial_block.cpp
+++ b/examples/transpose/transpose_serial_block.cpp
@@ -66,7 +66,8 @@ int hpx_main(hpx::program_options::variables_map& vm)
         {
             for(std::uint64_t j = 0; j < block_order; ++j)
             {
-                double col_val = COL_SHIFT * (b*block_order + j);
+                double col_val =
+                    COL_SHIFT * static_cast<double>(b * block_order + j);
 
                 A[b][i * block_order + j] = col_val + ROW_SHIFT * i;
                 B[b][i * block_order + j] = -1.0;
@@ -156,8 +157,8 @@ int main(int argc, char* argv[])
         ( "verbose", "Verbose output")
     ;
 
-    // Initialize and run HPX, this example is serial and therefor only needs
-    // on thread. We just use hpx::init to parse our command line arguments
+    // Initialize and run HPX, this example is serial and therefore only needs
+    // one thread. We just use hpx::init to parse our command line arguments
     std::vector<std::string> const cfg = {
         "hpx.os_threads!=1"
     };
@@ -211,7 +212,8 @@ double test_results(std::uint64_t order, std::uint64_t block_order,
             for(std::uint64_t j = 0; j < block_order; ++j)
             {
                 double diff = trans[b][i * block_order + j] -
-                  (col_val + ROW_SHIFT * (b * block_order + j));
+                    (col_val +
+                        ROW_SHIFT * static_cast<double>(b * block_order + j));
                 errsq += diff * diff;
             }
         }
diff --git a/examples/transpose/transpose_serial_vector.cpp b/examples/transpose/transpose_serial_vector.cpp
index c82d779a7c..2a0c12f3bb 100644
--- a/examples/transpose/transpose_serial_vector.cpp
+++ b/examples/transpose/transpose_serial_vector.cpp
@@ -157,8 +157,8 @@ int main(int argc, char* argv[])
         ( "verbose", "Verbose output")
     ;
 
-    // Initialize and run HPX, this example is serial and therefor only needs on thread,
-    // We just use hpx::init to parse our command line arguments
+    // Initialize and run HPX, this example is serial and therefore only needs
+    // one thread, We just use hpx::init to parse our command line arguments
     std::vector<std::string> const cfg = {
         "hpx.os_threads!=1"
     };
diff --git a/examples/transpose/transpose_smp_block.cpp b/examples/transpose/transpose_smp_block.cpp
index d78194016b..54259ca58f 100644
--- a/examples/transpose/transpose_smp_block.cpp
+++ b/examples/transpose/transpose_smp_block.cpp
@@ -77,7 +77,8 @@ int hpx_main(hpx::program_options::variables_map& vm)
             {
                 for(std::uint64_t j = 0; j < block_order; ++j)
                 {
-                    double col_val = COL_SHIFT * (b*block_order + j);
+                    double col_val =
+                        COL_SHIFT * static_cast<double>(b * block_order + j);
 
                     A[b][i * block_order + j] = col_val + ROW_SHIFT * i;
                     B[b][i * block_order + j] = -1.0;
@@ -242,7 +243,9 @@ double test_results(std::uint64_t order, std::uint64_t block_order,
                     for(std::uint64_t j = 0; j < block_order; ++j)
                     {
                         double diff = trans[b][i * block_order + j] -
-                            (col_val + ROW_SHIFT * (b * block_order + j));
+                            (col_val +
+                                ROW_SHIFT *
+                                    static_cast<double>(b * block_order + j));
                         errsq += diff * diff;
                     }
                 }
diff --git a/examples/tuplespace/CMakeLists.txt b/examples/tuplespace/CMakeLists.txt
index 6d8b102b7a..e5d706c61a 100644
--- a/examples/tuplespace/CMakeLists.txt
+++ b/examples/tuplespace/CMakeLists.txt
@@ -21,6 +21,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}_client
+    INTERNAL_FLAGS
     SOURCES ${sources}
     COMPONENT_DEPENDENCIES ${example_program} iostreams
     FOLDER "Examples/TupleSpace/${example_program}")
diff --git a/examples/tuplespace/central_tuplespace/CMakeLists.txt b/examples/tuplespace/central_tuplespace/CMakeLists.txt
index 2e47f60fed..fdf607dc21 100644
--- a/examples/tuplespace/central_tuplespace/CMakeLists.txt
+++ b/examples/tuplespace/central_tuplespace/CMakeLists.txt
@@ -12,6 +12,7 @@ set(components
 foreach(component ${components})
 
   add_hpx_component(${component}
+    INTERNAL_FLAGS
     AUTOGLOB
     HEADER_GLOB "${component}.h*"
     SOURCE_GLOB "${component}.c*"
diff --git a/examples/tuplespace/central_tuplespace/server/simple_central_tuplespace.hpp b/examples/tuplespace/central_tuplespace/server/simple_central_tuplespace.hpp
index bc7fe126c5..5e6b39811c 100644
--- a/examples/tuplespace/central_tuplespace/server/simple_central_tuplespace.hpp
+++ b/examples/tuplespace/central_tuplespace/server/simple_central_tuplespace.hpp
@@ -86,7 +86,7 @@ namespace examples { namespace server
 
             // put tuple into tuplespace
             // out function
-            int write(const tuple_type& tp)
+            int write(tuple_type const& tp)
             {
                 if(tp.empty())
                 {
@@ -104,7 +104,7 @@ namespace examples { namespace server
 
             // read from tuplespace
             // rd function
-            tuple_type read(const tuple_type& tp, const long timeout) const
+            tuple_type read(tuple_type const& tp, double const timeout) const
             {
                 tuple_type result;
                 hpx::util::high_resolution_timer t;
@@ -134,7 +134,7 @@ namespace examples { namespace server
 
             // take from tuplespace
             // in function
-            tuple_type take(const tuple_type& tp, const long timeout)
+            tuple_type take(tuple_type const& tp, double const timeout)
             {
                 tuple_type result;
                 hpx::util::high_resolution_timer t;
diff --git a/examples/tuplespace/central_tuplespace/server/tuples_warehouse.hpp b/examples/tuplespace/central_tuplespace/server/tuples_warehouse.hpp
index 6809ef8dcf..62dc1d5992 100644
--- a/examples/tuplespace/central_tuplespace/server/tuples_warehouse.hpp
+++ b/examples/tuplespace/central_tuplespace/server/tuples_warehouse.hpp
@@ -53,7 +53,7 @@ namespace examples { namespace server {
             return tuple_fields_[0].empty();
         }
 
-        int insert(const tuple_type& tp)
+        int insert(tuple_type const& tp)
         {
             if (tp.empty())    // empty tuple
                 return -1;
@@ -76,7 +76,7 @@ namespace examples { namespace server {
             return 0;
         }
 
-        tuple_type match(const tuple_type& tp) const
+        tuple_type match(tuple_type const& tp) const
         {
             tuple_type result;
 
@@ -99,7 +99,7 @@ namespace examples { namespace server {
             return result;
         }
 
-        tuple_type match_and_erase(const tuple_type& tp)
+        tuple_type match_and_erase(tuple_type const& tp)
         {
             tuple_type result;
 
@@ -123,7 +123,7 @@ namespace examples { namespace server {
         }
 
     private:    // private member functions
-        matched_indices_type find_matched_indices(const tuple_type& tp) const
+        matched_indices_type find_matched_indices(tuple_type const& tp) const
         {
             tuple_type::const_iterator it;
             unsigned int pos;
@@ -198,7 +198,7 @@ namespace examples { namespace server {
             return read_tuple_at(tuple_fields_[0].random_index());
         }
 
-        tuple_type read_tuple_at(const index_type& id) const
+        tuple_type read_tuple_at(index_type const& id) const
         {
             tuple_type result;
 
@@ -235,7 +235,7 @@ namespace examples { namespace server {
             return take_tuple_at(tuple_fields_[0].random_index());
         }
 
-        tuple_type take_tuple_at(const index_type& id)
+        tuple_type take_tuple_at(index_type const& id)
         {
             tuple_type result;
 
@@ -297,7 +297,7 @@ namespace examples { namespace server {
                 return field_index_map_.empty();
             }
 
-            int insert(const index_type& id, const elem_type& elem)
+            int insert(index_type const& id, elem_type const& elem)
             {
                 field_index_map_iterator_type it;
 
diff --git a/examples/tuplespace/central_tuplespace/simple_central_tuplespace.hpp b/examples/tuplespace/central_tuplespace/simple_central_tuplespace.hpp
index d427005351..2ae3fee2e0 100644
--- a/examples/tuplespace/central_tuplespace/simple_central_tuplespace.hpp
+++ b/examples/tuplespace/central_tuplespace/simple_central_tuplespace.hpp
@@ -111,7 +111,7 @@ namespace examples
         ///       for the action to be executed. Instead, it will return
         ///       immediately after the action has has been dispatched.
         //[simple_central_tuplespace_client_write_async
-        hpx::lcos::future<int> write_async(const tuple_type& tuple)
+        hpx::lcos::future<int> write_async(tuple_type const& tuple)
         {
             HPX_ASSERT(this->get_id());
             return this->base_type::write_async(this->get_id(), tuple);
@@ -121,7 +121,7 @@ namespace examples
         /// put \p tuple into tuplespace.
         ///
         /// \note This function is fully synchronous.
-        int write(hpx::launch::sync_policy, const tuple_type& tuple)
+        int write(hpx::launch::sync_policy, tuple_type const& tuple)
         {
             HPX_ASSERT(this->get_id());
             return this->base_type::write(hpx::launch::sync, this->get_id(), tuple);
@@ -134,7 +134,7 @@ namespace examples
         ///       for the action to be executed. Instead, it will return
         ///       immediately after the action has has been dispatched.
         hpx::lcos::future<tuple_type>
-            read_async(const tuple_type& tp, long const timeout)
+            read_async(tuple_type const& tp, double const timeout)
         {
             HPX_ASSERT(this->get_id());
             return this->base_type::read_async(this->get_id(), tp, timeout);
@@ -144,8 +144,8 @@ namespace examples
         ///
         /// \note This function is fully synchronous.
         //[simple_central_tuplespace_client_read_sync
-        tuple_type read(hpx::launch::sync_policy, const tuple_type& tp,
-            long const timeout)
+        tuple_type read(hpx::launch::sync_policy, tuple_type const& tp,
+            double const timeout)
         {
             HPX_ASSERT(this->get_id());
             return this->base_type::read(hpx::launch::sync, this->get_id(),
@@ -163,7 +163,7 @@ namespace examples
         ///          until the value is ready.
         //[simple_central_tuplespace_client_take_async
         hpx::lcos::future<tuple_type>
-            take_async(const tuple_type& tp, long const timeout)
+            take_async(tuple_type const& tp, double const timeout)
         {
             HPX_ASSERT(this->get_id());
             return this->base_type::take(hpx::launch::async, this->get_id(),
@@ -174,8 +174,8 @@ namespace examples
         /// take matching tuple from tuplespace within \p timeout.
         ///
         /// \note This function is fully synchronous.
-        tuple_type take(hpx::launch::sync_policy, const tuple_type& tp,
-            long const timeout)
+        tuple_type take(hpx::launch::sync_policy, tuple_type const& tp,
+            double const timeout)
         {
             HPX_ASSERT(this->get_id());
             return this->base_type::take(hpx::launch::sync, this->get_id(),
diff --git a/examples/tuplespace/central_tuplespace/stubs/simple_central_tuplespace.hpp b/examples/tuplespace/central_tuplespace/stubs/simple_central_tuplespace.hpp
index 71eb269018..007e9405a2 100644
--- a/examples/tuplespace/central_tuplespace/stubs/simple_central_tuplespace.hpp
+++ b/examples/tuplespace/central_tuplespace/stubs/simple_central_tuplespace.hpp
@@ -55,8 +55,8 @@ namespace examples { namespace stubs
         ///       for the action to be executed. Instead, it will return
         ///       immediately after the action has has been dispatched.
         static hpx::lcos::future<tuple_type>
-        read_async(hpx::naming::id_type const& gid, const tuple_type& tp,
-            long const timeout)
+        read_async(hpx::naming::id_type const& gid, tuple_type const& tp,
+            double const timeout)
         {
             typedef server::simple_central_tuplespace::read_action action_type;
             return hpx::async<action_type>(gid, tp, timeout);
@@ -68,7 +68,7 @@ namespace examples { namespace stubs
         //[simple_central_tuplespace_stubs_read_sync
         static tuple_type
         read(hpx::launch::sync_policy, hpx::naming::id_type const& gid,
-            const tuple_type& tp, long const timeout)
+            tuple_type const& tp, double const timeout)
         {
             typedef server::simple_central_tuplespace::read_action action_type;
             return hpx::async<action_type>(gid, tp, timeout).get();
@@ -86,7 +86,7 @@ namespace examples { namespace stubs
         //[simple_central_tuplespace_stubs_take_async
         static hpx::lcos::future<tuple_type>
         take(hpx::launch::async_policy, hpx::naming::id_type const& gid,
-            const tuple_type& tp, long const timeout)
+            tuple_type const& tp, double const timeout)
         {
             typedef server::simple_central_tuplespace::take_action action_type;
             return hpx::async<action_type>(gid, tp, timeout);
@@ -97,8 +97,8 @@ namespace examples { namespace stubs
         ///
         /// \note This function is fully synchronous.
         static tuple_type take(hpx::launch::sync_policy,
-            hpx::naming::id_type const& gid, const tuple_type& tp,
-            const long timeout)
+            hpx::naming::id_type const& gid, tuple_type const& tp,
+            double const timeout)
         {
             // The following get yields control while the action is executed.
             return take(hpx::launch::async, gid, tp, timeout).get();
diff --git a/examples/tuplespace/simple_central_tuplespace_client.cpp b/examples/tuplespace/simple_central_tuplespace_client.cpp
index f134230a81..4769400d7f 100644
--- a/examples/tuplespace/simple_central_tuplespace_client.cpp
+++ b/examples/tuplespace/simple_central_tuplespace_client.cpp
@@ -8,10 +8,9 @@
 #include <hpx/include/actions.hpp>
 #include <hpx/include/iostreams.hpp>
 #include <hpx/include/lcos.hpp>
-
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/trim.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/string_util/trim.hpp>
 
 #include <string>
 #include <vector>
@@ -23,7 +22,7 @@ typedef examples::server::simple_central_tuplespace central_tuplespace_type;
 typedef central_tuplespace_type::tuple_type tuple_type;
 typedef central_tuplespace_type::elem_type elem_type;
 
-void print_tuple(const tuple_type& tuple)
+void print_tuple(tuple_type const& tuple)
 {
     if (tuple.empty())
     {
@@ -41,7 +40,7 @@ void print_tuple(const tuple_type& tuple)
 }
 
 void simple_central_tuplespace_test(
-    const std::string& tuplespace_symbol_name, const tuple_type tuple)
+    std::string const& tuplespace_symbol_name, tuple_type const tuple)
 {
     examples::simple_central_tuplespace central_tuplespace;
 
@@ -105,7 +104,7 @@ int hpx_main()
         // Find the localities connected to this application.
         std::vector<hpx::id_type> localities = hpx::find_all_localities();
 
-        const std::string tuplespace_symbol_name = "/tuplespace";
+        std::string const tuplespace_symbol_name = "/tuplespace";
         examples::simple_central_tuplespace central_tuplespace;
 
         if (!central_tuplespace.create(
diff --git a/hpx/apply.hpp b/hpx/apply.hpp
index 192c671828..3a92709e45 100644
--- a/hpx/apply.hpp
+++ b/hpx/apply.hpp
@@ -11,17 +11,17 @@
 #include <hpx/runtime/applier/apply.hpp>
 #include <hpx/runtime/applier/apply_continue.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/runtime_fwd.hpp>
-#include <hpx/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/util/bind_action.hpp>
 #include <hpx/type_support/decay.hpp>
 #include <hpx/functional/deferred_call.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
 
 #include <type_traits>
 #include <utility>
@@ -86,12 +86,12 @@ namespace hpx { namespace detail
             traits::is_bound_action<Bound>::value
         >::type>
     {
-        template <typename Action, typename BoundArgs, typename ...Ts>
+        template <typename Action, typename Is, typename... Ts, typename ...Us>
         HPX_FORCEINLINE static bool
-        call(hpx::util::detail::bound_action<Action, BoundArgs> const& bound,
-            Ts&&... ts)
+        call(hpx::util::detail::bound_action<Action, Is, Ts...> const& bound,
+            Us&&... vs)
         {
-            return bound.apply(std::forward<Ts>(ts)...);
+            return bound.apply(std::forward<Us>(vs)...);
         }
     };
 }}
diff --git a/hpx/async.hpp b/hpx/async.hpp
index 7cde88c2b0..a1227f5a08 100644
--- a/hpx/async.hpp
+++ b/hpx/async.hpp
@@ -13,16 +13,16 @@
 #include <hpx/lcos/async_continue.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/functional/traits/is_action.hpp>
-#include <hpx/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/util/bind_action.hpp>
 #include <hpx/functional/deferred_call.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
 
 #include <exception>
 #include <functional>
@@ -47,8 +47,8 @@ namespace hpx { namespace detail
         call(F && f, Ts &&... ts)
         {
             parallel::execution::parallel_executor exec;
-            return parallel::execution::async_execute(
-                exec, std::forward<F>(f), std::forward<Ts>(ts)...);
+            return exec.async_execute(
+                std::forward<F>(f), std::forward<Ts>(ts)...);
         }
     };
 
@@ -88,15 +88,15 @@ namespace hpx { namespace detail
             traits::is_bound_action<Bound>::value
         >::type>
     {
-        template <typename Action, typename BoundArgs, typename ...Ts>
+        template <typename Action, typename Is, typename... Ts, typename ...Us>
         HPX_FORCEINLINE
         static hpx::future<typename hpx::util::detail::bound_action<
-            Action, BoundArgs
+            Action, Is, Ts...
         >::result_type>
-        call(hpx::util::detail::bound_action<Action, BoundArgs> const& bound,
-            Ts&&... ts)
+        call(hpx::util::detail::bound_action<Action, Is, Ts...> const& bound,
+            Us&&... vs)
         {
-            return bound.async(std::forward<Ts>(ts)...);
+            return bound.async(std::forward<Us>(vs)...);
         }
     };
 }}
diff --git a/hpx/async_launch_policy_dispatch.hpp b/hpx/async_launch_policy_dispatch.hpp
index a9224beafb..fb66e07063 100644
--- a/hpx/async_launch_policy_dispatch.hpp
+++ b/hpx/async_launch_policy_dispatch.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -8,18 +8,19 @@
 #define HPX_ASYNC_LAUNCH_POLICY_DISPATCH_NOV_26_2017_1243PM
 
 #include <hpx/config.hpp>
+#include <hpx/lcos/async_fwd.hpp>    // declare async_launch_policy_dispatch
+#include <hpx/lcos_fwd.hpp>          // declare futures_factory
+
 #include <hpx/assertion.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/traits/is_action.hpp>
-#include <hpx/lcos/async_fwd.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/local/futures_factory.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
 #include <exception>
 #include <type_traits>
@@ -98,12 +99,24 @@ namespace hpx { namespace detail
                     // make sure this thread is executed last
                     // yield_to
                     hpx::this_thread::suspend(threads::pending, tid,
-                        "async_launch_policy_dispatch<fork>");
+                        "async_launch_policy_dispatch<launch>");
                 }
             }
             return p.get_future();
         }
 
+        template <typename F, typename... Ts>
+        HPX_FORCEINLINE static typename std::enable_if<
+            traits::detail::is_deferred_invocable<F, Ts...>::value,
+            hpx::future<typename util::detail::invoke_deferred_result<F,
+                Ts...>::type>>::type
+        call(launch policy, threads::thread_schedule_hint hint, F&& f,
+            Ts&&... ts)
+        {
+            return call(policy, threads::detail::get_self_or_default_pool(),
+                hint, std::forward<F>(f), std::forward<Ts>(ts)...);
+        }
+
         template <typename F, typename... Ts>
         HPX_FORCEINLINE static typename std::enable_if<
             traits::detail::is_deferred_invocable<F, Ts...>::value,
diff --git a/hpx/custom_exception_info.hpp b/hpx/custom_exception_info.hpp
index 9f4007c835..9c02212967 100644
--- a/hpx/custom_exception_info.hpp
+++ b/hpx/custom_exception_info.hpp
@@ -11,7 +11,7 @@
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
+#include <hpx/naming_base.hpp>
 
 #include <boost/system/error_code.hpp>
 #include <boost/system/system_error.hpp>
@@ -105,8 +105,7 @@ namespace hpx {
             std::exception_ptr const&);
         HPX_EXPORT void report_exception_and_continue(hpx::exception const&);
 
-        template <typename Exception>
-        HPX_EXPORT std::exception_ptr construct_exception(Exception const& e,
+        HPX_EXPORT hpx::exception_info construct_exception_info(
             std::string const& func, std::string const& file, long line,
             std::string const& back_trace, std::uint32_t node,
             std::string const& hostname, std::int64_t pid, std::size_t shepherd,
@@ -114,6 +113,10 @@ namespace hpx {
             std::string const& env, std::string const& config,
             std::string const& state_name, std::string const& auxinfo);
 
+        template <typename Exception>
+        HPX_EXPORT std::exception_ptr construct_exception(
+            Exception const& e, hpx::exception_info info);
+
         HPX_EXPORT void pre_exception_handler();
     }    // namespace detail
     /// \endcond
diff --git a/hpx/hpx_init.hpp b/hpx/hpx_init.hpp
index 737bdd6e07..f0ff262299 100644
--- a/hpx/hpx_init.hpp
+++ b/hpx/hpx_init.hpp
@@ -16,7 +16,7 @@
 #include <hpx/hpx_finalize.hpp>
 #include <hpx/hpx_suspend.hpp>
 #include <hpx/program_options.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/functional/function.hpp>
@@ -779,6 +779,40 @@ namespace hpx
         std::vector<std::string> const& cfg,
         hpx::runtime_mode mode = hpx::runtime_mode_default);
 
+/// \cond NOINTERNAL
+    namespace resource {
+
+        // forward declaration only
+        class partitioner;
+    }
+/// \endcond
+
+    /// \brief Main entry point for launching the HPX runtime system.
+    ///
+    /// This is a simplified main entry point, which can be used to set up the
+    /// runtime for an HPX application. All initialization parameters for the
+    /// runtime are taken from the resource partitioner object provided.
+    ///
+    /// \param rp           [in] The resource partitioner object to use for
+    ///                     initializing the runtime.
+    /// \param startup      [in] A function to be executed inside a HPX
+    ///                     thread before \p f is called. If this parameter
+    ///                     is not given no function will be executed.
+    /// \param shutdown     [in] A function to be executed inside an HPX
+    ///                     thread while hpx::finalize is executed. If this
+    ///                     parameter is not given no function will be
+    ///                     executed.
+    ///
+    /// \returns            The function returns the value, which has been
+    ///                     returned from the user supplied function \p f.
+    ///
+    /// \note               The created runtime system instance will be
+    ///                     executed in console or worker mode depending on the
+    ///                     configuration passed in `cfg`.
+    inline int init(resource::partitioner& rp,
+        startup_function_type startup = startup_function_type(),
+        shutdown_function_type shutdown = shutdown_function_type());
+
 /// \cond NOINTERNAL
     inline int init(std::nullptr_t f, std::string const& app_name, int argc,
         char** argv, hpx::runtime_mode mode = hpx::runtime_mode_default);
diff --git a/hpx/hpx_init_impl.hpp b/hpx/hpx_init_impl.hpp
index 26f49fbc17..13f6abd1ce 100644
--- a/hpx/hpx_init_impl.hpp
+++ b/hpx/hpx_init_impl.hpp
@@ -13,11 +13,11 @@
 #include <hpx/hpx_init.hpp>
 #include <hpx/hpx_user_main_config.hpp>
 #include <hpx/program_options.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/functional/bind_back.hpp>
-#include <hpx/util/find_prefix.hpp>
+#include <hpx/prefix/find_prefix.hpp>
 #include <hpx/functional/function.hpp>
 
 #include <csignal>
@@ -46,6 +46,10 @@ namespace hpx
             startup_function_type startup, shutdown_function_type shutdown,
             hpx::runtime_mode mode, bool blocking);
 
+        HPX_EXPORT int run_or_start(resource::partitioner& rp,
+            startup_function_type startup, shutdown_function_type shutdown,
+            bool blocking);
+
 #if defined(HPX_WINDOWS)
         void init_winsocket();
 #endif
@@ -396,9 +400,32 @@ namespace hpx
     init(std::nullptr_t, std::vector<std::string> const& cfg,
          hpx::runtime_mode mode)
     {
-      char *dummy_argv[2] = { const_cast<char*>(HPX_APPLICATION_STRING), nullptr };
+        char* dummy_argv[2] = {
+            const_cast<char*>(HPX_APPLICATION_STRING), nullptr};
+
+        return init(nullptr, 1, dummy_argv, cfg, mode);
+    }
+
+    ////////////////////////////////////////////////////////////////////////////
+    inline int init(resource::partitioner& rp, startup_function_type startup,
+        shutdown_function_type shutdown)
+    {
+#if defined(HPX_WINDOWS)
+        detail::init_winsocket();
+#endif
+        util::set_hpx_prefix(HPX_PREFIX);
+#if defined(__FreeBSD__)
+        freebsd_environ = environ;
+#endif
+        // set a handler for std::abort
+        std::signal(SIGABRT, detail::on_abort);
+        std::atexit(detail::on_exit);
+#if defined(HPX_HAVE_CXX11_STD_QUICK_EXIT)
+        std::at_quick_exit(detail::on_exit);
+#endif
 
-      return init(nullptr, 1, dummy_argv, cfg, mode);
+        return detail::run_or_start(
+            rp, std::move(startup), std::move(shutdown), true);
     }
 }
 
diff --git a/hpx/hpx_start.hpp b/hpx/hpx_start.hpp
index ad2db6b565..45053d91fc 100644
--- a/hpx/hpx_start.hpp
+++ b/hpx/hpx_start.hpp
@@ -13,7 +13,7 @@
 #include <hpx/config.hpp>
 #include <hpx/hpx_finalize.hpp>
 #include <hpx/program_options.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/functional/function.hpp>
@@ -806,6 +806,40 @@ namespace hpx
         std::vector<std::string> const& cfg,
         hpx::runtime_mode mode = hpx::runtime_mode_default);
 
+/// \cond NOINTERNAL
+    namespace resource {
+
+        // forward declaration only
+        class partitioner;
+    }
+/// \endcond
+
+    /// \brief Main non-blocking entry point for launching the HPX runtime system.
+    ///
+    /// This is a simplified main entry point, which can be used to set up the
+    /// runtime for an HPX application. All initialization parameters for the
+    /// runtime are taken from the resource partitioner object provided.
+    ///
+    /// \param rp           [in] The resource partitioner object to use for
+    ///                     initializing the runtime.
+    /// \param startup      [in] A function to be executed inside a HPX
+    ///                     thread before \p f is called. If this parameter
+    ///                     is not given no function will be executed.
+    /// \param shutdown     [in] A function to be executed inside an HPX
+    ///                     thread while hpx::finalize is executed. If this
+    ///                     parameter is not given no function will be
+    ///                     executed.
+    ///
+    /// \returns            The function returns the value, which has been
+    ///                     returned from the user supplied function \p f.
+    ///
+    /// \note               The created runtime system instance will be
+    ///                     executed in console or worker mode depending on the
+    ///                     configuration passed in `cfg`.
+    inline bool start(resource::partitioner& rp,
+        startup_function_type startup = startup_function_type(),
+        shutdown_function_type shutdown = shutdown_function_type());
+
 /// \cond NOINTERNAL
     inline bool start(std::nullptr_t f,
         std::string const& app_name, int argc, char** argv,
diff --git a/hpx/hpx_start_impl.hpp b/hpx/hpx_start_impl.hpp
index eedaa31ffe..6ae3814fa8 100644
--- a/hpx/hpx_start_impl.hpp
+++ b/hpx/hpx_start_impl.hpp
@@ -12,11 +12,11 @@
 #include <hpx/hpx_start.hpp>
 #include <hpx/hpx_user_main_config.hpp>
 #include <hpx/program_options.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/functional/bind_back.hpp>
-#include <hpx/util/find_prefix.hpp>
+#include <hpx/prefix/find_prefix.hpp>
 #include <hpx/functional/function.hpp>
 
 #include <csignal>
@@ -45,6 +45,10 @@ namespace hpx
             startup_function_type startup, shutdown_function_type shutdown,
             hpx::runtime_mode mode, bool blocking);
 
+        HPX_EXPORT int run_or_start(resource::partitioner& rp,
+            startup_function_type startup, shutdown_function_type shutdown,
+            bool blocking);
+
 #if defined(HPX_WINDOWS)
         void init_winsocket();
 #endif
@@ -385,9 +389,32 @@ namespace hpx
     inline bool start(std::nullptr_t f, std::vector<std::string> const& cfg,
         hpx::runtime_mode mode)
     {
-      char *dummy_argv[2] = { const_cast<char*>(HPX_APPLICATION_STRING), nullptr };
+        char* dummy_argv[2] = {
+            const_cast<char*>(HPX_APPLICATION_STRING), nullptr};
+
+        return start(nullptr, 1, dummy_argv, cfg, mode);
+    }
+
+    ////////////////////////////////////////////////////////////////////////////
+    inline bool start(resource::partitioner& rp, startup_function_type startup,
+        shutdown_function_type shutdown)
+    {
+#if defined(HPX_WINDOWS)
+        detail::init_winsocket();
+#endif
+        util::set_hpx_prefix(HPX_PREFIX);
+#if defined(__FreeBSD__)
+        freebsd_environ = environ;
+#endif
+        // set a handler for std::abort
+        std::signal(SIGABRT, detail::on_abort);
+        std::atexit(detail::on_exit);
+#if defined(HPX_HAVE_CXX11_STD_QUICK_EXIT)
+        std::at_quick_exit(detail::on_exit);
+#endif
 
-      return start(nullptr, 1, dummy_argv, cfg, mode);
+        return 0 == detail::run_or_start(
+            rp, std::move(startup), std::move(shutdown), false);
     }
 }
 
diff --git a/hpx/include/compression.hpp b/hpx/include/compression.hpp
index 01272aecd9..ecdd2855b8 100644
--- a/hpx/include/compression.hpp
+++ b/hpx/include/compression.hpp
@@ -12,5 +12,17 @@
 #include <hpx/plugins/binary_filter/snappy_serialization_filter.hpp>
 #include <hpx/plugins/binary_filter/zlib_serialization_filter.hpp>
 
+#if defined(HPX_HAVE_DEPRECATION_WARNINGS)
+  #if defined(HPX_MSVC)
+  #pragma message("The header hpx/include/compression.hpp is deprecated, \
+    please include directly the corresponding header \
+    hpx/plugins/binary_filter/<libname>_serialization_filter.hpp instead")
+  #else
+  #warning "The header hpx/include/compression.hpp is deprecated, \
+    please include directly the corresponding header \
+    hpx/plugins/binary_filter/<libname>_serialization_filter.hpp instead"
+  #endif
+#endif
+
 #endif
 
diff --git a/hpx/include/compression_registration.hpp b/hpx/include/compression_registration.hpp
index 976a4f0617..8401ac66b6 100644
--- a/hpx/include/compression_registration.hpp
+++ b/hpx/include/compression_registration.hpp
@@ -12,5 +12,17 @@
 #include <hpx/plugins/binary_filter/snappy_serialization_filter_registration.hpp>
 #include <hpx/plugins/binary_filter/zlib_serialization_filter_registration.hpp>
 
+#if defined(HPX_HAVE_DEPRECATION_WARNINGS)
+  #if defined(HPX_MSVC)
+  #pragma message("The header hpx/include/compression_registration.hpp is deprecated, \
+    please include directly the corresponding header \
+    hpx/plugins/binary_filter/<libname>_serialization_filter_registration.hpp instead")
+  #else
+  #warning "The header hpx/include/compression_registration.hpp is deprecated, \
+    please include directly the corresponding header \
+    hpx/plugins/binary_filter/<libname>_serialization_filter_registration.hpp instead"
+  #endif
+#endif
+
 #endif
 
diff --git a/hpx/include/parallel_exception_list.hpp b/hpx/include/parallel_exception_list.hpp
index c13f627f25..a7344b3dde 100644
--- a/hpx/include/parallel_exception_list.hpp
+++ b/hpx/include/parallel_exception_list.hpp
@@ -8,7 +8,7 @@
 #define HPX_PARALLEL_EXCEPTION_LIST_MAY_27_2014_0910PM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/exception_list.hpp>
+#include <hpx/execution/exception_list.hpp>
 
 #endif
 
diff --git a/hpx/include/parallel_execution.hpp b/hpx/include/parallel_execution.hpp
index 88ea565e8d..217638710d 100644
--- a/hpx/include/parallel_execution.hpp
+++ b/hpx/include/parallel_execution.hpp
@@ -8,8 +8,8 @@
 #define HPX_EXECUTION
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/execution.hpp>
-#include <hpx/parallel/executors.hpp>
+#include <hpx/execution/execution.hpp>
+#include <hpx/execution/executors.hpp>
 
 #endif
 
diff --git a/hpx/include/parallel_execution_policy.hpp b/hpx/include/parallel_execution_policy.hpp
index 93ba568060..08ac69b0a8 100644
--- a/hpx/include/parallel_execution_policy.hpp
+++ b/hpx/include/parallel_execution_policy.hpp
@@ -8,7 +8,7 @@
 #define HPX_EXECUTION_POLICY_MAY_27_2014_0910PM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/execution_policy.hpp>
+#include <hpx/execution/execution_policy.hpp>
 
 #endif
 
diff --git a/hpx/include/parallel_executor_information.hpp b/hpx/include/parallel_executor_information.hpp
index 28b8fb0622..b8a138d97f 100644
--- a/hpx/include/parallel_executor_information.hpp
+++ b/hpx/include/parallel_executor_information.hpp
@@ -9,7 +9,7 @@
 
 #include <hpx/config.hpp>
 
-#include <hpx/parallel/executors/execution_information.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
 
 #endif
diff --git a/hpx/include/parallel_executor_parameters.hpp b/hpx/include/parallel_executor_parameters.hpp
index cf521023cf..1d754d6461 100644
--- a/hpx/include/parallel_executor_parameters.hpp
+++ b/hpx/include/parallel_executor_parameters.hpp
@@ -7,12 +7,12 @@
 #if !defined(HPX_PARALLEL_EXECUTOR_PARAMETERS_JUL_31_2015_0850PM)
 #define HPX_PARALLEL_EXECUTOR_PARAMETERS_JUL_31_2015_0850PM
 
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 
-#include <hpx/parallel/executors/auto_chunk_size.hpp>
-#include <hpx/parallel/executors/dynamic_chunk_size.hpp>
-#include <hpx/parallel/executors/guided_chunk_size.hpp>
-#include <hpx/parallel/executors/persistent_auto_chunk_size.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
+#include <hpx/execution/executors/auto_chunk_size.hpp>
+#include <hpx/execution/executors/dynamic_chunk_size.hpp>
+#include <hpx/execution/executors/guided_chunk_size.hpp>
+#include <hpx/execution/executors/persistent_auto_chunk_size.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
 
 #endif
diff --git a/hpx/include/parallel_executors.hpp b/hpx/include/parallel_executors.hpp
index 379e527323..99c658273f 100644
--- a/hpx/include/parallel_executors.hpp
+++ b/hpx/include/parallel_executors.hpp
@@ -7,6 +7,6 @@
 #if !defined(HPX_PARALLEL_EXECUTORS_MAY_11_2015_0622PM)
 #define HPX_PARALLEL_EXECUTORS_MAY_11_2015_0622PM
 
-#include <hpx/parallel/executors.hpp>
+#include <hpx/execution/executors.hpp>
 
 #endif
diff --git a/hpx/include/runtime.hpp b/hpx/include/runtime.hpp
index 34297de711..1fb4b00068 100644
--- a/hpx/include/runtime.hpp
+++ b/hpx/include/runtime.hpp
@@ -13,6 +13,7 @@
 #include <hpx/include/components.hpp>
 #include <hpx/include/naming.hpp>
 #include <hpx/include/parcelset.hpp>
+#include <hpx/include/resource_partitioner.hpp>
 #include <hpx/include/threadmanager.hpp>
 #include <hpx/runtime.hpp>
 
diff --git a/hpx/include/threadmanager.hpp b/hpx/include/threadmanager.hpp
index da3dd2786e..59bc1cf5a4 100644
--- a/hpx/include/threadmanager.hpp
+++ b/hpx/include/threadmanager.hpp
@@ -9,10 +9,11 @@
 #if !defined(HPX_THREADMANAGER_MAY_20_2008_840AM)
 #define HPX_THREADMANAGER_MAY_20_2008_840AM
 
+#include <hpx/runtime/thread_pool_helpers.hpp>
 #include <hpx/runtime/threads/executors/embedded_thread_pool_executors.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/runtime/threads/threadmanager_counters.hpp>
 #include <hpx/topology/topology.hpp>
diff --git a/hpx/include/threads.hpp b/hpx/include/threads.hpp
index 4b3f5acdc0..1e564a0efd 100644
--- a/hpx/include/threads.hpp
+++ b/hpx/include/threads.hpp
@@ -7,16 +7,16 @@
 #if !defined(HPX_THREAD_APR_17_2012_1003AM)
 #define HPX_THREAD_APR_17_2012_1003AM
 
+#include <hpx/runtime/thread_pool_helpers.hpp>
 #include <hpx/runtime/threads/executors.hpp>
-#include <hpx/runtime/threads/scheduler_specific_ptr.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_specific_ptr.hpp>
+#include <hpx/threading.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_specific_ptr.hpp>
 #include <hpx/topology/topology.hpp>
 #include <hpx/runtime/threads/run_as_os_thread.hpp>
 #include <hpx/runtime/threads/run_as_hpx_thread.hpp>
 #include <hpx/runtime/threads/thread_pool_suspension_helpers.hpp>
-#include <hpx/runtime/threads/thread_pools.hpp>
+#include <hpx/thread_pools.hpp>
 
 #endif
 
diff --git a/hpx/include/traits.hpp b/hpx/include/traits.hpp
index c621240e55..42c9507fee 100644
--- a/hpx/include/traits.hpp
+++ b/hpx/include/traits.hpp
@@ -54,13 +54,13 @@
 #include <hpx/traits/is_component.hpp>
 #include <hpx/traits/is_continuation.hpp>
 #include <hpx/traits/is_distribution_policy.hpp>
-#include <hpx/traits/is_executor.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/traits/is_future.hpp>
 #include <hpx/traits/is_future_range.hpp>
 #include <hpx/traits/is_future_tuple.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
-#include <hpx/traits/is_timed_executor.hpp>
+#include <hpx/execution/traits/is_timed_executor.hpp>
 #include <hpx/traits/is_valid_action.hpp>
 #include <hpx/traits/managed_component_policies.hpp>
 #include <hpx/traits/pointer_category.hpp>
diff --git a/hpx/include/util.hpp b/hpx/include/util.hpp
index 62c0b2d3ed..2c690e748f 100644
--- a/hpx/include/util.hpp
+++ b/hpx/include/util.hpp
@@ -15,6 +15,7 @@
 #include <hpx/functional/bind_front.hpp>
 #include <hpx/functional/function.hpp>
 #include <hpx/functional/function_ref.hpp>
+#include <hpx/functional/unique_function.hpp>
 #include <hpx/iterator_support/iterator_adaptor.hpp>
 #include <hpx/iterator_support/iterator_facade.hpp>
 #include <hpx/preprocessor/cat.hpp>
@@ -27,16 +28,15 @@
 #include <hpx/timing/high_resolution_timer.hpp>
 #include <hpx/type_support/decay.hpp>
 #include <hpx/util/activate_counters.hpp>
-#include <hpx/util/annotated_function.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/util/get_and_reset_value.hpp>
 #include <hpx/util/interval_timer.hpp>
-#include <hpx/util/parse_command_line.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/command_line_handling/parse_command_line.hpp>
 #include <hpx/util/thread_aware_timer.hpp>
-#include <hpx/functional/unique_function.hpp>
+#include <hpx/util/to_string.hpp>
 #include <hpx/util/unwrap.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/util/zip_iterator.hpp>
-#include <hpx/util/get_and_reset_value.hpp>
 
 #endif
-
diff --git a/hpx/lcos/async_continue_fwd.hpp b/hpx/lcos/async_continue_fwd.hpp
index 1750013d0f..3cb06a2458 100644
--- a/hpx/lcos/async_continue_fwd.hpp
+++ b/hpx/lcos/async_continue_fwd.hpp
@@ -12,6 +12,7 @@
 #include <hpx/config.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/lcos/future.hpp>
+#include <hpx/runtime/actions/basic_action_fwd.hpp>
 #include <hpx/traits/action_remote_result.hpp>
 #include <hpx/traits/extract_action.hpp>
 #include <hpx/traits/is_distribution_policy.hpp>
diff --git a/hpx/lcos/base_lco_with_value.hpp b/hpx/lcos/base_lco_with_value.hpp
index 2c0981db1f..6e535c1c76 100644
--- a/hpx/lcos/base_lco_with_value.hpp
+++ b/hpx/lcos/base_lco_with_value.hpp
@@ -25,7 +25,7 @@
 #include <hpx/runtime/naming/id_type.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/traits/is_component.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
 #include <hpx/type_support/unused.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
diff --git a/hpx/lcos/channel.hpp b/hpx/lcos/channel.hpp
index 1dcd69b51d..433daeebdc 100644
--- a/hpx/lcos/channel.hpp
+++ b/hpx/lcos/channel.hpp
@@ -162,8 +162,7 @@ namespace hpx { namespace lcos
                 channel<T>, lcos::server::channel<T>
             > base_type;
 
-        HPX_CONSTEXPR_OR_CONST
-        static std::size_t default_generation = std::size_t(-1);
+        static constexpr std::size_t default_generation = std::size_t(-1);
 
     public:
         // FIXME: this typedef is currently needed for traits::is_future_range
@@ -373,8 +372,7 @@ namespace hpx { namespace lcos
                 receive_channel<T>, lcos::server::channel<T>
             > base_type;
 
-        HPX_CONSTEXPR_OR_CONST
-        static std::size_t default_generation = std::size_t(-1);
+        static constexpr std::size_t default_generation = std::size_t(-1);
 
     public:
         // FIXME: this typedef is currently needed for traits::is_future_range
@@ -457,8 +455,7 @@ namespace hpx { namespace lcos
                 send_channel<T>, lcos::server::channel<T>
             > base_type;
 
-        HPX_CONSTEXPR_OR_CONST
-        static std::size_t default_generation = std::size_t(-1);
+        static constexpr std::size_t default_generation = std::size_t(-1);
 
     public:
         // FIXME: this typedef is currently needed for traits::is_future_range
diff --git a/hpx/lcos/dataflow.hpp b/hpx/lcos/dataflow.hpp
index d7cc7b2155..d7583e1886 100644
--- a/hpx/lcos/dataflow.hpp
+++ b/hpx/lcos/dataflow.hpp
@@ -4,9 +4,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #include <hpx/config.hpp>
 
 // #if defined(HPX_COMPUTE_DEVICE_CODE)
@@ -30,24 +27,24 @@
 #include <hpx/functional/traits/is_action.hpp>
 #include <hpx/lcos/detail/future_transforms.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
+#include <hpx/runtime/actions/basic_action_fwd.hpp>
 #include <hpx/runtime/get_worker_thread_num.hpp>
 #include <hpx/runtime/launch_policy.hpp>
+#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/traits/acquire_future.hpp>
 #include <hpx/traits/extract_action.hpp>
 #include <hpx/traits/future_access.hpp>
-#include <hpx/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/traits/is_future.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/traits/promise_local_result.hpp>
 #include <hpx/type_support/always_void.hpp>
-#include <hpx/util/annotated_function.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 #include <hpx/util/pack_traversal_async.hpp>
-#include <hpx/util/thread_description.hpp>
-
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
-#include <boost/ref.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -64,15 +61,10 @@ namespace hpx { namespace lcos { namespace detail
     template <typename F, typename Args>
     struct dataflow_not_callable
     {
-#if defined(HPX_HAVE_CXX14_RETURN_TYPE_DEDUCTION)
         static auto error(F f, Args args)
         {
             hpx::util::invoke_fused(std::move(f), std::move(args));
         }
-#else
-        static auto error(F f, Args args)
-         -> decltype(hpx::util::invoke_fused(std::move(f), std::move(args)));
-#endif
 
         using type = decltype(
             error(std::declval<F>(), std::declval<Args>()));
@@ -201,7 +193,7 @@ namespace hpx { namespace lcos { namespace detail
             parallel::execution::parallel_policy_executor<launch::async_policy>
                 exec{policy};
             parallel::execution::post(exec,
-                [HPX_CAPTURE_MOVE(this_)](Futures&& futures) -> void {
+                [this_ = std::move(this_)](Futures&& futures) -> void {
                     return this_->done(std::move(futures));
                 }, std::move(futures));
         }
@@ -251,7 +243,7 @@ namespace hpx { namespace lcos { namespace detail
             parallel::execution::parallel_policy_executor<launch::fork_policy>
                 exec{policy};
             parallel::execution::post(exec,
-                [HPX_CAPTURE_MOVE(this_)](Futures&& futures) -> void {
+                [this_ = std::move(this_)](Futures&& futures) -> void {
                     return this_->done(std::move(futures));
                 }, std::move(futures));
         }
@@ -288,7 +280,7 @@ namespace hpx { namespace lcos { namespace detail
         {
             hpx::intrusive_ptr<dataflow_frame> this_(this);
             parallel::execution::post(std::forward<Executor>(exec),
-                [HPX_CAPTURE_MOVE(this_)](Futures&& futures) -> void {
+                [this_ = std::move(this_)](Futures&& futures) -> void {
                     return this_->execute(is_void{}, std::move(futures));
                 }, std::move(futures));
         }
diff --git a/hpx/lcos/detail/async_colocated.hpp b/hpx/lcos/detail/async_colocated.hpp
index 8ec9a1b9dd..c3f0102053 100644
--- a/hpx/lcos/detail/async_colocated.hpp
+++ b/hpx/lcos/detail/async_colocated.hpp
@@ -9,6 +9,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/datastructures/tuple.hpp>
+#include <hpx/functional/bind.hpp>
+#include <hpx/functional/unique_function.hpp>
 #include <hpx/lcos/async_continue_fwd.hpp>
 #include <hpx/lcos/async_fwd.hpp>
 #include <hpx/lcos/detail/async_colocated_fwd.hpp>
@@ -20,31 +23,29 @@
 #include <hpx/traits/extract_action.hpp>
 #include <hpx/traits/is_continuation.hpp>
 #include <hpx/traits/promise_local_result.hpp>
-#include <hpx/functional/bind.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/bind_action.hpp>
 #include <hpx/util/functional/colocated_helpers.hpp>
-#include <hpx/functional/unique_function.hpp>
 
 #include <type_traits>
 #include <utility>
 
 namespace hpx { namespace detail
 {
-    template <typename Tuple>
-    struct async_colocated_bound_tuple;
+    template <typename Action, typename Ts = typename Action::arguments_type>
+    struct async_colocated_bound_action;
 
-    template <typename ...Ts>
-    struct async_colocated_bound_tuple<util::tuple<Ts...> >
+    template <typename Action, typename... Ts>
+    struct async_colocated_bound_action<Action, hpx::util::tuple<Ts...>>
     {
-        typedef
-            util::tuple<
-                hpx::util::detail::bound<
-                    hpx::util::functional::extract_locality
-                  , hpx::util::detail::placeholder<2ul>
-                  , hpx::id_type
-                >
-              , Ts...
-            >
+        typedef hpx::util::detail::bound_action<Action
+          , hpx::util::make_index_pack<1 + sizeof...(Ts)>
+          , hpx::util::detail::bound<
+                hpx::util::functional::extract_locality
+              , hpx::util::index_pack<0, 1>
+              , hpx::util::detail::placeholder<2ul>
+              , hpx::id_type>
+          , Ts...>
             type;
     };
 }}
@@ -53,13 +54,8 @@ namespace hpx { namespace detail
     HPX_UTIL_REGISTER_UNIQUE_FUNCTION_DECLARATION(                            \
         void (hpx::naming::id_type, hpx::naming::id_type)                     \
       , (hpx::util::functional::detail::async_continuation_impl<              \
-            hpx::util::detail::bound_action<                                  \
-                Action                                                        \
-              , hpx::detail::async_colocated_bound_tuple<                     \
-                    Action ::arguments_type                                   \
-                >::type                                                       \
-            >,                                                                \
-            hpx::util::unused_type                                            \
+            typename hpx::detail::async_colocated_bound_action<Action>::type  \
+          , hpx::util::unused_type                                            \
         >)                                                                    \
       , Name                                                                  \
     );                                                                        \
@@ -69,13 +65,8 @@ namespace hpx { namespace detail
     HPX_UTIL_REGISTER_UNIQUE_FUNCTION(                                        \
         void (hpx::naming::id_type, hpx::naming::id_type)                     \
       , (hpx::util::functional::detail::async_continuation_impl<              \
-            hpx::util::detail::bound_action<                                  \
-                Action                                                        \
-              , hpx::detail::async_colocated_bound_tuple<                     \
-                    Action ::arguments_type                                   \
-                >::type                                                       \
-            >,                                                                \
-            hpx::util::unused_type                                            \
+            typename hpx::detail::async_colocated_bound_action<Action>::type  \
+          , hpx::util::unused_type                                            \
         >)                                                                    \
       , Name                                                                  \
     );                                                                        \
diff --git a/hpx/lcos/detail/async_implementations.hpp b/hpx/lcos/detail/async_implementations.hpp
index 5e351eddb9..a56b9c5b5f 100644
--- a/hpx/lcos/detail/async_implementations.hpp
+++ b/hpx/lcos/detail/async_implementations.hpp
@@ -15,8 +15,8 @@
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/runtime/naming/address.hpp>
 #include <hpx/runtime/naming/id_type.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/traits/action_decorate_function.hpp>
 #include <hpx/traits/action_select_direct_execution.hpp>
diff --git a/hpx/lcos/detail/async_implementations_fwd.hpp b/hpx/lcos/detail/async_implementations_fwd.hpp
index 8f3c8865b5..a6ed8ddd18 100644
--- a/hpx/lcos/detail/async_implementations_fwd.hpp
+++ b/hpx/lcos/detail/async_implementations_fwd.hpp
@@ -11,7 +11,6 @@
 #include <hpx/lcos/async_fwd.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/traits/extract_action.hpp>
 
 namespace hpx { namespace detail
diff --git a/hpx/lcos/detail/async_unwrap_result_implementations.hpp b/hpx/lcos/detail/async_unwrap_result_implementations.hpp
index e20b1346fe..8f1e030a94 100644
--- a/hpx/lcos/detail/async_unwrap_result_implementations.hpp
+++ b/hpx/lcos/detail/async_unwrap_result_implementations.hpp
@@ -17,8 +17,8 @@
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/runtime/naming/address.hpp>
 #include <hpx/runtime/naming/id_type.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/traits/action_decorate_function.hpp>
 #include <hpx/traits/action_select_direct_execution.hpp>
@@ -44,6 +44,7 @@ namespace hpx { namespace detail
         typedef typename hpx::traits::extract_action<Action>::type action_type;
         typedef typename action_type::local_result_type result_type;
 
+        // NOLINTNEXTLINE(bugprone-branch-clone)
         if (policy == launch::sync || action_type::direct_execution::value)
         {
             return hpx::detail::sync_local_invoke_direct<
diff --git a/hpx/lcos/detail/async_unwrap_result_implementations_fwd.hpp b/hpx/lcos/detail/async_unwrap_result_implementations_fwd.hpp
index 784976a1cc..86a38077cf 100644
--- a/hpx/lcos/detail/async_unwrap_result_implementations_fwd.hpp
+++ b/hpx/lcos/detail/async_unwrap_result_implementations_fwd.hpp
@@ -11,7 +11,6 @@
 #include <hpx/lcos/async_fwd.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/traits/extract_action.hpp>
 
 namespace hpx { namespace detail
diff --git a/hpx/lcos/detail/future_data.hpp b/hpx/lcos/detail/future_data.hpp
index 7cfdc8ef53..793d4a4db8 100644
--- a/hpx/lcos/detail/future_data.hpp
+++ b/hpx/lcos/detail/future_data.hpp
@@ -17,8 +17,10 @@
 #include <hpx/synchronization/spinlock.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
 #include <hpx/runtime/launch_policy.hpp>
+#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/thread_support/assert_owns_lock.hpp>
 #include <hpx/thread_support/atomic_count.hpp>
 #include <hpx/timing/steady_clock.hpp>
@@ -26,7 +28,7 @@
 #include <hpx/traits/get_remote_result.hpp>
 #include <hpx/type_support/decay.hpp>
 #include <hpx/type_support/unused.hpp>
-#include <hpx/util/annotated_function.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 
 #include <boost/container/small_vector.hpp>
 
@@ -678,6 +680,13 @@ namespace hpx { namespace lcos { namespace detail {
         {
         }
 
+        future_data_allocator(
+            init_no_addref no_addref, other_allocator const& alloc)
+          : future_data<Result>(no_addref)
+          , alloc_(alloc)
+        {
+        }
+
         template <typename... T>
         future_data_allocator(init_no_addref no_addref, in_place in_place,
             other_allocator const& alloc, T&&... ts)
@@ -734,7 +743,8 @@ namespace hpx { namespace lcos { namespace detail {
 
             error_code ec;
             threads::thread_id_type id = threads::register_thread_nullary(
-                [HPX_CAPTURE_MOVE(this_), HPX_CAPTURE_FORWARD(init)]() {
+                [this_ = std::move(this_),
+                    init = std::forward<Result_>(init)]() {
                     this_->set_value(init);
                 },
                 "timed_future_data<Result>::timed_future_data",
diff --git a/hpx/lcos/future.hpp b/hpx/lcos/future.hpp
index a07288eae7..03e6522637 100644
--- a/hpx/lcos/future.hpp
+++ b/hpx/lcos/future.hpp
@@ -30,7 +30,7 @@
 #include <hpx/traits/future_access.hpp>
 #include <hpx/traits/future_then_result.hpp>
 #include <hpx/traits/future_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/traits/is_future.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/type_support/always_void.hpp>
@@ -1167,10 +1167,8 @@ namespace hpx { namespace lcos
         >::type
         convert_future_helper(Future && f, Conv && conv) //-V659
         {
-            return f.then(
-                hpx::launch::sync,
-                [HPX_CAPTURE_FORWARD(conv)](Future && f) -> T
-                {
+            return f.then(hpx::launch::sync,
+                [conv = std::forward<Conv>(conv)](Future&& f) -> T {
                     return hpx::util::invoke(conv, f.get());
                 });
         }
@@ -1454,10 +1452,8 @@ namespace hpx { namespace lcos
             "the argument type must be convertible to the requested "
             "result type by using the supplied conversion function");
 
-        return f.then(
-                hpx::launch::sync,
-            [HPX_CAPTURE_FORWARD(conv)](hpx::shared_future<U> const& f)
-            {
+        return f.then(hpx::launch::sync,
+            [conv = std::forward<Conv>(conv)](hpx::shared_future<U> const& f) {
                 return hpx::util::invoke(conv, f.get());
             });
     }
diff --git a/hpx/lcos/local/futures_factory.hpp b/hpx/lcos/local/futures_factory.hpp
index 98d5d1d7f0..6400029363 100644
--- a/hpx/lcos/local/futures_factory.hpp
+++ b/hpx/lcos/local/futures_factory.hpp
@@ -18,12 +18,11 @@
 #include <hpx/memory/intrusive_ptr.hpp>
 #include <hpx/runtime/get_worker_thread_num.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/traits/future_access.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
+#include <hpx/execution/executors/execution.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -255,43 +254,23 @@ namespace hpx { namespace lcos { namespace local {
                 threads::thread_schedule_hint schedulehint,
                 error_code& ec) override
             {
-                this->check_started();
-
-                typedef typename Base::future_base_type future_base_type;
-                future_base_type this_(this);
-
                 if (exec_)
                 {
+                    this->check_started();
+
+                    typedef typename Base::future_base_type future_base_type;
+                    future_base_type this_(this);
+
                     parallel::execution::post(*exec_,
                         util::deferred_call(
                             &base_type::run_impl, std::move(this_)),
-                        exec_->get_schedulehint(), annotation);
-                    return threads::invalid_thread_id;
-                }
-                else if (policy == launch::fork)
-                {
-                    return threads::register_thread_nullary(pool,
-                        util::deferred_call(
-                            &base_type::run_impl, std::move(this_)),
-                        util::thread_description(
-                            this->f_, annotation),
-                        threads::pending_do_not_schedule, true,
-                        threads::thread_priority_boost,
-                        threads::thread_schedule_hint(
-                            static_cast<std::int16_t>(get_worker_thread_num())),
-                        stacksize, ec);
-                }
-                else
-                {
-                    threads::register_thread_nullary(pool,
-                        util::deferred_call(
-                            &base_type::run_impl, std::move(this_)),
-                        util::thread_description(
-                            this->f_, annotation),
-                        threads::pending, false, priority, schedulehint,
-                        stacksize, ec);
+                        schedulehint, annotation);
                     return threads::invalid_thread_id;
                 }
+
+                return this->base_type::apply(
+                    pool, annotation, policy, priority, stacksize,
+                    schedulehint, ec);
             }
         };
 
diff --git a/hpx/lcos/local/packaged_continuation.hpp b/hpx/lcos/local/packaged_continuation.hpp
index aede71ed9e..cde65d92af 100644
--- a/hpx/lcos/local/packaged_continuation.hpp
+++ b/hpx/lcos/local/packaged_continuation.hpp
@@ -18,11 +18,11 @@
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/traits/future_access.hpp>
 #include <hpx/traits/future_traits.hpp>
-#include <hpx/util/annotated_function.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/post_policy_dispatch.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/post_policy_dispatch.hpp>
 
 #include <exception>
 #include <functional>
@@ -146,8 +146,8 @@ namespace hpx { namespace lcos { namespace detail
             hpx::intrusive_ptr<Continuation> cont_(&cont);
             ptr->execute_deferred();
             ptr->set_on_completed(
-                [HPX_CAPTURE_MOVE(inner_state),
-                    HPX_CAPTURE_MOVE(cont_)
+                [inner_state = std::move(inner_state),
+                    cont_ = std::move(cont_)
                 ]() mutable -> void {
                     return transfer_result<inner_future>(
                         std::move(inner_state), std::move(cont_));
@@ -382,8 +382,8 @@ namespace hpx { namespace lcos { namespace detail
             parallel::execution::detail::post_policy_dispatch<
                     hpx::launch::async_policy
                 >::call(hpx::launch::async, desc,
-                    [HPX_CAPTURE_MOVE(this_),
-                        HPX_CAPTURE_MOVE(f)
+                    [this_ = std::move(this_),
+                        f = std::move(f)
                     ]() mutable -> void {
                         this_->async_impl(std::move(f));
                     });
@@ -428,8 +428,8 @@ namespace hpx { namespace lcos { namespace detail
             parallel::execution::detail::post_policy_dispatch<
                     hpx::launch::async_policy
                 >::call(hpx::launch::async, desc,
-                    [HPX_CAPTURE_MOVE(this_),
-                        HPX_CAPTURE_MOVE(f)
+                    [this_ = std::move(this_),
+                        f = std::move(f)
                     ]() mutable -> void {
                         this_->async_impl_nounwrap(std::move(f));
                     });
@@ -469,8 +469,8 @@ namespace hpx { namespace lcos { namespace detail
 
             hpx::intrusive_ptr<continuation> this_(this);
             parallel::execution::post(std::forward<Executor>(exec),
-                [HPX_CAPTURE_MOVE(this_),
-                    HPX_CAPTURE_MOVE(f)
+                [this_ = std::move(this_),
+                    f = std::move(f)
                 ]() mutable -> void {
                     this_->async_exec_impl(std::move(f));
                 });
@@ -556,9 +556,9 @@ namespace hpx { namespace lcos { namespace detail
 
             ptr->execute_deferred();
             ptr->set_on_completed(
-                [HPX_CAPTURE_MOVE(this_),
-                    HPX_CAPTURE_MOVE(state),
-                    HPX_CAPTURE_FORWARD(policy)
+                [this_ = std::move(this_),
+                    state = std::move(state),
+                    policy = std::forward<Policy>(policy)
                 ]() mutable -> void {
                     if (hpx::detail::has_async_policy(policy))
                         this_->async(std::move(state), policy.priority());
@@ -591,9 +591,9 @@ namespace hpx { namespace lcos { namespace detail
 
             ptr->execute_deferred();
             ptr->set_on_completed(
-                [HPX_CAPTURE_MOVE(this_),
-                    HPX_CAPTURE_MOVE(state),
-                    HPX_CAPTURE_FORWARD(policy)
+                [this_ = std::move(this_),
+                    state = std::move(state),
+                    policy = std::forward<Policy>(policy)
                 ]() mutable -> void {
                     if (hpx::detail::has_async_policy(policy))
                         this_->async_nounwrap(std::move(state), policy.priority());
@@ -626,8 +626,8 @@ namespace hpx { namespace lcos { namespace detail
 
             ptr->execute_deferred();
             ptr->set_on_completed(
-                [HPX_CAPTURE_MOVE(this_),
-                    HPX_CAPTURE_MOVE(state),
+                [this_ = std::move(this_),
+                    state = std::move(state),
                     &exec
                 ]() mutable -> void {
                     this_->async_exec(std::move(state), exec);
@@ -657,9 +657,9 @@ namespace hpx { namespace lcos { namespace detail
 
             ptr->execute_deferred();
             ptr->set_on_completed(
-                [HPX_CAPTURE_MOVE(this_),
-                    HPX_CAPTURE_MOVE(state),
-                    HPX_CAPTURE_MOVE(exec)
+                [this_ = std::move(this_),
+                    state = std::move(state),
+                    exec = std::move(exec)
                 ]() mutable -> void {
                     return this_->async_exec(std::move(state), std::move(exec));
                 });
@@ -910,8 +910,8 @@ namespace hpx { namespace lcos { namespace detail
 
                 ptr->execute_deferred();
                 ptr->set_on_completed(
-                    [HPX_CAPTURE_MOVE(this_),
-                        HPX_CAPTURE_MOVE(inner_state)
+                    [this_ = std::move(this_),
+                        inner_state = std::move(inner_state)
                     ]() mutable -> void {
                         return this_->template on_inner_ready<inner_future>(
                             std::move(inner_state));
@@ -956,8 +956,8 @@ namespace hpx { namespace lcos { namespace detail
 
             ptr->execute_deferred();
             ptr->set_on_completed(
-                [HPX_CAPTURE_MOVE(this_),
-                    HPX_CAPTURE_MOVE(outer_state)
+                [this_ = std::move(this_),
+                    outer_state = std::move(outer_state)
                 ]() mutable -> void {
                     return this_->template on_outer_ready<Future>(std::move(outer_state));
                 });
diff --git a/hpx/lcos/local/spmd_block.hpp b/hpx/lcos/local/spmd_block.hpp
index 1ac7eadb88..c6bc58de8a 100644
--- a/hpx/lcos/local/spmd_block.hpp
+++ b/hpx/lcos/local/spmd_block.hpp
@@ -10,10 +10,10 @@
 #include <hpx/lcos/future.hpp>
 #include <hpx/synchronization/barrier.hpp>
 #include <hpx/synchronization/mutex.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/functional/first_argument.hpp>
 
 #include <boost/range/irange.hpp>
@@ -122,8 +122,7 @@ namespace hpx { namespace lcos { namespace local
 
         template<typename ... I>
         typename std::enable_if<
-            util::detail::all_of<
-                typename std::is_integral<I>::type ... >::value
+            util::all_of<typename std::is_integral<I>::type...>::value
         >::type
         sync_images(I ... i) const
         {
diff --git a/hpx/lcos/packaged_action.hpp b/hpx/lcos/packaged_action.hpp
index 83d7b0a766..c634fdb05e 100644
--- a/hpx/lcos/packaged_action.hpp
+++ b/hpx/lcos/packaged_action.hpp
@@ -139,7 +139,7 @@ namespace hpx { namespace lcos {
             auto&& f = detail::parcel_write_handler<Result>{this->shared_state_};
 #else
             auto shared_state = this->shared_state_;
-            auto&& f = [HPX_CAPTURE_MOVE(shared_state)]() {};
+            auto&& f = [shared_state = std::move(shared_state)]() {};
 #endif
             naming::address resolved_addr(this->resolve());
             naming::id_type cont_id(this->get_id(false));
@@ -176,7 +176,7 @@ namespace hpx { namespace lcos {
             auto&& f = detail::parcel_write_handler<Result>{this->shared_state_};
 #else
             auto shared_state = this->shared_state_;
-            auto&& f = [HPX_CAPTURE_MOVE(shared_state)]() {};
+            auto&& f = [shared_state = std::move(shared_state)]() {};
 #endif
 
             naming::address resolved_addr(this->resolve());
@@ -206,11 +206,8 @@ namespace hpx { namespace lcos {
                 this->shared_state_, std::forward<Callback>(cb)};
 #else
             auto shared_state = this->shared_state_;
-            auto&& f =
-                [HPX_CAPTURE_MOVE(shared_state), HPX_CAPTURE_FORWARD(cb)]()
-                {
-                    cb();
-                };
+            auto&& f = [shared_state = std::move(shared_state),
+                           cb = std::forward<Callback>(cb)]() { cb(); };
 #endif
 
             naming::address resolved_addr(this->resolve());
@@ -251,11 +248,8 @@ namespace hpx { namespace lcos {
                 this->shared_state_, std::forward<Callback>(cb)};
 #else
             auto shared_state = this->shared_state_;
-            auto&& f =
-                [HPX_CAPTURE_MOVE(shared_state), HPX_CAPTURE_FORWARD(cb)]()
-                {
-                    cb();
-                };
+            auto&& f = [shared_state = std::move(shared_state),
+                           cb = std::forward<Callback>(cb)]() { cb(); };
 #endif
 
             naming::address resolved_addr(this->resolve());
@@ -360,7 +354,7 @@ namespace hpx { namespace lcos {
             auto&& f = detail::parcel_write_handler<Result>{this->shared_state_};
 #else
             auto shared_state = this->shared_state_;
-            auto&& f = [HPX_CAPTURE_MOVE(shared_state)]() {};
+            auto&& f = [shared_state = std::move(shared_state)]() {};
 #endif
 
             naming::id_type cont_id(this->get_id(false));
@@ -388,11 +382,8 @@ namespace hpx { namespace lcos {
                 this->shared_state_, std::forward<Callback>(cb)};
 #else
             auto shared_state = this->shared_state_;
-            auto&& f =
-                [HPX_CAPTURE_MOVE(shared_state),HPX_CAPTURE_FORWARD(cb)]()
-                {
-                    cb();
-                };
+            auto&& f = [shared_state = std::move(shared_state),
+                           cb = std::forward<Callback>(cb)]() { cb(); };
 #endif
 
             naming::id_type cont_id(this->get_id(false));
diff --git a/hpx/lcos/split_future.hpp b/hpx/lcos/split_future.hpp
index d9acf504c8..0bc8833b6b 100644
--- a/hpx/lcos/split_future.hpp
+++ b/hpx/lcos/split_future.hpp
@@ -67,7 +67,6 @@ namespace hpx
 #else // DOXYGEN
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/deferred_call.hpp>
@@ -79,6 +78,7 @@ namespace hpx
 #include <hpx/traits/acquire_shared_state.hpp>
 #include <hpx/traits/future_access.hpp>
 #include <hpx/traits/future_traits.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/type_support/unused.hpp>
 
 #include <array>
@@ -192,7 +192,7 @@ namespace hpx { namespace lcos
         HPX_FORCEINLINE
         hpx::util::tuple<hpx::future<Ts>...>
         split_future_helper(hpx::future<hpx::util::tuple<Ts...> > && f,
-            hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::util::index_pack<Is...>)
         {
             return hpx::util::make_tuple(extract_nth_future<Is>(f)...);
         }
@@ -201,7 +201,7 @@ namespace hpx { namespace lcos
         HPX_FORCEINLINE
         hpx::util::tuple<hpx::future<Ts>...>
         split_future_helper(hpx::shared_future<hpx::util::tuple<Ts...> > && f,
-            hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::util::index_pack<Is...>)
         {
             return hpx::util::make_tuple(extract_nth_future<Is>(f)...);
         }
@@ -320,10 +320,8 @@ namespace hpx { namespace lcos
     HPX_FORCEINLINE hpx::util::tuple<hpx::future<Ts>...>
     split_future(hpx::future<hpx::util::tuple<Ts...> > && f)
     {
-        return detail::split_future_helper(
-                std::move(f),
-                typename hpx::util::detail::make_index_pack<sizeof...(Ts)>::type()
-            );
+        return detail::split_future_helper(std::move(f),
+            typename hpx::util::make_index_pack<sizeof...(Ts)>::type());
     }
 
     HPX_FORCEINLINE hpx::util::tuple<hpx::future<void> >
@@ -332,14 +330,12 @@ namespace hpx { namespace lcos
         return hpx::util::make_tuple(hpx::future<void>(std::move(f)));
     }
 
-    template <typename ... Ts>
-    HPX_FORCEINLINE hpx::util::tuple<hpx::future<Ts>...>
-    split_future(hpx::shared_future<hpx::util::tuple<Ts...> > && f)
+    template <typename... Ts>
+    HPX_FORCEINLINE hpx::util::tuple<hpx::future<Ts>...> split_future(
+        hpx::shared_future<hpx::util::tuple<Ts...>>&& f)
     {
-        return detail::split_future_helper(
-                std::move(f),
-                typename hpx::util::detail::make_index_pack<sizeof...(Ts)>::type()
-            );
+        return detail::split_future_helper(std::move(f),
+            typename hpx::util::make_index_pack<sizeof...(Ts)>::type());
     }
 
     HPX_FORCEINLINE hpx::util::tuple<hpx::future<void> >
diff --git a/hpx/lcos/wait_all.hpp b/hpx/lcos/wait_all.hpp
index 0005ab8caf..620ba33a85 100644
--- a/hpx/lcos/wait_all.hpp
+++ b/hpx/lcos/wait_all.hpp
@@ -5,9 +5,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 /// \file lcos/wait_all.hpp
 
 #if !defined(HPX_LCOS_WAIT_ALL_APR_19_2012_1140AM)
@@ -119,8 +116,6 @@ namespace hpx
 #include <hpx/type_support/decay.hpp>
 #include <hpx/type_support/unwrap_ref.hpp>
 
-#include <boost/ref.hpp>
-
 #include <algorithm>
 #include <array>
 #include <cstddef>
@@ -152,11 +147,6 @@ namespace hpx { namespace lcos
           : is_future_or_shared_state<R>
         {};
 
-        template <typename R>
-        struct is_future_or_shared_state<boost::reference_wrapper<R> >
-          : is_future_or_shared_state<R>
-        {};
-
         ///////////////////////////////////////////////////////////////////////
         template <typename Range, typename Enable = void>
         struct is_future_or_shared_state_range
@@ -260,7 +250,7 @@ namespace hpx { namespace lcos
                             // in the sequence (if any).
                             next_future_data->set_on_completed(
                                 [this,
-                                    HPX_CAPTURE_MOVE(next), HPX_CAPTURE_MOVE(end)
+                                    next = std::move(next), end = std::move(end)
                                 ]() mutable -> void {
                                     return await_range<I>(
                                         std::move(next), std::move(end));
diff --git a/hpx/lcos/wait_any.hpp b/hpx/lcos/wait_any.hpp
index ed76f6117e..f4d5c86707 100644
--- a/hpx/lcos/wait_any.hpp
+++ b/hpx/lcos/wait_any.hpp
@@ -166,12 +166,10 @@ namespace hpx
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/wait_some.hpp>
 #include <hpx/preprocessor/strip_parens.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/type_support/always_void.hpp>
 #include <hpx/datastructures/tuple.hpp>
 
-#include <boost/utility/swap.hpp>
-
 #include <array>
 #include <cstddef>
 #include <utility>
diff --git a/hpx/lcos/wait_each.hpp b/hpx/lcos/wait_each.hpp
index 84a92df227..cc73a0509d 100644
--- a/hpx/lcos/wait_each.hpp
+++ b/hpx/lcos/wait_each.hpp
@@ -120,7 +120,7 @@ namespace hpx
 #include <hpx/config.hpp>
 #include <hpx/lcos/when_each.hpp>
 #include <hpx/traits/is_future.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -166,7 +166,7 @@ namespace hpx { namespace lcos
     template <typename F, typename... Ts>
     typename std::enable_if<
         !traits::is_future<typename std::decay<F>::type>::value &&
-        util::detail::all_of<traits::is_future<Ts>...>::value
+        util::all_of<traits::is_future<Ts>...>::value
     >::type
     wait_each(F&& f, Ts&&... ts)
     {
diff --git a/hpx/lcos/wait_some.hpp b/hpx/lcos/wait_some.hpp
index 090ef01176..d6cdb39815 100644
--- a/hpx/lcos/wait_some.hpp
+++ b/hpx/lcos/wait_some.hpp
@@ -179,14 +179,14 @@ namespace hpx
 #include <hpx/assertion.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/preprocessor/strip_parens.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/traits/acquire_shared_state.hpp>
 #include <hpx/traits/future_access.hpp>
 #include <hpx/traits/is_future.hpp>
 #include <hpx/type_support/always_void.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/functional/deferred_call.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 
 #include <algorithm>
@@ -259,7 +259,7 @@ namespace hpx { namespace lcos
 
             template <typename Tuple, std::size_t ...Is>
             HPX_FORCEINLINE
-            void apply(Tuple& tuple, util::detail::pack_c<std::size_t, Is...>) const
+            void apply(Tuple& tuple, util::index_pack<Is...>) const
             {
                 int const _sequencer[]= {
                     (((*this)(util::get<Is>(tuple))), 0)...
@@ -272,7 +272,7 @@ namespace hpx { namespace lcos
             void apply(util::tuple<Ts...>& sequence) const
             {
                 apply(sequence,
-                    typename util::detail::make_index_pack<sizeof...(Ts)>::type());
+                    typename util::make_index_pack<sizeof...(Ts)>::type());
             }
 
             template <typename Sequence_>
diff --git a/hpx/lcos/when_any.hpp b/hpx/lcos/when_any.hpp
index 5b5eeaa46e..6a757b9dba 100644
--- a/hpx/lcos/when_any.hpp
+++ b/hpx/lcos/when_any.hpp
@@ -124,21 +124,19 @@ namespace hpx
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/basic_execution/this_thread.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/local/futures_factory.hpp>
 #include <hpx/lcos/when_any.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/traits/acquire_future.hpp>
 #include <hpx/traits/future_access.hpp>
 #include <hpx/traits/is_future.hpp>
 #include <hpx/traits/is_future_range.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/detail/reserve.hpp>
 
-#include <boost/utility/swap.hpp>
-
 #include <algorithm>
 #include <atomic>
 #include <cstddef>
@@ -274,7 +272,7 @@ namespace hpx { namespace lcos
 
             template <typename Tuple, std::size_t ...Is>
             HPX_FORCEINLINE
-            void apply(Tuple& tuple, util::detail::pack_c<std::size_t, Is...>) const
+            void apply(Tuple& tuple, util::index_pack<Is...>) const
             {
                 int const _sequencer[]= {
                     (((*this)(util::get<Is>(tuple))), 0)...
@@ -287,7 +285,7 @@ namespace hpx { namespace lcos
             void apply(util::tuple<Ts...>& sequence) const
             {
                 apply(sequence,
-                    typename util::detail::make_index_pack<sizeof...(Ts)>::type());
+                    typename util::make_index_pack<sizeof...(Ts)>::type());
             }
 
             template <typename Sequence_>
@@ -386,7 +384,7 @@ namespace hpx { namespace lcos
                 std::move(lazy_values_));
 
         lcos::local::futures_factory<when_any_result<result_type>()> p(
-            [HPX_CAPTURE_MOVE(f)]() -> when_any_result<result_type> {
+            [f = std::move(f)]() -> when_any_result<result_type> {
                 return (*f)();
             });
 
@@ -465,7 +463,7 @@ namespace hpx { namespace lcos
                 std::move(lazy_values));
 
         lcos::local::futures_factory<when_any_result<result_type>()> p(
-            [HPX_CAPTURE_MOVE(f)]() -> when_any_result<result_type> {
+            [f = std::move(f)]() -> when_any_result<result_type> {
                 return (*f)();
             });
 
diff --git a/hpx/lcos/when_each.hpp b/hpx/lcos/when_each.hpp
index 7341c71401..e0a9b73cbe 100644
--- a/hpx/lcos/when_each.hpp
+++ b/hpx/lcos/when_each.hpp
@@ -128,7 +128,6 @@ namespace hpx
 #else // DOXYGEN
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/bind_back.hpp>
 #include <hpx/iterator_support/range.hpp>
@@ -143,6 +142,7 @@ namespace hpx
 #include <hpx/traits/is_future.hpp>
 #include <hpx/traits/is_future_range.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/type_support/unwrap_ref.hpp>
 
 #include <algorithm>
@@ -241,8 +241,8 @@ namespace hpx { namespace lcos
                             // (if any).
                             hpx::intrusive_ptr<when_each_frame> this_(this);
                             next_future_data->set_on_completed(
-                                [HPX_CAPTURE_MOVE(this_),
-                                    HPX_CAPTURE_MOVE(next), HPX_CAPTURE_MOVE(end)
+                                [this_ = std::move(this_),
+                                    next = std::move(next), end = std::move(end)
                                 ]() mutable -> void {
                                     return this_->template await_range<I>(
                                         std::move(next), std::move(end));
@@ -310,7 +310,7 @@ namespace hpx { namespace lcos
                         // (if any).
                         hpx::intrusive_ptr<when_each_frame> this_(this);
                         next_future_data->set_on_completed(
-                            [HPX_CAPTURE_MOVE(this_)]() -> void {
+                            [this_ = std::move(this_)]() -> void {
                                 return this_->template await_next<I>(
                                     std::true_type(), std::false_type());
                             });
@@ -341,12 +341,12 @@ namespace hpx { namespace lcos
                     typename util::tuple_element<I, Tuple>::type
                 >::type future_type;
 
-                typedef util::detail::any_of<
+                typedef util::any_of<
                         traits::is_future<future_type>,
                         traits::is_ref_wrapped_future<future_type>
                     > is_future;
 
-                typedef util::detail::any_of<
+                typedef util::any_of<
                         traits::is_future_range<future_type>,
                         traits::is_ref_wrapped_future_range<future_type>
                     > is_range;
@@ -422,7 +422,7 @@ namespace hpx { namespace lcos
 
         return lcos::when_each(std::forward<F>(f), lazy_values_)
             .then(hpx::launch::sync, [
-                HPX_CAPTURE_MOVE(end)
+                end = std::move(end)
             ](lcos::future<void> fut) -> Iterator {
                 fut.get();      // rethrow exceptions, if any
                 return end;
@@ -446,7 +446,7 @@ namespace hpx { namespace lcos
 
         return lcos::when_each(std::forward<F>(f), lazy_values_)
             .then(hpx::launch::sync, [
-                HPX_CAPTURE_MOVE(begin)
+                begin = std::move(begin)
             ](lcos::future<void> fut) -> Iterator {
                 fut.get();      // rethrow exceptions, if any
                 return begin;
@@ -464,7 +464,7 @@ namespace hpx { namespace lcos
     template <typename F, typename... Ts>
     typename std::enable_if<
         !traits::is_future<typename std::decay<F>::type>::value &&
-        util::detail::all_of<traits::is_future<Ts>...>::value,
+        util::all_of<traits::is_future<Ts>...>::value,
         lcos::future<void>
     >::type
     when_each(F&& f, Ts&&... ts)
diff --git a/hpx/lcos/when_some.hpp b/hpx/lcos/when_some.hpp
index a934a93d7c..eeafd14514 100644
--- a/hpx/lcos/when_some.hpp
+++ b/hpx/lcos/when_some.hpp
@@ -229,7 +229,7 @@ namespace hpx
 #include <hpx/assertion.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/local/futures_factory.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/traits/acquire_future.hpp>
 #include <hpx/traits/acquire_shared_state.hpp>
@@ -238,7 +238,7 @@ namespace hpx
 #include <hpx/traits/is_future.hpp>
 #include <hpx/traits/is_future_range.hpp>
 #include <hpx/functional/deferred_call.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 
 #include <algorithm>
@@ -371,7 +371,7 @@ namespace hpx { namespace lcos
 
             template <typename Tuple, std::size_t ...Is>
             HPX_FORCEINLINE
-            void apply(Tuple& tuple, util::detail::pack_c<std::size_t, Is...>) const
+            void apply(Tuple& tuple, util::index_pack<Is...>) const
             {
                 int const _sequencer[]= {
                     (((*this)(util::get<Is>(tuple))), 0)...
@@ -384,7 +384,7 @@ namespace hpx { namespace lcos
             void apply(util::tuple<Ts...>& sequence) const
             {
                 apply(sequence,
-                    typename util::detail::make_index_pack<sizeof...(Ts)>::type());
+                    typename util::make_index_pack<sizeof...(Ts)>::type());
             }
 
             template <typename Sequence_>
@@ -510,7 +510,7 @@ namespace hpx { namespace lcos
                 std::move(lazy_values_), n);
 
         lcos::local::futures_factory<when_some_result<result_type>()> p(
-            [HPX_CAPTURE_MOVE(f)]() -> when_some_result<result_type> {
+            [f = std::move(f)]() -> when_some_result<result_type> {
                 return (*f)();
             });
 
@@ -615,7 +615,7 @@ namespace hpx { namespace lcos
                 std::move(lazy_values), n);
 
         lcos::local::futures_factory<when_some_result<result_type>()> p(
-            [HPX_CAPTURE_MOVE(f)]() -> when_some_result<result_type> {
+            [f = std::move(f)]() -> when_some_result<result_type> {
                 return (*f)();
             });
 
@@ -664,7 +664,7 @@ namespace hpx { namespace lcos
                 std::move(lazy_values), n);
 
         lcos::local::futures_factory<when_some_result<result_type>()> p(
-            [HPX_CAPTURE_MOVE(f)]() -> when_some_result<result_type> {
+            [f = std::move(f)]() -> when_some_result<result_type> {
                 return (*f)();
             });
 
diff --git a/hpx/parallel/spmd_block.hpp b/hpx/parallel/spmd_block.hpp
index 849c2dc64d..54d248c6b8 100644
--- a/hpx/parallel/spmd_block.hpp
+++ b/hpx/parallel/spmd_block.hpp
@@ -9,8 +9,8 @@
 
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/local/spmd_block.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 
 #include <cstddef>
 #include <type_traits>
diff --git a/hpx/parallel/task_block.hpp b/hpx/parallel/task_block.hpp
index 371d243092..0d4ebec0c2 100644
--- a/hpx/parallel/task_block.hpp
+++ b/hpx/parallel/task_block.hpp
@@ -21,12 +21,11 @@
 #include <hpx/traits/is_future.hpp>
 #include <hpx/type_support/decay.hpp>
 
-#include <hpx/parallel/exception_list.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
+#include <hpx/execution/exception_list.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 
-#include <boost/utility/addressof.hpp>      // boost::addressof
 #include <memory>                           // std::addressof
 
 #include <exception>
@@ -529,12 +528,6 @@ namespace std
     hpx::parallel::v2::task_block<ExPolicy>*
     addressof(hpx::parallel::v2::task_block<ExPolicy>&) = delete;
 }
-namespace boost
-{
-    template <typename ExPolicy>
-    hpx::parallel::v2::task_block<ExPolicy>*
-    addressof(hpx::parallel::v2::task_block<ExPolicy>&) = delete;
-}
 /// \endcond
 
 #endif
diff --git a/hpx/parallel/util/numa_allocator.hpp b/hpx/parallel/util/numa_allocator.hpp
index 6c5948458a..6406627d90 100644
--- a/hpx/parallel/util/numa_allocator.hpp
+++ b/hpx/parallel/util/numa_allocator.hpp
@@ -13,9 +13,9 @@
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/wait_all.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution_information.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
 #include <hpx/runtime/get_worker_thread_num.hpp>
 #include <hpx/topology/topology.hpp>
 
diff --git a/hpx/parallel/util/numa_binding_allocator.hpp b/hpx/parallel/util/numa_binding_allocator.hpp
index 1f3f7e3f9f..67ee426600 100644
--- a/hpx/parallel/util/numa_binding_allocator.hpp
+++ b/hpx/parallel/util/numa_binding_allocator.hpp
@@ -10,7 +10,7 @@
 #include <hpx/config.hpp>
 
 #include <hpx/assertion.hpp>
-#include <hpx/parallel/execution_policy.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/runtime/threads/executors/guided_pool_executor.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
@@ -58,7 +58,7 @@ namespace hpx { namespace threads { namespace executors {
     {
         // The call operator () must return an int type
         // The arguments must be const ref versions of the equivalent task arguments
-        int operator()(const int& domain) const
+        int operator()(int const& domain) const
         {
             nba_deb.debug(debug::str<>("pool_numa_hint"),
                 "allocator returns domain ", domain);
@@ -79,8 +79,8 @@ namespace hpx { namespace compute { namespace host {
         // should touch this page. The thread with the matching domain will
         // perform a memory read/write on the page.
         virtual std::size_t operator()(const T* const /*base_ptr*/,
-            const T* const /*page_ptr*/, const std::size_t /*page_size*/,
-            const std::size_t /*domains*/) const
+            const T* const /*page_ptr*/, std::size_t const /*page_size*/,
+            std::size_t const /*domains*/) const
         {
             return 0;
         }
@@ -570,11 +570,11 @@ namespace hpx { namespace compute { namespace host {
 
         void touch_pages(pointer p, size_t n, numa_binding_helper_ptr helper,
             size_type numa_domain,
-            const std::vector<threads::hwloc_bitmap_ptr>& nodesets) const
+            std::vector<threads::hwloc_bitmap_ptr> const& nodesets) const
         {
-            const size_type pagesize = threads::get_memory_page_size();
-            const size_type pageN = pagesize / sizeof(T);
-            const size_type num_pages =
+            size_type const pagesize = threads::get_memory_page_size();
+            size_type const pageN = pagesize / sizeof(T);
+            size_type const num_pages =
                 (n * sizeof(T) + pagesize - 1) / pagesize;
             pointer page_ptr = p;
             HPX_ASSERT(reinterpret_cast<std::intptr_t>(p) % pagesize == 0);
@@ -615,11 +615,11 @@ namespace hpx { namespace compute { namespace host {
         // This is obsolete but kept for possible future use
         void bind_pages(pointer p, size_t n, numa_binding_helper_ptr helper,
             size_type numa_domain,
-            const std::vector<threads::hwloc_bitmap_ptr>& nodesets) const
+            std::vector<threads::hwloc_bitmap_ptr> const& nodesets) const
         {
-            const size_type pagesize = threads::get_memory_page_size();
-            const size_type pageN = pagesize / sizeof(T);
-            const size_type num_pages =
+            size_type const pagesize = threads::get_memory_page_size();
+            size_type const pageN = pagesize / sizeof(T);
+            size_type const num_pages =
                 (n * sizeof(T) + pagesize - 1) / pagesize;
             pointer page_ptr = p;
             HPX_ASSERT(reinterpret_cast<std::intptr_t>(p) % pagesize == 0);
diff --git a/hpx/performance_counters/counters_fwd.hpp b/hpx/performance_counters/counters_fwd.hpp
deleted file mode 100644
index 05dea1b2bc..0000000000
--- a/hpx/performance_counters/counters_fwd.hpp
+++ /dev/null
@@ -1,600 +0,0 @@
-//  Copyright (c) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#if !defined(HPX_PERFORMANCE_COUNTERS_FWD_NOV_26_2017_0107PM)
-#define HPX_PERFORMANCE_COUNTERS_FWD_NOV_26_2017_0107PM
-
-#include <hpx/config.hpp>
-#include <hpx/lcos_fwd.hpp>
-#include <hpx/errors.hpp>
-#include <hpx/runtime/naming/name.hpp>
-#include <hpx/serialization/serialization_fwd.hpp>
-#include <hpx/functional/function.hpp>
-
-#include <cstddef>
-#include <cstdint>
-#include <string>
-#include <utility>
-#include <vector>
-
-///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
-    ///////////////////////////////////////////////////////////////////////////
-    inline std::string& ensure_counter_prefix(std::string& name);
-    inline std::string ensure_counter_prefix(std::string const& counter);
-    inline std::string& remove_counter_prefix(std::string& name);
-    inline std::string remove_counter_prefix(std::string const& counter);
-
-    ///////////////////////////////////////////////////////////////////////////
-    enum counter_type
-    {
-        // \a counter_text shows a variable-length text string. It does not
-        // deliver calculated values.
-        //
-        // Formula:  None
-        // Average:  None
-        // Type:     Text
-        counter_text,
-
-        // \a counter_raw shows the last observed value only. It does
-        // not deliver an average.
-        //
-        // Formula:  None. Shows raw data as collected.
-        // Average:  None
-        // Type:     Instantaneous
-        counter_raw,
-
-        // \a counter_average_base is used as the base data (denominator) in the
-        // computation of time or count averages for the \a counter_average_count
-        // and \a counter_average_timer counter types. This counter type
-        // collects the last observed value only.
-        //
-        // Formula:  None. This counter uses raw data in factional calculations
-        //           without delivering an output.
-        // Average:  SUM (N) / x
-        // Type:     Instantaneous
-        counter_average_base,
-
-        // \a counter_average_count shows how many items are processed, on
-        // average, during an operation. Counters of this type display a ratio
-        // of the items processed (such as bytes sent) to the number of
-        // operations completed. The ratio is calculated by comparing the
-        // number of items processed during the last interval to the number of
-        // operations completed during the last interval.
-        //
-        // Formula:  (N1 - N0) / (D1 - D0), where the numerator (N) represents
-        //           the number of items processed during the last sample
-        //           interval, and the denominator (D) represents the number
-        //           of operations completed during the last two sample
-        //           intervals.
-        // Average:  (Nx - N0) / (Dx - D0)
-        // Type:     Average
-        counter_average_count,
-
-        // \a counter_aggregating applies a function to an embedded counter
-        // instance. The embedded counter is usually evaluated repeatedly
-        // after a fixed (but configurable) time interval.
-        //
-        // Formula:  F(Nx)
-        counter_aggregating,
-
-        // \a counter_average_timer measures the average time it takes to
-        // complete a process or operation. Counters of this type display a
-        // ratio of the total elapsed time of the sample interval to the
-        // number of processes or operations completed during that time. This
-        // counter type measures time in ticks of the system clock. The
-        // variable F represents the number of ticks per second. The value of
-        // F is factored into the equation so that the result is displayed in
-        // seconds.
-        //
-        // Formula:  ((N1 - N0) / F) / (D1 - D0), where the numerator (N)
-        //           represents the number of ticks counted during the last
-        //           sample interval, the variable F represents the frequency
-        //           of the ticks, and the denominator (D) represents the
-        //           number of operations completed during the last sample
-        //           interval.
-        // Average:  ((Nx - N0) / F) / (Dx - D0)
-        // Type:     Average
-        counter_average_timer,
-
-        // \a counter_elapsed_time shows the total time between when the
-        // component or process started and the time when this value is
-        // calculated. The variable F represents the number of time units that
-        // elapse in one second. The value of F is factored into the equation
-        // so that the result is displayed in seconds.
-        //
-        // Formula:  (D0 - N0) / F, where the nominator (D) represents the
-        //           current time, the numerator (N) represents the time the
-        //           object was started, and the variable F represents the
-        //           number of time units that elapse in one second.
-        // Average:  (Dx - N0) / F
-        // Type:     Difference
-        counter_elapsed_time,
-
-        // \a counter_histogram exposes a histogram of the measured values
-        // instead of a single value as many of the other counter types.
-        // Counters of this type expose a \a counter_value_array instead of a
-        // \a counter_value. Those will also not implement the
-        // \a get_counter_value() functionality. The results are exposed
-        // through a separate \a get_counter_values_array() function.
-        //
-        // The first three values in the returned array represent the lower
-        // and upper boundaries, and the size of the histogram buckets. All
-        // remaining values in the returned array represent the number of
-        // measurements for each of the buckets in the histogram.
-        counter_histogram,
-
-        /// \a counter_raw_values exposes an array of measured values
-        /// instead of a single value as many of the other counter types.
-        /// Counters of this type expose a \a counter_value_array instead of a
-        /// \a counter_value. Those will also not implement the
-        /// \a get_counter_value() functionality. The results are exposed
-        /// through a separate \a get_counter_values_array() function.
-        counter_raw_values
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Return the readable name of a given counter type
-    HPX_API_EXPORT char const* get_counter_type_name(counter_type state);
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Status and error codes used by the functions related to
-    // performance counters.
-    enum counter_status
-    {
-        status_valid_data,      // No error occurred, data is valid
-        status_new_data,        // Data is valid and different from last call
-        status_invalid_data,    // Some error occurred, data is not value
-        status_already_defined, // The type or instance already has been defined
-        status_counter_unknown, // The counter instance is unknown
-        status_counter_type_unknown,  // The counter type is unknown
-        status_generic_error    // A unknown error occurred
-    };
-
-    inline bool status_is_valid(counter_status s);
-
-    ///////////////////////////////////////////////////////////////////////////
-    // A counter_type_path_elements holds the elements of a full name for a
-    // counter type.
-    struct counter_type_path_elements;
-
-    ///////////////////////////////////////////////////////////////////////////
-    // A counter_path_elements holds the elements of a full name for a counter
-    // instance.
-    struct counter_path_elements;
-
-    ///////////////////////////////////////////////////////////////////////////
-    /// \brief Create a full name of a counter type from the contents of the
-    ///        given \a counter_type_path_elements instance.The generated
-    ///        counter type name will not contain any parameters.
-    HPX_API_EXPORT counter_status get_counter_type_name(
-        counter_type_path_elements const& path, std::string& result,
-        error_code& ec = throws);
-
-    /// \brief Create a full name of a counter type from the contents of the
-    ///        given \a counter_type_path_elements instance. The generated
-    ///        counter type name will contain all parameters.
-    HPX_API_EXPORT counter_status get_full_counter_type_name(
-        counter_type_path_elements const& path, std::string& result,
-        error_code& ec = throws);
-
-    /// \brief Create a full name of a counter from the contents of the given
-    ///        \a counter_path_elements instance.
-    HPX_API_EXPORT counter_status get_counter_name(
-        counter_path_elements const& path, std::string& result,
-        error_code& ec = throws);
-
-    /// \brief Create a name of a counter instance from the contents of the
-    ///        given \a counter_path_elements instance.
-    HPX_API_EXPORT counter_status get_counter_instance_name(
-        counter_path_elements const& path, std::string& result,
-        error_code& ec = throws);
-
-    /// \brief Fill the given \a counter_type_path_elements instance from the
-    ///        given full name of a counter type
-    HPX_API_EXPORT counter_status get_counter_type_path_elements(
-        std::string const& name, counter_type_path_elements& path,
-        error_code& ec = throws);
-
-    /// \brief Fill the given \a counter_path_elements instance from the given
-    ///        full name of a counter
-    HPX_API_EXPORT counter_status get_counter_path_elements(
-        std::string const& name, counter_path_elements& path,
-        error_code& ec = throws);
-
-    /// \brief Return the canonical counter instance name from a given full
-    ///        instance name
-    HPX_API_EXPORT counter_status get_counter_name(
-        std::string const& name, std::string& countername,
-        error_code& ec = throws);
-
-    /// \brief Return the canonical counter type name from a given (full)
-    ///        instance name
-    HPX_API_EXPORT counter_status get_counter_type_name(
-        std::string const& name, std::string& type_name,
-        error_code& ec = throws);
-
-    // default version of performance counter structures
-    #define HPX_PERFORMANCE_COUNTER_V1 0x01000000
-
-    ///////////////////////////////////////////////////////////////////////////
-    struct counter_info;
-
-    ///////////////////////////////////////////////////////////////////////////
-    // This declares the type of a function, which will be
-    // called by HPX whenever a new performance counter instance of a
-    // particular type needs to be created.
-    typedef hpx::util::function_nonser<
-        naming::gid_type(counter_info const&, error_code&)>
-        create_counter_func;
-
-    ///////////////////////////////////////////////////////////////////////////
-    // This declares a type of a function, which will be passed to
-    // a \a discover_counters_func in order to be called for each
-    // discovered performance counter instance.
-    typedef hpx::util::function_nonser<
-        bool(counter_info const&, error_code&)>
-        discover_counter_func;
-
-    enum discover_counters_mode
-    {
-        discover_counters_minimal,
-        discover_counters_full      // fully expand all wild cards
-    };
-
-    // This declares the type of a function, which will be called by
-    // HPX whenever it needs to discover all performance counter
-    // instances of a particular type.
-    typedef hpx::util::function_nonser<
-        bool(counter_info const&, discover_counter_func const&,
-            discover_counters_mode, error_code&)>
-        discover_counters_func;
-
-    ///////////////////////////////////////////////////////////////////////////
-    /// \brief Complement the counter info if parent instance name is missing
-    HPX_API_EXPORT counter_status complement_counter_info(counter_info& info,
-        counter_info const& type_info, error_code& ec = throws);
-
-    HPX_API_EXPORT counter_status complement_counter_info(counter_info& info,
-        error_code& ec = throws);
-
-    ///////////////////////////////////////////////////////////////////////////
-    struct counter_value
-    {
-        counter_value(std::int64_t value = 0, std::int64_t scaling = 1,
-                bool scale_inverse = false)
-          : time_(), count_(0), value_(value), scaling_(scaling),
-            status_(status_new_data),
-            scale_inverse_(scale_inverse)
-        {}
-
-        std::uint64_t time_;      ///< The local time when data was collected
-        std::uint64_t count_;     ///< The invocation counter for the data
-        std::int64_t value_;      ///< The current counter value
-        std::int64_t scaling_;    ///< The scaling of the current counter value
-        counter_status status_;     ///< The status of the counter value
-        bool scale_inverse_;        ///< If true, value_ needs to be divided by
-                                    ///< scaling_, otherwise it has to be
-                                    ///< multiplied.
-
-        /// \brief Retrieve the 'real' value of the counter_value, converted to
-        ///        the requested type \a T
-        template <typename T>
-        T get_value(error_code& ec = throws) const
-        {
-            if (!status_is_valid(status_)) {
-                HPX_THROWS_IF(ec, invalid_status,
-                    "counter_value::get_value<T>",
-                    "counter value is in invalid status");
-                return T();
-            }
-
-            T val = static_cast<T>(value_);
-
-            if (scaling_ != 1) {
-                if (scaling_ == 0) {
-                    HPX_THROWS_IF(ec, uninitialized_value,
-                        "counter_value::get_value<T>",
-                        "scaling should not be zero");
-                    return T();
-                }
-
-                // calculate and return the real counter value
-                if (scale_inverse_)
-                    return val / static_cast<T>(scaling_);
-
-                return val * static_cast<T>(scaling_);
-            }
-            return val;
-        }
-
-    private:
-        // serialization support
-        friend class hpx::serialization::access;
-
-        HPX_EXPORT void serialize(
-            serialization::output_archive& ar, const unsigned int);
-        HPX_EXPORT void serialize(
-            serialization::input_archive& ar, const unsigned int);
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    struct counter_values_array
-    {
-        counter_values_array(std::int64_t scaling = 1,
-                bool scale_inverse = false)
-          : time_(), count_(0), values_(), scaling_(scaling),
-            status_(status_new_data),
-            scale_inverse_(scale_inverse)
-        {}
-
-        counter_values_array(std::vector<std::int64_t> && values,
-                std::int64_t scaling = 1, bool scale_inverse = false)
-          : time_(), count_(0), values_(std::move(values)), scaling_(scaling),
-            status_(status_new_data),
-            scale_inverse_(scale_inverse)
-        {}
-
-        counter_values_array(std::vector<std::int64_t> const& values,
-                std::int64_t scaling = 1, bool scale_inverse = false)
-          : time_(), count_(0), values_(values), scaling_(scaling),
-            status_(status_new_data),
-            scale_inverse_(scale_inverse)
-        {}
-
-        std::uint64_t time_;      ///< The local time when data was collected
-        std::uint64_t count_;     ///< The invocation counter for the data
-        std::vector<std::int64_t> values_;  ///< The current counter values
-        std::int64_t scaling_;    ///< The scaling of the current counter values
-        counter_status status_;     ///< The status of the counter value
-        bool scale_inverse_;        ///< If true, value_ needs to be divided by
-                                    ///< scaling_, otherwise it has to be
-                                    ///< multiplied.
-
-        /// \brief Retrieve the 'real' value of the counter_value, converted to
-        ///        the requested type \a T
-        template <typename T>
-        T get_value(std::size_t index, error_code& ec = throws) const
-        {
-            if (!status_is_valid(status_)) {
-                HPX_THROWS_IF(ec, invalid_status,
-                    "counter_values_array::get_value<T>",
-                    "counter value is in invalid status");
-                return T();
-            }
-            if (index >= values_.size()) {
-                HPX_THROWS_IF(ec, bad_parameter,
-                    "counter_values_array::get_value<T>",
-                    "index out of bounds");
-                return T();
-            }
-
-            T val = static_cast<T>(values_[index]);
-
-            if (scaling_ != 1) {
-                if (scaling_ == 0) {
-                    HPX_THROWS_IF(ec, uninitialized_value,
-                        "counter_values_array::get_value<T>",
-                        "scaling should not be zero");
-                    return T();
-                }
-
-                // calculate and return the real counter value
-                if (scale_inverse_)
-                    return val / static_cast<T>(scaling_);
-
-                return val * static_cast<T>(scaling_);
-            }
-            return val;
-        }
-
-    private:
-        // serialization support
-        friend class hpx::serialization::access;
-
-        HPX_EXPORT void serialize(
-            serialization::output_archive& ar, const unsigned int);
-        HPX_EXPORT void serialize(
-            serialization::input_archive& ar, const unsigned int);
-    };
-
-    ///////////////////////////////////////////////////////////////////////
-    // Add a new performance counter type to the (local) registry
-    HPX_API_EXPORT counter_status add_counter_type(counter_info const& info,
-        create_counter_func const& create_counter,
-        discover_counters_func const& discover_counters,
-        error_code& ec = throws);
-
-    inline counter_status add_counter_type(counter_info const& info,
-        error_code& ec = throws);
-
-    ///////////////////////////////////////////////////////////////////////////
-    /// \brief Call the supplied function for each registered counter type
-    HPX_API_EXPORT counter_status discover_counter_types(
-        discover_counter_func const& discover_counter,
-        discover_counters_mode mode = discover_counters_minimal,
-        error_code& ec = throws);
-
-    /// \brief Return a list of all available counter descriptions.
-    HPX_API_EXPORT counter_status discover_counter_types(
-        std::vector<counter_info>& counters,
-        discover_counters_mode mode = discover_counters_minimal,
-        error_code& ec = throws);
-
-    /// \brief Call the supplied function for the given registered counter type.
-    HPX_API_EXPORT counter_status discover_counter_type(
-        std::string const& name,
-        discover_counter_func const& discover_counter,
-        discover_counters_mode mode = discover_counters_minimal,
-        error_code& ec = throws);
-
-    HPX_API_EXPORT counter_status discover_counter_type(
-        counter_info const& info,
-        discover_counter_func const& discover_counter,
-        discover_counters_mode mode = discover_counters_minimal,
-        error_code& ec = throws);
-
-    /// \brief Return a list of matching counter descriptions for the given
-    ///        registered counter type.
-    HPX_API_EXPORT counter_status discover_counter_type(
-        std::string const& name, std::vector<counter_info>& counters,
-        discover_counters_mode mode = discover_counters_minimal,
-        error_code& ec = throws);
-
-    HPX_API_EXPORT counter_status discover_counter_type(
-        counter_info const& info, std::vector<counter_info>& counters,
-        discover_counters_mode mode = discover_counters_minimal,
-        error_code& ec = throws);
-
-    /// \brief call the supplied function will all expanded versions of the
-    /// supplied counter info.
-    ///
-    /// This function expands all locality#* and worker-thread#* wild
-    /// cards only.
-    HPX_API_EXPORT bool expand_counter_info(counter_info const&,
-        discover_counter_func const&, error_code&);
-
-    /// \brief Remove an existing counter type from the (local) registry
-    ///
-    /// \note This doesn't remove existing counters of this type, it just
-    ///       inhibits defining new counters using this type.
-    HPX_API_EXPORT counter_status remove_counter_type(
-        counter_info const& info, error_code& ec = throws);
-
-    /// \brief Retrieve the counter type for the given counter name from the
-    ///        (local) registry
-    HPX_API_EXPORT counter_status get_counter_type(std::string const& name,
-        counter_info& info, error_code& ec = throws);
-
-    ///////////////////////////////////////////////////////////////////////////
-    /// \brief Get the global id of an existing performance counter, if the
-    ///        counter does not exist yet, the function attempts to create the
-    ///        counter based on the given counter name.
-    HPX_API_EXPORT lcos::future<naming::id_type>
-        get_counter_async(std::string name, error_code& ec = throws);
-
-    inline naming::id_type get_counter(std::string const& name,
-        error_code& ec = throws);
-
-    /// \brief Get the global id of an existing performance counter, if the
-    ///        counter does not exist yet, the function attempts to create the
-    ///        counter based on the given counter info.
-    HPX_API_EXPORT lcos::future<naming::id_type>
-        get_counter_async(counter_info const& info, error_code& ec = throws);
-
-    inline naming::id_type get_counter(counter_info const& info,
-        error_code& ec = throws);
-
-    ///////////////////////////////////////////////////////////////////////////
-    /// \brief Retrieve the meta data specific for the given counter instance
-    HPX_API_EXPORT void get_counter_infos(counter_info const& info,
-        counter_type& type, std::string& helptext, std::uint32_t& version,
-        error_code& ec = throws);
-
-    /// \brief Retrieve the meta data specific for the given counter instance
-    HPX_API_EXPORT void get_counter_infos(std::string name, counter_type& type,
-        std::string& helptext, std::uint32_t& version, error_code& ec = throws);
-
-    ///////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
-        /// \brief Add an existing performance counter instance to the registry
-        HPX_API_EXPORT counter_status add_counter(naming::id_type const& id,
-            counter_info const& info, error_code& ec = throws);
-
-        /// \brief Remove an existing performance counter instance with the
-        ///        given id (as returned from \a create_counter)
-        HPX_API_EXPORT counter_status remove_counter(
-            counter_info const& info, naming::id_type const& id,
-            error_code& ec = throws);
-
-        ///////////////////////////////////////////////////////////////////////
-        // Helper function for creating counters encapsulating a function
-        // returning the counter value.
-        HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
-            hpx::util::function_nonser<std::int64_t()> const&, error_code&);
-
-        // Helper function for creating counters encapsulating a function
-        // returning the counter value.
-        HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
-            hpx::util::function_nonser<std::int64_t(bool)> const&, error_code&);
-
-        // Helper function for creating counters encapsulating a function
-        // returning the counter values array.
-        HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
-            hpx::util::function_nonser<std::vector<std::int64_t>()> const&,
-            error_code&);
-
-        // Helper function for creating counters encapsulating a function
-        // returning the counter values array.
-        HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
-            hpx::util::function_nonser<std::vector<std::int64_t>(bool)> const&,
-            error_code&);
-
-        // Helper function for creating a new performance counter instance
-        // based on a given counter value.
-        HPX_EXPORT naming::gid_type create_raw_counter_value(
-            counter_info const&, std::int64_t*, error_code&);
-
-        // Creation function for aggregating performance counters; to be
-        // registered with the counter types.
-        HPX_EXPORT naming::gid_type statistics_counter_creator(
-            counter_info const&, error_code&);
-
-        // Creation function for aggregating performance counters; to be
-        // registered with the counter types.
-        HPX_EXPORT naming::gid_type arithmetics_counter_creator(
-            counter_info const&, error_code&);
-
-        // Creation function for extended aggregating performance counters; to
-        // be registered with the counter types.
-        HPX_EXPORT naming::gid_type arithmetics_counter_extended_creator(
-            counter_info const&, error_code&);
-
-        // Creation function for uptime counters.
-        HPX_EXPORT naming::gid_type uptime_counter_creator(
-            counter_info const&, error_code&);
-
-        // Creation function for instance counters.
-        HPX_EXPORT naming::gid_type component_instance_counter_creator(
-            counter_info const&, error_code&);
-
-        // \brief Create a new statistics performance counter instance based on
-        //        the given base counter name and given base time interval
-        //        (milliseconds).
-        HPX_EXPORT naming::gid_type create_statistics_counter(
-            counter_info const& info, std::string const& base_counter_name,
-            std::vector<std::size_t> const& parameters,
-            error_code& ec = throws);
-
-        // \brief Create a new arithmetics performance counter instance based on
-        //        the given base counter names
-        HPX_EXPORT naming::gid_type create_arithmetics_counter(
-            counter_info const& info,
-            std::vector<std::string> const& base_counter_names,
-            error_code& ec = throws);
-
-        // \brief Create a new extended arithmetics performance counter instance
-        //        based on the given base counter names
-        HPX_EXPORT naming::gid_type create_arithmetics_counter_extended(
-            counter_info const& info,
-            std::vector<std::string> const& base_counter_names,
-            error_code& ec = throws);
-
-        // \brief Create a new performance counter instance based on given
-        //        counter info
-        HPX_EXPORT naming::gid_type create_counter(counter_info const& info,
-            error_code& ec = throws);
-
-        // \brief Create an arbitrary counter on this locality
-        HPX_EXPORT naming::gid_type create_counter_local(
-            counter_info const& info);
-    }
-}}
-
-#endif
-
diff --git a/hpx/plugins/parcel/message_buffer.hpp b/hpx/plugins/parcel/message_buffer.hpp
index 5f97b7d89e..ca3358d434 100644
--- a/hpx/plugins/parcel/message_buffer.hpp
+++ b/hpx/plugins/parcel/message_buffer.hpp
@@ -17,8 +17,7 @@
 #include <hpx/runtime/parcelset/parcel.hpp>
 #include <hpx/runtime/parcelset/parcelport.hpp>
 #include <hpx/runtime/parcelset_fwd.hpp>
-#include <hpx/runtime/threads/register_thread.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
+#include <hpx/threading_base/register_thread.hpp>
 
 #include <cstddef>
 #include <utility>
diff --git a/hpx/plugins/parcelport/mpi/locality.hpp b/hpx/plugins/parcelport/mpi/locality.hpp
index c187ed12c7..c01450802d 100644
--- a/hpx/plugins/parcelport/mpi/locality.hpp
+++ b/hpx/plugins/parcelport/mpi/locality.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2014 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2013-2014 Thomas Heller
 //
 //  SPDX-License-Identifier: BSL-1.0
@@ -15,8 +15,7 @@
 #include <hpx/plugins/parcelport/mpi/mpi_environment.hpp>
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/serialization/serialize.hpp>
-
-#include <boost/io/ios_state.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 
 #include <cstdint>
 
@@ -73,7 +72,7 @@ namespace hpx { namespace parcelset
 
             friend std::ostream & operator<<(std::ostream & os, locality const & loc)
             {
-                boost::io::ios_flags_saver ifs(os);
+                hpx::util::ios_flags_saver ifs(os);
                 os << loc.rank_;
 
                 return os;
diff --git a/hpx/plugins/parcelport/tcp/locality.hpp b/hpx/plugins/parcelport/tcp/locality.hpp
index 3edc7fcfca..e017552ac6 100644
--- a/hpx/plugins/parcelport/tcp/locality.hpp
+++ b/hpx/plugins/parcelport/tcp/locality.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2014 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2014 Thomas Heller
 //  Copyright (c) 2007 Richard D Guidry Jr
 //  Copyright (c) 2011 Bryce Lelbach
@@ -18,10 +18,10 @@
 #include <hpx/config/asio.hpp>
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/serialization/serialize.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 
 #include <boost/asio/ip/host_name.hpp>
 #include <boost/asio/ip/tcp.hpp>
-#include <boost/io/ios_state.hpp>
 
 #include <cstdint>
 #include <string>
@@ -87,7 +87,7 @@ namespace hpx { namespace parcelset
 
             friend std::ostream & operator<<(std::ostream & os, locality const & loc)
             {
-                boost::io::ios_flags_saver ifs(os);
+                hpx::util::ios_flags_saver ifs(os);
                 os << loc.address_ << ":" << loc.port_;
 
                 return os;
diff --git a/hpx/plugins/parcelport/tcp/receiver.hpp b/hpx/plugins/parcelport/tcp/receiver.hpp
index b8cb63fdfd..4390e9bee3 100644
--- a/hpx/plugins/parcelport/tcp/receiver.hpp
+++ b/hpx/plugins/parcelport/tcp/receiver.hpp
@@ -26,7 +26,7 @@
 #include <hpx/runtime/parcelset/decode_parcels.hpp>
 #include <hpx/runtime/parcelset/parcelport_connection.hpp>
 #include <hpx/timing/high_resolution_timer.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <boost/asio/buffer.hpp>
 #include <boost/asio/io_service.hpp>
diff --git a/hpx/plugins/parcelport/tcp/sender.hpp b/hpx/plugins/parcelport/tcp/sender.hpp
index 2881f0443a..a41ae6bf09 100644
--- a/hpx/plugins/parcelport/tcp/sender.hpp
+++ b/hpx/plugins/parcelport/tcp/sender.hpp
@@ -22,7 +22,7 @@
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/runtime/parcelset/parcelport.hpp>
 #include <hpx/runtime/parcelset/parcelport_connection.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/state.hpp>
 #include <hpx/util/asio_util.hpp>
 #include <hpx/functional/bind.hpp>
diff --git a/hpx/plugins/parcelport_factory.hpp b/hpx/plugins/parcelport_factory.hpp
index 7e61cc0b91..14125fd29a 100644
--- a/hpx/plugins/parcelport_factory.hpp
+++ b/hpx/plugins/parcelport_factory.hpp
@@ -5,8 +5,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #if !defined(HPX_PLUGINS_PARCELPORT_FACTORY_HPP)
 #define HPX_PLUGINS_PARCELPORT_FACTORY_HPP
 
@@ -17,11 +15,10 @@
 #include <hpx/plugins/unique_plugin_name.hpp>
 #include <hpx/preprocessor/cat.hpp>
 #include <hpx/runtime/parcelset/parcelhandler.hpp>
-#include <hpx/util/find_prefix.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
+#include <hpx/prefix/find_prefix.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
 
 #include <algorithm>
 #include <cctype>
@@ -121,7 +118,7 @@ namespace hpx { namespace plugins
             if (more != nullptr)    // -V547
             {
                 std::vector<std::string> data;
-                boost::split(data, more, boost::is_any_of("\n"));
+                hpx::string_util::split(data, more, hpx::string_util::is_any_of("\n"));
                 std::copy(data.begin(), data.end(), std::back_inserter(fillini));
             }
         }
diff --git a/hpx/plugins/parcelport_factory_base.hpp b/hpx/plugins/parcelport_factory_base.hpp
index 43745ec1ae..6ea2307b37 100644
--- a/hpx/plugins/parcelport_factory_base.hpp
+++ b/hpx/plugins/parcelport_factory_base.hpp
@@ -9,7 +9,7 @@
 #define HPX_PLUGINS_PARCELPORT_FACTORY_BASE_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
 #include <hpx/util_fwd.hpp>
 
 #include <cstddef>
diff --git a/hpx/plugins/plugin_factory_base.hpp b/hpx/plugins/plugin_factory_base.hpp
index a102d2d623..96343ff03b 100644
--- a/hpx/plugins/plugin_factory_base.hpp
+++ b/hpx/plugins/plugin_factory_base.hpp
@@ -8,10 +8,10 @@
 #define HPX_PLUGIN_FACTORY_BASE_MAR_24_2013_0333PM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/plugin.hpp>
-#include <hpx/plugins/plugin_registry_base.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/type_support/pack.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace plugins
@@ -49,7 +49,7 @@ namespace hpx { namespace util { namespace plugin
     struct virtual_constructor<hpx::plugins::plugin_factory_base>
     {
         typedef
-            hpx::util::detail::pack<
+            hpx::util::pack<
                 hpx::util::section const*, hpx::util::section const*, bool
             > type;
     };
diff --git a/hpx/plugins/plugin_registry.hpp b/hpx/plugins/plugin_registry.hpp
index 915b0a614d..8067d1b210 100644
--- a/hpx/plugins/plugin_registry.hpp
+++ b/hpx/plugins/plugin_registry.hpp
@@ -4,13 +4,11 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #if !defined(HPX_PLUGIN_REGISTRY_MAR_24_2013_0235PM)
 #define HPX_PLUGIN_REGISTRY_MAR_24_2013_0235PM
 
 #include <hpx/config.hpp>
-#include <hpx/plugins/plugin_registry_base.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
 #include <hpx/plugins/unique_plugin_name.hpp>
 
 #include <hpx/plugin/traits/plugin_config_data.hpp>
@@ -18,11 +16,10 @@
 #include <hpx/preprocessor/expand.hpp>
 #include <hpx/preprocessor/nargs.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-#include <hpx/util/find_prefix.hpp>
-#include <hpx/util/ini.hpp>
-
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
+#include <hpx/prefix/find_prefix.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
 
 #include <string>
 #include <vector>
@@ -64,7 +61,7 @@ namespace hpx { namespace plugins
             if (more != nullptr)    // -V547
             {
                 std::vector<std::string> data;
-                boost::split(data, more, boost::is_any_of("\n"));
+                hpx::string_util::split(data, more, hpx::string_util::is_any_of("\n"));
                 std::copy(data.begin(), data.end(), std::back_inserter(fillini));
             }
             return true;
@@ -97,10 +94,10 @@ namespace hpx { namespace plugins
     /**/
 #define HPX_REGISTER_PLUGIN_REGISTRY_5(                                        \
         PluginType, pluginname, pluginstring, pluginsection, pluginsuffix)     \
-    HPX_CXX14_CONSTEXPR char __##pluginname##_string[] =                       \
+    constexpr char __##pluginname##_string[] =                                 \
         HPX_PP_STRINGIZE(pluginstring);                                        \
-    HPX_CXX14_CONSTEXPR char __##pluginname##_section[] = pluginsection;       \
-    HPX_CXX14_CONSTEXPR char __##pluginname##_suffix[] = pluginsuffix;         \
+    constexpr char __##pluginname##_section[] = pluginsection;                 \
+    constexpr char __##pluginname##_suffix[] = pluginsuffix;                   \
     typedef hpx::plugins::plugin_registry<PluginType, __##pluginname##_string, \
         __##pluginname##_section, __##pluginname##_suffix>                     \
         __##pluginname##_plugin_registry_type;                                 \
diff --git a/hpx/runtime.hpp b/hpx/runtime.hpp
index d2f95fe794..febc376e62 100644
--- a/hpx/runtime.hpp
+++ b/hpx/runtime.hpp
@@ -11,19 +11,20 @@
 #include <hpx/config.hpp>
 #include <hpx/synchronization/spinlock.hpp>
 #include <hpx/performance_counters/counters.hpp>
+#include <hpx/program_options.hpp>
 #include <hpx/runtime/applier_fwd.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/runtime/parcelset_fwd.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/runtime/thread_hooks.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
 #include <hpx/topology/topology.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/state.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -288,7 +289,7 @@ namespace hpx
             char const* description = nullptr, error_code& ec = throws);
 
         // stop periodic evaluation of counters during shutdown
-        void stop_evaluating_counters();
+        void stop_evaluating_counters(bool terminate = false);
 
 #if defined(HPX_HAVE_NETWORKING)
         void register_message_handler(char const* message_handler_type,
@@ -350,11 +351,24 @@ namespace hpx
         std::unique_ptr<components::server::memory> memory_;
         std::unique_ptr<components::server::runtime_support> runtime_support_;
 
-        // support tieing in external functions to be called for thread events
+        // support tying in external functions to be called for thread events
         notification_policy_type::on_startstop_type on_start_func_;
         notification_policy_type::on_startstop_type on_stop_func_;
         notification_policy_type::on_error_type on_error_func_;
     };
+
+    namespace util {
+        ///////////////////////////////////////////////////////////////////////////
+        // retrieve the command line arguments for the current locality
+        HPX_API_EXPORT bool retrieve_commandline_arguments(
+            hpx::program_options::options_description const& app_options,
+            hpx::program_options::variables_map& vm);
+
+        ///////////////////////////////////////////////////////////////////////////
+        // retrieve the command line arguments for the current locality
+        HPX_API_EXPORT bool retrieve_commandline_arguments(
+            std::string const& appname, hpx::program_options::variables_map& vm);
+    }    // namespace util
 }   // namespace hpx
 
 #include <hpx/config/warnings_suffix.hpp>
diff --git a/hpx/runtime/actions/action_support.hpp b/hpx/runtime/actions/action_support.hpp
index 7d68f0b321..d21d8b9265 100644
--- a/hpx/runtime/actions/action_support.hpp
+++ b/hpx/runtime/actions/action_support.hpp
@@ -20,8 +20,8 @@
 #include <hpx/serialization/base_object.hpp>
 #include <hpx/serialization/input_archive.hpp>
 #include <hpx/serialization/output_archive.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 #include <hpx/traits/action_remote_result.hpp>
 #include <hpx/debugging/demangle_helper.hpp>
 #if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
diff --git a/hpx/runtime/actions/base_action.hpp b/hpx/runtime/actions/base_action.hpp
index 697e9c766f..f9ff3b6ee6 100644
--- a/hpx/runtime/actions/base_action.hpp
+++ b/hpx/runtime/actions/base_action.hpp
@@ -15,9 +15,7 @@
 
 #if defined(HPX_HAVE_NETWORKING)
 #include <hpx/runtime/actions_fwd.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/runtime/parcelset_fwd.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 
 #include <hpx/runtime/actions/action_support.hpp>
 #include <hpx/runtime/actions/detail/action_factory.hpp>
diff --git a/hpx/runtime/actions/basic_action.hpp b/hpx/runtime/actions/basic_action.hpp
index 35131d91b4..9b232ab768 100644
--- a/hpx/runtime/actions/basic_action.hpp
+++ b/hpx/runtime/actions/basic_action.hpp
@@ -35,7 +35,6 @@
 #include <hpx/runtime/naming/id_type.hpp>
 #include <hpx/runtime/parcelset/detail/per_action_data_counter_registry.hpp>
 #include <hpx/serialization/tuple.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/traits/action_decorate_function.hpp>
@@ -45,7 +44,7 @@
 #include <hpx/functional/traits/is_action.hpp>
 #include <hpx/traits/is_distribution_policy.hpp>
 #include <hpx/traits/promise_local_result.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/get_and_reset_value.hpp>
 #if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
 #include <hpx/concurrency/itt_notify.hpp>
@@ -222,19 +221,19 @@ namespace hpx { namespace actions
     {
         // Flag the use of raw pointer types as action arguments
         static_assert(
-            !util::detail::any_of<std::is_pointer<Args>...>::value,
+            !util::any_of<std::is_pointer<Args>...>::value,
             "Using raw pointers as arguments for actions is not supported.");
 
         // Flag the use of array types as action arguments
         static_assert(
-            !util::detail::any_of<
+            !util::any_of<
                 std::is_array<typename std::remove_reference<Args>::type>...
             >::value,
             "Using arrays as arguments for actions is not supported.");
 
         // Flag the use of non-const reference types as action arguments
         static_assert(
-            !util::detail::any_of<
+            !util::any_of<
                 detail::is_non_const_reference<Args>...
             >::value,
             "Using non-const references as arguments for actions is not supported.");
@@ -256,7 +255,7 @@ namespace hpx { namespace actions
             hpx::actions::typed_continuation<local_result_type,
                 remote_result_type>;
 
-        static HPX_CONSTEXPR_OR_CONST std::size_t arity = sizeof...(Args);
+        static constexpr std::size_t arity = sizeof...(Args);
 
         using internal_result_type = R;
         using arguments_type = util::tuple<typename std::decay<Args>::type...>;
@@ -468,7 +467,7 @@ namespace hpx { namespace actions
 
         /// The function \a get_action_type returns whether this action needs
         /// to be executed in a new thread or directly.
-        HPX_CONSTEXPR static actions::action_flavor get_action_type()
+        static constexpr actions::action_flavor get_action_type()
         {
             return actions::action_flavor::plain_action;
         }
@@ -546,7 +545,7 @@ namespace hpx { namespace actions
 
         /// The function \a get_action_type returns whether this action needs
         /// to be executed in a new thread or directly.
-        HPX_CONSTEXPR static actions::action_flavor action_flavor()
+        static constexpr actions::action_flavor action_flavor()
         {
             return actions::action_flavor::direct_action;
         }
diff --git a/hpx/runtime/actions/basic_action_fwd.hpp b/hpx/runtime/actions/basic_action_fwd.hpp
index 7ddd71f469..718ca70ce0 100644
--- a/hpx/runtime/actions/basic_action_fwd.hpp
+++ b/hpx/runtime/actions/basic_action_fwd.hpp
@@ -14,7 +14,7 @@
     (HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX))
 #include <hpx/concurrency/itt_notify.hpp>
 #endif
-
+#include <hpx/functional/traits/get_action_name.hpp>
 #include <hpx/runtime/actions/preassigned_action_id.hpp>
 
 namespace hpx { namespace actions
@@ -25,18 +25,6 @@ namespace hpx { namespace actions
     /// \tparam Derived           derived action class
     template <typename Component, typename Signature, typename Derived>
     struct basic_action;
-
-    //////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
-        template <typename Action>
-        char const* get_action_name();
-
-#if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
-        template <typename Action>
-        util::itt::string_handle const& get_action_name_itt();
-#endif
-    }
 }}
 
 #endif /*HPX_RUNTIME_ACTIONS_BASIC_ACTION_FWD_HPP*/
diff --git a/hpx/runtime/actions/lambda_to_action.hpp b/hpx/runtime/actions/lambda_to_action.hpp
index ebf5bb4621..5b14c15652 100644
--- a/hpx/runtime/actions/lambda_to_action.hpp
+++ b/hpx/runtime/actions/lambda_to_action.hpp
@@ -81,7 +81,7 @@ namespace hpx { namespace actions
         struct action_maker
         {
             template<typename F>
-            HPX_CONSTEXPR typename hpx::actions::detail::action_from_lambda<F>::type
+            constexpr typename hpx::actions::detail::action_from_lambda<F>::type
             operator += (F*) const
             {
                 static_assert(
diff --git a/hpx/runtime/actions/transfer_action.hpp b/hpx/runtime/actions/transfer_action.hpp
index 034d646577..f513099be3 100644
--- a/hpx/runtime/actions/transfer_action.hpp
+++ b/hpx/runtime/actions/transfer_action.hpp
@@ -20,9 +20,9 @@
 #include <hpx/serialization/input_archive.hpp>
 #include <hpx/serialization/output_archive.hpp>
 #include <hpx/serialization/serialization_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -71,7 +71,7 @@ namespace hpx { namespace actions
         ///       continuations.
         template <std::size_t ...Is>
         threads::thread_function_type
-        get_thread_function(util::detail::pack_c<std::size_t, Is...>,
+        get_thread_function(util::index_pack<Is...>,
             naming::id_type&& target, naming::address::address_type lva,
             naming::address::component_type comptype);
 
@@ -82,7 +82,7 @@ namespace hpx { namespace actions
 
         template <std::size_t ...Is>
         void
-        schedule_thread(util::detail::pack_c<std::size_t, Is...>,
+        schedule_thread(util::index_pack<Is...>,
             naming::gid_type const& target_gid,
             naming::address::address_type lva,
             naming::address::component_type comptype,
@@ -131,7 +131,7 @@ namespace hpx { namespace actions
     template <std::size_t ...Is>
     threads::thread_function_type
     transfer_action<Action>::get_thread_function(
-        util::detail::pack_c<std::size_t, Is...>,
+        util::index_pack<Is...>,
         naming::id_type&& target, naming::address::address_type lva,
         naming::address::component_type comptype)
     {
@@ -147,7 +147,7 @@ namespace hpx { namespace actions
         naming::address::component_type comptype)
     {
         return get_thread_function(
-            typename util::detail::make_index_pack<Action::arity>::type(),
+            typename util::make_index_pack<Action::arity>::type(),
             std::move(target), lva, comptype);
     }
 
@@ -155,7 +155,7 @@ namespace hpx { namespace actions
     template <std::size_t ...Is>
     void
     transfer_action<Action>::schedule_thread(
-            util::detail::pack_c<std::size_t, Is...>,
+            util::index_pack<Is...>,
         naming::gid_type const& target_gid,
         naming::address::address_type lva,
         naming::address::component_type comptype,
@@ -185,7 +185,7 @@ namespace hpx { namespace actions
         std::size_t num_thread)
     {
         schedule_thread(
-            typename util::detail::make_index_pack<Action::arity>::type(),
+            typename util::make_index_pack<Action::arity>::type(),
             target_gid, lva, comptype, num_thread);
 
         // keep track of number of invocations
diff --git a/hpx/runtime/actions/transfer_base_action.hpp b/hpx/runtime/actions/transfer_base_action.hpp
index dac0c39ce1..9358de631d 100644
--- a/hpx/runtime/actions/transfer_base_action.hpp
+++ b/hpx/runtime/actions/transfer_base_action.hpp
@@ -81,7 +81,7 @@ namespace hpx { namespace actions
             }
 
 #if defined(HPX_DISABLE_ASSERTS) || defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)
-            HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+            constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             Args const& data() const
             {
                 return *data_;
@@ -104,7 +104,7 @@ namespace hpx { namespace actions
 namespace hpx { namespace util
 {
     template <std::size_t I, typename Args>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
     typename util::tuple_element<I, Args>::type&
     get(hpx::actions::detail::argument_holder<Args>& t)
     {
@@ -112,7 +112,7 @@ namespace hpx { namespace util
     }
 
     template <std::size_t I, typename Args>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
     typename util::tuple_element<I, Args>::type const&
     get(hpx::actions::detail::argument_holder<Args> const& t)
     {
@@ -120,7 +120,7 @@ namespace hpx { namespace util
     }
 
     template <std::size_t I, typename Args>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
     typename util::tuple_element<I, Args>::type&&
     get(hpx::actions::detail::argument_holder<Args>&& t)
     {
@@ -129,7 +129,7 @@ namespace hpx { namespace util
     }
 
     template <std::size_t I, typename Args>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
     typename util::tuple_element<I, Args>::type const&&
     get(hpx::actions::detail::argument_holder<Args> const&& t)
     {
@@ -283,7 +283,7 @@ namespace hpx { namespace actions
     public:
         /// retrieve the N's argument
         template <std::size_t N>
-        HPX_CONSTEXPR inline
+        constexpr inline
         typename util::tuple_element<N, arguments_type>::type const&
         get() const
         {
@@ -343,7 +343,7 @@ namespace hpx { namespace actions
 
     ///////////////////////////////////////////////////////////////////////////
     template <std::size_t N, typename Action>
-    HPX_CONSTEXPR inline typename util::tuple_element<
+    constexpr inline typename util::tuple_element<
         N, typename transfer_action<Action>::arguments_type
     >::type const& get(transfer_base_action<Action> const& args)
     {
diff --git a/hpx/runtime/actions/transfer_continuation_action.hpp b/hpx/runtime/actions/transfer_continuation_action.hpp
index bb92de3559..980a1513f3 100644
--- a/hpx/runtime/actions/transfer_continuation_action.hpp
+++ b/hpx/runtime/actions/transfer_continuation_action.hpp
@@ -21,9 +21,9 @@
 #include <hpx/serialization/input_archive.hpp>
 #include <hpx/serialization/output_archive.hpp>
 #include <hpx/serialization/serialization_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -76,7 +76,7 @@ namespace hpx { namespace actions
         ///       continuations.
         template <std::size_t ...Is>
         threads::thread_function_type
-        get_thread_function(util::detail::pack_c<std::size_t, Is...>,
+        get_thread_function(util::index_pack<Is...>,
             naming::id_type&& target, naming::address::address_type lva,
             naming::address::component_type comptype);
 
@@ -86,7 +86,7 @@ namespace hpx { namespace actions
             naming::address::component_type comptype) override;
 
         template <std::size_t... Is>
-        void schedule_thread(util::detail::pack_c<std::size_t, Is...>,
+        void schedule_thread(util::index_pack<Is...>,
             naming::gid_type const& target_gid,
             naming::address::address_type lva,
             naming::address::component_type comptype, std::size_t num_thread);
@@ -140,7 +140,7 @@ namespace hpx { namespace actions
     template <std::size_t ...Is>
     threads::thread_function_type
     transfer_continuation_action<Action>::get_thread_function(
-        util::detail::pack_c<std::size_t, Is...>,
+        util::index_pack<Is...>,
         naming::id_type&& target, naming::address::address_type lva,
         naming::address::component_type comptype)
     {
@@ -156,7 +156,7 @@ namespace hpx { namespace actions
         naming::address::component_type comptype)
     {
         return get_thread_function(
-            typename util::detail::make_index_pack<Action::arity>::type(),
+            typename util::make_index_pack<Action::arity>::type(),
             std::move(target), lva, comptype);
     }
 
@@ -164,7 +164,7 @@ namespace hpx { namespace actions
     template <std::size_t ...Is>
     void
     transfer_continuation_action<Action>::schedule_thread(
-        util::detail::pack_c<std::size_t, Is...>,
+        util::index_pack<Is...>,
         naming::gid_type const& target_gid,
         naming::address::address_type lva,
         naming::address::component_type comptype, std::size_t /*num_thread*/)
@@ -192,7 +192,7 @@ namespace hpx { namespace actions
         naming::address::component_type comptype, std::size_t num_thread)
     {
         schedule_thread(
-            typename util::detail::make_index_pack<Action::arity>::type(),
+            typename util::make_index_pack<Action::arity>::type(),
             target_gid, lva, comptype, num_thread);
 
         // keep track of number of invocations
diff --git a/hpx/runtime/agas/addressing_service.hpp b/hpx/runtime/agas/addressing_service.hpp
index 256c76aa89..50ab0d742c 100644
--- a/hpx/runtime/agas/addressing_service.hpp
+++ b/hpx/runtime/agas/addressing_service.hpp
@@ -15,7 +15,7 @@
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/synchronization/spinlock.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/runtime/agas_fwd.hpp>
 #include <hpx/runtime/agas/gva.hpp>
 #include <hpx/runtime/agas/component_namespace.hpp>
diff --git a/hpx/runtime/agas/big_boot_barrier.hpp b/hpx/runtime/agas/big_boot_barrier.hpp
index a59a236ea2..29468fb9ac 100644
--- a/hpx/runtime/agas/big_boot_barrier.hpp
+++ b/hpx/runtime/agas/big_boot_barrier.hpp
@@ -19,7 +19,7 @@
 #include <hpx/runtime/naming/address.hpp>
 #include <hpx/runtime/parcelset_fwd.hpp>
 #include <hpx/util/connection_cache.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 #include <hpx/util_fwd.hpp>
 #include <boost/lockfree/queue.hpp>
 
diff --git a/hpx/runtime/agas/gva.hpp b/hpx/runtime/agas/gva.hpp
index edcaba420c..ce31ce1fd9 100644
--- a/hpx/runtime/agas/gva.hpp
+++ b/hpx/runtime/agas/gva.hpp
@@ -1,6 +1,6 @@
 ////////////////////////////////////////////////////////////////////////////////
 //  Copyright (c)      2011 Bryce Adelstein-Lelbach
-//  Copyright (c) 2007-2012 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -13,10 +13,9 @@
 #include <hpx/config.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/runtime/naming/name.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 #include <hpx/errors.hpp>
 
-#include <boost/io/ios_state.hpp>
-
 #include <cstdint>
 
 namespace hpx { namespace agas
@@ -160,7 +159,7 @@ template <typename Char, typename Traits>
 inline std::basic_ostream<Char, Traits>&
 operator<< (std::basic_ostream<Char, Traits>& os, gva const& addr)
 {
-    boost::io::ios_flags_saver ifs(os);
+    hpx::util::ios_flags_saver ifs(os);
     os << "(" << addr.prefix << " "
        << components::get_component_type_name(addr.type) << " "
        << addr.count << " "
diff --git a/hpx/runtime/agas/namespace_action_code.hpp b/hpx/runtime/agas/namespace_action_code.hpp
index e6465ad906..36358208a7 100644
--- a/hpx/runtime/agas/namespace_action_code.hpp
+++ b/hpx/runtime/agas/namespace_action_code.hpp
@@ -13,8 +13,6 @@
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
 
-#include <boost/utility/binary.hpp>
-
 #include <cstddef>
 #include <string>
 
@@ -29,48 +27,48 @@ enum namespace_action_code
 {
     invalid_request                         = 0,
 
-    locality_ns_service                     = BOOST_BINARY_U(1100000),
-    locality_ns_bulk_service                = BOOST_BINARY_U(1100001),
-    locality_ns_allocate                    = BOOST_BINARY_U(1100010),
-    locality_ns_free                        = BOOST_BINARY_U(1100011),
-    locality_ns_localities                  = BOOST_BINARY_U(1100100),
-    locality_ns_num_localities              = BOOST_BINARY_U(1100101),
-    locality_ns_num_threads                 = BOOST_BINARY_U(1100110),
-    locality_ns_statistics_counter          = BOOST_BINARY_U(1100111),
-    locality_ns_resolve_locality            = BOOST_BINARY_U(1101000),
+    locality_ns_service                     = 0b1100000,
+    locality_ns_bulk_service                = 0b1100001,
+    locality_ns_allocate                    = 0b1100010,
+    locality_ns_free                        = 0b1100011,
+    locality_ns_localities                  = 0b1100100,
+    locality_ns_num_localities              = 0b1100101,
+    locality_ns_num_threads                 = 0b1100110,
+    locality_ns_statistics_counter          = 0b1100111,
+    locality_ns_resolve_locality            = 0b1101000,
 
-    primary_ns_service                      = BOOST_BINARY_U(1000000),
-    primary_ns_bulk_service                 = BOOST_BINARY_U(1000001),
-    primary_ns_route                        = BOOST_BINARY_U(1000010),
-    primary_ns_bind_gid                     = BOOST_BINARY_U(1000011),
-    primary_ns_resolve_gid                  = BOOST_BINARY_U(1000100),
-    primary_ns_unbind_gid                   = BOOST_BINARY_U(1000101),
-    primary_ns_increment_credit             = BOOST_BINARY_U(1000110),
-    primary_ns_decrement_credit             = BOOST_BINARY_U(1000111),
-    primary_ns_allocate                     = BOOST_BINARY_U(1001000),
-    primary_ns_begin_migration              = BOOST_BINARY_U(1001001),
-    primary_ns_end_migration                = BOOST_BINARY_U(1001010),
-    primary_ns_statistics_counter           = BOOST_BINARY_U(1001011),
+    primary_ns_service                      = 0b1000000,
+    primary_ns_bulk_service                 = 0b1000001,
+    primary_ns_route                        = 0b1000010,
+    primary_ns_bind_gid                     = 0b1000011,
+    primary_ns_resolve_gid                  = 0b1000100,
+    primary_ns_unbind_gid                   = 0b1000101,
+    primary_ns_increment_credit             = 0b1000110,
+    primary_ns_decrement_credit             = 0b1000111,
+    primary_ns_allocate                     = 0b1001000,
+    primary_ns_begin_migration              = 0b1001001,
+    primary_ns_end_migration                = 0b1001010,
+    primary_ns_statistics_counter           = 0b1001011,
 
-    component_ns_service                    = BOOST_BINARY_U(0100000),
-    component_ns_bulk_service               = BOOST_BINARY_U(0100001),
-    component_ns_bind_prefix                = BOOST_BINARY_U(0100010),
-    component_ns_bind_name                  = BOOST_BINARY_U(0100011),
-    component_ns_resolve_id                 = BOOST_BINARY_U(0100100),
-    component_ns_unbind_name                = BOOST_BINARY_U(0100101),
-    component_ns_iterate_types              = BOOST_BINARY_U(0100110),
-    component_ns_get_component_type_name    = BOOST_BINARY_U(0100111),
-    component_ns_num_localities             = BOOST_BINARY_U(0101000),
-    component_ns_statistics_counter         = BOOST_BINARY_U(0101001),
+    component_ns_service                    = 0b0100000,
+    component_ns_bulk_service               = 0b0100001,
+    component_ns_bind_prefix                = 0b0100010,
+    component_ns_bind_name                  = 0b0100011,
+    component_ns_resolve_id                 = 0b0100100,
+    component_ns_unbind_name                = 0b0100101,
+    component_ns_iterate_types              = 0b0100110,
+    component_ns_get_component_type_name    = 0b0100111,
+    component_ns_num_localities             = 0b0101000,
+    component_ns_statistics_counter         = 0b0101001,
 
-    symbol_ns_service                       = BOOST_BINARY_U(0010000),
-    symbol_ns_bulk_service                  = BOOST_BINARY_U(0010001),
-    symbol_ns_bind                          = BOOST_BINARY_U(0010010),
-    symbol_ns_resolve                       = BOOST_BINARY_U(0010011),
-    symbol_ns_unbind                        = BOOST_BINARY_U(0010100),
-    symbol_ns_iterate_names                 = BOOST_BINARY_U(0010101),
-    symbol_ns_on_event                      = BOOST_BINARY_U(0010110),
-    symbol_ns_statistics_counter            = BOOST_BINARY_U(0010111)
+    symbol_ns_service                       = 0b0010000,
+    symbol_ns_bulk_service                  = 0b0010001,
+    symbol_ns_bind                          = 0b0010010,
+    symbol_ns_resolve                       = 0b0010011,
+    symbol_ns_unbind                        = 0b0010100,
+    symbol_ns_iterate_names                 = 0b0010101,
+    symbol_ns_on_event                      = 0b0010110,
+    symbol_ns_statistics_counter            = 0b0010111
 };
 
 namespace detail
diff --git a/hpx/runtime/agas_fwd.hpp b/hpx/runtime/agas_fwd.hpp
index 8af529691a..41e0c27f71 100644
--- a/hpx/runtime/agas_fwd.hpp
+++ b/hpx/runtime/agas_fwd.hpp
@@ -10,6 +10,7 @@
 
 #include <hpx/config.hpp>
 #include <hpx/functional/function.hpp>
+#include <hpx/runtime_configuration/agas_service_mode.hpp>
 
 #include <cstdint>
 #include <string>
@@ -37,13 +38,6 @@ namespace hpx { namespace agas
         struct HPX_EXPORT symbol_namespace;
     }
     struct HPX_API_EXPORT addressing_service;
-
-    enum service_mode
-    {
-        service_mode_invalid = -1,
-        service_mode_bootstrap = 0,
-        service_mode_hosted = 1
-    };
 }}
 
 #endif /*HPX_RUNTIME_AGAS_FWD_HPP*/
diff --git a/hpx/runtime/applier/applier.hpp b/hpx/runtime/applier/applier.hpp
index 51abc214de..3575fb570d 100644
--- a/hpx/runtime/applier/applier.hpp
+++ b/hpx/runtime/applier/applier.hpp
@@ -18,7 +18,6 @@
 #include <hpx/runtime/naming/name.hpp>
 #include <hpx/runtime/parcelset/parcel.hpp>
 #include <hpx/runtime/parcelset_fwd.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 #include <hpx/threadmanager.hpp>
 
 #include <cstddef>
diff --git a/hpx/runtime/applier/apply_callback.hpp b/hpx/runtime/applier/apply_callback.hpp
index c530b000b1..babdeeb603 100644
--- a/hpx/runtime/applier/apply_callback.hpp
+++ b/hpx/runtime/applier/apply_callback.hpp
@@ -8,7 +8,6 @@
 #define HPX_APPLIER_APPLY_CALLBACK_DEC_16_2012_1228PM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/format.hpp>
@@ -17,6 +16,7 @@
 #include <hpx/traits/extract_action.hpp>
 #include <hpx/traits/is_continuation.hpp>
 #include <hpx/traits/is_distribution_policy.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <hpx/runtime/applier/apply.hpp>
 
@@ -431,14 +431,12 @@ namespace hpx
             void operator()()
             {
                 apply_action(
-                    typename util::detail::make_index_pack<
-                        sizeof...(Ts)
-                    >::type());
+                    typename util::make_index_pack<sizeof...(Ts)>::type());
             }
 
         protected:
             template <std::size_t ...Is>
-            void apply_action(util::detail::pack_c<std::size_t, Is...>)
+            void apply_action(util::index_pack<Is...>)
             {
                 if (addr_)
                 {
diff --git a/hpx/runtime/applier/apply_helper.hpp b/hpx/runtime/applier/apply_helper.hpp
index acdbaa2255..4cc382d576 100644
--- a/hpx/runtime/applier/apply_helper.hpp
+++ b/hpx/runtime/applier/apply_helper.hpp
@@ -13,7 +13,7 @@
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/runtime/naming/address.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/state.hpp>
 #include <hpx/traits/action_continuation.hpp>
diff --git a/hpx/runtime/applier/detail/apply_colocated.hpp b/hpx/runtime/applier/detail/apply_colocated.hpp
index adb7dcf864..bdf756185b 100644
--- a/hpx/runtime/applier/detail/apply_colocated.hpp
+++ b/hpx/runtime/applier/detail/apply_colocated.hpp
@@ -73,7 +73,7 @@ namespace hpx { namespace detail
         // shortcut co-location code if target already is a locality
         if (naming::is_locality(gid))
         {
-            return apply_c<Action>(std::forward<Continuation>(cont), gid,
+            return apply_continue<Action>(std::forward<Continuation>(cont), gid,
                 std::forward<Ts>(vs)...);
         }
 
diff --git a/hpx/runtime/applier/detail/apply_implementations_fwd.hpp b/hpx/runtime/applier/detail/apply_implementations_fwd.hpp
index 9a70c891ba..12d3b05744 100644
--- a/hpx/runtime/applier/detail/apply_implementations_fwd.hpp
+++ b/hpx/runtime/applier/detail/apply_implementations_fwd.hpp
@@ -10,6 +10,7 @@
 #include <hpx/config.hpp>
 #include <hpx/runtime/naming/address.hpp>
 #include <hpx/runtime/naming/id_type.hpp>
+#include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/traits/is_continuation.hpp>
 
 #include <type_traits>
diff --git a/hpx/runtime/applier/register_apply_colocated.hpp b/hpx/runtime/applier/register_apply_colocated.hpp
index 4952b87eb6..5c5c42fc5b 100644
--- a/hpx/runtime/applier/register_apply_colocated.hpp
+++ b/hpx/runtime/applier/register_apply_colocated.hpp
@@ -11,27 +11,28 @@
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/functional/unique_function.hpp>
-#include <hpx/runtime/naming/name.hpp>
 #include <hpx/runtime/naming/id_type.hpp>
+#include <hpx/runtime/naming/name.hpp>
+#include <hpx/type_support/pack.hpp>
+#include <hpx/util/bind_action.hpp>
 #include <hpx/util/functional/colocated_helpers.hpp>
 
 namespace hpx { namespace detail
 {
-    template <typename Tuple>
-    struct apply_colocated_bound_tuple;
+    template <typename Action, typename Ts = typename Action::arguments_type>
+    struct apply_colocated_bound_action;
 
-    template <typename ...Ts>
-    struct apply_colocated_bound_tuple<util::tuple<Ts...> >
+    template <typename Action, typename... Ts>
+    struct apply_colocated_bound_action<Action, hpx::util::tuple<Ts...>>
     {
-        typedef
-            util::tuple<
-                hpx::util::detail::bound<
-                    hpx::util::functional::extract_locality
-                  , hpx::util::detail::placeholder<2ul>
-                  , hpx::id_type
-                >
-              , Ts...
-            >
+        typedef hpx::util::detail::bound_action<Action
+          , hpx::util::make_index_pack<1 + sizeof...(Ts)>
+          , hpx::util::detail::bound<
+                hpx::util::functional::extract_locality
+              , hpx::util::index_pack<0, 1>
+              , hpx::util::detail::placeholder<2ul>
+              , hpx::id_type>
+          , Ts...>
             type;
     };
 }}
@@ -42,12 +43,7 @@ namespace hpx { namespace detail
     HPX_UTIL_REGISTER_UNIQUE_FUNCTION_DECLARATION(                            \
         void (hpx::naming::id_type, hpx::naming::id_type)                     \
       , (hpx::util::functional::detail::apply_continuation_impl<              \
-            hpx::util::detail::bound_action<                                  \
-                Action                                                        \
-              , hpx::detail::apply_colocated_bound_tuple<                     \
-                    Action ::arguments_type                                   \
-                >::type                                                       \
-            >                                                                 \
+            typename hpx::detail::apply_colocated_bound_action<Action>::type  \
         >)                                                                    \
       , Name                                                                  \
     );                                                                        \
@@ -60,12 +56,7 @@ namespace hpx { namespace detail
     HPX_UTIL_REGISTER_UNIQUE_FUNCTION(                                        \
         void (hpx::naming::id_type, hpx::naming::id_type)                     \
       , (hpx::util::functional::detail::apply_continuation_impl<              \
-            hpx::util::detail::bound_action<                                  \
-                action                                                        \
-              , hpx::detail::apply_colocated_bound_tuple<                     \
-                    action::arguments_type                                    \
-                >::type                                                       \
-            >                                                                 \
+            typename hpx::detail::apply_colocated_bound_action<Action>::type  \
         >)                                                                    \
       , name                                                                  \
     );                                                                        \
diff --git a/hpx/runtime/basename_registration.hpp b/hpx/runtime/basename_registration.hpp
index c30d3665a1..17c51f572e 100644
--- a/hpx/runtime/basename_registration.hpp
+++ b/hpx/runtime/basename_registration.hpp
@@ -139,7 +139,7 @@ namespace hpx
         std::size_t sequence_nr)
     {
         return client.then(
-            [sequence_nr, HPX_CAPTURE_MOVE(base_name)](
+            [sequence_nr, base_name = std::move(base_name)](
                 components::client_base<Client, Stub> && c
             ) mutable -> hpx::future<bool>
             {
diff --git a/hpx/runtime/components/binpacking_distribution_policy.hpp b/hpx/runtime/components/binpacking_distribution_policy.hpp
index de17d37436..4510d1dd52 100644
--- a/hpx/runtime/components/binpacking_distribution_policy.hpp
+++ b/hpx/runtime/components/binpacking_distribution_policy.hpp
@@ -297,7 +297,7 @@ namespace hpx { namespace components
                     id, count, std::forward<Ts>(vs)...);
 
             return f.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](
+                [id = std::move(id)](
                     hpx::future<std::vector<hpx::id_type> > && f
                 ) -> std::vector<bulk_locality_result>
                 {
diff --git a/hpx/runtime/components/colocating_distribution_policy.hpp b/hpx/runtime/components/colocating_distribution_policy.hpp
index 32b6570728..891edefed6 100644
--- a/hpx/runtime/components/colocating_distribution_policy.hpp
+++ b/hpx/runtime/components/colocating_distribution_policy.hpp
@@ -135,7 +135,7 @@ namespace hpx { namespace components
             }
 
             return f.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](
+                [id = std::move(id)](
                     hpx::future<std::vector<hpx::id_type> > && f
                 ) -> std::vector<bulk_locality_result>
                 {
diff --git a/hpx/runtime/components/component_factory_base.hpp b/hpx/runtime/components/component_factory_base.hpp
index 511fec9364..db9cdbc8d6 100644
--- a/hpx/runtime/components/component_factory_base.hpp
+++ b/hpx/runtime/components/component_factory_base.hpp
@@ -8,7 +8,7 @@
 #define HPX_COMPONENT_FACTORY_BASE_SEP_26_2008_0446PM
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/components/component_registry_base.hpp>
+#include <hpx/runtime_configuration/component_registry_base.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
 /// This macro is used to register the given component factory with
diff --git a/hpx/runtime/components/component_registry.hpp b/hpx/runtime/components/component_registry.hpp
index d50b64e1d3..54ea503014 100644
--- a/hpx/runtime/components/component_registry.hpp
+++ b/hpx/runtime/components/component_registry.hpp
@@ -15,7 +15,7 @@
 #include <hpx/preprocessor/nargs.hpp>
 #include <hpx/preprocessor/stringize.hpp>
 #include <hpx/runtime/components/component_factory_base.hpp>
-#include <hpx/runtime/components/component_registry_base.hpp>
+#include <hpx/runtime_configuration/component_registry_base.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/runtime/components/server/destroy_component.hpp>
 #include <hpx/traits/component_config_data.hpp>
diff --git a/hpx/runtime/components/component_type.hpp b/hpx/runtime/components/component_type.hpp
index 807ed50180..559e50d483 100644
--- a/hpx/runtime/components/component_type.hpp
+++ b/hpx/runtime/components/component_type.hpp
@@ -177,12 +177,12 @@ namespace hpx { namespace components
 
     // Returns the (unique) name for a given component
     template <typename Component, typename Enable = void>
-    HPX_CONSTEXPR char const* get_component_name();
+    constexpr char const* get_component_name();
 
     // Returns the (unique) name of the base component. If there is none,
     // nullptr is returned
     template <typename Component, typename Enable = void>
-    HPX_CONSTEXPR const char* get_component_base_name();
+    constexpr const char* get_component_base_name();
 
     template <typename Component>
     inline void set_component_type(component_type type)
@@ -256,12 +256,12 @@ namespace hpx { namespace components
 
 #define HPX_DEFINE_COMPONENT_NAME_2(Component, name)                          \
 namespace hpx { namespace components {                                        \
-    template <> HPX_CONSTEXPR                                                 \
+    template <> constexpr                                                     \
     char const* get_component_name< Component, void>()                        \
     {                                                                         \
         return HPX_PP_STRINGIZE(name);                                        \
     }                                                                         \
-    template <> HPX_CONSTEXPR                                                 \
+    template <> constexpr                                                     \
     char const* get_component_base_name< Component, void>()                   \
     {                                                                         \
         return nullptr;                                                       \
@@ -271,12 +271,12 @@ namespace hpx { namespace components {                                        \
 
 #define HPX_DEFINE_COMPONENT_NAME_3(Component, name, base_name)               \
 namespace hpx { namespace components {                                        \
-    template <> HPX_CONSTEXPR                                                 \
+    template <> constexpr                                                     \
     char const* get_component_name< Component, void>()                        \
     {                                                                         \
         return HPX_PP_STRINGIZE(name);                                        \
     }                                                                         \
-    template <> HPX_CONSTEXPR                                                 \
+    template <> constexpr                                                     \
     char const* get_component_base_name< Component, void>()                   \
     {                                                                         \
         return base_name;                                                     \
diff --git a/hpx/runtime/components/default_distribution_policy.hpp b/hpx/runtime/components/default_distribution_policy.hpp
index c3c73efc8e..99850c872d 100644
--- a/hpx/runtime/components/default_distribution_policy.hpp
+++ b/hpx/runtime/components/default_distribution_policy.hpp
@@ -190,7 +190,7 @@ namespace hpx { namespace components
                     id, count, std::forward<Ts>(vs)...);
 
             return f.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](
+                [id = std::move(id)](
                     hpx::future<std::vector<hpx::id_type> > && f
                 ) -> std::vector<bulk_locality_result>
                 {
diff --git a/hpx/runtime/components/new.hpp b/hpx/runtime/components/new.hpp
index ba3ebf7244..2933364012 100644
--- a/hpx/runtime/components/new.hpp
+++ b/hpx/runtime/components/new.hpp
@@ -107,7 +107,7 @@ namespace hpx
     ///          of that type which can be used to refer to the newly created
     ///          component instance.
     ///
-    /// \note    The difference of this funtion to \a hpx::new_ is that it can
+    /// \note    The difference of this function to \a hpx::new_ is that it can
     ///          be used in cases where the supplied arguments are non-copyable
     ///          and non-movable. All operations are guaranteed to be local
     ///          only.
diff --git a/hpx/runtime/components/pinned_ptr.hpp b/hpx/runtime/components/pinned_ptr.hpp
index b6aee747c2..8fa1efa6cd 100644
--- a/hpx/runtime/components/pinned_ptr.hpp
+++ b/hpx/runtime/components/pinned_ptr.hpp
@@ -9,8 +9,8 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/naming_base.hpp>
 #include <hpx/runtime/get_lva.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/traits/action_decorate_function.hpp>
 #include <hpx/traits/component_pin_support.hpp>
 
@@ -32,14 +32,14 @@ namespace hpx { namespace components
               : lva_(0)
             {}
 
-            explicit pinned_ptr_base(naming::address::address_type lva) noexcept
+            explicit pinned_ptr_base(naming::address_type lva) noexcept
               : lva_(lva)
             {}
 
             virtual ~pinned_ptr_base() {}
 
         protected:
-            naming::address::address_type lva_;
+            naming::address_type lva_;
         };
 
         template <typename Component>
@@ -51,7 +51,7 @@ namespace hpx { namespace components
         public:
             pinned_ptr() noexcept {}
 
-            explicit pinned_ptr(naming::address::address_type lva) noexcept
+            explicit pinned_ptr(naming::address_type lva) noexcept
               : pinned_ptr_base(lva)
             {
                 HPX_ASSERT(0 != this->lva_);
@@ -95,7 +95,7 @@ namespace hpx { namespace components
         template <typename Component, typename Enable = void>
         struct create_helper
         {
-            static pinned_ptr call(naming::address::address_type)
+            static pinned_ptr call(naming::address_type)
             {
                 return pinned_ptr{};
             }
@@ -108,14 +108,14 @@ namespace hpx { namespace components
                 traits::component_decorates_action<Component>::value
             >::type>
         {
-            static pinned_ptr call(naming::address::address_type lva)
+            static pinned_ptr call(naming::address_type lva)
             {
                 return pinned_ptr(lva, id<Component>{});
             }
         };
 
         template <typename Component>
-        pinned_ptr(naming::address::address_type lva, id<Component>)
+        pinned_ptr(naming::address_type lva, id<Component>)
           : data_(new detail::pinned_ptr<Component>(lva))
         {
         }
@@ -130,7 +130,7 @@ namespace hpx { namespace components
         pinned_ptr& operator= (pinned_ptr && rhs) = default;
 
         template <typename Component>
-        static pinned_ptr create(naming::address::address_type lva)
+        static pinned_ptr create(naming::address_type lva)
         {
             using component_type = typename std::remove_cv<Component>::type;
             return create_helper<component_type>::call(lva);
diff --git a/hpx/runtime/components/server/abstract_component_base.hpp b/hpx/runtime/components/server/abstract_component_base.hpp
index 849f4366ec..1ea0f458af 100644
--- a/hpx/runtime/components/server/abstract_component_base.hpp
+++ b/hpx/runtime/components/server/abstract_component_base.hpp
@@ -13,8 +13,8 @@
 #include <hpx/config.hpp>
 #include <hpx/runtime/naming/address.hpp>
 #include <hpx/runtime/naming/id_type.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 #include <hpx/traits/is_component.hpp>
 
 #include <utility>
diff --git a/hpx/runtime/components/server/abstract_migration_support.hpp b/hpx/runtime/components/server/abstract_migration_support.hpp
index cd2a5807d2..f96b6267b2 100644
--- a/hpx/runtime/components/server/abstract_migration_support.hpp
+++ b/hpx/runtime/components/server/abstract_migration_support.hpp
@@ -36,7 +36,7 @@ namespace hpx { namespace components
         virtual ~abstract_base_migration_support() = default;
 
         // This component type supports migration.
-//         HPX_CONSTEXPR static bool supports_migration() { return true; }
+//         static constexpr bool supports_migration() { return true; }
 
         // Pinning functionality
         virtual void pin() = 0;
@@ -104,7 +104,7 @@ namespace hpx { namespace components
 
         ~abstract_migration_support() = default;
 
-        HPX_CXX14_CONSTEXPR void finalize() {}
+        constexpr void finalize() {}
 
         hpx::future<void> mark_as_migrated(
             hpx::id_type const& to_migrate) override
diff --git a/hpx/runtime/components/server/component_base.hpp b/hpx/runtime/components/server/component_base.hpp
index 4e9c695493..c85aeade4b 100644
--- a/hpx/runtime/components/server/component_base.hpp
+++ b/hpx/runtime/components/server/component_base.hpp
@@ -69,7 +69,7 @@ namespace hpx { namespace components
 
             /// \brief finalize() will be called just before the instance gets
             ///        destructed
-            HPX_CXX14_CONSTEXPR static void finalize()
+            static constexpr void finalize()
             {
             }
 
@@ -78,10 +78,10 @@ namespace hpx { namespace components
                 naming::gid_type const& gid) const;
 
 #if defined(HPX_DISABLE_ASSERTS) || defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)
-            HPX_CXX14_CONSTEXPR static void mark_as_migrated()
+            static constexpr void mark_as_migrated()
             {
             }
-            HPX_CXX14_CONSTEXPR static void on_migrated()
+            static constexpr void on_migrated()
             {
             }
 #else
@@ -145,8 +145,7 @@ namespace hpx { namespace components
         /// \brief Destruct a component
         ~component_base() = default;
 
-#if defined(HPX_HAVE_CXX11_EXTENDED_FRIEND_DECLARATIONS) &&                    \
-    !defined(__NVCC__)
+#if !defined(__NVCC__) && !defined(__CUDACC__)
     protected:
         // declare friends which are allowed to access get_base_gid()
         template <typename Component_, typename...Ts>
diff --git a/hpx/runtime/components/server/executor_component.hpp b/hpx/runtime/components/server/executor_component.hpp
index 0f0b0c76a4..babd4f68e7 100644
--- a/hpx/runtime/components/server/executor_component.hpp
+++ b/hpx/runtime/components/server/executor_component.hpp
@@ -10,15 +10,14 @@
 #include <hpx/config.hpp>
 #include <hpx/runtime/get_lva.hpp>
 #include <hpx/runtime/naming/address.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
-#include <hpx/util/annotated_function.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 #include <hpx/functional/deferred_call.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
+#include <hpx/execution/executors/execution.hpp>
 
 #include <type_traits>
 #include <utility>
diff --git a/hpx/runtime/components/server/fixed_component_base.hpp b/hpx/runtime/components/server/fixed_component_base.hpp
index a0353d63ca..aee0f24eaf 100644
--- a/hpx/runtime/components/server/fixed_component_base.hpp
+++ b/hpx/runtime/components/server/fixed_component_base.hpp
@@ -165,10 +165,10 @@ public:
     }
 
 #if defined(HPX_DISABLE_ASSERTS) || defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)
-    HPX_CXX14_CONSTEXPR static void mark_as_migrated()
+    static constexpr void mark_as_migrated()
     {
     }
-    HPX_CXX14_CONSTEXPR static void on_migrated()
+    static constexpr void on_migrated()
     {
     }
 #else
@@ -201,11 +201,11 @@ namespace detail
     struct fixed_heap
     {
 #if defined(HPX_DISABLE_ASSERTS) || defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)
-        HPX_CONSTEXPR static void* alloc(std::size_t count)
+        static constexpr void* alloc(std::size_t count)
         {
             return nullptr;
         }
-        HPX_CXX14_CONSTEXPR static void free(void* p, std::size_t count)
+        static constexpr void free(void* p, std::size_t count)
         {
         }
 #else
@@ -233,12 +233,12 @@ class fixed_component : public Component
     typedef detail::fixed_heap heap_type;
 
 #if defined(HPX_DISABLE_ASSERTS) || defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)
-    HPX_CONSTEXPR static Component* create(std::size_t count)
+    static constexpr Component* create(std::size_t count)
     {
         return nullptr;
     }
 
-    HPX_CXX14_CONSTEXPR static void destroy(Component* p, std::size_t count = 1)
+    static constexpr void destroy(Component* p, std::size_t count = 1)
     {
     }
 #else
diff --git a/hpx/runtime/components/server/invoke_function.hpp b/hpx/runtime/components/server/invoke_function.hpp
index 13e377e4a1..d93b387c75 100644
--- a/hpx/runtime/components/server/invoke_function.hpp
+++ b/hpx/runtime/components/server/invoke_function.hpp
@@ -8,10 +8,10 @@
 #define HPX_COMPONENTS_INVOKE_FUNCTION_JUL_21_2015_0521PM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/runtime/actions/basic_action.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <utility>
 
diff --git a/hpx/runtime/components/server/locking_hook.hpp b/hpx/runtime/components/server/locking_hook.hpp
index 5309299b1c..37cece4cc4 100644
--- a/hpx/runtime/components/server/locking_hook.hpp
+++ b/hpx/runtime/components/server/locking_hook.hpp
@@ -14,6 +14,7 @@
 #include <hpx/runtime/get_lva.hpp>
 #include <hpx/coroutines/coroutine.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/traits/action_decorate_function.hpp>
 
 #include <mutex>
@@ -85,6 +86,7 @@ namespace hpx { namespace components
             template <typename F, typename Enable = typename
                 std::enable_if<!std::is_same<typename hpx::util::decay<F>::type,
                     decorate_wrapper>::value>::type>
+            // NOLINTNEXTLINE(bugprone-forwarding-reference-overload)
             decorate_wrapper(F && f)
             {
                 threads::get_self().decorate_yield(std::forward<F>(f));
diff --git a/hpx/runtime/components/server/managed_component_base.hpp b/hpx/runtime/components/server/managed_component_base.hpp
index e2a03f3863..6c93e38a52 100644
--- a/hpx/runtime/components/server/managed_component_base.hpp
+++ b/hpx/runtime/components/server/managed_component_base.hpp
@@ -46,7 +46,7 @@ namespace hpx { namespace components
         struct init<traits::construct_with_back_ptr>
         {
             template <typename Component, typename Managed>
-            HPX_CXX14_CONSTEXPR static void call(Component* component,
+            static constexpr void call(Component* component,
                 Managed* this_)
             {
             }
@@ -101,7 +101,7 @@ namespace hpx { namespace components
         struct destroy_backptr<traits::managed_object_controls_lifetime>
         {
             template <typename BackPtr>
-            HPX_CXX14_CONSTEXPR static void call(BackPtr*)
+            static constexpr void call(BackPtr*)
             {
                 // The managed_component's lifetime is controlled by the
                 // component implementation. Do nothing.
@@ -118,7 +118,7 @@ namespace hpx { namespace components
         struct manage_lifetime<traits::managed_object_is_lifetime_controlled>
         {
             template <typename Component>
-            HPX_CXX14_CONSTEXPR static void call(Component*)
+            static constexpr void call(Component*)
             {
                 // The managed_component's lifetime is controlled by the
                 // component implementation. Do nothing.
@@ -150,12 +150,12 @@ namespace hpx { namespace components
             }
 
             template <typename Component>
-            HPX_CXX14_CONSTEXPR static void addref(Component*)
+            static constexpr void addref(Component*)
             {
             }
 
             template <typename Component>
-            HPX_CXX14_CONSTEXPR static void release(Component*)
+            static constexpr void release(Component*)
             {
             }
         };
@@ -169,13 +169,13 @@ namespace hpx { namespace components
         {
             /// \brief finalize() will be called just before the instance gets
             ///        destructed
-            HPX_CXX14_CONSTEXPR static void finalize() {}
+            static constexpr void finalize() {}
 
 #if defined(HPX_DISABLE_ASSERTS) || defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)
-            HPX_CXX14_CONSTEXPR static void mark_as_migrated()
+            static constexpr void mark_as_migrated()
             {
             }
-            HPX_CXX14_CONSTEXPR static void on_migrated()
+            static constexpr void on_migrated()
             {
             }
 #else
@@ -379,7 +379,7 @@ namespace hpx { namespace components
         /// \brief finalize() will be called just before the instance gets
         ///        destructed
         ///
-        HPX_CXX14_CONSTEXPR static void finalize() {}
+        static constexpr void finalize() {}
 
         /// \brief Return a pointer to the wrapped instance
         /// \note  Caller must check validity of returned pointer
@@ -462,8 +462,7 @@ namespace hpx { namespace components
 #endif
 
     private:
-#if defined(HPX_HAVE_CXX11_EXTENDED_FRIEND_DECLARATIONS) && !defined(__NVCC__) && \
-    !defined(__CUDACC__)
+#if !defined(__NVCC__) && !defined(__CUDACC__)
         // declare friends which are allowed to access get_base_gid()
         friend Component;
 
diff --git a/hpx/runtime/components/server/memory.hpp b/hpx/runtime/components/server/memory.hpp
index 805da2af1d..6492f53ca9 100644
--- a/hpx/runtime/components/server/memory.hpp
+++ b/hpx/runtime/components/server/memory.hpp
@@ -44,7 +44,7 @@ namespace hpx { namespace components { namespace server
 
         /// \brief finalize() will be called just before the instance gets
         ///        destructed
-        HPX_CXX14_CONSTEXPR static void finalize() {}
+        static constexpr void finalize() {}
 
         ///////////////////////////////////////////////////////////////////////
         // exposed functionality of this component
@@ -123,7 +123,7 @@ namespace hpx { namespace components { namespace server
         HPX_DEFINE_COMPONENT_DIRECT_ACTION(memory, load128);
 
         // This component type requires valid id for its actions to be invoked
-        HPX_CONSTEXPR static bool is_target_valid(naming::id_type const&)
+        static constexpr bool is_target_valid(naming::id_type const&)
         {
             return true;
         }
diff --git a/hpx/runtime/components/server/migrate_component.hpp b/hpx/runtime/components/server/migrate_component.hpp
index 7a65e6c047..1f13b342a6 100644
--- a/hpx/runtime/components/server/migrate_component.hpp
+++ b/hpx/runtime/components/server/migrate_component.hpp
@@ -307,7 +307,7 @@ namespace hpx { namespace components { namespace server
                     // mark object in AGAS as being migrated first
                     return agas::begin_migration(to_migrate).then(
                         launch::sync,
-                        [HPX_CAPTURE_MOVE(ptr), to_migrate, policy](
+                        [ptr = std::move(ptr), to_migrate, policy](
                             hpx::future<bm_result> && bmf) mutable
                         -> future<id_type>
                     {
diff --git a/hpx/runtime/components/server/migration_support.hpp b/hpx/runtime/components/server/migration_support.hpp
index 78b42448c5..4d40dcd15e 100644
--- a/hpx/runtime/components/server/migration_support.hpp
+++ b/hpx/runtime/components/server/migration_support.hpp
@@ -71,7 +71,7 @@ namespace hpx { namespace components
         }
 
         // This component type supports migration.
-        HPX_CONSTEXPR static bool supports_migration() { return true; }
+        static constexpr bool supports_migration() { return true; }
 
         // Pinning functionality
         void pin()
@@ -188,7 +188,7 @@ namespace hpx { namespace components
 
         /// This hook is invoked on the newly created object after the migration
         /// has been finished
-        HPX_CXX14_CONSTEXPR void on_migrated() {}
+        constexpr void on_migrated() {}
 
         typedef void decorates_action;
 
diff --git a/hpx/runtime/components/server/runtime_support.hpp b/hpx/runtime/components/server/runtime_support.hpp
index 8eb13eef5c..036e9c0a3f 100644
--- a/hpx/runtime/components/server/runtime_support.hpp
+++ b/hpx/runtime/components/server/runtime_support.hpp
@@ -23,7 +23,7 @@
 #include <hpx/runtime/actions/manage_object_action.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/runtime/components/server/create_component.hpp>
-#include <hpx/runtime/components/static_factory_data.hpp>
+#include <hpx/runtime_configuration/static_factory_data.hpp>
 #include <hpx/runtime/find_here.hpp>
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/traits/action_does_termination_detection.hpp>
@@ -105,7 +105,7 @@ namespace hpx { namespace components { namespace server
         /// \param self [in] The HPX \a thread used to execute this function.
         /// \param appl [in] The applier to be used for finalization of the
         ///             component instance.
-        HPX_CXX14_CONSTEXPR static void finalize() {}
+        static constexpr void finalize() {}
 
         void delete_function_lists();
         void tidy();
diff --git a/hpx/runtime/components/stubs/runtime_support.hpp b/hpx/runtime/components/stubs/runtime_support.hpp
index e04eef9017..3e50cfc01d 100644
--- a/hpx/runtime/components/stubs/runtime_support.hpp
+++ b/hpx/runtime/components/stubs/runtime_support.hpp
@@ -20,7 +20,7 @@
 #include <hpx/runtime/naming/name.hpp>
 #include <hpx/serialization/vector.hpp>
 #include <hpx/type_support/decay.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
 
 #include <cstddef>
 #include <cstdint>
diff --git a/hpx/runtime/components/target_distribution_policy.hpp b/hpx/runtime/components/target_distribution_policy.hpp
index 93f60d35cd..aabf6cb15c 100644
--- a/hpx/runtime/components/target_distribution_policy.hpp
+++ b/hpx/runtime/components/target_distribution_policy.hpp
@@ -107,7 +107,7 @@ namespace hpx { namespace components
                     id, count, std::forward<Ts>(vs)...);
 
             return f.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](
+                [id = std::move(id)](
                     hpx::future<std::vector<hpx::id_type> > && f
                 ) -> std::vector<bulk_locality_result>
                 {
diff --git a/hpx/runtime/get_os_thread_count.hpp b/hpx/runtime/get_os_thread_count.hpp
index 896a76f885..bdfec5878c 100644
--- a/hpx/runtime/get_os_thread_count.hpp
+++ b/hpx/runtime/get_os_thread_count.hpp
@@ -10,7 +10,6 @@
 #define HPX_RUNTIME_GET_OS_THREAD_COUNT_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 
 #include <cstddef>
 
@@ -21,6 +20,10 @@ namespace hpx
     ///        the current HPX-thread is associated with.
     HPX_API_EXPORT std::size_t get_os_thread_count();
 
+    namespace threads {
+        class executor;
+    }
+
     /// \brief Return the number of worker OS- threads used by the given
     ///        executor to execute HPX threads
     ///
diff --git a/hpx/runtime/get_worker_thread_num.hpp b/hpx/runtime/get_worker_thread_num.hpp
index 553149a5e7..88c09b84a7 100644
--- a/hpx/runtime/get_worker_thread_num.hpp
+++ b/hpx/runtime/get_worker_thread_num.hpp
@@ -9,46 +9,6 @@
 #if !defined(HPX_RUNTIME_GET_WORKER_THREAD_NUM_AUG_15_2015_1120AM)
 #define HPX_RUNTIME_GET_WORKER_THREAD_NUM_AUG_15_2015_1120AM
 
-#include <hpx/config.hpp>
-#include <hpx/errors.hpp>
-
-#include <cstddef>
-
-namespace hpx
-{
-    ///////////////////////////////////////////////////////////////////////////
-    /// \brief Return the number of the current OS-thread running in the
-    ///        runtime instance the current HPX-thread is executed with.
-    ///
-    /// This function returns the zero based index of the OS-thread which
-    /// executes the current HPX-thread.
-    ///
-    /// \note   The returned value is zero based and its maximum value is
-    ///         smaller than the overall number of OS-threads executed (as
-    ///         returned by \a get_os_thread_count().
-    ///
-    /// \note   This function needs to be executed on a HPX-thread. It will
-    ///         fail otherwise (it will return -1).
-    HPX_API_EXPORT std::size_t get_worker_thread_num();
-
-    ///////////////////////////////////////////////////////////////////////////
-    /// \brief Return the number of the current OS-thread running in the
-    ///        runtime instance the current HPX-thread is executed with.
-    ///
-    /// This function returns the zero based index of the OS-thread which
-    /// executes the current HPX-thread.
-    ///
-    /// \param ec [in,out] this represents the error status on exit.
-    ///
-    /// \note   The returned value is zero based and its maximum value is
-    ///         smaller than the overall number of OS-threads executed (as
-    ///         returned by \a get_os_thread_count(). It will return -1 if
-    ///         the current thread is not a known thread or if the runtime is
-    ///         not in running state.
-    ///
-    /// \note   This function needs to be executed on a HPX-thread. It will
-    ///         fail otherwise (it will return -1).
-    HPX_API_EXPORT std::size_t get_worker_thread_num(error_code& ec);
-}
+#include <hpx/threading_base/thread_num_tss.hpp>
 
 #endif
diff --git a/hpx/runtime/launch_policy.hpp b/hpx/runtime/launch_policy.hpp
index 63caa61a00..a892dcc19e 100644
--- a/hpx/runtime/launch_policy.hpp
+++ b/hpx/runtime/launch_policy.hpp
@@ -38,29 +38,29 @@ namespace hpx
 
         struct policy_holder_base
         {
-            HPX_CONSTEXPR explicit policy_holder_base(launch_policy p,
+            constexpr explicit policy_holder_base(launch_policy p,
                     threads::thread_priority priority =
                         threads::thread_priority_default) noexcept
               : policy_(p),
                 priority_(priority)
             {}
 
-            HPX_CONSTEXPR explicit operator bool() const noexcept
+            constexpr explicit operator bool() const noexcept
             {
                 return is_valid();
             }
 
-            HPX_CONSTEXPR launch_policy get_policy() const noexcept
+            constexpr launch_policy get_policy() const noexcept
             {
                 return policy_;
             }
 
-            HPX_CONSTEXPR bool is_valid() const noexcept
+            constexpr bool is_valid() const noexcept
             {
                 return static_cast<int>(policy_) != 0;
             }
 
-            HPX_CONSTEXPR threads::thread_priority get_priority() const
+            constexpr threads::thread_priority get_priority() const
             {
                 return priority_;
             }
@@ -81,31 +81,31 @@ namespace hpx
         template <typename Derived = void>
         struct policy_holder : policy_holder_base
         {
-            HPX_CONSTEXPR explicit policy_holder(launch_policy p,
+            constexpr explicit policy_holder(launch_policy p,
                     threads::thread_priority priority =
                         threads::thread_priority_default) noexcept
               : policy_holder_base(p, priority)
             {}
 
-            HPX_CONSTEXPR explicit policy_holder(policy_holder_base p) noexcept
+            constexpr explicit policy_holder(policy_holder_base p) noexcept
               : policy_holder_base(p)
             {}
 
-            HPX_CONSTEXPR operator launch_policy() const noexcept
+            constexpr operator launch_policy() const noexcept
             {
                 return static_cast<Derived const*>(this)->get_policy();
             }
 
-            HPX_CONSTEXPR explicit operator bool() const noexcept
+            constexpr explicit operator bool() const noexcept
             {
                 return static_cast<Derived const*>(this)->is_valid();
             }
 
-            HPX_CONSTEXPR launch_policy policy() const
+            constexpr launch_policy policy() const
             {
                 return static_cast<Derived const*>(this)->get_policy();
             }
-            HPX_CONSTEXPR threads::thread_priority priority() const
+            constexpr threads::thread_priority priority() const
             {
                 return static_cast<Derived const*>(this)->get_priority();
             }
@@ -114,31 +114,31 @@ namespace hpx
         template <>
         struct policy_holder<void> : policy_holder_base
         {
-            HPX_CONSTEXPR explicit policy_holder(launch_policy p,
+            constexpr explicit policy_holder(launch_policy p,
                     threads::thread_priority priority =
                         threads::thread_priority_default) noexcept
               : policy_holder_base(p, priority)
             {}
 
-            HPX_CONSTEXPR explicit policy_holder(policy_holder_base p) noexcept
+            constexpr explicit policy_holder(policy_holder_base p) noexcept
               : policy_holder_base(p)
             {}
 
-            HPX_CONSTEXPR operator launch_policy() const noexcept
+            constexpr operator launch_policy() const noexcept
             {
                 return this->policy_holder_base::get_policy();
             }
 
-            HPX_CONSTEXPR explicit operator bool() const noexcept
+            constexpr explicit operator bool() const noexcept
             {
                 return this->policy_holder_base::is_valid();
             }
 
-            HPX_CONSTEXPR launch_policy policy() const
+            constexpr launch_policy policy() const
             {
                 return this->policy_holder_base::get_policy();
             }
-            HPX_CONSTEXPR threads::thread_priority priority() const
+            constexpr threads::thread_priority priority() const
             {
                 return this->policy_holder_base::get_priority();
             }
@@ -147,13 +147,13 @@ namespace hpx
         ///////////////////////////////////////////////////////////////////////
         struct async_policy : policy_holder<async_policy>
         {
-            HPX_CONSTEXPR explicit async_policy(
+            constexpr explicit async_policy(
                     threads::thread_priority priority =
                         threads::thread_priority_default) noexcept
               : policy_holder<async_policy>(launch_policy::async, priority)
             {}
 
-            HPX_CONSTEXPR async_policy operator()(
+            constexpr async_policy operator()(
                 threads::thread_priority priority) const noexcept
             {
                 return async_policy(priority);
@@ -162,13 +162,13 @@ namespace hpx
 
         struct fork_policy : policy_holder<fork_policy>
         {
-            HPX_CONSTEXPR explicit fork_policy(
+            constexpr explicit fork_policy(
                     threads::thread_priority priority =
                         threads::thread_priority_boost) noexcept
               : policy_holder<fork_policy>(launch_policy::fork, priority)
             {}
 
-            HPX_CONSTEXPR fork_policy operator()(
+            constexpr fork_policy operator()(
                 threads::thread_priority priority) const noexcept
             {
                 return fork_policy(priority);
@@ -177,21 +177,21 @@ namespace hpx
 
         struct sync_policy : policy_holder<sync_policy>
         {
-            HPX_CONSTEXPR sync_policy() noexcept
+            constexpr sync_policy() noexcept
               : policy_holder<sync_policy>(launch_policy::sync)
             {}
         };
 
         struct deferred_policy : policy_holder<deferred_policy>
         {
-            HPX_CONSTEXPR deferred_policy() noexcept
+            constexpr deferred_policy() noexcept
               : policy_holder<deferred_policy>(launch_policy::deferred)
             {}
         };
 
         struct apply_policy : policy_holder<apply_policy>
         {
-            HPX_CONSTEXPR apply_policy() noexcept
+            constexpr apply_policy() noexcept
               : policy_holder<apply_policy>(launch_policy::apply)
             {}
         };
@@ -211,12 +211,12 @@ namespace hpx
               , pred_(std::forward<F>(f))
             {}
 
-            HPX_CONSTEXPR launch_policy get_policy() const
+            constexpr launch_policy get_policy() const
             {
                 return pred_();
             }
 
-            HPX_CONSTEXPR bool is_valid() const noexcept
+            constexpr bool is_valid() const noexcept
             {
                 return true;
             }
@@ -227,7 +227,7 @@ namespace hpx
 
         struct select_policy_generator
         {
-            HPX_CONSTEXPR async_policy operator()(
+            constexpr async_policy operator()(
                 threads::thread_priority priority) const noexcept
             {
                 return async_policy(priority);
@@ -245,7 +245,7 @@ namespace hpx
 
         ///////////////////////////////////////////////////////////////////////
         template <typename Left, typename Right>
-        HPX_CONSTEXPR inline policy_holder_base operator&(
+        constexpr inline policy_holder_base operator&(
             policy_holder<Left> const& lhs,
             policy_holder<Right> const& rhs) noexcept
         {
@@ -257,7 +257,7 @@ namespace hpx
         }
 
         template <typename Left, typename Right>
-        HPX_CONSTEXPR inline policy_holder_base operator|(
+        constexpr inline policy_holder_base operator|(
             policy_holder<Left> const& lhs,
             policy_holder<Right> const& rhs) noexcept
         {
@@ -269,7 +269,7 @@ namespace hpx
         }
 
         template <typename Left, typename Right>
-        HPX_CONSTEXPR inline policy_holder_base operator^(
+        constexpr inline policy_holder_base operator^(
             policy_holder<Left> const& lhs,
             policy_holder<Right> const& rhs) noexcept
         {
@@ -281,7 +281,7 @@ namespace hpx
         }
 
         template <typename Derived>
-        HPX_CONSTEXPR inline policy_holder<Derived>
+        constexpr inline policy_holder<Derived>
         operator~(policy_holder<Derived> const& p) noexcept
         {
             return policy_holder<Derived>(
@@ -315,14 +315,14 @@ namespace hpx
         }
 
         template <typename Left, typename Right>
-        HPX_CONSTEXPR inline bool operator==(policy_holder<Left> const& lhs,
+        constexpr inline bool operator==(policy_holder<Left> const& lhs,
             policy_holder<Right> const& rhs) noexcept
         {
             return static_cast<int>(lhs.policy()) == static_cast<int>(rhs.policy());
         }
 
         template <typename Left, typename Right>
-        HPX_CONSTEXPR inline bool operator!=(policy_holder<Left> const& lhs,
+        constexpr inline bool operator!=(policy_holder<Left> const& lhs,
             policy_holder<Right> const& rhs) noexcept
         {
             return !(lhs == rhs);
@@ -337,50 +337,50 @@ namespace hpx
         ///////////////////////////////////////////////////////////////////////
         /// Default constructor. This creates a launch policy representing all
         /// possible launch modes
-        HPX_CONSTEXPR launch() noexcept
+        constexpr launch() noexcept
           : detail::policy_holder<>{detail::launch_policy::all}
         {}
 
         /// \cond NOINTERNAL
         template <typename Derived>
-        HPX_CONSTEXPR launch(detail::policy_holder<Derived> const& ph) noexcept
+        constexpr launch(detail::policy_holder<Derived> const& ph) noexcept
           : detail::policy_holder<>{ph}
         {}
 
-        HPX_CONSTEXPR launch(detail::policy_holder_base const& ph) noexcept
+        constexpr launch(detail::policy_holder_base const& ph) noexcept
           : detail::policy_holder<>{ph}
         {}
         /// \endcond
 
         /// Create a launch policy representing asynchronous execution
-        HPX_CONSTEXPR launch(detail::async_policy) noexcept
+        constexpr launch(detail::async_policy) noexcept
           : detail::policy_holder<>{detail::launch_policy::async}
         {}
 
         /// Create a launch policy representing asynchronous execution. The
         /// new thread is executed in a preferred way
-        HPX_CONSTEXPR launch(detail::fork_policy) noexcept
+        constexpr launch(detail::fork_policy) noexcept
           : detail::policy_holder<>{detail::launch_policy::fork}
         {}
 
         /// Create a launch policy representing synchronous execution
-        HPX_CONSTEXPR launch(detail::sync_policy) noexcept
+        constexpr launch(detail::sync_policy) noexcept
           : detail::policy_holder<>{detail::launch_policy::sync}
         {}
 
         /// Create a launch policy representing deferred execution
-        HPX_CONSTEXPR launch(detail::deferred_policy) noexcept
+        constexpr launch(detail::deferred_policy) noexcept
           : detail::policy_holder<>{detail::launch_policy::deferred}
         {}
 
         /// Create a launch policy representing fire and forget execution
-        HPX_CONSTEXPR launch(detail::apply_policy) noexcept
+        constexpr launch(detail::apply_policy) noexcept
           : detail::policy_holder<>{detail::launch_policy::apply}
         {}
 
         /// Create a launch policy representing fire and forget execution
         template <typename F>
-        HPX_CONSTEXPR launch(detail::select_policy<F> const& p) noexcept
+        constexpr launch(detail::select_policy<F> const& p) noexcept
           : detail::policy_holder<>{p.policy()}
         {}
 
@@ -426,7 +426,7 @@ namespace hpx
     /// \cond NOINTERNAL
     namespace detail
     {
-        HPX_FORCEINLINE HPX_CONSTEXPR
+        HPX_FORCEINLINE constexpr
         bool has_async_policy(launch p) noexcept
         {
             return bool(
@@ -436,7 +436,7 @@ namespace hpx
         }
 
         template <typename F>
-        HPX_FORCEINLINE HPX_CONSTEXPR
+        HPX_FORCEINLINE constexpr
         bool has_async_policy(detail::policy_holder<F> const& p) noexcept
         {
             return bool(
diff --git a/hpx/runtime/naming/name.hpp b/hpx/runtime/naming/name.hpp
index 18006f5b6c..722439b8be 100644
--- a/hpx/runtime/naming/name.hpp
+++ b/hpx/runtime/naming/name.hpp
@@ -22,7 +22,7 @@
 #include <hpx/thread_support/atomic_count.hpp>
 #include <hpx/traits/get_remote_result.hpp>
 #include <hpx/traits/promise_local_result.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <cstddef>
 #include <cstdint>
diff --git a/hpx/runtime/naming_fwd.hpp b/hpx/runtime/naming_fwd.hpp
index 39e3267daa..46f05b476d 100644
--- a/hpx/runtime/naming_fwd.hpp
+++ b/hpx/runtime/naming_fwd.hpp
@@ -9,6 +9,7 @@
 #define HPX_RUNTIME_NAMING_FWD_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/naming_base.hpp>
 #include <hpx/runtime/agas_fwd.hpp>
 
 #include <cstdint>
@@ -29,12 +30,6 @@ namespace hpx
 
         HPX_API_EXPORT resolver_client& get_agas_client();
 
-        using component_type = std::int32_t;
-        using address_type = std::uint64_t;
-
-        HPX_CONSTEXPR_OR_CONST std::uint32_t invalid_locality_id =
-            ~static_cast<std::uint32_t>(0);
-
         // tag used to mark serialization archive during check-pointing
         struct checkpointing_tag {};
     }
diff --git a/hpx/runtime/parcelset/decode_parcels.hpp b/hpx/runtime/parcelset/decode_parcels.hpp
index 75dd79bcb3..65229c1457 100644
--- a/hpx/runtime/parcelset/decode_parcels.hpp
+++ b/hpx/runtime/parcelset/decode_parcels.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2014-2015 Thomas Heller
 //
 //  SPDX-License-Identifier: BSL-1.0
@@ -24,7 +24,9 @@
 #include <hpx/timing/high_resolution_timer.hpp>
 #include <hpx/functional/deferred_call.hpp>
 
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
 #include <boost/exception/exception.hpp>
+#endif
 
 #include <cstddef>
 #include <cstdint>
@@ -250,11 +252,13 @@ namespace hpx { namespace parcelset
                     << e.what();
                 hpx::report_error(std::current_exception());
             }
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
             catch (boost::exception const&) {
                 LPT_(error)
                     << "decode_message: caught boost::exception.";
                 hpx::report_error(std::current_exception());
             }
+#endif
             catch (std::exception const& e) {
                 // We have to repackage all exceptions thrown by the
                 // serialization library as otherwise we will loose the
diff --git a/hpx/runtime/parcelset/encode_parcels.hpp b/hpx/runtime/parcelset/encode_parcels.hpp
index c41325a8c5..dd653ea790 100644
--- a/hpx/runtime/parcelset/encode_parcels.hpp
+++ b/hpx/runtime/parcelset/encode_parcels.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2011-2015 Thomas Heller
 //  Copyright (c) 2007 Richard D Guidry Jr
 //  Copyright (c) 2011 Bryce Lelbach
@@ -29,7 +29,9 @@
 #include <hpx/timing/high_resolution_timer.hpp>
 #include <hpx/util/integer/endian.hpp>
 
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
 #include <boost/exception/exception.hpp>
+#endif
 
 #include <cstddef>
 #include <cstdint>
@@ -244,6 +246,7 @@ namespace hpx
                     hpx::report_error(std::current_exception());
                     return 0;
                 }
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
                 catch (boost::exception const&) {
                     LPT_(fatal)
                         << "encode_parcels: "
@@ -251,6 +254,7 @@ namespace hpx
                     hpx::report_error(std::current_exception());
                     return 0;
                 }
+#endif
                 catch (std::exception const& e) {
                     // We have to repackage all exceptions thrown by the
                     // serialization library as otherwise we will loose the
diff --git a/hpx/runtime/parcelset/locality.hpp b/hpx/runtime/parcelset/locality.hpp
index c68e2015fd..4791b7acda 100644
--- a/hpx/runtime/parcelset/locality.hpp
+++ b/hpx/runtime/parcelset/locality.hpp
@@ -29,6 +29,7 @@
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace parcelset
 {
+    ////////////////////////////////////////////////////////////////////////////
     class HPX_EXPORT locality
     {
         template <typename Impl>
diff --git a/hpx/runtime/parcelset/parcel.hpp b/hpx/runtime/parcelset/parcel.hpp
index c19f7aefab..d5b275368f 100644
--- a/hpx/runtime/parcelset/parcel.hpp
+++ b/hpx/runtime/parcelset/parcel.hpp
@@ -14,6 +14,7 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_NETWORKING)
+#include <hpx/naming_base.hpp>
 #include <hpx/runtime/actions_fwd.hpp>
 #include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/runtime/naming/address.hpp>
@@ -21,6 +22,7 @@
 #include <hpx/runtime/parcelset_fwd.hpp>
 #include <hpx/serialization/serialization_fwd.hpp>
 #include <hpx/serialization/traits/is_bitwise_serializable.hpp>
+#include <hpx/coroutines/thread_enums.hpp>
 
 #include <cstddef>
 #include <cstdint>
diff --git a/hpx/runtime/parcelset/parcelhandler.hpp b/hpx/runtime/parcelset/parcelhandler.hpp
index fa0dfb3898..99eb7dcd56 100644
--- a/hpx/runtime/parcelset/parcelhandler.hpp
+++ b/hpx/runtime/parcelset/parcelhandler.hpp
@@ -91,7 +91,7 @@ namespace hpx { namespace parcelset
         ///                 transport operations the parcelhandler carries out.
         parcelhandler(util::runtime_configuration& cfg,
             threads::threadmanager* tm,
-            threads::policies::callback_notifier const& notifer);
+            threads::policies::callback_notifier const& notifier);
 
         ~parcelhandler() = default;
 
@@ -493,18 +493,16 @@ namespace hpx { namespace parcelset
         /// cache whether networking has been enabled
         bool is_networking_enabled_;
 
-    private:
+    public:
         static std::vector<plugins::parcelport_factory_base *> &
             get_parcelport_factories();
 
-    public:
         static void add_parcelport_factory(plugins::parcelport_factory_base *);
 
         static void init(int *argc, char ***argv, util::command_line_handling &cfg);
-
-        /// load runtime configuration settings ...
-        static std::vector<std::string> load_runtime_configuration();
     };
+
+    std::vector<std::string> load_runtime_configuration();
 }}
 
 #include <hpx/config/warnings_suffix.hpp>
diff --git a/hpx/runtime/parcelset/parcelport_impl.hpp b/hpx/runtime/parcelset/parcelport_impl.hpp
index eba535c7a7..aa6a179a41 100644
--- a/hpx/runtime/parcelset/parcelport_impl.hpp
+++ b/hpx/runtime/parcelset/parcelport_impl.hpp
@@ -23,13 +23,14 @@
 #include <hpx/runtime/parcelset/detail/parcel_await.hpp>
 #include <hpx/runtime/parcelset/encode_parcels.hpp>
 #include <hpx/runtime/parcelset/parcelport.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/thread_support/atomic_count.hpp>
 #include <hpx/util/connection_cache.hpp>
-#include <hpx/util/io_service_pool.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/util/get_entry_as.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <boost/predef/other/endian.h>
 
@@ -71,7 +72,7 @@ namespace hpx { namespace parcelset
             key += connection_handler_type();
 
             return hpx::util::get_entry_as<std::size_t>(
-                ini, key + ".io_pool_size", "2");
+                ini, key + ".io_pool_size", 2);
         }
 
         static const char *pool_name()
@@ -117,7 +118,7 @@ namespace hpx { namespace parcelset
           , archive_flags_(0)
           , operations_in_flight_(0)
           , num_thread_(0)
-          , max_background_thread_(hpx::util::safe_lexical_cast<std::size_t>(
+          , max_background_thread_(hpx::util::from_string<std::size_t>(
                 hpx::get_config_entry("hpx.max_background_threads",
                     (std::numeric_limits<std::size_t>::max)())))
         {
diff --git a/hpx/runtime/runtime_fwd.hpp b/hpx/runtime/runtime_fwd.hpp
index a7d9e8ad56..1c07fae96d 100644
--- a/hpx/runtime/runtime_fwd.hpp
+++ b/hpx/runtime/runtime_fwd.hpp
@@ -10,7 +10,6 @@
 #define HPX_RUNTIME_RUNTIME_FWD_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 
 namespace hpx
 {
diff --git a/hpx/runtime/serialization/detail/preprocess_container.hpp b/hpx/runtime/serialization/detail/preprocess_container.hpp
index 698a67c250..95902412a0 100644
--- a/hpx/runtime/serialization/detail/preprocess_container.hpp
+++ b/hpx/runtime/serialization/detail/preprocess_container.hpp
@@ -21,7 +21,7 @@ namespace hpx { namespace serialization { namespace detail {
     class preprocess_container
     {
     public:
-        HPX_CONSTEXPR preprocess_container()
+        constexpr preprocess_container()
           : size_(0)
         {
         }
@@ -40,7 +40,7 @@ namespace hpx { namespace serialization { namespace detail {
             size_ = 0;
         }
 
-        HPX_CONSTEXPR static bool is_preprocessing()
+        static constexpr bool is_preprocessing()
         {
             return true;
         }
@@ -60,7 +60,7 @@ namespace hpx { namespace traits {
     {
         using preprocessing_only = std::true_type;
 
-        HPX_CONSTEXPR static bool is_preprocessing()
+        static constexpr bool is_preprocessing()
         {
             return true;
         }
diff --git a/hpx/runtime/serialization/detail/preprocess_futures.hpp b/hpx/runtime/serialization/detail/preprocess_futures.hpp
index 41046fdf32..a0544f5889 100644
--- a/hpx/runtime/serialization/detail/preprocess_futures.hpp
+++ b/hpx/runtime/serialization/detail/preprocess_futures.hpp
@@ -136,7 +136,7 @@ namespace hpx { namespace serialization { namespace detail {
             auto& shared_state_ =
                 hpx::traits::future_access<hpx::future<void>>::get_shared_state(
                     fut);
-            shared_state_->set_on_completed([this, HPX_CAPTURE_MOVE(f)]() {
+            shared_state_->set_on_completed([this, f = std::move(f)]() {
                 reset();
                 f();
             });
diff --git a/hpx/runtime/thread_hooks.hpp b/hpx/runtime/thread_hooks.hpp
index 63e27dd483..f412fac17d 100644
--- a/hpx/runtime/thread_hooks.hpp
+++ b/hpx/runtime/thread_hooks.hpp
@@ -8,7 +8,7 @@
 #define HPX_THREAD_HOOKS_JUN_06_2018_0514PM
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
 
 namespace hpx
 {
diff --git a/hpx/runtime/thread_pool_helpers.hpp b/hpx/runtime/thread_pool_helpers.hpp
index b96db1865c..3d46e40a1a 100644
--- a/hpx/runtime/thread_pool_helpers.hpp
+++ b/hpx/runtime/thread_pool_helpers.hpp
@@ -10,15 +10,12 @@
 #define HPX_RUNTIME_THREAD_POOL_HELPERS_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
 #include <cstddef>
+#include <cstdint>
 #include <string>
 
-namespace hpx { namespace threads
-{
-    class HPX_EXPORT thread_pool_base;
-}}
-
 namespace hpx { namespace resource
 {
     ///////////////////////////////////////////////////////////////////////////
@@ -53,4 +50,46 @@ namespace hpx { namespace resource
         std::size_t pool_index);
 }}
 
+namespace hpx { namespace threads {
+    ///    The function \a get_thread_count returns the number of currently
+    /// known threads.
+    ///
+    /// \param state    [in] This specifies the thread-state for which the
+    ///                 number of threads should be retrieved.
+    ///
+    /// \note If state == unknown this function will not only return the
+    ///       number of currently existing threads, but will add the number
+    ///       of registered task descriptions (which have not been
+    ///       converted into threads yet).
+    HPX_API_EXPORT std::int64_t get_thread_count(
+        thread_state_enum state = unknown);
+
+    /// The function \a get_thread_count returns the number of currently
+    /// known threads.
+    ///
+    /// \param priority [in] This specifies the thread-priority for which the
+    ///                 number of threads should be retrieved.
+    /// \param state    [in] This specifies the thread-state for which the
+    ///                 number of threads should be retrieved.
+    ///
+    /// \note If state == unknown this function will not only return the
+    ///       number of currently existing threads, but will add the number
+    ///       of registered task descriptions (which have not been
+    ///       converted into threads yet).
+    HPX_API_EXPORT std::int64_t get_thread_count(
+        thread_priority priority, thread_state_enum state = unknown);
+
+    /// The function \a enumerate_threads will invoke the given function \a f
+    /// for each thread with a matching thread state.
+    ///
+    /// \param f        [in] The function which should be called for each
+    ///                 matching thread. Returning 'false' from this function
+    ///                 will stop the enumeration process.
+    /// \param state    [in] This specifies the thread-state for which the
+    ///                 threads should be enumerated.
+    HPX_API_EXPORT bool enumerate_threads(
+        util::function_nonser<bool(thread_id_type)> const& f,
+        thread_state_enum state = unknown);
+}}
+
 #endif
diff --git a/hpx/runtime/threads/detail/thread_num_tss.hpp b/hpx/runtime/threads/detail/thread_num_tss.hpp
deleted file mode 100644
index 29db7a1262..0000000000
--- a/hpx/runtime/threads/detail/thread_num_tss.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-//  Copyright (c) 2007-2015 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#if !defined(HPX_RUNTIME_THREADS_DETAIL_THREAD_NUM_TSS_JUL_17_2015_0811PM)
-#define HPX_RUNTIME_THREADS_DETAIL_THREAD_NUM_TSS_JUL_17_2015_0811PM
-
-#include <hpx/config.hpp>
-
-#include <cstddef>
-#include <cstdint>
-#include <tuple>
-#include <utility>
-
-#include <hpx/config/warnings_prefix.hpp>
-
-namespace hpx { namespace threads { namespace detail {
-    // set/get the global thread Id to/from thread local storage
-    HPX_EXPORT std::size_t set_thread_num_tss(std::size_t num);
-    HPX_EXPORT std::size_t get_thread_num_tss();
-
-    // this struct holds the local thread Id and the pool index
-    // associated with the thread
-    struct thread_pool
-    {
-        std::uint16_t local_thread_num;
-        std::uint16_t pool_index;
-    };
-    HPX_EXPORT void set_thread_pool_tss(const thread_pool&);
-    HPX_EXPORT thread_pool get_thread_pool_tss();
-
-    ///////////////////////////////////////////////////////////////////////////
-    struct reset_tss_helper
-    {
-        reset_tss_helper(std::size_t thread_num)
-          : thread_num_(set_thread_num_tss(thread_num))
-        {
-        }
-
-        ~reset_tss_helper()
-        {
-            set_thread_num_tss(thread_num_);
-        }
-
-        std::size_t previous_thread_num() const
-        {
-            return thread_num_;
-        }
-
-    private:
-        std::size_t thread_num_;
-    };
-}}}    // namespace hpx::threads::detail
-
-#include <hpx/config/warnings_suffix.hpp>
-
-#endif
diff --git a/hpx/runtime/threads/executors/current_executor.hpp b/hpx/runtime/threads/executors/current_executor.hpp
index 6e6389ae52..583df28147 100644
--- a/hpx/runtime/threads/executors/current_executor.hpp
+++ b/hpx/runtime/threads/executors/current_executor.hpp
@@ -9,13 +9,13 @@
 
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/runtime/threads_fwd.hpp>
 #include <hpx/state.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <chrono>
@@ -101,6 +101,42 @@ namespace hpx { namespace threads { namespace executors
     };
 }}}
 
+namespace hpx { namespace threads {
+    ///  Returns a reference to the executor which was used to create
+    /// the given thread.
+    ///
+    /// \throws If <code>&ec != &throws</code>, never throws, but will set \a ec
+    ///         to an appropriate value when an error occurs. Otherwise, this
+    ///         function will throw an \a hpx#exception with an error code of
+    ///         \a hpx#yield_aborted if it is signaled with \a wait_aborted.
+    ///         If called outside of a HPX-thread, this function will throw
+    ///         an \a hpx#exception with an error code of \a hpx::null_thread_id.
+    ///         If this function is called while the thread-manager is not
+    ///         running, it will throw an \a hpx#exception with an error code of
+    ///         \a hpx#invalid_status.
+    ///
+    HPX_API_EXPORT threads::executors::current_executor get_executor(
+        thread_id_type const& id, error_code& ec = throws);
+}}
+
+namespace hpx { namespace this_thread {
+    /// Returns a reference to the executor which was used to create the current
+    /// thread.
+    ///
+    /// \throws If <code>&ec != &throws</code>, never throws, but will set \a ec
+    ///         to an appropriate value when an error occurs. Otherwise, this
+    ///         function will throw an \a hpx#exception with an error code of
+    ///         \a hpx#yield_aborted if it is signaled with \a wait_aborted.
+    ///         If called outside of a HPX-thread, this function will throw
+    ///         an \a hpx#exception with an error code of \a hpx::null_thread_id.
+    ///         If this function is called while the thread-manager is not
+    ///         running, it will throw an \a hpx#exception with an error code of
+    ///         \a hpx#invalid_status.
+    ///
+    HPX_EXPORT threads::executors::current_executor get_executor(
+        error_code& ec = throws);
+}}
+
 #include <hpx/config/warnings_suffix.hpp>
 
 #endif /*HPX_RUNTIME_THREADS_EXECUTORS_CURRENT_EXECUTOR_HPP*/
diff --git a/hpx/runtime/threads/executors/default_executor.hpp b/hpx/runtime/threads/executors/default_executor.hpp
index f21809aefb..c91a286af3 100644
--- a/hpx/runtime/threads/executors/default_executor.hpp
+++ b/hpx/runtime/threads/executors/default_executor.hpp
@@ -9,11 +9,11 @@
 
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <chrono>
diff --git a/hpx/runtime/threads/executors/embedded_thread_pool_executors.hpp b/hpx/runtime/threads/executors/embedded_thread_pool_executors.hpp
index 67751a1c3a..ff38d4b57f 100644
--- a/hpx/runtime/threads/executors/embedded_thread_pool_executors.hpp
+++ b/hpx/runtime/threads/executors/embedded_thread_pool_executors.hpp
@@ -16,7 +16,7 @@
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
 #include <atomic>
 #include <chrono>
diff --git a/hpx/runtime/threads/executors/guided_pool_executor.hpp b/hpx/runtime/threads/executors/guided_pool_executor.hpp
index 9818851ee8..824d27b441 100644
--- a/hpx/runtime/threads/executors/guided_pool_executor.hpp
+++ b/hpx/runtime/threads/executors/guided_pool_executor.hpp
@@ -15,10 +15,10 @@
 #include <hpx/lcos/dataflow.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/traits/is_future_tuple.hpp>
 #include <hpx/util/pack_traversal.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -63,7 +63,7 @@ namespace hpx { namespace threads { namespace executors {
     // --------------------------------------------------------------------
     struct future_extract_value
     {
-        template <typename T, template <typename> class Future>
+        template<typename T, template <typename> class Future>
         const T& operator()(const Future<T>& el) const
         {
             const auto& state = traits::detail::get_shared_state(el);
@@ -301,7 +301,7 @@ namespace hpx { namespace threads { namespace executors {
             // the real task will be spawned on a new task with hints - as intended
             return dataflow(
                 launch::sync,
-                [HPX_CAPTURE_FORWARD(f), this](
+                [f = std::forward<F>(f), this](
                     Future&& predecessor, Ts&&... ts) {
                     pre_execution_then_domain_schedule<pool_executor,
                         pool_numa_hint<Tag>>
@@ -359,7 +359,7 @@ namespace hpx { namespace threads { namespace executors {
             // Please see notes for previous then_execute function above
             return dataflow(
                 launch::sync,
-                [HPX_CAPTURE_FORWARD(f), this](
+                [f = std::forward<F>(f), this](
                     OuterFuture<util::tuple<InnerFutures...>>&& predecessor,
                     Ts&&... ts) {
                     pre_execution_then_domain_schedule<pool_executor,
diff --git a/hpx/runtime/threads/executors/limiting_executor.hpp b/hpx/runtime/threads/executors/limiting_executor.hpp
index 4eb7ab1a0e..5ae3c86e16 100644
--- a/hpx/runtime/threads/executors/limiting_executor.hpp
+++ b/hpx/runtime/threads/executors/limiting_executor.hpp
@@ -9,13 +9,13 @@
 
 #include <hpx/config.hpp>
 #include <hpx/apply.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
 #include <hpx/functional/invoke.hpp>
-#include <hpx/parallel/executors/execution_fwd.hpp>
 #include <hpx/runtime/threads/executors/default_executor.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -76,7 +76,7 @@ namespace hpx { namespace threads { namespace executors {
             {
                 hpx::util::yield_while(
                     [&]() { return (count_ > lower_threshold_); }, nullptr,
-                    hpx::threads::pending, false);
+                    false);
             }
         }
 
@@ -94,8 +94,8 @@ namespace hpx { namespace threads { namespace executors {
             count_up();
             auto&& args = hpx::util::make_tuple(std::forward<Ts>(ts)...);
             parallel::execution::post(executor_,
-                [this, HPX_CAPTURE_FORWARD(f),
-                    HPX_CAPTURE_FORWARD(args)]() mutable {
+                [this, f = std::forward<F>(f),
+                    args = std::forward<decltype(args)>(args)]() mutable {
                     hpx::util::invoke_fused(std::move(f), std::move(args));
                     count_down();
                 });
@@ -116,8 +116,8 @@ namespace hpx { namespace threads { namespace executors {
             count_up();
             auto&& args = hpx::util::make_tuple(std::forward<Ts>(ts)...);
             lcos::local::futures_factory<result_type()> p(executor_,
-                [this, HPX_CAPTURE_FORWARD(f),
-                    HPX_CAPTURE_FORWARD(args)]() mutable {
+                [this, f = std::forward<F>(f),
+                    args = std::forward<decltype(args)>(args)]() mutable {
                     hpx::util::invoke_fused(std::move(f), std::move(args));
                     count_down();
                 });
@@ -146,8 +146,8 @@ namespace hpx { namespace threads { namespace executors {
 
             auto&& args = hpx::util::make_tuple(std::forward<Ts>(ts)...);
             lcos::local::futures_factory<result_type()> p(executor_,
-                [this, HPX_CAPTURE_FORWARD(f),
-                    HPX_CAPTURE_FORWARD(args)]() mutable {
+                [this, f = std::forward<F>(f),
+                    args = std::forward<decltype(args)>(args)]() mutable {
                     hpx::util::invoke_fused(std::move(f), std::move(args));
                     count_down();
                 });
diff --git a/hpx/runtime/threads/executors/pool_executor.hpp b/hpx/runtime/threads/executors/pool_executor.hpp
index 128bf47f7f..9f1ab15a22 100644
--- a/hpx/runtime/threads/executors/pool_executor.hpp
+++ b/hpx/runtime/threads/executors/pool_executor.hpp
@@ -9,9 +9,9 @@
 #define HPX_RUNTIME_THREADS_CUSTOMIZED_POOL_EXECUTOR
 
 #include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <cstddef>
diff --git a/hpx/runtime/threads/executors/service_executors.hpp b/hpx/runtime/threads/executors/service_executors.hpp
index 77d2415e92..ce6bfb682a 100644
--- a/hpx/runtime/threads/executors/service_executors.hpp
+++ b/hpx/runtime/threads/executors/service_executors.hpp
@@ -10,10 +10,11 @@
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
+#include <hpx/io_service.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/thread_support/atomic_count.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <atomic>
diff --git a/hpx/runtime/threads/executors/this_thread_executors.hpp b/hpx/runtime/threads/executors/this_thread_executors.hpp
index 79cbbcad39..8486e49f1d 100644
--- a/hpx/runtime/threads/executors/this_thread_executors.hpp
+++ b/hpx/runtime/threads/executors/this_thread_executors.hpp
@@ -18,7 +18,7 @@
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <atomic>
diff --git a/hpx/runtime/threads/executors/thread_pool_attached_executors.hpp b/hpx/runtime/threads/executors/thread_pool_attached_executors.hpp
index 0e42218214..c37a0422cd 100644
--- a/hpx/runtime/threads/executors/thread_pool_attached_executors.hpp
+++ b/hpx/runtime/threads/executors/thread_pool_attached_executors.hpp
@@ -11,7 +11,7 @@
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <atomic>
diff --git a/hpx/runtime/threads/executors/thread_pool_os_executors.hpp b/hpx/runtime/threads/executors/thread_pool_os_executors.hpp
index 1730b76be1..c39f36aca6 100644
--- a/hpx/runtime/threads/executors/thread_pool_os_executors.hpp
+++ b/hpx/runtime/threads/executors/thread_pool_os_executors.hpp
@@ -10,13 +10,13 @@
 #include <hpx/config.hpp>
 #include <hpx/datastructures/optional.hpp>
 #include <hpx/resource_partitioner/detail/partitioner.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
 #include <hpx/affinity/affinity_data.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <atomic>
@@ -85,7 +85,7 @@ namespace hpx { namespace threads { namespace executors {
             void set_scheduler_mode(
                 threads::policies::scheduler_mode mode) override
             {
-                pool_->set_scheduler_mode(mode);
+                pool_->get_scheduler()->set_scheduler_mode(mode);
             }
 
         protected:
diff --git a/hpx/runtime/threads/policies/lockfree_queue_backends.hpp b/hpx/runtime/threads/policies/lockfree_queue_backends.hpp
deleted file mode 100644
index 3477a836f7..0000000000
--- a/hpx/runtime/threads/policies/lockfree_queue_backends.hpp
+++ /dev/null
@@ -1,301 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2012 Bryce Adelstein-Lelbach
-//  Copyright (c) 2019 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#if !defined(HPX_FB3518C8_4493_450E_A823_A9F8A3185B2D)
-#define HPX_FB3518C8_4493_450E_A823_A9F8A3185B2D
-
-#include <hpx/config.hpp>
-
-#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
-#include <hpx/concurrency/deque.hpp>
-#else
-#include <boost/lockfree/queue.hpp>
-#endif
-
-// Does not rely on CXX11_STD_ATOMIC_128BIT
-#include <hpx/concurrency/concurrentqueue.hpp>
-
-#include <cstddef>
-#include <cstdint>
-#include <utility>
-
-namespace hpx { namespace threads { namespace policies {
-
-    struct lockfree_fifo;
-
-    ///////////////////////////////////////////////////////////////////////////////
-    // FIFO
-    template <typename T>
-    struct lockfree_fifo_backend
-    {
-#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
-        using container_type = boost::lockfree::deque<T>;
-#else
-        using container_type = boost::lockfree::queue<T>;
-#endif
-
-        using value_type = T;
-        using reference = T&;
-        using const_reference = T const&;
-        using size_type = std::uint64_t;
-
-        lockfree_fifo_backend(
-            size_type initial_size = 0, size_type num_thread = size_type(-1))
-          : queue_(std::size_t(initial_size))
-        {
-        }
-
-        bool push(const_reference val, bool /*other_end*/ = false)
-        {
-#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
-            return queue_.push_left(val);
-#else
-            return queue_.push(val);
-#endif
-        }
-
-        bool pop(reference val, bool steal = true)
-        {
-#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
-            return queue_.pop_right(val);
-#else
-            return queue_.pop(val);
-#endif
-        }
-
-        bool empty()
-        {
-            return queue_.empty();
-        }
-
-    private:
-        container_type queue_;
-    };
-
-    struct lockfree_fifo
-    {
-        template <typename T>
-        struct apply
-        {
-            using type = lockfree_fifo_backend<T>;
-        };
-    };
-
-    ////////////////////////////////////////////////////////////////////////////
-    // MoodyCamel FIFO
-    template <typename T>
-    struct moodycamel_fifo_backend
-    {
-        using container_type = moodycamel::ConcurrentQueue<T>;
-
-        using value_type = T;
-        using reference = T&;
-        using const_reference = T const&;
-        using rval_reference = T&&;
-        using size_type = std::uint64_t;
-
-        moodycamel_fifo_backend(
-            size_type initial_size = 0, size_type num_thread = size_type(-1))
-          : queue_(std::size_t(initial_size))
-        {
-        }
-
-        bool push(rval_reference val, bool /*other_end*/ = false)
-        {
-            return queue_.enqueue(std::move(val));
-        }
-
-        bool push(const_reference val, bool /*other_end*/ = false)
-        {
-            return queue_.enqueue(val);
-        }
-
-        bool pop(reference val, bool steal = true)
-        {
-            return queue_.try_dequeue(val);
-        }
-
-        bool empty()
-        {
-            return (queue_.size_approx() == 0);
-        }
-
-    private:
-        container_type queue_;
-    };
-
-    struct concurrentqueue_fifo
-    {
-        template <typename T>
-        struct apply
-        {
-            using type = moodycamel_fifo_backend<T>;
-        };
-    };
-
-// LIFO
-#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
-    struct lockfree_lifo;
-
-    template <typename T>
-    struct lockfree_lifo_backend
-    {
-        using container_type = boost::lockfree::deque<T>;
-
-        using value_type = T;
-        using reference = T&;
-        using const_reference = T const&;
-        using size_type = std::uint64_t;
-
-        lockfree_lifo_backend(
-            size_type initial_size = 0, size_type num_thread = size_type(-1))
-          : queue_(std::size_t(initial_size))
-        {
-        }
-
-        bool push(const_reference val, bool other_end = false)
-        {
-            if (other_end)
-                return queue_.push_right(val);
-            return queue_.push_left(val);
-        }
-
-        bool pop(reference val, bool steal = true)
-        {
-            return queue_.pop_left(val);
-        }
-
-        bool empty()
-        {
-            return queue_.empty();
-        }
-
-    private:
-        container_type queue_;
-    };
-
-    struct lockfree_lifo
-    {
-        template <typename T>
-        struct apply
-        {
-            using type = lockfree_lifo_backend<T>;
-        };
-    };
-
-#if defined(HPX_HAVE_ABP_SCHEDULER)
-    ////////////////////////////////////////////////////////////////////////////
-    // FIFO + stealing at opposite end.
-    struct lockfree_abp_fifo;
-    struct lockfree_abp_lifo;
-
-    template <typename T>
-    struct lockfree_abp_fifo_backend
-    {
-        using container_type = boost::lockfree::deque<T>;
-
-        using value_type = T;
-        using reference = T&;
-        using const_reference = T const&;
-        using size_type = std::uint64_t;
-
-        lockfree_abp_fifo_backend(
-            size_type initial_size = 0, size_type num_thread = size_type(-1))
-          : queue_(std::size_t(initial_size))
-        {
-        }
-
-        bool push(const_reference val, bool /*other_end*/ = false)
-        {
-            return queue_.push_left(val);
-        }
-
-        bool pop(reference val, bool steal = true)
-        {
-            if (steal)
-                return queue_.pop_left(val);
-            return queue_.pop_right(val);
-        }
-
-        bool empty()
-        {
-            return queue_.empty();
-        }
-
-    private:
-        container_type queue_;
-    };
-
-    struct lockfree_abp_fifo
-    {
-        template <typename T>
-        struct apply
-        {
-            using type = lockfree_abp_fifo_backend<T>;
-        };
-    };
-
-    ////////////////////////////////////////////////////////////////////////////
-    // LIFO + stealing at opposite end.
-    // E.g. ABP (Arora, Blumofe and Plaxton) queuing
-    // http://dl.acm.org/citation.cfm?id=277678
-    template <typename T>
-    struct lockfree_abp_lifo_backend
-    {
-        using container_type = boost::lockfree::deque<T>;
-
-        using value_type = T;
-        using reference = T&;
-        using const_reference = T const&;
-        using size_type = std::uint64_t;
-
-        lockfree_abp_lifo_backend(
-            size_type initial_size = 0, size_type num_thread = size_type(-1))
-          : queue_(std::size_t(initial_size))
-        {
-        }
-
-        bool push(const_reference val, bool other_end = false)
-        {
-            if (other_end)
-                return queue_.push_right(val);
-            return queue_.push_left(val);
-        }
-
-        bool pop(reference val, bool steal = true)
-        {
-            if (steal)
-                return queue_.pop_right(val);
-            return queue_.pop_left(val);
-        }
-
-        bool empty()
-        {
-            return queue_.empty();
-        }
-
-    private:
-        container_type queue_;
-    };
-
-    struct lockfree_abp_lifo
-    {
-        template <typename T>
-        struct apply
-        {
-            using type = lockfree_abp_lifo_backend<T>;
-        };
-    };
-
-#endif    // HPX_HAVE_ABP_SCHEDULER
-#endif    // HPX_HAVE_CXX11_STD_ATOMIC_128BIT
-
-}}}    // namespace hpx::threads::policies
-
-#endif    // HPX_FB3518C8_4493_450E_A823_A9F8A3185B2D
diff --git a/hpx/runtime/threads/policies/scheduler_mode.hpp b/hpx/runtime/threads/policies/scheduler_mode.hpp
deleted file mode 100644
index 5fad4e3d5c..0000000000
--- a/hpx/runtime/threads/policies/scheduler_mode.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-//  Copyright (c) 2015-2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#if !defined(HPX_THREADS_SCHEDULER_MODE_AUG_27_2017_1136AM)
-#define HPX_THREADS_SCHEDULER_MODE_AUG_27_2017_1136AM
-
-#include <cstdint>
-
-namespace hpx { namespace threads { namespace policies
-{
-    /// This enumeration describes the possible modes of a scheduler.
-    enum scheduler_mode : std::uint32_t
-    {
-        nothing_special = 0x000,            ///< As the name suggests, this option
-            ///< can be used to disable all other options.
-
-        do_background_work = 0x001,       ///< The scheduler will periodically
-            ///< call a provided callback function from a special HPX thread
-            ///< to enable performing background-work, for instance driving
-            ///< networking progress or garbage-collect AGAS.
-        reduce_thread_priority = 0x002,  ///< The kernel priority of the
-            ///< os-thread driving the scheduler will be reduced below normal.
-        delay_exit = 0x004,              ///< The scheduler will wait for some
-            ///< unspecified amount of time before exiting the scheduling loop
-            ///< while being terminated to make sure no other work is being
-            ///< scheduled during processing the shutdown request.
-        fast_idle_mode = 0x008,          ///< Some schedulers have the capability
-            ///< to act as 'embedded' schedulers. In this case it needs to
-            ///< periodically invoke a provided callback into the outer scheduler
-            ///< more frequently than normal. This option enables this behavior.
-        enable_elasticity = 0x010,        ///< This option allows for the
-            ///< scheduler to dynamically increase and reduce the number of
-            ///< processing units it runs on. Setting this value not succeed for
-            ///< schedulers that do not support this functionality.
-        enable_stealing = 0x020,          ///< This option allows schedulers
-            ///< that support work thread/stealing to enable/disable it
-        enable_stealing_numa = 0x040,     ///< This option allows schedulers
-            ///<that support it to disallow stealing between numa domains
-        assign_work_round_robin   = 0x080,///< This option tells schedulers
-            ///<that support it to add tasks round robin to queues on each core
-        assign_work_thread_parent = 0x100,///< This option tells schedulers
-            ///< that support it to add tasks round to the same core/queue that the
-            ///< parent task is running on
-        steal_high_priority_first = 0x200,///< This option tells schedulers
-            ///< that support it to always (try to) steal high priority tasks
-            ///< from other queues before finishing their own lower priority tasks
-        steal_after_local         = 0x400,///< This option tells schedulers
-            ///< that support it to steal tasks only when their local
-            ///< queues are empty
-        enable_idle_backoff       = 0x800,     ///< This option allows for certain
-            ///< schedulers to explicitly disable exponential idle-back off
-        default_mode =
-                do_background_work |
-                reduce_thread_priority |
-                delay_exit |
-                enable_stealing |
-                enable_stealing_numa |
-                assign_work_round_robin |
-                steal_after_local |
-                enable_idle_backoff,
-            ///< This option represents the default mode.
-        all_flags =
-                do_background_work |
-                reduce_thread_priority |
-                delay_exit |
-                fast_idle_mode |
-                enable_elasticity |
-                enable_stealing |
-                enable_stealing_numa |
-                assign_work_round_robin |
-                assign_work_thread_parent |
-                steal_high_priority_first |
-                steal_after_local |
-                enable_idle_backoff
-    };
-}}}
-
-#endif
-
diff --git a/hpx/runtime/threads/run_as_hpx_thread.hpp b/hpx/runtime/threads/run_as_hpx_thread.hpp
index 894335f6e4..e4493aa1bf 100644
--- a/hpx/runtime/threads/run_as_hpx_thread.hpp
+++ b/hpx/runtime/threads/run_as_hpx_thread.hpp
@@ -14,7 +14,7 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/synchronization/spinlock.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 
 #include <chrono>
 #include <condition_variable>
diff --git a/hpx/runtime/threads/run_as_os_thread.hpp b/hpx/runtime/threads/run_as_os_thread.hpp
index fc12fe04e2..1c9faefe4e 100644
--- a/hpx/runtime/threads/run_as_os_thread.hpp
+++ b/hpx/runtime/threads/run_as_os_thread.hpp
@@ -9,8 +9,8 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/service_executors.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/service_executors.hpp>
 #include <hpx/runtime/threads_fwd.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/result_of.hpp>
diff --git a/hpx/runtime/threads/scheduler_specific_ptr.hpp b/hpx/runtime/threads/scheduler_specific_ptr.hpp
deleted file mode 100644
index d0d82f50fc..0000000000
--- a/hpx/runtime/threads/scheduler_specific_ptr.hpp
+++ /dev/null
@@ -1,122 +0,0 @@
-//  Copyright (c) 2007-2015 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-// This code has been partially adopted from the Boost.Threads library
-//
-// (C) Copyright 2008 Anthony Williams
-// (C) Copyright 2011-2012 Vicente J. Botet Escriba
-
-#if !defined(HPX_RUNTIME_THREADS_SCHEDULER_TSS_AUG_08_2015_0733PM)
-#define HPX_RUNTIME_THREADS_SCHEDULER_TSS_AUG_08_2015_0733PM
-
-#include <hpx/config.hpp>
-#include <hpx/coroutines/detail/tss.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-
-#include <memory>
-
-namespace hpx { namespace threads
-{
-    ///////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
-        HPX_API_EXPORT void set_tss_data(void const* key,
-            std::shared_ptr<
-                coroutines::detail::tss_cleanup_function
-            > const& func,
-            void* tss_data, bool cleanup_existing);
-        HPX_API_EXPORT void* get_tss_data(void const* key);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    template <typename T>
-    class scheduler_specific_ptr
-    {
-    public:
-        HPX_NON_COPYABLE(scheduler_specific_ptr);
-
-    private:
-        struct delete_data : coroutines::detail::tss_cleanup_function
-        {
-            void operator()(void* data)
-            {
-                delete static_cast<T*>(data);
-            }
-        };
-
-        struct run_custom_cleanup_function
-          : coroutines::detail::tss_cleanup_function
-        {
-            void (*cleanup_function)(T*);
-
-            explicit run_custom_cleanup_function(void (*cleanup_function_)(T*))
-              : cleanup_function(cleanup_function_)
-            {}
-
-            void operator()(void* data)
-            {
-                cleanup_function(static_cast<T*>(data));
-            }
-        };
-
-        std::shared_ptr<coroutines::detail::tss_cleanup_function> cleanup;
-
-    public:
-        typedef T element_type;
-
-        scheduler_specific_ptr()
-          : cleanup(std::make_shared<delete_data>())
-        {}
-
-        explicit scheduler_specific_ptr(void (*func_)(T*))
-        {
-            if (func_)
-                cleanup.reset(new run_custom_cleanup_function(func_));
-        }
-
-        ~scheduler_specific_ptr()
-        {
-            // clean up data if this type is used locally for one thread
-            if (get_self_ptr())
-            {
-                detail::set_tss_data(this,
-                    std::shared_ptr<coroutines::detail::tss_cleanup_function>(),
-                    0, true);
-            }
-        }
-
-        T* get() const
-        {
-            return static_cast<T*>(detail::get_tss_data(this));
-        }
-        T* operator->() const
-        {
-            return get();
-        }
-        T& operator*() const
-        {
-            return *get();
-        }
-
-        T* release()
-        {
-            T* const temp = get();
-            detail::set_tss_data(this,
-                std::shared_ptr<coroutines::detail::tss_cleanup_function>(),
-                0, false);
-            return temp;
-        }
-
-        void reset(T* new_value = nullptr)
-        {
-            T* const current_value = get();
-            if (current_value != new_value)
-                detail::set_tss_data(this, cleanup, new_value, true);
-        }
-    };
-}}
-
-#endif
diff --git a/hpx/runtime/threads/thread_data_fwd.hpp b/hpx/runtime/threads/thread_data_fwd.hpp
deleted file mode 100644
index 8bfb5b65a5..0000000000
--- a/hpx/runtime/threads/thread_data_fwd.hpp
+++ /dev/null
@@ -1,192 +0,0 @@
-//  Copyright (c) 2007-2015 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-/// \file hpx/runtime/threads/thread_data_fwd.hpp
-
-#if !defined(HPX_THREADS_THREAD_DATA_FWD_AUG_11_2015_0228PM)
-#define HPX_THREADS_THREAD_DATA_FWD_AUG_11_2015_0228PM
-
-#include <hpx/config.hpp>
-#include <hpx/coroutines/coroutine_fwd.hpp>
-#include <hpx/coroutines/thread_enums.hpp>
-#include <hpx/coroutines/thread_id_type.hpp>
-#include <hpx/errors.hpp>
-#include <hpx/functional/function.hpp>
-#include <hpx/functional/unique_function.hpp>
-#include <hpx/util_fwd.hpp>
-
-#include <cstddef>
-#include <cstdint>
-#include <memory>
-#include <utility>
-
-#if defined(HPX_HAVE_APEX)
-namespace hpx { namespace util { namespace external_timer {
-    struct task_wrapper;
-}}}
-#endif
-
-namespace hpx {
-    /// \cond NOINTERNAL
-    class HPX_EXPORT thread;
-    /// \endcond
-}    // namespace hpx
-
-namespace hpx { namespace threads {
-
-    class thread_data;
-    class thread_data_stackful;
-    class thread_data_stackless;
-
-    /// \cond NOINTERNAL
-    struct HPX_EXPORT topology;
-
-    class HPX_EXPORT executor;
-
-    using thread_id_type = thread_id;
-
-    using coroutine_type = coroutines::coroutine;
-    using stackless_coroutine_type = coroutines::stackless_coroutine;
-
-    using thread_self = coroutines::detail::coroutine_self;
-    using thread_self_impl_type =
-        coroutines::detail::coroutine_impl;
-
-    using thread_result_type = std::pair<thread_state_enum, thread_id_type>;
-    using thread_arg_type = thread_state_ex_enum;
-
-    using thread_function_sig = thread_result_type(thread_arg_type);
-    using thread_function_type =
-        util::unique_function_nonser<thread_function_sig>;
-    /// \endcond
-
-    ///////////////////////////////////////////////////////////////////////
-    /// The function \a get_self returns a reference to the (OS thread
-    /// specific) self reference to the current HPX thread.
-    HPX_API_EXPORT thread_self& get_self();
-
-    /// The function \a get_self_ptr returns a pointer to the (OS thread
-    /// specific) self reference to the current HPX thread.
-    HPX_API_EXPORT thread_self* get_self_ptr();
-
-    /// The function \a get_ctx_ptr returns a pointer to the internal data
-    /// associated with each coroutine.
-    HPX_API_EXPORT thread_self_impl_type* get_ctx_ptr();
-
-    /// The function \a get_self_ptr_checked returns a pointer to the (OS
-    /// thread specific) self reference to the current HPX thread.
-    HPX_API_EXPORT thread_self* get_self_ptr_checked(error_code& ec = throws);
-
-    /// The function \a get_self_id returns the HPX thread id of the current
-    /// thread (or zero if the current thread is not a HPX thread).
-    HPX_API_EXPORT thread_id_type get_self_id();
-
-    /// The function \a get_self_id_data returns the data of the HPX thread id
-    /// associated with the current thread (or nullptr if the current thread is
-    /// not a HPX thread).
-    HPX_API_EXPORT thread_data* get_self_id_data();
-
-    /// The function \a get_parent_id returns the HPX thread id of the
-    /// current thread's parent (or zero if the current thread is not a
-    /// HPX thread).
-    ///
-    /// \note This function will return a meaningful value only if the
-    ///       code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE
-    ///       being defined.
-    HPX_API_EXPORT thread_id_type get_parent_id();
-
-    /// The function \a get_parent_phase returns the HPX phase of the
-    /// current thread's parent (or zero if the current thread is not a
-    /// HPX thread).
-    ///
-    /// \note This function will return a meaningful value only if the
-    ///       code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE
-    ///       being defined.
-    HPX_API_EXPORT std::size_t get_parent_phase();
-
-    /// The function \a get_self_stacksize returns the stack size of the
-    /// current thread (or zero if the current thread is not a HPX thread).
-    HPX_API_EXPORT std::size_t get_self_stacksize();
-
-    /// The function \a get_parent_locality_id returns the id of the locality of
-    /// the current thread's parent (or zero if the current thread is not a
-    /// HPX thread).
-    ///
-    /// \note This function will return a meaningful value only if the
-    ///       code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE
-    ///       being defined.
-    HPX_API_EXPORT std::uint32_t get_parent_locality_id();
-
-    /// The function \a get_self_component_id returns the lva of the
-    /// component the current thread is acting on
-    ///
-    /// \note This function will return a meaningful value only if the
-    ///       code was compiled with HPX_HAVE_THREAD_TARGET_ADDRESS
-    ///       being defined.
-    HPX_API_EXPORT std::uint64_t get_self_component_id();
-
-    /// The function \a get_thread_count returns the number of currently
-    /// known threads.
-    ///
-    /// \param state    [in] This specifies the thread-state for which the
-    ///                 number of threads should be retrieved.
-    ///
-    /// \note If state == unknown this function will not only return the
-    ///       number of currently existing threads, but will add the number
-    ///       of registered task descriptions (which have not been
-    ///       converted into threads yet).
-    HPX_API_EXPORT std::int64_t get_thread_count(
-        thread_state_enum state = unknown);
-
-    /// The function \a get_thread_count returns the number of currently
-    /// known threads.
-    ///
-    /// \param priority [in] This specifies the thread-priority for which the
-    ///                 number of threads should be retrieved.
-    /// \param state    [in] This specifies the thread-state for which the
-    ///                 number of threads should be retrieved.
-    ///
-    /// \note If state == unknown this function will not only return the
-    ///       number of currently existing threads, but will add the number
-    ///       of registered task descriptions (which have not been
-    ///       converted into threads yet).
-    HPX_API_EXPORT std::int64_t get_thread_count(
-        thread_priority priority, thread_state_enum state = unknown);
-
-    /// The function \a enumerate_threads will invoke the given function \a f
-    /// for each thread with a matching thread state.
-    ///
-    /// \param f        [in] The function which should be called for each
-    ///                 matching thread. Returning 'false' from this function
-    ///                 will stop the enumeration process.
-    /// \param state    [in] This specifies the thread-state for which the
-    ///                 threads should be enumerated.
-    HPX_API_EXPORT bool enumerate_threads(
-        util::function_nonser<bool(thread_id_type)> const& f,
-        thread_state_enum state = unknown);
-
-#if defined(HPX_HAVE_APEX)
-    HPX_API_EXPORT std::shared_ptr<hpx::util::external_timer::task_wrapper>
-        get_self_timer_data(void);
-    HPX_API_EXPORT void set_self_timer_data(
-        std::shared_ptr<hpx::util::external_timer::task_wrapper> data);
-#endif
-}}    // namespace hpx::threads
-
-namespace std {
-    template <>
-    struct hash<::hpx::threads::thread_id>
-    {
-        std::size_t operator()(::hpx::threads::thread_id const& v) const
-            noexcept
-        {
-            std::hash<::hpx::threads::thread_data const*> hasher_;
-            return hasher_(static_cast<::hpx::threads::thread_data*>(v.get()));
-        }
-    };
-}    // namespace std
-
-#endif
diff --git a/hpx/runtime/threads/thread_executor.hpp b/hpx/runtime/threads/thread_executor.hpp
index 49e63c35fe..e236e6a261 100644
--- a/hpx/runtime/threads/thread_executor.hpp
+++ b/hpx/runtime/threads/thread_executor.hpp
@@ -12,12 +12,13 @@
 #include <hpx/functional/unique_function.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
 #include <hpx/runtime/get_os_thread_count.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/thread_support/atomic_count.hpp>
 #include <hpx/timing/steady_clock.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
 #include <chrono>
 #include <cstddef>
@@ -31,19 +32,6 @@
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads
 {
-    /// \brief Data structure which stores statistics collected by an
-    ///        executor instance.
-    struct executor_statistics
-    {
-        executor_statistics()
-          : tasks_scheduled_(0), tasks_completed_(0), queue_length_(0)
-        {}
-
-        std::uint64_t tasks_scheduled_;
-        std::uint64_t tasks_completed_;
-        std::uint64_t queue_length_;
-    };
-
     ///////////////////////////////////////////////////////////////////////////
     namespace detail
     {
@@ -113,41 +101,6 @@ namespace hpx { namespace threads
 
     namespace detail
     {
-        ///////////////////////////////////////////////////////////////////////
-        enum executor_parameter
-        {
-            min_concurrency = 1,
-            max_concurrency = 2,
-            current_concurrency = 3
-        };
-
-        ///////////////////////////////////////////////////////////////////////
-        // The interface below is used by the resource manager to
-        // interact with the executor.
-        struct manage_executor
-        {
-            virtual ~manage_executor() {}
-
-            // Return the requested policy element
-            virtual std::size_t get_policy_element(executor_parameter p,
-                error_code& ec) const = 0;
-
-            // Return statistics collected by this scheduler
-            virtual void get_statistics(executor_statistics& stats,
-                error_code& ec) const = 0;
-
-            // Provide the given processing unit to the scheduler.
-            virtual void add_processing_unit(std::size_t virt_core,
-                std::size_t thread_num, error_code& ec) = 0;
-
-            // Remove the given processing unit from the scheduler.
-            virtual void remove_processing_unit(std::size_t thread_num,
-                error_code& ec) = 0;
-
-            // return the description string of the underlying scheduler
-            virtual char const* get_description() const = 0;
-        };
-
         ///////////////////////////////////////////////////////////////////////
         // Main executor interface
         void intrusive_ptr_add_ref(executor_base* p);
@@ -278,9 +231,8 @@ namespace hpx { namespace threads
                     stacksize, ec);
             }
 
-            thread_stacksize     get_stacksize() const { return stacksize_; }
-            thread_priority      get_priority() const { return priority_; }
-            thread_schedule_hint get_schedulehint() const { return schedulehint_; }
+            thread_priority  get_priority() const { return priority_; }
+            thread_stacksize get_stacksize() const { return stacksize_; }
 
         protected:
             thread_stacksize     stacksize_;
@@ -479,11 +431,6 @@ namespace hpx { namespace threads
                     (executor_data_.get())->get_stacksize();
         }
 
-        thread_schedule_hint get_schedulehint() const {
-            return static_cast<detail::scheduled_executor_base*>
-                    (executor_data_.get())->get_schedulehint();
-        }
-
         /// Return a reference to the default executor for this process.
         static scheduled_executor& default_executor();
     };
diff --git a/hpx/runtime/threads/thread_init_data.hpp b/hpx/runtime/threads/thread_init_data.hpp
deleted file mode 100644
index e9fbdbded1..0000000000
--- a/hpx/runtime/threads/thread_init_data.hpp
+++ /dev/null
@@ -1,149 +0,0 @@
-//  Copyright (c) 2007-2013 Hartmut Kaiser
-//  Copyright (c) 2008-2009 Chirag Dekate, Anshul Tandon
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef HPX_RUNTIME_THREADS_THREAD_INIT_DATA_HPP
-#define HPX_RUNTIME_THREADS_THREAD_INIT_DATA_HPP
-
-#include <hpx/config.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/coroutines/thread_enums.hpp>
-#include <hpx/runtime/threads_fwd.hpp>
-#include <hpx/util/thread_description.hpp>
-#if defined(HPX_HAVE_APEX)
-#include <hpx/util/external_timer.hpp>
-#endif
-
-#include <cstddef>
-#include <cstdint>
-#include <utility>
-#include <memory>
-
-namespace hpx { namespace threads
-{
-    HPX_API_EXPORT std::ptrdiff_t get_default_stack_size();
-    HPX_API_EXPORT std::ptrdiff_t get_stack_size(thread_stacksize);
-
-    ///////////////////////////////////////////////////////////////////////////
-    class thread_init_data
-    {
-    public:
-        thread_init_data()
-          : func(),
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-            description(),
-#endif
-#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
-            parent_locality_id(0), parent_id(nullptr), parent_phase(0),
-#endif
-#ifdef HPX_HAVE_APEX
-            timer_data(nullptr),
-#endif
-            priority(thread_priority_normal),
-            schedulehint(),
-            stacksize(HPX_SMALL_STACK_SIZE),
-            scheduler_base(nullptr)
-        {}
-
-        thread_init_data& operator=(thread_init_data&& rhs) {
-            func            = std::move(rhs.func);
-            priority        = rhs.priority;
-            schedulehint    = rhs.schedulehint;
-            stacksize       = rhs.stacksize;
-            scheduler_base  = rhs.scheduler_base;
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-            description = rhs.description;
-#endif
-#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
-            parent_locality_id = rhs.parent_locality_id;
-            parent_id = rhs.parent_id;
-            parent_phase = rhs.parent_phase;
-#endif
-#ifdef HPX_HAVE_APEX
-        // HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION
-        // and HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on
-            timer_data = rhs.timer_data;
-#endif
-            return *this;
-        }
-
-        thread_init_data(thread_init_data&& rhs)
-          : func(std::move(rhs.func)),
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-            description(rhs.description),
-#endif
-#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
-            parent_locality_id(rhs.parent_locality_id), parent_id(rhs.parent_id),
-            parent_phase(rhs.parent_phase),
-#endif
-#ifdef HPX_HAVE_APEX
-        /* HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION
-         * and HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on */
-            timer_data(util::external_timer::new_task(description,
-                parent_locality_id, parent_id )),
-#endif
-            priority(rhs.priority),
-            schedulehint(rhs.schedulehint),
-            stacksize(rhs.stacksize),
-            scheduler_base(rhs.scheduler_base)
-        {
-            if (stacksize == 0)
-                stacksize = HPX_SMALL_STACK_SIZE;
-        }
-
-        template <typename F>
-        thread_init_data(F && f, util::thread_description const& desc,
-                thread_priority priority_ = thread_priority_normal,
-                thread_schedule_hint os_thread = thread_schedule_hint(),
-                std::ptrdiff_t stacksize_ = HPX_SMALL_STACK_SIZE,
-                policies::scheduler_base* scheduler_base_ = nullptr)
-          : func(std::forward<F>(f)),
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-            description(desc),
-#endif
-#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
-            parent_locality_id(0), parent_id(nullptr), parent_phase(0),
-#endif
-#ifdef HPX_HAVE_APEX
-        /* HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION
-         * and HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on */
-            timer_data(util::external_timer::new_task(description,
-                parent_locality_id,parent_id)),
-#endif
-            priority(priority_), schedulehint(os_thread),
-            stacksize(stacksize_),
-            scheduler_base(scheduler_base_)
-        {
-            if (stacksize == 0)
-                stacksize = HPX_SMALL_STACK_SIZE;
-        }
-
-        threads::thread_function_type func;
-
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-        util::thread_description description;
-#endif
-#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
-        std::uint32_t parent_locality_id;
-        threads::thread_id_type parent_id;
-        std::size_t parent_phase;
-#endif
-#ifdef HPX_HAVE_APEX
-        /* HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION
-         * and HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on */
-        std::shared_ptr<util::external_timer::task_wrapper> timer_data;
-#endif
-
-        thread_priority priority;
-        thread_schedule_hint schedulehint;
-        std::ptrdiff_t stacksize;
-
-        policies::scheduler_base* scheduler_base;
-    };
-}}
-
-#endif /*HPX_RUNTIME_THREADS_THREAD_INIT_DATA_HPP*/
diff --git a/hpx/runtime/threads/thread_pool_suspension_helpers.hpp b/hpx/runtime/threads/thread_pool_suspension_helpers.hpp
index 0aaabaee51..217ff84f76 100644
--- a/hpx/runtime/threads/thread_pool_suspension_helpers.hpp
+++ b/hpx/runtime/threads/thread_pool_suspension_helpers.hpp
@@ -9,7 +9,7 @@
 
 #include <hpx/config.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
 #include <cstddef>
 
diff --git a/hpx/runtime/threads/thread_pools.hpp b/hpx/runtime/threads/thread_pools.hpp
deleted file mode 100644
index 721c69f388..0000000000
--- a/hpx/runtime/threads/thread_pools.hpp
+++ /dev/null
@@ -1,13 +0,0 @@
-//  Copyright (c) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#if !defined(HPX_THREADS_THREAD_POOLS_AUG_08_2017_1110AM)
-#define HPX_THREADS_THREAD_POOLS_AUG_08_2017_1110AM
-
-#include <hpx/runtime/threads/detail/scheduled_thread_pool.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-
-#endif
diff --git a/hpx/runtime/threads_fwd.hpp b/hpx/runtime/threads_fwd.hpp
index 3d5c3662cc..5cd66254b5 100644
--- a/hpx/runtime/threads_fwd.hpp
+++ b/hpx/runtime/threads_fwd.hpp
@@ -9,28 +9,18 @@
 #define HPX_RUNTIME_THREADS_FWD_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
 
 namespace hpx
 {
     namespace threads
     {
-        namespace policies
-        {
-            struct scheduler_base;
-            namespace detail {
-                struct HPX_EXPORT affinity_data;
-            }
-        }
-
         namespace executors
         {
             struct HPX_EXPORT current_executor;
         }
-
-        class HPX_EXPORT thread_pool_base;
-        struct HPX_EXPORT thread_pool_init_parameters;
     }
 }
 
diff --git a/hpx/runtime_fwd.hpp b/hpx/runtime_fwd.hpp
index 76bfa2e7d7..307dac885b 100644
--- a/hpx/runtime_fwd.hpp
+++ b/hpx/runtime_fwd.hpp
@@ -25,7 +25,7 @@
 #include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/runtime/report_error.hpp>
 #include <hpx/runtime/runtime_fwd.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/runtime/set_parcel_write_handler.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
@@ -274,6 +274,31 @@ namespace hpx
         // current thread manager.
         HPX_API_EXPORT threadmanager& get_thread_manager();
         /// \endcond
+
+        /// \cond NOINTERNAL
+        /// Reset internal (round robin) thread distribution scheme
+        HPX_API_EXPORT void reset_thread_distribution();
+
+        /// Set the new scheduler mode
+        HPX_API_EXPORT void set_scheduler_mode(
+            threads::policies::scheduler_mode new_mode);
+
+        /// Add the given flags to the scheduler mode
+        HPX_API_EXPORT void add_scheduler_mode(
+            threads::policies::scheduler_mode to_add);
+
+        /// Add/remove the given flags to the scheduler mode
+        HPX_API_EXPORT void add_remove_scheduler_mode(
+            threads::policies::scheduler_mode to_add,
+            threads::policies::scheduler_mode to_remove);
+
+        /// Remove the given flags from the scheduler mode
+        HPX_API_EXPORT void remove_scheduler_mode(
+            threads::policies::scheduler_mode to_remove);
+
+        /// Get the global topology instance
+        HPX_API_EXPORT topology const& get_topology();
+        /// \endcond
     }
 }
 
diff --git a/hpx/runtime_handlers.hpp b/hpx/runtime_handlers.hpp
index 231df2f167..1ce0fd80ec 100644
--- a/hpx/runtime_handlers.hpp
+++ b/hpx/runtime_handlers.hpp
@@ -8,8 +8,11 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/config/asio.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+
+#include <boost/asio/io_service.hpp>
 
 #include <string>
 
@@ -26,4 +29,5 @@ namespace hpx { namespace detail {
     bool register_locks_predicate();
 #endif
     threads::thread_pool_base* get_default_pool();
+    boost::asio::io_service* get_default_timer_service();
 }}    // namespace hpx::detail
diff --git a/hpx/runtime_impl.hpp b/hpx/runtime_impl.hpp
index 647b48ebda..dcd5ae0132 100644
--- a/hpx/runtime_impl.hpp
+++ b/hpx/runtime_impl.hpp
@@ -17,10 +17,10 @@
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/runtime/parcelset/parcelhandler.hpp>
 #include <hpx/runtime/parcelset/parcelport.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/util/generate_unique_ids.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 #include <hpx/util_fwd.hpp>
 
 #include <condition_variable>
@@ -306,7 +306,7 @@ namespace hpx
         void add_startup_function(startup_function_type f) override;
 
         /// Add a function to be executed inside a HPX thread during
-        /// hpx::finalize, but guaranteed before any of teh shutdown functions
+        /// hpx::finalize, but guaranteed before any of the shutdown functions
         /// is executed.
         ///
         /// \param  f   The function 'f' will be called from inside a HPX
diff --git a/hpx/state.hpp b/hpx/state.hpp
index f4a8743f8d..3fa5e1968a 100644
--- a/hpx/state.hpp
+++ b/hpx/state.hpp
@@ -10,30 +10,10 @@
 #define HPX_703646B3_0567_484E_AD34_A752B8163B30
 
 #include <hpx/config.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
 
 namespace hpx
 {
-    enum state
-    {
-        state_invalid = -1,
-        state_initialized = 0,
-        first_valid_runtime_state = state_initialized,
-        state_pre_startup = 1,
-        state_startup = 2,
-        state_pre_main = 3,
-        state_starting = 4,
-        state_running = 5,
-        state_suspended = 6,
-        state_pre_sleep = 7,
-        state_sleeping = 8,
-        state_pre_shutdown = 9,
-        state_shutdown = 10,
-        state_stopping = 11,
-        state_terminating = 12,
-        state_stopped = 13,
-        last_valid_runtime_state = state_stopped
-    };
-
     namespace threads
     {
         // return whether thread manager is in the state described by 'mask'
diff --git a/hpx/sync.hpp b/hpx/sync.hpp
index f2e6ad984e..2c16337561 100644
--- a/hpx/sync.hpp
+++ b/hpx/sync.hpp
@@ -13,13 +13,13 @@
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/functional/traits/is_action.hpp>
-#include <hpx/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/util/bind_action.hpp>
 #include <hpx/functional/deferred_call.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
 
 #include <exception>
 #include <functional>
@@ -81,15 +81,15 @@ namespace hpx { namespace detail
             traits::is_bound_action<Bound>::value
         >::type>
     {
-        template <typename Action, typename BoundArgs, typename ...Ts>
+        template <typename Action, typename Is, typename... Ts, typename ...Us>
         HPX_FORCEINLINE
         static typename hpx::util::detail::bound_action<
-            Action, BoundArgs
+            Action, Is, Ts...
         >::result_type
-        call(hpx::util::detail::bound_action<Action, BoundArgs> const& bound,
-            Ts&&... ts)
+        call(hpx::util::detail::bound_action<Action, Is, Ts...> const& bound,
+            Us&&... vs)
         {
-            return bound(std::forward<Ts>(ts)...);
+            return bound(std::forward<Us>(vs)...);
         }
     };
 }}
diff --git a/hpx/traits/action_decorate_function.hpp b/hpx/traits/action_decorate_function.hpp
index 1f15ff39da..8f367dd686 100644
--- a/hpx/traits/action_decorate_function.hpp
+++ b/hpx/traits/action_decorate_function.hpp
@@ -9,8 +9,8 @@
 
 #include <hpx/concepts/has_xxx.hpp>
 #include <hpx/functional/unique_function.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
+#include <hpx/naming_base.hpp>
+#include <hpx/threading_base.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
 
 #include <utility>
diff --git a/hpx/traits/action_schedule_thread.hpp b/hpx/traits/action_schedule_thread.hpp
index 97ba556795..86b485dd0d 100644
--- a/hpx/traits/action_schedule_thread.hpp
+++ b/hpx/traits/action_schedule_thread.hpp
@@ -9,8 +9,8 @@
 
 #include <hpx/runtime/naming/address.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
 
 namespace hpx { namespace traits
diff --git a/hpx/traits/action_select_direct_execution.hpp b/hpx/traits/action_select_direct_execution.hpp
index 165bbeb812..abf257062e 100644
--- a/hpx/traits/action_select_direct_execution.hpp
+++ b/hpx/traits/action_select_direct_execution.hpp
@@ -8,8 +8,8 @@
 #define HPX_TRAITS_ACTION_SELECT_DIRECT_EXECUTION_MAR_22_21018_0124PM
 
 #include <hpx/config.hpp>
+#include <hpx/naming_base.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
 
 namespace hpx { namespace traits
@@ -22,7 +22,7 @@ namespace hpx { namespace traits
         {
             // by default we return the unchanged function
             template <typename Action>
-            static HPX_CONSTEXPR launch call(
+            static constexpr launch call(
                 wrap_int, launch policy, naming::address_type)
             {
                 return policy;
@@ -43,7 +43,7 @@ namespace hpx { namespace traits
         };
 
         template <typename Action>
-        HPX_CONSTEXPR launch call_select_direct_execution(
+        constexpr launch call_select_direct_execution(
             launch policy, naming::address_type lva)
         {
             return select_direct_execution_helper::template call<Action>(
@@ -54,7 +54,7 @@ namespace hpx { namespace traits
     template <typename Action, typename Enable = void>
     struct action_select_direct_execution
     {
-        static HPX_CONSTEXPR launch call(launch policy,
+        static constexpr launch call(launch policy,
             naming::address_type lva)
         {
             return detail::call_select_direct_execution<Action>(policy, lva);
diff --git a/hpx/traits/component_pin_support.hpp b/hpx/traits/component_pin_support.hpp
index 9c5cab7c1a..04c089dd92 100644
--- a/hpx/traits/component_pin_support.hpp
+++ b/hpx/traits/component_pin_support.hpp
@@ -21,13 +21,13 @@ namespace hpx { namespace traits
         struct pin_helper
         {
             template <typename Component>
-            HPX_CXX14_CONSTEXPR static void call(wrap_int, Component* p)
+            static constexpr void call(wrap_int, Component* p)
             {
             }
 
             // forward the call if the component implements the function
             template <typename Component>
-            HPX_CXX14_CONSTEXPR static auto call(int, Component* p)
+            static constexpr auto call(int, Component* p)
             ->  decltype(p->pin())
             {
                 p->pin();
@@ -37,14 +37,14 @@ namespace hpx { namespace traits
         struct unpin_helper
         {
             template <typename Component>
-            HPX_CONSTEXPR static bool call(wrap_int, Component* p)
+            static constexpr bool call(wrap_int, Component* p)
             {
                 return false;
             }
 
             // forward the call if the component implements the function
             template <typename Component>
-            HPX_CONSTEXPR static auto call(int, Component* p)
+            static constexpr auto call(int, Component* p)
             ->  decltype(p->unpin())
             {
                 return p->unpin();
@@ -54,14 +54,14 @@ namespace hpx { namespace traits
         struct pin_count_helper
         {
             template <typename Component>
-            HPX_CONSTEXPR static std::uint32_t call(wrap_int, Component* p)
+            static constexpr std::uint32_t call(wrap_int, Component* p)
             {
                 return 0;
             }
 
             // forward the call if the component implements the function
             template <typename Component>
-            HPX_CONSTEXPR static auto call(int, Component* p)
+            static constexpr auto call(int, Component* p)
             ->  decltype(p->pin_count())
             {
                 return p->pin_count();
@@ -72,17 +72,17 @@ namespace hpx { namespace traits
     template <typename Component, typename Enable = void>
     struct component_pin_support
     {
-        HPX_CXX14_CONSTEXPR static void pin(Component* p)
+        static constexpr void pin(Component* p)
         {
             detail::pin_helper::call(0, p);
         }
 
-        HPX_CONSTEXPR static bool unpin(Component* p)
+        static constexpr bool unpin(Component* p)
         {
             return detail::unpin_helper::call(0, p);
         }
 
-        HPX_CONSTEXPR static std::uint32_t pin_count(Component* p)
+        static constexpr std::uint32_t pin_count(Component* p)
         {
             return detail::pin_count_helper::call(0, p);
         }
diff --git a/hpx/traits/component_supports_migration.hpp b/hpx/traits/component_supports_migration.hpp
index 6b7bd882f6..b88477cb4a 100644
--- a/hpx/traits/component_supports_migration.hpp
+++ b/hpx/traits/component_supports_migration.hpp
@@ -24,14 +24,14 @@ namespace hpx { namespace traits
             // by default we return 'false' (component does not support
             // migration)
             template <typename Component>
-            static HPX_CONSTEXPR bool call(wrap_int)
+            static constexpr bool call(wrap_int)
             {
                 return false;
             }
 
             // forward the call if the component implements the function
             template <typename Component>
-            static HPX_CONSTEXPR auto call(int)
+            static constexpr auto call(int)
             ->  decltype(Component::supports_migration())
             {
                 return Component::supports_migration();
@@ -39,7 +39,7 @@ namespace hpx { namespace traits
         };
 
         template <typename Component>
-        HPX_CONSTEXPR bool call_supports_migration()
+        constexpr bool call_supports_migration()
         {
             return supports_migration_helper::template call<Component>(0);
         }
@@ -49,7 +49,7 @@ namespace hpx { namespace traits
     struct component_supports_migration
     {
         // returns whether target supports migration
-        static HPX_CONSTEXPR bool call()
+        static constexpr bool call()
         {
             return detail::call_supports_migration<Component>();
         }
diff --git a/hpx/traits/future_then_result.hpp b/hpx/traits/future_then_result.hpp
index 4f77246718..f43ac28278 100644
--- a/hpx/traits/future_then_result.hpp
+++ b/hpx/traits/future_then_result.hpp
@@ -9,14 +9,14 @@
 #define HPX_TRAITS_FUTURE_THEN_RESULT_DEC_25_2016_1141AM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/functional/result_of.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
+#include <hpx/traits/is_future.hpp>
+#include <hpx/traits/future_traits.hpp>
 #include <hpx/type_support/always_void.hpp>
 #include <hpx/type_support/identity.hpp>
 #include <hpx/type_support/lazy_conditional.hpp>
-#include <hpx/traits/is_executor.hpp>
-#include <hpx/traits/is_future.hpp>
-#include <hpx/traits/future_traits.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <type_traits>
 #include <utility>
@@ -33,7 +33,7 @@ namespace hpx { namespace traits
         struct executor_future;
 
         template <typename Executor, typename T, typename ...Ts>
-        struct executor_future<Executor, T, hpx::util::detail::pack<Ts...>,
+        struct executor_future<Executor, T, hpx::util::pack<Ts...>,
             typename std::enable_if<
                 hpx::traits::is_two_way_executor<Executor>::value
             >::type>
@@ -57,7 +57,7 @@ namespace hpx { namespace traits
     struct executor_future
       : detail::executor_future<
             typename std::decay<Executor>::type,
-            T, hpx::util::detail::pack<typename std::decay<Ts>::type...> >
+            T, hpx::util::pack<typename std::decay<Ts>::type...> >
     {};
 
     template <typename Executor, typename T, typename ...Ts>
@@ -70,15 +70,10 @@ namespace hpx { namespace traits
         template <typename Future, typename F>
         struct continuation_not_callable
         {
-#if defined(HPX_HAVE_CXX14_RETURN_TYPE_DEDUCTION)
             static auto error(Future future, F& f)
             {
                 f(std::move(future));
             }
-#else
-            static auto error(Future future, F& f)
-             -> decltype(f(std::move(future)));
-#endif
 
             using type = decltype(
                 error(std::declval<Future>(), std::declval<F&>()));
diff --git a/hpx/traits/is_future.hpp b/hpx/traits/is_future.hpp
index 1bd3038533..d23baa6edc 100644
--- a/hpx/traits/is_future.hpp
+++ b/hpx/traits/is_future.hpp
@@ -4,16 +4,11 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #if !defined(HPX_TRAITS_IS_FUTURE_APR_20_2012_0536PM)
 #define HPX_TRAITS_IS_FUTURE_APR_20_2012_0536PM
 
 #include <hpx/config.hpp>
 
-#include <boost/ref.hpp>
-
 #include <functional>
 #include <type_traits>
 
@@ -63,11 +58,6 @@ namespace hpx { namespace traits
       : std::false_type
     {};
 
-    template <typename Future>
-    struct is_ref_wrapped_future<boost::reference_wrapper<Future> >
-      : is_future<Future>
-    {};
-
     template <typename Future>
     struct is_ref_wrapped_future<std::reference_wrapper<Future> >
       : is_future<Future>
diff --git a/hpx/traits/is_future_range.hpp b/hpx/traits/is_future_range.hpp
index 0d5c56a90d..3e69e76cf5 100644
--- a/hpx/traits/is_future_range.hpp
+++ b/hpx/traits/is_future_range.hpp
@@ -5,17 +5,12 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #ifndef HPX_TRAITS_IS_FUTURE_RANGE_HPP
 #define HPX_TRAITS_IS_FUTURE_RANGE_HPP
 
 #include <hpx/traits/is_future.hpp>
 #include <hpx/iterator_support/traits/is_range.hpp>
 
-#include <boost/ref.hpp>
-
 #include <functional>
 #include <type_traits>
 
@@ -39,11 +34,6 @@ namespace hpx { namespace traits
       : std::false_type
     {};
 
-    template <typename R>
-    struct is_ref_wrapped_future_range< ::boost::reference_wrapper<R> >
-      : is_future_range<R>
-    {};
-
     template <typename R>
     struct is_ref_wrapped_future_range< ::std::reference_wrapper<R> >
       : is_future_range<R>
diff --git a/hpx/traits/is_future_tuple.hpp b/hpx/traits/is_future_tuple.hpp
index 33db46eefa..7051283139 100644
--- a/hpx/traits/is_future_tuple.hpp
+++ b/hpx/traits/is_future_tuple.hpp
@@ -8,8 +8,8 @@
 #define HPX_TRAITS_IS_FUTURE_TUPLE_HPP
 
 #include <hpx/traits/is_future.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <type_traits>
 
@@ -22,7 +22,7 @@ namespace hpx { namespace traits
 
     template <typename ...Ts>
     struct is_future_tuple<util::tuple<Ts...> >
-      : util::detail::all_of<is_future<Ts>...>
+      : util::all_of<is_future<Ts>...>
     {};
 }}
 
diff --git a/hpx/traits/is_launch_policy.hpp b/hpx/traits/is_launch_policy.hpp
index f32ee6beef..fdf1abb345 100644
--- a/hpx/traits/is_launch_policy.hpp
+++ b/hpx/traits/is_launch_policy.hpp
@@ -9,7 +9,6 @@
 
 #include <hpx/config.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 #include <hpx/traits/executor_traits.hpp>
 #include <hpx/type_support/decay.hpp>
 
diff --git a/hpx/traits/pack_traversal_rebind_container.hpp b/hpx/traits/pack_traversal_rebind_container.hpp
index 03099dee42..e35a514238 100644
--- a/hpx/traits/pack_traversal_rebind_container.hpp
+++ b/hpx/traits/pack_traversal_rebind_container.hpp
@@ -67,7 +67,7 @@ namespace hpx { namespace traits
 
     template <typename NewType, typename OldType, typename Enable = void>
     struct pack_traversal_rebind_container
-      : detail::pack_traversal_rebind_container<NewType, OldType>
+      : pack_traversal_rebind_container<NewType, OldType>
     {};
 
     // gcc reports an ambiguity for any standard container that has a defaulted
diff --git a/hpx/traits/pointer_category.hpp b/hpx/traits/pointer_category.hpp
index 907600d66a..1100448acd 100644
--- a/hpx/traits/pointer_category.hpp
+++ b/hpx/traits/pointer_category.hpp
@@ -20,9 +20,7 @@ namespace hpx { namespace traits
 {
     struct general_pointer_tag {};
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
     struct trivially_copyable_pointer_tag : general_pointer_tag {};
-#endif
 
     template <typename Source, typename Dest, typename Enable = void>
     struct pointer_category
@@ -31,7 +29,6 @@ namespace hpx { namespace traits
     };
 
     ///////////////////////////////////////////////////////////////////////////
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
     namespace detail
     {
         template <typename Source, typename Dest>
@@ -86,7 +83,6 @@ namespace hpx { namespace traits
             >::type
             type;
     };
-#endif
 
     // Allow for matching of iterator<T const> to iterator<T> while calculating
     // pointer category.
diff --git a/hpx/util/backtrace.hpp b/hpx/util/backtrace.hpp
index b9f972308c..315081b2db 100644
--- a/hpx/util/backtrace.hpp
+++ b/hpx/util/backtrace.hpp
@@ -26,12 +26,6 @@ namespace hpx { namespace util {
     {
         return "";
     }
-
-    inline std::string trace_on_new_stack(
-        std::size_t frames_no = HPX_HAVE_THREAD_BACKTRACE_DEPTH)
-    {
-        return "";
-    }
 }}    // namespace hpx::util
 
 #endif
diff --git a/hpx/util/backtrace/backtrace.hpp b/hpx/util/backtrace/backtrace.hpp
index bf78b90efc..09e4089cc9 100644
--- a/hpx/util/backtrace/backtrace.hpp
+++ b/hpx/util/backtrace/backtrace.hpp
@@ -19,123 +19,113 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
-    namespace stack_trace
+namespace hpx { namespace util {
+    namespace stack_trace {
+        HPX_API_EXPORT std::size_t trace(void** addresses, std::size_t size);
+        HPX_API_EXPORT void write_symbols(
+            void* const* addresses, std::size_t size, std::ostream&);
+        HPX_API_EXPORT std::string get_symbol(void* address);
+        HPX_API_EXPORT std::string get_symbols(
+            void* const* address, std::size_t size);
+    }    // namespace stack_trace
+
+    class backtrace
     {
-        HPX_API_EXPORT std::size_t trace(void **addresses, std::size_t size);
-        HPX_API_EXPORT void write_symbols(void *const *addresses,
-            std::size_t size,std::ostream &);
-        HPX_API_EXPORT std::string get_symbol(void *address);
-        HPX_API_EXPORT std::string get_symbols(void * const *address,
-            std::size_t size);
-    } // stack_trace
-
-    class backtrace {
     public:
-
-        explicit backtrace(std::size_t frames_no = HPX_HAVE_THREAD_BACKTRACE_DEPTH)
+        explicit backtrace(
+            std::size_t frames_no = HPX_HAVE_THREAD_BACKTRACE_DEPTH)
         {
-            if(frames_no == 0)
+            if (frames_no == 0)
                 return;
-            frames_.resize(frames_no,nullptr);
-            std::size_t size = stack_trace::trace(&frames_.front(),frames_no);
-            if(size != 0)
+            frames_.resize(frames_no, nullptr);
+            std::size_t size = stack_trace::trace(&frames_.front(), frames_no);
+            if (size != 0)
                 frames_.resize(size);
         }
 
-        virtual ~backtrace() noexcept
-        {
-        }
+        virtual ~backtrace() noexcept {}
 
         std::size_t stack_size() const
         {
             return frames_.size();
         }
 
-        void *return_address(std::size_t frame_no) const
+        void* return_address(std::size_t frame_no) const
         {
-            if(frame_no < stack_size())
+            if (frame_no < stack_size())
                 return frames_[frame_no];
             return nullptr;
         }
 
-        void trace_line(std::size_t frame_no,std::ostream &out) const
+        void trace_line(std::size_t frame_no, std::ostream& out) const
         {
-            if(frame_no < frames_.size())
-                stack_trace::write_symbols(&frames_[frame_no],1,out);
+            if (frame_no < frames_.size())
+                stack_trace::write_symbols(&frames_[frame_no], 1, out);
         }
 
         std::string trace_line(std::size_t frame_no) const
         {
-            if(frame_no < frames_.size())
+            if (frame_no < frames_.size())
                 return stack_trace::get_symbol(frames_[frame_no]);
             return std::string();
         }
 
         std::string trace() const
         {
-            if(frames_.empty())
+            if (frames_.empty())
                 return std::string();
-            return stack_trace::get_symbols(&frames_.front(),frames_.size());
+            return stack_trace::get_symbols(&frames_.front(), frames_.size());
         }
 
-        HPX_API_EXPORT std::string trace_on_new_stack() const;
-
-        void trace(std::ostream &out) const
+        void trace(std::ostream& out) const
         {
-            if(frames_.empty())
+            if (frames_.empty())
                 return;
-            stack_trace::write_symbols(&frames_.front(),frames_.size(),out);
+            stack_trace::write_symbols(&frames_.front(), frames_.size(), out);
         }
 
     private:
-        std::vector<void *> frames_;
+        std::vector<void*> frames_;
     };
 
     namespace details {
-        class trace_manip {
+        class trace_manip
+        {
         public:
-            trace_manip(backtrace const *tr) :
-                tr_(tr)
+            trace_manip(backtrace const* tr)
+              : tr_(tr)
             {
             }
-            std::ostream &write(std::ostream &out) const
+            std::ostream& write(std::ostream& out) const
             {
-                if(tr_)
+                if (tr_)
                     tr_->trace(out);
                 return out;
             }
+
         private:
-            backtrace const *tr_;
+            backtrace const* tr_;
         };
 
-        inline std::ostream &operator<<(std::ostream &out,details::trace_manip const &t)
+        inline std::ostream& operator<<(
+            std::ostream& out, details::trace_manip const& t)
         {
             return t.write(out);
         }
-    }
+    }    // namespace details
 
-    template<typename E>
-    inline details::trace_manip trace(E const &e)
+    template <typename E>
+    inline details::trace_manip trace(E const& e)
     {
-        backtrace const *tr = dynamic_cast<backtrace const *>(&e);
+        backtrace const* tr = dynamic_cast<backtrace const*>(&e);
         return details::trace_manip(tr);
     }
 
     inline std::string trace(
-        std::size_t frames_no = HPX_HAVE_THREAD_BACKTRACE_DEPTH) //-V659
+        std::size_t frames_no = HPX_HAVE_THREAD_BACKTRACE_DEPTH)    //-V659
     {
         return backtrace(frames_no).trace();
     }
-
-    inline std::string trace_on_new_stack(
-        std::size_t frames_no = HPX_HAVE_THREAD_BACKTRACE_DEPTH)
-    {
-        return backtrace(frames_no).trace_on_new_stack();
-    }
-
-}} // hpx::util
+}}    // namespace hpx::util
 
 #endif
-
diff --git a/hpx/util/bind_action.hpp b/hpx/util/bind_action.hpp
index 5183a7cb8b..9b456faffe 100644
--- a/hpx/util/bind_action.hpp
+++ b/hpx/util/bind_action.hpp
@@ -10,317 +10,177 @@
 #define HPX_UTIL_BIND_ACTION_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/tuple.hpp>
+#include <hpx/datastructures/member_pack.hpp>
 #include <hpx/functional/bind.hpp>
+#include <hpx/functional/traits/is_action.hpp>
+#include <hpx/functional/traits/is_bind_expression.hpp>
+#include <hpx/functional/traits/is_placeholder.hpp>
 #include <hpx/lcos/async_fwd.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/applier/apply.hpp>
 #include <hpx/traits/extract_action.hpp>
-#include <hpx/functional/traits/is_action.hpp>
-#include <hpx/functional/traits/is_bind_expression.hpp>
 #include <hpx/traits/is_continuation.hpp>
-#include <hpx/functional/traits/is_placeholder.hpp>
 #include <hpx/traits/promise_local_result.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
 #include <utility>
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
-        ///////////////////////////////////////////////////////////////////////
-        template <
-            typename Action,
-            std::size_t ...Is, typename ...Ts, typename Us>
-        HPX_FORCEINLINE
-        bool bind_action_apply_impl(
-            detail::pack_c<std::size_t, Is...>,
-            util::tuple<Ts...> const& bound, Us&& unbound)
-        {
-            return hpx::apply<Action>(
-                detail::bind_eval<Ts const&>::call(
-                    util::get<Is>(bound),
-                    std::forward<Us>(unbound))...);
-        }
-
-        template <typename Action, typename Ts, typename Us>
-        HPX_FORCEINLINE
-        bool
-        bind_action_apply(Ts const& bound, Us&& unbound)
-        {
-            using index_pack = typename detail::make_index_pack<
-                    util::tuple_size<typename std::decay<Ts>::type>::value
-                >::type;
-            return detail::bind_action_apply_impl<Action>(index_pack{},
-                bound, std::forward<Us>(unbound));
-        }
-
+    namespace detail {
         ///////////////////////////////////////////////////////////////////////
-        template <
-            typename Action,
-            std::size_t ...Is, typename ...Ts, typename Us>
-        HPX_FORCEINLINE
-        bool bind_action_apply_cont_impl(
-            detail::pack_c<std::size_t, Is...>,
-            naming::id_type const& cont,
-            util::tuple<Ts...> const& bound, Us&& unbound)
-        {
-            return hpx::apply_c<Action>(cont,
-                detail::bind_eval<Ts const&>::call(
-                    util::get<Is>(bound),
-                    std::forward<Us>(unbound))...);
-        }
-
-        template <typename Action, typename Ts, typename Us>
-        HPX_FORCEINLINE
-        bool
-        bind_action_apply_cont(naming::id_type const& cont,
-            Ts const& bound, Us&& unbound)
-        {
-            using index_pack = typename detail::make_index_pack<
-                    util::tuple_size<typename std::decay<Ts>::type>::value
-                >::type;
-            return detail::bind_action_apply_cont_impl<Action>(index_pack{},
-                cont, bound, std::forward<Us>(unbound));
-        }
-
-        ///////////////////////////////////////////////////////////////////////
-        template <
-            typename Action,
-            std::size_t ...Is, typename Continuation, typename ...Ts, typename Us>
-        HPX_FORCEINLINE
-        bool bind_action_apply_cont_impl2(
-            detail::pack_c<std::size_t, Is...>,
-            Continuation && cont,
-            util::tuple<Ts...> const& bound, Us&& unbound)
-        {
-            return hpx::apply<Action>(std::forward<Continuation>(cont),
-                detail::bind_eval<Ts const&>::call(
-                    util::get<Is>(bound),
-                    std::forward<Us>(unbound))...);
-        }
+        template <typename Action, typename Is, typename... Ts>
+        class bound_action;
 
-        template <typename Action, typename Continuation, typename Ts,
-            typename Us>
-        HPX_FORCEINLINE
-        typename std::enable_if<
-            traits::is_continuation<Continuation>::value, bool
-        >::type
-        bind_action_apply_cont2(Continuation && cont,
-            Ts const& bound, Us&& unbound)
-        {
-            using index_pack = typename detail::make_index_pack<
-                    util::tuple_size<typename std::decay<Ts>::type>::value
-                >::type;
-            return detail::bind_action_apply_cont_impl2<Action>(index_pack{},
-                std::forward<Continuation>(cont), bound, std::forward<Us>(unbound));
-        }
-
-        ///////////////////////////////////////////////////////////////////////
-        template <
-            typename Action,
-            std::size_t ...Is, typename ...Ts, typename Us>
-        HPX_FORCEINLINE
-        lcos::future<typename traits::promise_local_result<
-            typename hpx::traits::extract_action<Action>::remote_result_type
-        >::type> bind_action_async_impl(
-            detail::pack_c<std::size_t, Is...>,
-            util::tuple<Ts...> const& bound, Us&& unbound)
-        {
-            return hpx::async<Action>(
-                detail::bind_eval<Ts const&>::call(
-                    util::get<Is>(bound),
-                    std::forward<Us>(unbound))...);
-        }
-
-        template <typename Action, typename Ts, typename Us>
-        HPX_FORCEINLINE
-        lcos::future<typename traits::promise_local_result<
-            typename hpx::traits::extract_action<Action>::remote_result_type
-        >::type>
-        bind_action_async(Ts const& bound, Us&& unbound)
-        {
-            using index_pack = typename detail::make_index_pack<
-                    util::tuple_size<typename std::decay<Ts>::type>::value
-                >::type;
-            return detail::bind_action_async_impl<Action>(index_pack{},
-                bound, std::forward<Us>(unbound));
-        }
-
-        ///////////////////////////////////////////////////////////////////////
-        template <typename Action, typename Ts, typename Us>
-        HPX_FORCEINLINE
-        typename traits::promise_local_result<
-            typename hpx::traits::extract_action<Action>::remote_result_type
-        >::type
-        bind_action_invoke(Ts&& bound, Us&& unbound)
-        {
-            using index_pack = typename detail::make_index_pack<
-                    util::tuple_size<typename std::decay<Ts>::type>::value
-                >::type;
-            return detail::bind_action_async_impl<Action>(index_pack{},
-                bound, std::forward<Us>(unbound)).get();
-        }
-
-        ///////////////////////////////////////////////////////////////////////
-        template <typename Action, typename BoundArgs>
-        class bound_action //-V690
+        template <typename Action, std::size_t... Is, typename... Ts>
+        class bound_action<Action, index_pack<Is...>, Ts...>
         {
         public:
             typedef typename traits::promise_local_result<
-                typename hpx::traits::extract_action<Action>::remote_result_type
-            >::type result_type;
+                typename hpx::traits::extract_action<
+                    Action>::remote_result_type>::type result_type;
 
         public:
             // default constructor is needed for serialization
-            bound_action()
-            {}
+            bound_action() = default;
 
-            template <typename BoundArgs_>
-            explicit bound_action(Action /*action*/, BoundArgs_&& bound_args)
-              : _bound_args(std::forward<BoundArgs_>(bound_args))
-            {}
+            template <typename Derived, typename... Ts_>
+            explicit bound_action(Derived /*action*/, Ts_&&... vs)
+              : _args(std::piecewise_construct, std::forward<Ts_>(vs)...)
+            {
+            }
 
-            bound_action(bound_action const& other)
-              : _bound_args(other._bound_args)
-            {}
-            bound_action(bound_action&& other)
-              : _bound_args(std::move(other._bound_args))
-            {}
+#if !defined(__NVCC__) && !defined(__CUDACC__)
+            bound_action(bound_action const&) = default;
+            bound_action(bound_action&&) = default;
+#else
+            HPX_HOST_DEVICE bound_action(bound_action const& other)
+              : _args(other._args)
+            {
+            }
 
-            template <typename ...Us>
-            HPX_FORCEINLINE
-            bool
-            apply(Us&&... us) const
+            HPX_HOST_DEVICE bound_action(bound_action&& other)
+              : _args(std::move(other._args))
             {
-                return detail::bind_action_apply<Action>(
-                    _bound_args, util::forward_as_tuple(std::forward<Us>(us)...));
             }
+#endif
+
+            bound_action& operator=(bound_action const&) = delete;
 
-            template <typename ...Us>
-            HPX_FORCEINLINE
-            bool
-            apply_c(naming::id_type const& contgid, Us&&... us) const
+            template <typename... Us>
+            HPX_FORCEINLINE bool apply(Us&&... vs) const
             {
-                return detail::bind_action_apply_cont<Action>(contgid,
-                    _bound_args, util::forward_as_tuple(std::forward<Us>(us)...));
+                return hpx::apply<Action>(detail::bind_eval<Ts const&>::call(
+                    _args.template get<Is>(), std::forward<Us>(vs)...)...);
             }
 
-            template <typename Continuation, typename ...Us>
-            HPX_FORCEINLINE
-            typename std::enable_if<
-                traits::is_continuation<Continuation>::value, bool
-            >::type
-            apply_c(Continuation && cont, Us&&... us) const
+            template <typename... Us>
+            HPX_FORCEINLINE bool apply_c(
+                naming::id_type const& cont, Us&&... vs) const
             {
-                return detail::bind_action_apply_cont2<Action>(
-                    std::forward<Continuation>(cont),
-                    _bound_args, util::forward_as_tuple(std::forward<Us>(us)...));
+                return hpx::apply_c<Action>(cont,
+                    detail::bind_eval<Ts const&>::call(
+                        _args.template get<Is>(), std::forward<Us>(vs)...)...);
             }
 
-            template <typename ...Us>
-            HPX_FORCEINLINE
-            hpx::lcos::future<result_type>
-            async(Us&&... us) const
+            template <typename Continuation, typename... Us>
+            HPX_FORCEINLINE typename std::enable_if<
+                traits::is_continuation<Continuation>::value, bool>::type
+            apply_c(Continuation&& cont, Us&&... vs) const
             {
-                return detail::bind_action_async<Action>(
-                    _bound_args, util::forward_as_tuple(std::forward<Us>(us)...));
+                return hpx::apply<Action>(std::forward<Continuation>(cont),
+                    detail::bind_eval<Ts const&>::call(
+                        _args.template get<Is>(), std::forward<Us>(vs)...)...);
             }
 
-            template <typename ...Us>
-            HPX_FORCEINLINE
-            result_type
-            operator()(Us&&... us) const
+            template <typename... Us>
+            HPX_FORCEINLINE hpx::lcos::future<result_type> async(
+                Us&&... vs) const
             {
-                return detail::bind_action_invoke<Action>(
-                    _bound_args, util::forward_as_tuple(std::forward<Us>(us)...));
+                return hpx::async<Action>(detail::bind_eval<Ts const&>::call(
+                    _args.template get<Is>(), std::forward<Us>(vs)...)...);
             }
 
-        public: // exposition-only
-            BoundArgs _bound_args;
+            template <typename... Us>
+            HPX_FORCEINLINE result_type operator()(Us&&... vs) const
+            {
+                return async(std::forward<Us>(vs)...).get();
+            }
+
+            template <typename Archive>
+            void serialize(Archive& ar, unsigned int const /*version*/)
+            {
+                ar& _args;
+            }
+
+        private:
+            util::member_pack_for<Ts...> _args;
         };
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
-    template <typename Action, typename ...Ts>
-    typename std::enable_if<
-        traits::is_action<typename std::decay<Action>::type>::value
-      , detail::bound_action<
-            typename std::decay<Action>::type
-          , util::tuple<typename std::decay<Ts>::type...>
-        >
-    >::type
+    template <typename Action, typename... Ts,
+        typename Enable = typename std::enable_if<
+            traits::is_action<typename std::decay<Action>::type>::value>::type>
+    detail::bound_action<typename std::decay<Action>::type,
+        typename util::make_index_pack<sizeof...(Ts)>::type,
+        typename std::decay<Ts>::type...>
     bind(Ts&&... vs)
     {
-        typedef detail::bound_action<
-            typename std::decay<Action>::type,
-            util::tuple<typename std::decay<Ts>::type...>
-        > result_type;
+        typedef detail::bound_action<typename std::decay<Action>::type,
+            typename util::make_index_pack<sizeof...(Ts)>::type,
+            typename std::decay<Ts>::type...>
+            result_type;
 
-        return result_type(Action(),
-            util::forward_as_tuple(std::forward<Ts>(vs)...));
+        return result_type(Action(), std::forward<Ts>(vs)...);
     }
 
-    template <
-        typename Component, typename Signature, typename Derived
-      , typename ...Ts>
-    detail::bound_action<
-        Derived
-      , util::tuple<typename std::decay<Ts>::type...>
-    >
-    bind(
-        hpx::actions::basic_action<Component, Signature, Derived> action,
+    template <typename Component, typename Signature, typename Derived,
+        typename... Ts>
+    detail::bound_action<Derived,
+        typename util::make_index_pack<sizeof...(Ts)>::type,
+        typename std::decay<Ts>::type...>
+    bind(hpx::actions::basic_action<Component, Signature, Derived> action,
         Ts&&... vs)
     {
-        typedef detail::bound_action<
-            Derived,
-            util::tuple<typename std::decay<Ts>::type...>
-        > result_type;
+        typedef detail::bound_action<Derived,
+            typename util::make_index_pack<sizeof...(Ts)>::type,
+            typename std::decay<Ts>::type...>
+            result_type;
 
-        return result_type(static_cast<Derived const&>(action),
-            util::forward_as_tuple(std::forward<Ts>(vs)...));
+        return result_type(
+            static_cast<Derived const&>(action), std::forward<Ts>(vs)...);
     }
-}}
+}}    // namespace hpx::util
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace traits
-{
+namespace hpx { namespace traits {
     ///////////////////////////////////////////////////////////////////////////
-    template <typename Action, typename BoundArgs>
-    struct is_bind_expression<util::detail::bound_action<Action, BoundArgs> >
+    template <typename Action, typename Is, typename... Ts>
+    struct is_bind_expression<util::detail::bound_action<Action, Is, Ts...>>
       : std::true_type
-    {};
+    {
+    };
 
-    template <typename Action, typename BoundArgs>
-    struct is_bound_action<util::detail::bound_action<Action, BoundArgs> >
+    template <typename Action, typename Is, typename... Ts>
+    struct is_bound_action<util::detail::bound_action<Action, Is, Ts...>>
       : std::true_type
-    {};
-}}
+    {
+    };
+}}    // namespace hpx::traits
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace serialization
-{
+namespace hpx { namespace serialization {
     // serialization of the bound action object
-    template <typename Action, typename BoundArgs>
-    void serialize(
-        ::hpx::serialization::input_archive& ar
-      , ::hpx::util::detail::bound_action<Action, BoundArgs>& bound
-      , unsigned int const /*version*/)
-    {
-        ar >> bound._bound_args;
-    }
-
-    template <typename Action, typename BoundArgs>
-    void serialize(
-        ::hpx::serialization::output_archive& ar
-      , ::hpx::util::detail::bound_action<Action, BoundArgs>& bound
-      , unsigned int const /*version*/)
+    template <typename Archive, typename F, typename... Ts>
+    void serialize(Archive& ar,
+        ::hpx::util::detail::bound_action<F, Ts...>& bound,
+        unsigned int const version = 0)
     {
-        ar << bound._bound_args;
+        bound.serialize(ar, version);
     }
-}}
+}}    // namespace hpx::serialization
 
 #endif
diff --git a/hpx/util/debug/thread_stacktrace.hpp b/hpx/util/debug/thread_stacktrace.hpp
index efa00b4cca..f7f5946eda 100644
--- a/hpx/util/debug/thread_stacktrace.hpp
+++ b/hpx/util/debug/thread_stacktrace.hpp
@@ -8,8 +8,8 @@
 #define HPX_UTIL_DEBUG_THREAD_STACKS_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
+#include <hpx/threading_base.hpp>
 
 #include <vector>
 #include <string>
diff --git a/hpx/util/debugging.hpp b/hpx/util/debugging.hpp
index b1cd229a1f..c9ad8adeca 100644
--- a/hpx/util/debugging.hpp
+++ b/hpx/util/debugging.hpp
@@ -13,9 +13,6 @@
 
 namespace hpx {
 namespace util {
-    /// Tries to break an attached debugger, if not supported a loop is
-    /// invoked which gives enough time to attach a debugger manually.
-    void HPX_EXPORT attach_debugger();
     /// Attaches a debugger if \c category is equal to the configuration entry
     /// hpx.attach-debugger.
     void HPX_EXPORT may_attach_debugger(std::string const& category);
diff --git a/hpx/util/detail/pack_traversal_async_impl.hpp b/hpx/util/detail/pack_traversal_async_impl.hpp
index 6b3390b96c..c331ca4247 100644
--- a/hpx/util/detail/pack_traversal_async_impl.hpp
+++ b/hpx/util/detail/pack_traversal_async_impl.hpp
@@ -10,13 +10,13 @@
 #include <hpx/config.hpp>
 #include <hpx/allocator_support/allocator_deleter.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/invoke_fused.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
 #include <hpx/traits/future_access.hpp>
 #include <hpx/type_support/always_void.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/detail/container_category.hpp>
 
 #include <atomic>
@@ -60,8 +60,8 @@ namespace util {
         template <std::size_t Offset, typename Pack>
         struct relocate_index_pack;
         template <std::size_t Offset, std::size_t... Sequence>
-        struct relocate_index_pack<Offset, pack_c<std::size_t, Sequence...>>
-          : std::common_type<pack_c<std::size_t, (Sequence + Offset)...>>
+        struct relocate_index_pack<Offset, index_pack<Sequence...>>
+          : std::common_type<index_pack<(Sequence + Offset)...>>
         {
         };
 
@@ -272,26 +272,26 @@ namespace util {
                 return *this;
             }
 
-            HPX_CONSTEXPR auto operator*() const noexcept
+            constexpr auto operator*() const noexcept
                 -> decltype(util::get<Begin>(*target_))
             {
                 return util::get<Begin>(*target_);
             }
 
             template <std::size_t Position>
-            HPX_CONSTEXPR static_async_range<Target, Position, End> relocate()
+            constexpr static_async_range<Target, Position, End> relocate()
                 const noexcept
             {
                 return static_async_range<Target, Position, End>{target_};
             }
 
-            HPX_CONSTEXPR static_async_range<Target, Begin + 1, End> next()
+            constexpr static_async_range<Target, Begin + 1, End> next()
                 const noexcept
             {
                 return static_async_range<Target, Begin + 1, End>{target_};
             }
 
-            HPX_CONSTEXPR bool is_finished() const noexcept
+            constexpr bool is_finished() const noexcept
             {
                 return false;
             }
@@ -302,9 +302,9 @@ namespace util {
         template <typename Target, std::size_t Begin>
         struct static_async_range<Target, Begin, Begin>
         {
-            explicit static_async_range(Target*) {}
+            explicit constexpr static_async_range(Target*) {}
 
-            HPX_CONSTEXPR bool is_finished() const noexcept
+            constexpr bool is_finished() const noexcept
             {
                 return true;
             }
@@ -508,7 +508,7 @@ namespace util {
 
             template <std::size_t... Sequence, typename Current>
             void async_traverse_static_async_range(
-                pack_c<std::size_t, Sequence...>,
+                index_pack<Sequence...>,
                 Current&& current)
             {
                 int dummy[] = {((void) async_traverse_one_checked(
diff --git a/hpx/util/detail/pack_traversal_impl.hpp b/hpx/util/detail/pack_traversal_impl.hpp
index 4335f05151..6da09cfd40 100644
--- a/hpx/util/detail/pack_traversal_impl.hpp
+++ b/hpx/util/detail/pack_traversal_impl.hpp
@@ -8,7 +8,6 @@
 #define HPX_UTIL_DETAIL_PACK_TRAVERSAL_IMPL_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/invoke_fused.hpp>
@@ -16,6 +15,7 @@
 #include <hpx/functional/traits/is_callable.hpp>
 #include <hpx/traits/pack_traversal_rebind_container.hpp>
 #include <hpx/type_support/always_void.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/detail/container_category.hpp>
 #include <hpx/util/detail/reserve.hpp>
 
@@ -37,7 +37,7 @@ namespace util {
                 tuple<T...> boxed_;
 
             public:
-                explicit HPX_CONSTEXPR spread_box(tuple<T...> boxed)
+                explicit constexpr spread_box(tuple<T...> boxed)
                   : boxed_(std::move(boxed))
                 {
                 }
@@ -51,14 +51,14 @@ namespace util {
             class spread_box<>
             {
             public:
-                explicit HPX_CONSTEXPR spread_box() noexcept
+                explicit constexpr spread_box() noexcept
                 {
                 }
-                explicit HPX_CONSTEXPR spread_box(tuple<> const&) noexcept
+                explicit constexpr spread_box(tuple<> const&) noexcept
                 {
                 }
 
-                HPX_CONSTEXPR tuple<> unbox() const noexcept
+                constexpr tuple<> unbox() const noexcept
                 {
                     return tuple<>{};
                 }
@@ -66,7 +66,7 @@ namespace util {
 
             /// Returns an empty spread box which represents an empty
             /// mapped object.
-            HPX_CONSTEXPR inline spread_box<> empty_spread() noexcept
+            constexpr inline spread_box<> empty_spread() noexcept
             {
                 return spread_box<>{};
             }
@@ -95,12 +95,12 @@ namespace util {
             /// Converts types to the type and spread_box objects to its
             /// underlying tuple.
             template <typename T>
-            HPX_CONSTEXPR T unpack(T&& type)
+            constexpr T unpack(T&& type)
             {
                 return std::forward<T>(type);
             }
             template <typename... T>
-            HPX_CONSTEXPR auto unpack(spread_box<T...> type)
+            constexpr auto unpack(spread_box<T...> type)
                 -> decltype(type.unbox())
             {
                 return type.unbox();
@@ -115,7 +115,7 @@ namespace util {
             /// underlying tuple. If the type is mapped to zero elements,
             /// the return type will be void.
             template <typename T>
-            HPX_CONSTEXPR auto unpack_or_void(T&& type)
+            constexpr auto unpack_or_void(T&& type)
                 -> decltype(unpack(std::forward<T>(type)))
             {
                 return unpack(std::forward<T>(type));
@@ -127,12 +127,12 @@ namespace util {
             /// Converts types to the a tuple carrying the single type and
             /// spread_box objects to its underlying tuple.
             template <typename T>
-            HPX_CONSTEXPR tuple<T> undecorate(T&& type)
+            constexpr tuple<T> undecorate(T&& type)
             {
                 return tuple<T>{std::forward<T>(type)};
             }
             template <typename... T>
-            HPX_CONSTEXPR auto undecorate(spread_box<T...> type)
+            constexpr auto undecorate(spread_box<T...> type)
                 -> decltype(type.unbox())
             {
                 return type.unbox();
@@ -146,7 +146,7 @@ namespace util {
                 // We overload with one argument here so Clang and GCC don't
                 // have any issues with overloading against zero arguments.
                 template <typename First, typename... T>
-                HPX_CONSTEXPR Type<First, T...> operator()(
+                constexpr Type<First, T...> operator()(
                     First&& first, T&&... args) const
                 {
                     return Type<First, T...>{
@@ -155,7 +155,7 @@ namespace util {
 
                 // Specifically return the empty object which can be different
                 // from a tuple.
-                HPX_CONSTEXPR EmptyType operator()() const
+                constexpr EmptyType operator()() const
                     noexcept(noexcept(EmptyType{}))
                 {
                     return EmptyType{};
@@ -189,14 +189,14 @@ namespace util {
                 // We overload with one argument here so Clang and GCC don't
                 // have any issues with overloading against zero arguments.
                 template <typename First, typename... T>
-                HPX_CONSTEXPR auto operator()(First&& first, T&&... args) const
+                constexpr auto operator()(First&& first, T&&... args) const
                     -> array_type_of_t<First, T...>
                 {
                     return array_type_of_t<First, T...>{
                         {std::forward<First>(first), std::forward<T>(args)...}};
                 }
 
-                HPX_CONSTEXPR auto operator()() const noexcept
+                constexpr auto operator()() const noexcept
                     -> decltype(empty_spread())
                 {
                     return empty_spread();
@@ -206,7 +206,7 @@ namespace util {
             /// Use the recursive instantiation for a variadic pack which
             /// may contain spread types
             template <typename C, typename... T>
-            HPX_CONSTEXPR auto apply_spread_impl(std::true_type, C&& callable,
+            constexpr auto apply_spread_impl(std::true_type, C&& callable,
                 T&&... args) -> decltype(invoke_fused(std::forward<C>(callable),
                 util::tuple_cat(undecorate(std::forward<T>(args))...)))
             {
@@ -217,7 +217,7 @@ namespace util {
             /// Use the linear instantiation for variadic packs which don't
             /// contain spread types.
             template <typename C, typename... T>
-            HPX_CONSTEXPR auto apply_spread_impl(std::false_type, C&& callable,
+            constexpr auto apply_spread_impl(std::false_type, C&& callable,
                 T&&... args) -> typename invoke_result<C, T...>::type
             {
                 return hpx::util::invoke(
@@ -227,10 +227,10 @@ namespace util {
             /// Deduces to a true_type if any of the given types marks
             /// the underlying type to be spread into the current context.
             template <typename... T>
-            using is_any_spread_t = any_of<is_spread<T>...>;
+            using is_any_spread_t = util::any_of<is_spread<T>...>;
 
             template <typename C, typename... T>
-            HPX_CONSTEXPR auto map_spread(C&& callable, T&&... args)
+            constexpr auto map_spread(C&& callable, T&&... args)
                 -> decltype(apply_spread_impl(is_any_spread_t<T...>{},
                     std::forward<C>(callable), std::forward<T>(args)...))
             {
@@ -244,7 +244,7 @@ namespace util {
             /// Converts the given variadic arguments into a tuple in a way
             /// that spread return values are inserted into the current pack.
             template <typename... T>
-            HPX_CONSTEXPR auto tupelize(T&&... args) -> decltype(
+            constexpr auto tupelize(T&&... args) -> decltype(
                 map_spread(tupelizer_of_t<>{}, std::forward<T>(args)...))
             {
                 return map_spread(tupelizer_of_t<>{}, std::forward<T>(args)...);
@@ -255,7 +255,7 @@ namespace util {
             /// If the arguments were mapped to zero arguments, the empty
             /// mapping is propagated backwards to the caller.
             template <template <typename...> class Type, typename... T>
-            HPX_CONSTEXPR auto flat_tupelize_to(T&&... args)
+            constexpr auto flat_tupelize_to(T&&... args)
                 -> decltype(map_spread(
                     flat_tupelizer_of_t<Type>{}, std::forward<T>(args)...))
             {
@@ -270,7 +270,7 @@ namespace util {
             /// mapping is propagated backwards to the caller.
             template <template <typename, std::size_t> class Type,
                 typename... T>
-            HPX_CONSTEXPR auto flat_arraylize_to(T&&... args) -> decltype(
+            constexpr auto flat_arraylize_to(T&&... args) -> decltype(
                 map_spread(flat_arraylizer<Type>{}, std::forward<T>(args)...))
             {
                 return map_spread(
@@ -279,7 +279,7 @@ namespace util {
 
             /// Converts an empty tuple to void
             template <typename First, typename... Rest>
-            HPX_CONSTEXPR tuple<First, Rest...> voidify_empty_tuple(
+            constexpr tuple<First, Rest...> voidify_empty_tuple(
                 tuple<First, Rest...> val)
             {
                 return val;
@@ -293,7 +293,7 @@ namespace util {
             ///
             /// If the returned tuple is empty, voidis returned instead.
             template <typename... T>
-            HPX_CONSTEXPR auto tupelize_or_void(T&&... args) -> decltype(
+            constexpr auto tupelize_or_void(T&&... args) -> decltype(
                 voidify_empty_tuple(tupelize(std::forward<T>(args)...)))
             {
                 return voidify_empty_tuple(tupelize(std::forward<T>(args)...));
@@ -584,7 +584,9 @@ namespace util {
         namespace tuple_like_remapping {
             template <typename Strategy, typename Mapper, typename T,
                 typename Enable = void>
-            struct tuple_like_remapper;
+            struct tuple_like_remapper
+            {
+            };
 
             /// Specialization for std::tuple like types which contain
             /// an arbitrary amount of heterogeneous arguments.
diff --git a/hpx/util/detail/serializable_basic_function.hpp b/hpx/util/detail/serializable_basic_function.hpp
index 526152c0cb..b500910033 100644
--- a/hpx/util/detail/serializable_basic_function.hpp
+++ b/hpx/util/detail/serializable_basic_function.hpp
@@ -34,7 +34,7 @@ namespace hpx { namespace util { namespace detail
         using base_type = basic_function<R(Ts...), Copyable, false>;
 
     public:
-        HPX_CONSTEXPR basic_function() noexcept
+        constexpr basic_function() noexcept
           : base_type()
           , serializable_vptr(nullptr)
         {}
diff --git a/hpx/util/detail/vtable/serializable_vtable.hpp b/hpx/util/detail/vtable/serializable_vtable.hpp
index 81f817df0b..b3c3eb07b6 100644
--- a/hpx/util/detail/vtable/serializable_vtable.hpp
+++ b/hpx/util/detail/vtable/serializable_vtable.hpp
@@ -42,7 +42,7 @@ namespace hpx { namespace util { namespace detail
             serialization::input_archive&, unsigned);
 
         template <typename T>
-        HPX_CONSTEXPR serializable_vtable(construct_vtable<T>) noexcept
+        constexpr serializable_vtable(construct_vtable<T>) noexcept
           : save_object(&serializable_vtable::template _save_object<T>)
           , load_object(&serializable_vtable::template _load_object<T>)
         {}
diff --git a/hpx/util/external_timer.hpp b/hpx/util/external_timer.hpp
deleted file mode 100644
index fb023befef..0000000000
--- a/hpx/util/external_timer.hpp
+++ /dev/null
@@ -1,302 +0,0 @@
-//  Copyright (c) 2007-2016 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#pragma once    // prevent multiple inclusions of this header file.
-
-#include <hpx/config.hpp>
-#include <hpx/assertion.hpp>
-#include <hpx/coroutines/thread_id_type.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/util/thread_description.hpp>
-#include <cstdint>
-#include <memory>
-#include <string>
-
-namespace hpx { namespace util {
-
-#ifdef HPX_HAVE_APEX
-
-    using enable_parent_task_handler_type = std::function<bool()>;
-
-    HPX_EXPORT void set_enable_parent_task_handler(
-        enable_parent_task_handler_type f);
-
-    namespace external_timer {
-
-    /* HPX provides a smart pointer to a data object that maintains
-     * information about an hpx_thread.  Any library (i.e. APEX)
-     * that wants to use this callback API needs to extend this class.
-     */
-    struct task_wrapper {
-    };
-
-    /* Enumeration of function type flags */
-    typedef enum functions_t {
-        init_flag = 0,
-        finalize_flag,
-        register_thread_flag,
-        new_task_string_flag,
-        new_task_address_flag,
-        update_task_string_flag,
-        update_task_address_flag,
-        sample_value_flag,
-        send_flag,
-        recv_flag,
-        start_flag,
-        stop_flag,
-        yield_flag
-    } functions_t;
-
-    /* Typedefs of function pointers */
-    typedef uint64_t init_t(const char *, const uint64_t, const uint64_t);
-    typedef void finalize_t(void);
-    typedef void register_thread_t(const std::string &);
-    typedef std::shared_ptr<task_wrapper> new_task_string_t(
-                const std::string &, const uint64_t,
-                const std::shared_ptr<task_wrapper>);
-    typedef std::shared_ptr<task_wrapper> new_task_address_t(
-                uintptr_t, const uint64_t, const std::shared_ptr<task_wrapper>);
-    typedef void sample_value_t(const std::string &, double);
-    typedef void send_t(uint64_t, uint64_t, uint64_t);
-    typedef void recv_t(uint64_t, uint64_t, uint64_t, uint64_t);
-    typedef std::shared_ptr<task_wrapper> update_task_string_t(
-                std::shared_ptr<task_wrapper>, const std::string &);
-    typedef std::shared_ptr<task_wrapper> update_task_address_t(
-                std::shared_ptr<task_wrapper>, uintptr_t);
-    typedef void start_t(std::shared_ptr<task_wrapper>);
-    typedef void stop_t(std::shared_ptr<task_wrapper>);
-    typedef void yield_t(std::shared_ptr<task_wrapper>);
-
-    /* Structure for compiler type-checking of function pointer assignment */
-    typedef struct registration {
-        functions_t type;
-        union {
-            init_t *init;
-            finalize_t *finalize;
-            register_thread_t *register_thread;
-            new_task_string_t *new_task_string;
-            new_task_address_t *new_task_address;
-            update_task_string_t *update_task_string;
-            update_task_address_t *update_task_address;
-            sample_value_t *sample_value;
-            send_t *send;
-            recv_t *recv;
-            start_t *start;
-            stop_t *stop;
-            yield_t *yield;
-        } record;
-    } registration_t;
-
-    /* The actual function pointers.  Some of them need to be exported,
-     * because through the miracle of chained headers they get referenced
-     * outside of the HPX library. */
-    extern init_t *init_function;
-    extern finalize_t *finalize_function;
-    extern register_thread_t *register_thread_function;
-    extern new_task_string_t *new_task_string_function;
-    extern new_task_address_t *new_task_address_function;
-    extern sample_value_t *sample_value_function;
-    extern send_t *send_function;
-    extern recv_t *recv_function;
-    HPX_EXPORT extern update_task_string_t *update_task_string_function ;
-    HPX_EXPORT extern update_task_address_t *update_task_address_function ;
-    HPX_EXPORT extern start_t *start_function ;
-    HPX_EXPORT extern stop_t *stop_function ;
-    HPX_EXPORT extern yield_t *yield_function ;
-
-    /* The function registration interface */
-    HPX_EXPORT void register_external_timer(
-        registration_t &registration_record);
-
-    /* The actual API.  For all cases, check if the function pointer is
-       null, and if not null call the registered function. */
-    static inline uint64_t init(const char * thread_name,
-        const uint64_t comm_rank, const uint64_t comm_size) {
-        return (init_function == nullptr) ? 0ULL :
-            init_function(thread_name, comm_rank, comm_size);
-    };
-    static inline void finalize(void) {
-        if (finalize_function != nullptr) {
-            finalize_function();
-        }
-    };
-    static inline void register_thread(const std::string &name) {
-        if (register_thread_function != nullptr) {
-            register_thread_function(name);
-        }
-    };
-    static inline std::shared_ptr<task_wrapper> new_task(
-        const std::string &name, const uint64_t task_id,
-        const std::shared_ptr<task_wrapper> parent_task) {
-        return (new_task_string_function == nullptr) ? 0ULL :
-            new_task_string_function(name, task_id, parent_task);
-    };
-    static inline std::shared_ptr<task_wrapper> new_task(
-        uintptr_t address, const uint64_t task_id,
-        const std::shared_ptr<task_wrapper> parent_task) {
-        return (new_task_address_function == nullptr) ? 0ULL :
-            new_task_address_function(address, task_id, parent_task);
-    };
-    static inline void sample_value(const std::string &name, double value) {
-        if (sample_value_function != nullptr) {
-            sample_value_function(name, value);
-        }
-    };
-    static inline void send (uint64_t tag, uint64_t size, uint64_t target) {
-        if (send_function != nullptr) {
-            send_function(tag, size, target);
-        }
-    };
-    static inline void recv (uint64_t tag, uint64_t size,
-        uint64_t source_rank, uint64_t source_thread) {
-        if (recv_function != nullptr) {
-            recv_function(tag, size, source_rank, source_thread);
-        }
-    };
-    static inline std::shared_ptr<task_wrapper> update_task(
-        std::shared_ptr<task_wrapper> wrapper, const std::string &name) {
-        return (update_task_string_function == nullptr) ? 0ULL :
-            update_task_string_function(wrapper, name);
-    };
-    static inline std::shared_ptr<task_wrapper> update_task(
-        std::shared_ptr<task_wrapper> wrapper, uintptr_t address) {
-        return (update_task_address_function == nullptr) ? 0ULL :
-            update_task_address_function(wrapper, address);
-    };
-    static inline void start(std::shared_ptr<task_wrapper> task_wrapper_ptr) {
-        if (start_function != nullptr) {
-            start_function(task_wrapper_ptr);
-        }
-    };
-    static inline void stop(std::shared_ptr<task_wrapper> task_wrapper_ptr) {
-        if (stop_function != nullptr) {
-            stop_function(task_wrapper_ptr);
-        }
-    };
-    static inline void yield(std::shared_ptr<task_wrapper> task_wrapper_ptr) {
-        if (yield_function != nullptr) {
-            yield_function(task_wrapper_ptr);
-        }
-    };
-
-    HPX_EXPORT std::shared_ptr<task_wrapper> new_task(
-        thread_description const& description,
-        std::uint32_t parent_locality_id,
-        threads::thread_id_type const& parent_task);
-
-    HPX_EXPORT inline std::shared_ptr<task_wrapper> update_task(
-        std::shared_ptr<task_wrapper> wrapper,
-        thread_description const& description)
-    {
-        if (wrapper == nullptr)
-        {
-            threads::thread_id_type parent_task(nullptr);
-            // doesn't matter which locality we use, the parent is null
-            return new_task(description, 0, parent_task);
-        }
-        else if (description.kind() ==
-            thread_description::data_type_description)
-        {
-            // Disambiguate the call by making a temporary string object
-            return update_task(wrapper,
-                std::string(description.get_description()));
-        }
-        else
-        {
-            HPX_ASSERT(
-                description.kind() == thread_description::data_type_address);
-            return update_task(wrapper, description.get_address());
-        }
-    }
-
-    /* This is a scoped object around task scheduling to measure the time
-     * spent executing hpx threads */
-    struct scoped_timer
-    {
-        explicit scoped_timer(std::shared_ptr<task_wrapper> data_ptr)
-          : stopped(false)
-          , data_(nullptr)
-        {
-            /* APEX internal actions are not timed.  Otherwise, we would
-             * end up with recursive timers. So it's possible to have
-             * a null task wrapper pointer here. */
-            if (data_ptr != nullptr)
-            {
-                data_ = data_ptr;
-                hpx::util::external_timer::start(data_);
-            }
-        }
-        ~scoped_timer()
-        {
-            stop();
-        }
-
-        void stop()
-        {
-            if (!stopped)
-            {
-                stopped = true;
-                /* APEX internal actions are not timed.  Otherwise, we would
-             * end up with recursive timers. So it's possible to have
-             * a null task wrapper pointer here. */
-                if (data_ != nullptr)
-                {
-                    hpx::util::external_timer::stop(data_);
-                }
-            }
-        }
-
-        void yield()
-        {
-            if (!stopped)
-            {
-                stopped = true;
-                /* APEX internal actions are not timed.  Otherwise, we would
-             * end up with recursive timers. So it's possible to have
-             * a null task wrapper pointer here. */
-                if (data_ != nullptr)
-                {
-                    hpx::util::external_timer::yield(data_);
-                }
-            }
-        }
-
-        bool stopped;
-        std::shared_ptr<task_wrapper> data_;
-    };
-    }    // namespace hpx::util::external_timer
-
-#else
-    namespace external_timer {
-
-    struct task_wrapper {
-    };
-
-    inline std::shared_ptr<task_wrapper> new_task(
-        thread_description const& description,
-        std::uint32_t parent_locality_id,
-        threads::thread_id_type const& parent_task)
-    {
-        return nullptr;
-    }
-
-    inline std::shared_ptr<task_wrapper> update_task(
-        std::shared_ptr<task_wrapper> wrapper,
-        thread_description const& description)
-    {
-        return nullptr;
-    }
-
-    struct scoped_timer
-    {
-        explicit scoped_timer(std::shared_ptr<task_wrapper> data_ptr) {}
-        ~scoped_timer() {}
-        void stop(void) {}
-        void yield(void) {}
-    };
-    }    // namespace hpx::util::external_timer
-#endif
-}}    // namespace hpx::util
diff --git a/hpx/util/init_logging.hpp b/hpx/util/init_logging.hpp
index 512112df83..91e656f321 100644
--- a/hpx/util/init_logging.hpp
+++ b/hpx/util/init_logging.hpp
@@ -8,7 +8,7 @@
 #define HPX_UTIL_AGAS_INIT_LOGGING_SEP_07_2013_0754PM
 
 #include <hpx/runtime_fwd.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
 #include <hpx/util_fwd.hpp>
 
 #include <string>
@@ -20,10 +20,6 @@ namespace hpx { namespace util { namespace detail
     /// The init_logging type will be used for initialization purposes only as
     /// well.
     HPX_API_EXPORT void init_logging(runtime_configuration& ini, bool isconsole);
-
-    /// Get the data to use to pre-fill the runtime_configuration instance with
-    /// logging specific data.
-    HPX_API_EXPORT std::vector<std::string> const& get_logging_data();
 }}}
 
 #endif
diff --git a/hpx/util/interval_timer.hpp b/hpx/util/interval_timer.hpp
index 005e82e4f1..b687bc7d17 100644
--- a/hpx/util/interval_timer.hpp
+++ b/hpx/util/interval_timer.hpp
@@ -11,10 +11,9 @@
 #include <hpx/synchronization/spinlock.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/functional/function.hpp>
+#include <hpx/threading_base.hpp>
 #include <hpx/timing/steady_clock.hpp>
 
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-
 #include <algorithm>
 #include <cstdint>
 #include <memory>
@@ -56,7 +55,7 @@ namespace hpx { namespace util { namespace detail
         ~interval_timer();
 
         bool start(bool evaluate);
-        bool stop();
+        bool stop(bool terminate = false);
 
         bool restart(bool evaluate);
 
@@ -83,6 +82,8 @@ namespace hpx { namespace util { namespace detail
         util::function_nonser<void()> on_term_; ///< function to call on termination
         std::int64_t microsecs_;    ///< time interval
         threads::thread_id_type id_;  ///< id of currently scheduled thread
+        threads::thread_id_type timerid_;  ///< id of the timer thread for the
+                                           ///< currently scheduled thread
         std::string description_;     ///< description of this interval timer
 
         bool pre_shutdown_;           ///< execute termination during pre-shutdown
@@ -125,9 +126,9 @@ namespace hpx { namespace util
         {
             return timer_->start(evaluate);
         }
-        bool stop()
+        bool stop(bool terminate = false)
         {
-            return timer_->stop();
+            return timer_->stop(terminate);
         }
 
         bool restart(bool evaluate = true)
diff --git a/hpx/util/pack_traversal.hpp b/hpx/util/pack_traversal.hpp
index c7ae8e3250..ff82cd0624 100644
--- a/hpx/util/pack_traversal.hpp
+++ b/hpx/util/pack_traversal.hpp
@@ -20,7 +20,7 @@ namespace util {
     ///
     /// This function tries to visit all plain elements which may be wrapped in:
     /// - homogeneous containers (`std::vector`, `std::list`)
-    /// - heterogenous containers `(hpx::tuple`, `std::pair`, `std::array`)
+    /// - heterogeneous containers `(hpx::tuple`, `std::pair`, `std::array`)
     /// and re-assembles the pack with the result of the mapper.
     /// Mapping from one type to a different one is supported.
     ///
@@ -70,7 +70,7 @@ namespace util {
     /// if possible. This can be used to create a mapper function used
     /// in map_pack that maps one element to an arbitrary count (1:n).
     template <typename... T>
-    HPX_CONSTEXPR detail::spreading::spread_box<typename std::decay<T>::type...>
+    constexpr detail::spreading::spread_box<typename std::decay<T>::type...>
     spread_this(T&&... args)
     {
         return detail::spreading::spread_box<typename std::decay<T>::type...>(
diff --git a/hpx/util/query_counters.hpp b/hpx/util/query_counters.hpp
index 414b89089c..78518d351d 100644
--- a/hpx/util/query_counters.hpp
+++ b/hpx/util/query_counters.hpp
@@ -41,7 +41,7 @@ namespace hpx { namespace util
             bool csv_header, bool print_counters_locally);
 
         void start();
-        void stop_evaluating_counters();
+        void stop_evaluating_counters(bool terminate = false);
         bool evaluate();
         void terminate();
 
@@ -70,7 +70,7 @@ namespace hpx { namespace util
 
         template <typename Stream, typename Future>
         void print_values(Stream* output, std::vector<Future> &&,
-            std::vector<std::size_t> && indicies,
+            std::vector<std::size_t> && indices,
             std::vector<performance_counters::counter_info> const& infos);
 
         template <typename Stream>
diff --git a/hpx/util/register_locks_globally.hpp b/hpx/util/register_locks_globally.hpp
index 8cfc829210..d9d5775ec0 100644
--- a/hpx/util/register_locks_globally.hpp
+++ b/hpx/util/register_locks_globally.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2014 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -18,6 +18,7 @@ namespace hpx { namespace util
     HPX_API_EXPORT bool register_lock_globally(void const* lock);
     HPX_API_EXPORT bool unregister_lock_globally(void const* lock);
     HPX_API_EXPORT void enable_global_lock_detection();
+    HPX_API_EXPORT void disable_global_lock_detection();
 #else
     inline bool register_lock_globally(void const*)
     {
@@ -30,6 +31,9 @@ namespace hpx { namespace util
     inline void enable_global_lock_detection()
     {
     }
+    inline void disable_global_lock_detection()
+    {
+    }
 #endif
 
 }}
diff --git a/hpx/util/sed_transform.hpp b/hpx/util/sed_transform.hpp
deleted file mode 100644
index 0ead6a8830..0000000000
--- a/hpx/util/sed_transform.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2011 Bryce Adelstein-Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#if !defined(HPX_EC1602ED_CCC2_471C_BC28_1DBB98902F40)
-#define HPX_EC1602ED_CCC2_471C_BC28_1DBB98902F40
-
-#include <hpx/config.hpp>
-
-#include <memory>
-#include <string>
-
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(push)
-#pragma warning(disable: 4251)
-#endif
-
-namespace hpx { namespace util
-{
-
-/// Parse a sed command.
-///
-/// \param input    [in] The content to parse.
-/// \param search   [out] If the parsing is successful, this string is set to
-///                 the search expression.
-/// \param search   [out] If the parsing is successful, this string is set to
-///                 the replace expression.
-///
-/// \returns \a true if the parsing was successful, false otherwise.
-///
-/// \note Currently, only supports search and replace syntax (s/search/replace/)
-HPX_EXPORT bool parse_sed_expression(
-    std::string const& input
-  , std::string& search
-  , std::string& replace
-    );
-
-/// An unary function object which applies a sed command to its subject and
-/// returns the resulting string.
-///
-/// \note Currently, only supports search and replace syntax (s/search/replace/)
-struct HPX_EXPORT sed_transform
-{
-  private:
-    struct command;
-
-    std::shared_ptr<command> command_;
-
-  public:
-    sed_transform(
-        std::string const& search
-      , std::string const& replace
-        );
-
-    sed_transform(
-        std::string const& expression
-        );
-
-    std::string operator()(
-        std::string const& input
-        ) const;
-
-    explicit operator bool() const noexcept
-    {
-        // avoid compiler warning about conversion to bool
-        return command_.get() ? true : false;
-    }
-
-    bool operator!() const
-    {
-        return !command_.get();
-    }
-};
-
-}}
-
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(pop)
-#endif
-
-#endif // HPX_EC1602ED_CCC2_471C_BC28_1DBB98902F40
-
diff --git a/hpx/util/serializable_any.hpp b/hpx/util/serializable_any.hpp
index 6987d1e312..7917366528 100644
--- a/hpx/util/serializable_any.hpp
+++ b/hpx/util/serializable_any.hpp
@@ -121,7 +121,7 @@ namespace hpx { namespace util {
     {
     public:
         // constructors
-        HPX_CONSTEXPR basic_any() noexcept
+        constexpr basic_any() noexcept
           : table(
                 detail::any::get_table<detail::any::empty>::template get<IArch,
                     OArch, Char, std::true_type>())
@@ -246,6 +246,7 @@ namespace hpx { namespace util {
 
     public:
         // copy assignment operator
+        // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
         basic_any& operator=(basic_any const& x)
         {
             basic_any(x).swap(*this);
@@ -253,6 +254,7 @@ namespace hpx { namespace util {
         }
 
         // move assignment
+        // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
         basic_any& operator=(basic_any&& rhs) noexcept
         {
             rhs.swap(*this);
diff --git a/hpx/util/serialize_exception.hpp b/hpx/util/serialize_exception.hpp
index 688a318039..3804959036 100644
--- a/hpx/util/serialize_exception.hpp
+++ b/hpx/util/serialize_exception.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2012 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -31,15 +31,17 @@ namespace hpx { namespace util
         std_bad_exception = 8,
         std_exception = 9,
 
-        // boost exceptions
-        boost_exception = 10,
-
         // boost::system::system_error
-        boost_system_error = 11,
+        boost_system_error = 10,
 
         // hpx::exception
-        hpx_exception = 12,
-        hpx_thread_interrupted_exception = 13
+        hpx_exception = 11,
+        hpx_thread_interrupted_exception = 12,
+
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
+        // boost exceptions
+        boost_exception = 13
+#endif
     };
 }}  // namespace hpx::util
 
diff --git a/hpx/util/tagged.hpp b/hpx/util/tagged.hpp
index d4fb57b81a..fb5fbf2408 100644
--- a/hpx/util/tagged.hpp
+++ b/hpx/util/tagged.hpp
@@ -13,8 +13,8 @@
 #include <hpx/config.hpp>
 #include <hpx/concepts/concepts.hpp>
 #include <hpx/type_support/decay.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <functional>
@@ -57,7 +57,7 @@ namespace hpx { namespace util
             struct collect_;
 
             template <typename T, std::size_t ...Is, typename ...Tags>
-            struct collect_<T, detail::pack_c<std::size_t, Is...>, Tags...>
+            struct collect_<T, index_pack<Is...>, Tags...>
               : unpack_getter<T, Tags, Is>::type...
             {};
 
@@ -66,7 +66,7 @@ namespace hpx { namespace util
             struct collect
               : collect_<
                     T,
-                    typename detail::make_index_pack<sizeof...(Tags)>::type,
+                    typename util::make_index_pack<sizeof...(Tags)>::type,
                     Tags...
                 >
             {};
@@ -229,7 +229,7 @@ namespace tag                                                                 \
             {                                                                 \
                 return hpx::util::get<I>(static_cast<Derived&>(*this));       \
             }                                                                 \
-            HPX_CONSTEXPR HPX_FORCEINLINE Type const& NAME() const            \
+            constexpr HPX_FORCEINLINE Type const& NAME() const                \
             {                                                                 \
                 return hpx::util::get<I>(static_cast<Derived const&>(*this)); \
             }                                                                 \
diff --git a/hpx/util/tagged_pair.hpp b/hpx/util/tagged_pair.hpp
index 4bccd51fb8..4d8d7924a3 100644
--- a/hpx/util/tagged_pair.hpp
+++ b/hpx/util/tagged_pair.hpp
@@ -52,7 +52,7 @@ namespace hpx { namespace util
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename Tag1, typename Tag2, typename T1, typename T2>
-    HPX_CONSTEXPR HPX_FORCEINLINE
+    constexpr HPX_FORCEINLINE
     tagged_pair<Tag1(typename decay<T1>::type), Tag2(typename decay<T2>::type)>
     make_tagged_pair(std::pair<T1, T2> && p)
     {
@@ -64,7 +64,7 @@ namespace hpx { namespace util
     }
 
     template <typename Tag1, typename Tag2, typename T1, typename T2>
-    HPX_CONSTEXPR HPX_FORCEINLINE
+    constexpr HPX_FORCEINLINE
     tagged_pair<Tag1(typename decay<T1>::type), Tag2(typename decay<T2>::type)>
     make_tagged_pair(std::pair<T1, T2> const& p)
     {
@@ -76,7 +76,7 @@ namespace hpx { namespace util
     }
 
     template <typename Tag1, typename Tag2, typename ... Ts>
-    HPX_CONSTEXPR HPX_FORCEINLINE
+    constexpr HPX_FORCEINLINE
     tagged_pair<
         Tag1(typename tuple_element<0, tuple<Ts...> >::type),
         Tag2(typename tuple_element<1, tuple<Ts...> >::type)
@@ -94,7 +94,7 @@ namespace hpx { namespace util
     }
 
     template <typename Tag1, typename Tag2, typename ... Ts>
-    HPX_CONSTEXPR HPX_FORCEINLINE
+    constexpr HPX_FORCEINLINE
     tagged_pair<
         Tag1(typename tuple_element<0, tuple<Ts...> >::type),
         Tag2(typename tuple_element<1, tuple<Ts...> >::type)
@@ -162,7 +162,7 @@ namespace hpx { namespace util
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename Tag1, typename Tag2, typename T1, typename T2>
-    HPX_CONSTEXPR HPX_FORCEINLINE
+    constexpr HPX_FORCEINLINE
     tagged_pair<Tag1(typename decay<T1>::type), Tag2(typename decay<T2>::type)>
     make_tagged_pair(T1 && t1, T2 && t2)
     {
diff --git a/hpx/util/tagged_tuple.hpp b/hpx/util/tagged_tuple.hpp
index 66ab4e407c..837ca868ad 100644
--- a/hpx/util/tagged_tuple.hpp
+++ b/hpx/util/tagged_tuple.hpp
@@ -51,9 +51,8 @@ namespace hpx { namespace util
         };
     }
 
-#if defined(HPX_HAVE_CXX11_EXPLICIT_VARIADIC_TEMPLATES)
     template <typename ...Tags, typename ...Ts>
-    HPX_CONSTEXPR HPX_FORCEINLINE
+    constexpr HPX_FORCEINLINE
     tagged_tuple<typename detail::tagged_type<Tags, Ts>::type...>
     make_tagged_tuple(Ts && ...ts)
     {
@@ -65,7 +64,7 @@ namespace hpx { namespace util
     }
 
     template <typename ...Tags, typename ...Ts>
-    HPX_CONSTEXPR HPX_FORCEINLINE
+    constexpr HPX_FORCEINLINE
     tagged_tuple<typename detail::tagged_type<Tags, Ts>::type...>
     make_tagged_tuple(tuple<Ts...> && t)
     {
@@ -78,49 +77,6 @@ namespace hpx { namespace util
 
         return result_type(std::move(t));
     }
-#else
-    // workaround for the only direct use in HPX itself
-    template <
-        typename Tag1, typename Tag2, typename Tag3,
-        typename T1, typename T2, typename T3>
-    HPX_CONSTEXPR HPX_FORCEINLINE
-    tagged_tuple<
-        typename detail::tagged_type<Tag1, T1>::type,
-        typename detail::tagged_type<Tag2, T2>::type,
-        typename detail::tagged_type<Tag3, T3>::type
-    >
-    make_tagged_tuple(T1 && t1, T2 && t2, T3 && t3)
-    {
-        typedef tagged_tuple<
-                typename detail::tagged_type<Tag1, T1>::type,
-                typename detail::tagged_type<Tag2, T2>::type,
-                typename detail::tagged_type<Tag3, T3>::type
-            > result_type;
-
-        return result_type(std::forward<T1>(t1), std::forward<T2>(t2),
-            std::forward<T3>(t3));
-    }
-
-    template <
-        typename Tag1, typename Tag2, typename Tag3,
-        typename T1, typename T2, typename T3>
-    HPX_CONSTEXPR HPX_FORCEINLINE
-    tagged_tuple<
-        typename detail::tagged_type<Tag1, T1>::type,
-        typename detail::tagged_type<Tag2, T2>::type,
-        typename detail::tagged_type<Tag3, T3>::type
-    >
-    make_tagged_tuple(tuple<T1, T2, T3> && t)
-    {
-        typedef tagged_tuple<
-                typename detail::tagged_type<Tag1, T1>::type,
-                typename detail::tagged_type<Tag2, T2>::type,
-                typename detail::tagged_type<Tag3, T3>::type
-            > result_type;
-
-        return result_type(std::move(t));
-    }
-#endif
 
     ///////////////////////////////////////////////////////////////////////////
     namespace detail
@@ -132,33 +88,23 @@ namespace hpx { namespace util
             typedef typename hpx::util::identity<Tag(element_type)>::type type;
         };
 
-        template <typename Tuple, typename Indicies, typename ...Tags>
+        template <typename Tuple, typename Indices, typename ...Tags>
         struct tagged_tuple_helper;
 
         template <typename ...Ts, std::size_t ...Is, typename ...Tags>
         struct tagged_tuple_helper<
-            tuple<Ts...>, pack_c<std::size_t, Is...>, Tags...>
+            tuple<Ts...>, index_pack<Is...>, Tags...>
         {
             typedef tagged_tuple<
                 typename tagged_element_type<Tags, Is, tuple<Ts...> >::type...
             > type;
         };
-
-        // workaround for broken MSVC2013
-        template <typename ...Ts>
-        struct pack_size
-        {
-            static const std::size_t value = sizeof...(Ts);
-        };
     }
 
-#if defined(HPX_HAVE_CXX11_EXPLICIT_VARIADIC_TEMPLATES)
     template <typename ...Tags, typename ...Ts>
     hpx::future<typename detail::tagged_tuple_helper<
         tuple<Ts...>,
-        typename detail::make_index_pack<
-            detail::pack_size<Tags...>::value
-        >::type,
+        typename util::make_index_pack<sizeof...(Tags)>::type,
         Tags...
     >::type>
     make_tagged_tuple(hpx::future<tuple<Ts...> > && f)
@@ -168,7 +114,7 @@ namespace hpx { namespace util
 
         typedef typename detail::tagged_tuple_helper<
             tuple<Ts...>,
-            typename detail::make_index_pack<sizeof...(Tags)>::type,
+            typename util::make_index_pack<sizeof...(Tags)>::type,
             Tags...
         >::type result_type;
 
@@ -178,31 +124,6 @@ namespace hpx { namespace util
                 return make_tagged_tuple<Tags...>(std::move(t));
             });
     }
-#else
-    // workaround for the only direct use in HPX itself
-    template <
-        typename Tag1, typename Tag2, typename Tag3,
-        typename T1, typename T2, typename T3>
-    hpx::future<typename detail::tagged_tuple_helper<
-        tuple<T1, T2, T3>,
-        typename detail::make_index_pack<3ul>::type,
-        Tag1, Tag2, Tag3
-    >::type>
-    make_tagged_tuple(hpx::future<tuple<T1, T2, T3> > && f)
-    {
-        typedef typename detail::tagged_tuple_helper<
-            tuple<T1, T2, T3>,
-            typename detail::make_index_pack<3ul>::type,
-            Tag1, Tag2, Tag3
-        >::type result_type;
-
-        return lcos::make_future<result_type>(std::move(f),
-            [](tuple<T1, T2, T3> && t) -> result_type
-            {
-                return make_tagged_tuple<Tag1, Tag2, Tag3>(std::move(t));
-            });
-    }
-#endif
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename ...Ts>
diff --git a/hpx/util/thread_aware_timer.hpp b/hpx/util/thread_aware_timer.hpp
index 6c2eb93527..3c2a5d1b51 100644
--- a/hpx/util/thread_aware_timer.hpp
+++ b/hpx/util/thread_aware_timer.hpp
@@ -50,7 +50,7 @@ namespace hpx { namespace util
 
         std::int64_t elapsed_microseconds() const
         {
-            return std::int64_t((take_time_stamp() - start_time_) * 1e-3);
+            return std::int64_t((take_time_stamp() - start_time_) / 1000);
         }
 
         std::int64_t elapsed_nanoseconds() const
diff --git a/hpx/util/wrapper_heap_base.hpp b/hpx/util/wrapper_heap_base.hpp
index 975cc943ba..6029ab268e 100644
--- a/hpx/util/wrapper_heap_base.hpp
+++ b/hpx/util/wrapper_heap_base.hpp
@@ -8,7 +8,6 @@
 #define HPX_UTIL_WRAPPER_HEAP_BASE_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/util/generate_unique_ids.hpp>
 
diff --git a/hpx/util/yield_while.hpp b/hpx/util/yield_while.hpp
deleted file mode 100644
index 08fa0e90f3..0000000000
--- a/hpx/util/yield_while.hpp
+++ /dev/null
@@ -1,43 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2013 Thomas Heller
-//  Copyright (c) 2008 Peter Dimov
-//  Copyright (c) 2018 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#ifndef HPX_UTIL_DETAIL_YIELD_WHILE_HPP
-#define HPX_UTIL_DETAIL_YIELD_WHILE_HPP
-
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
-
-#include <cstddef>
-
-namespace hpx { namespace util {
-    template <typename Predicate>
-    inline void yield_while(Predicate && predicate,
-        const char *thread_name = nullptr,
-        hpx::threads::thread_state_enum p = hpx::threads::pending_boost,
-        bool allow_timed_suspension = true)
-    {
-        if (allow_timed_suspension)
-        {
-            for (std::size_t k = 0; predicate(); ++k)
-            {
-                detail::yield_k(k, thread_name, p);
-            }
-        }
-        else
-        {
-            for (std::size_t k = 0; predicate(); ++k)
-            {
-                detail::yield_k(k & 31/*k % 32*/, thread_name, p);
-            }
-        }
-    }
-}}
-
-#endif
diff --git a/hpx/util/zip_iterator.hpp b/hpx/util/zip_iterator.hpp
index 987601a7d2..9eb563f8fa 100644
--- a/hpx/util/zip_iterator.hpp
+++ b/hpx/util/zip_iterator.hpp
@@ -61,7 +61,7 @@ namespace hpx { namespace traits {
     template <typename... Ts>
     struct segmented_iterator_traits<util::zip_iterator<Ts...>,
         typename std::enable_if<
-            util::detail::all_of<typename segmented_iterator_traits<
+            util::all_of<typename segmented_iterator_traits<
                 Ts>::is_segmented_iterator...>::value>::type>
     {
         typedef std::true_type is_segmented_iterator;
@@ -151,7 +151,7 @@ namespace hpx { namespace traits {
     template <typename... Ts>
     struct segmented_local_iterator_traits<util::zip_iterator<Ts...>,
         typename std::enable_if<
-            util::detail::all_of<typename segmented_local_iterator_traits<
+            util::all_of<typename segmented_local_iterator_traits<
                 Ts>::is_segmented_local_iterator...>::value>::type>
     {
         typedef std::true_type is_segmented_local_iterator;
diff --git a/libs/CMakeLists.txt b/libs/CMakeLists.txt
index 1bdb6c49cb..b43d188851 100644
--- a/libs/CMakeLists.txt
+++ b/libs/CMakeLists.txt
@@ -14,12 +14,14 @@ set(HPX_LIBS
   affinity
   algorithms
   allocator_support
+  asio
   assertion
   basic_execution
   batch_environments
   cache
   checkpoint
   collectives
+  command_line_handling
   compute
   compute_cuda
   concepts
@@ -35,27 +37,38 @@ set(HPX_LIBS
   functional
   hardware
   hashing
+  io_service
   iterator_support
   local_lcos
   logging
   memory
+  naming_base
+  performance_counters
   plugin
+  prefix
   preprocessor
   program_options
   resiliency
   resource_partitioner
+  runtime_configuration
+  schedulers
   segmented_algorithms
   serialization
   static_reinit
   statistics
+  string_util
   synchronization
   testing
+  threading
+  thread_pools
   thread_support
+  threading_base
   threadmanager
   timing
   topology
   type_support
   util
+  version
   CACHE INTERNAL "list of HPX modules" FORCE
 )
 
diff --git a/libs/README.rst b/libs/README.rst
index b3287aa305..160b4cfd81 100644
--- a/libs/README.rst
+++ b/libs/README.rst
@@ -54,7 +54,7 @@ the library and a link to the generated documentation.
 
 The ``include`` directory should contain only headers that other libraries need.
 Private headers should be placed under the ``src`` directory. This allows for
-clear seperation. The ``cmake`` subdirectory may include additional |cmake|_
+clear separation. The ``cmake`` subdirectory may include additional |cmake|_
 scripts needed to generate the respective build configurations.
 
 Documentation is placed in the ``docs`` folder. A empty skeleton for the index
diff --git a/libs/affinity/CMakeLists.txt b/libs/affinity/CMakeLists.txt
index 719242e405..870f0bfcab 100644
--- a/libs/affinity/CMakeLists.txt
+++ b/libs/affinity/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -42,5 +42,6 @@ add_hpx_module(affinity
     hpx_format
     hpx_topology
     hpx_util
+    hpx::hwloc
   CMAKE_SUBDIRS tests
 )
diff --git a/libs/affinity/README.rst b/libs/affinity/README.rst
index acac1fb742..d83f1c99f9 100644
--- a/libs/affinity/README.rst
+++ b/libs/affinity/README.rst
@@ -13,4 +13,4 @@ affinity
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/affinity/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/affinity/docs/index.html>`__.
diff --git a/libs/affinity/src/affinity_data.cpp b/libs/affinity/src/affinity_data.cpp
index 7f18f5bd13..86e66fcc6f 100644
--- a/libs/affinity/src/affinity_data.cpp
+++ b/libs/affinity/src/affinity_data.cpp
@@ -11,7 +11,6 @@
 #include <hpx/format.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
 
 #include <algorithm>
 #include <atomic>
diff --git a/libs/affinity/src/parse_affinity_options.cpp b/libs/affinity/src/parse_affinity_options.cpp
index f725bd0762..6b3d964bf6 100644
--- a/libs/affinity/src/parse_affinity_options.cpp
+++ b/libs/affinity/src/parse_affinity_options.cpp
@@ -13,8 +13,6 @@
 
 #include <hwloc.h>
 
-#include <boost/variant.hpp>
-
 // #define BOOST_SPIRIT_DEBUG
 #define BOOST_SPIRIT_USE_PHOENIX_V3
 #include <boost/fusion/include/adapt_struct.hpp>
diff --git a/libs/affinity/tests/unit/CMakeLists.txt b/libs/affinity/tests/unit/CMakeLists.txt
index 16f10f3b5f..a1d59d9fb0 100644
--- a/libs/affinity/tests/unit/CMakeLists.txt
+++ b/libs/affinity/tests/unit/CMakeLists.txt
@@ -18,6 +18,7 @@ foreach(test ${tests})
 
   # add example executable
   add_hpx_executable(${test}_test
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${test}_FLAGS}
                      EXCLUDE_FROM_ALL
diff --git a/libs/affinity/tests/unit/parse_affinity_options.cpp b/libs/affinity/tests/unit/parse_affinity_options.cpp
index b8c5854711..d5b0a454a9 100644
--- a/libs/affinity/tests/unit/parse_affinity_options.cpp
+++ b/libs/affinity/tests/unit/parse_affinity_options.cpp
@@ -1127,6 +1127,6 @@ int main(int argc, char* argv[])
     std::vector<std::string> const cfg = {"hpx.os_threads=4"};
 
     // Initialize and run HPX
-    HPX_TEST(0 == hpx::init(argc, argv, cfg));
+    HPX_TEST_EQ(0, hpx::init(argc, argv, cfg));
     return hpx::util::report_errors();
 }
diff --git a/libs/algorithms/CMakeLists.txt b/libs/algorithms/CMakeLists.txt
index 063b9d201e..378538e0d7 100644
--- a/libs/algorithms/CMakeLists.txt
+++ b/libs/algorithms/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(algorithms_headers
   hpx/parallel/algorithm.hpp
diff --git a/libs/algorithms/README.rst b/libs/algorithms/README.rst
index ee2cc7e28d..a8b721398b 100644
--- a/libs/algorithms/README.rst
+++ b/libs/algorithms/README.rst
@@ -12,4 +12,4 @@ algorithms
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/algorithms/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/algorithms/docs/index.html>`__.
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp b/libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp
index 6208ef571c..fa12899228 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp
@@ -13,8 +13,8 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/iterator_support/zip_iterator.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -78,7 +78,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     return result::get(std::move(dest));
                 }
 
-                auto f1 = [HPX_CAPTURE_FORWARD(op)](zip_iterator part_begin,
+                auto f1 = [op = std::forward<Op>(op)](zip_iterator part_begin,
                               std::size_t part_size) mutable {
                     // VS2015RC bails out when op is captured by ref
                     using hpx::util::get;
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/adjacent_find.hpp b/libs/algorithms/include/hpx/parallel/algorithms/adjacent_find.hpp
index f5a8f8bba9..ec28a1160e 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/adjacent_find.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/adjacent_find.hpp
@@ -12,9 +12,9 @@
 #include <hpx/config.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -70,7 +70,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 difference_type count = std::distance(first, last);
                 util::cancellation_token<difference_type> tok(count);
 
-                auto f1 = [HPX_CAPTURE_FORWARD(op), tok](zip_iterator it,
+                auto f1 = [op = std::forward<Pred>(op), tok](zip_iterator it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable {
                     util::loop_idx_n(base_idx, it, part_size, tok,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp b/libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp
index 7bde2dd863..746a93c24b 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp
@@ -14,8 +14,8 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/invoke_projected.hpp>
@@ -65,8 +65,9 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 }
 
                 util::cancellation_token<> tok;
-                auto f1 = [HPX_CAPTURE_FORWARD(op), tok,
-                              HPX_CAPTURE_FORWARD(proj)](FwdIter part_begin,
+                auto f1 = [op = std::forward<F>(op), tok,
+                              proj = std::forward<Proj>(proj)](
+                              FwdIter part_begin,
                               std::size_t part_count) mutable -> bool {
                     util::loop_n<ExPolicy>(part_begin, part_count, tok,
                         [&op, &tok, &proj](FwdIter const& curr) {
@@ -229,8 +230,9 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 }
 
                 util::cancellation_token<> tok;
-                auto f1 = [HPX_CAPTURE_FORWARD(op), tok,
-                              HPX_CAPTURE_FORWARD(proj)](FwdIter part_begin,
+                auto f1 = [op = std::forward<F>(op), tok,
+                              proj = std::forward<Proj>(proj)](
+                              FwdIter part_begin,
                               std::size_t part_count) mutable -> bool {
                     util::loop_n<ExPolicy>(part_begin, part_count, tok,
                         [&op, &tok, &proj](FwdIter const& curr) {
@@ -393,8 +395,9 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 }
 
                 util::cancellation_token<> tok;
-                auto f1 = [HPX_CAPTURE_FORWARD(op), tok,
-                              HPX_CAPTURE_FORWARD(proj)](FwdIter part_begin,
+                auto f1 = [op = std::forward<F>(op), tok,
+                              proj = std::forward<Proj>(proj)](
+                              FwdIter part_begin,
                               std::size_t part_count) mutable -> bool {
                     util::loop_n<ExPolicy>(part_begin, part_count, tok,
                         [&op, &tok, &proj](FwdIter const& curr) {
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/copy.hpp b/libs/algorithms/include/hpx/parallel/algorithms/copy.hpp
index 0bf908370c..4248d627a9 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/copy.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/copy.hpp
@@ -18,11 +18,11 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
 #include <hpx/parallel/algorithms/detail/transfer.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -405,8 +405,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     std::pair<FwdIter1, FwdIter2>, std::size_t>
                     scan_partitioner_type;
 
-                auto f1 = [HPX_CAPTURE_FORWARD(pred),
-                              HPX_CAPTURE_FORWARD(proj)](
+                auto f1 = [pred = std::forward<Pred>(pred),
+                              proj = std::forward<decltype(proj)>(proj)](
                               zip_iterator part_begin,
                               std::size_t part_size) -> std::size_t {
                     std::size_t curr = 0;
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/count.hpp b/libs/algorithms/include/hpx/parallel/algorithms/count.hpp
index 3aebffa28a..6c3aaebd7b 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/count.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/count.hpp
@@ -16,11 +16,11 @@
 #include <hpx/traits/segmented_iterator_traits.hpp>
 #include <hpx/util/unwrap.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_count_bits.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/distance.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/traits/projected.hpp>
-#include <hpx/parallel/traits/vector_pack_count_bits.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/invoke_projected.hpp>
 #include <hpx/parallel/util/loop.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp b/libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp
index 6ae1b19a4a..2e7865e978 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp
@@ -13,9 +13,9 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/foreach_partitioner.hpp>
 #include <hpx/parallel/util/loop.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/detail/dispatch.hpp b/libs/algorithms/include/hpx/parallel/algorithms/detail/dispatch.hpp
index 20423998a8..d4fe877595 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/detail/dispatch.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/detail/dispatch.hpp
@@ -15,9 +15,9 @@
 #include <hpx/type_support/decay.hpp>
 
 #include <hpx/datastructures/tuple.hpp>
-#include <hpx/parallel/exception_list.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
+#include <hpx/execution/exception_list.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/scoped_executor_parameters.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/detail/distance.hpp b/libs/algorithms/include/hpx/parallel/algorithms/detail/distance.hpp
index ebf01fb505..e31aba27d2 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/detail/distance.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/detail/distance.hpp
@@ -14,9 +14,8 @@
 namespace hpx { namespace parallel { inline namespace v1 { namespace detail {
     // provide implementation of std::distance supporting iterators/sentinels
     template <typename InIterB, typename InIterE>
-    HPX_CXX14_CONSTEXPR inline
-        typename std::iterator_traits<InIterB>::difference_type
-        distance(InIterB first, InIterE last, std::input_iterator_tag)
+    constexpr inline typename std::iterator_traits<InIterB>::difference_type
+    distance(InIterB first, InIterE last, std::input_iterator_tag)
     {
         typename std::iterator_traits<InIterB>::difference_type offset = 0;
         for (/**/; first != last; ++first)
@@ -27,15 +26,14 @@ namespace hpx { namespace parallel { inline namespace v1 { namespace detail {
     }
 
     template <typename RanIterB, typename RanIterE>
-    HPX_CONSTEXPR inline
-        typename std::iterator_traits<RanIterB>::difference_type
-        distance(RanIterB first, RanIterE last, std::random_access_iterator_tag)
+    constexpr inline typename std::iterator_traits<RanIterB>::difference_type
+    distance(RanIterB first, RanIterE last, std::random_access_iterator_tag)
     {
         return last - first;
     }
 
     template <typename InIterB, typename InIterE>
-    HPX_CONSTEXPR inline typename std::iterator_traits<InIterB>::difference_type
+    constexpr inline typename std::iterator_traits<InIterB>::difference_type
     distance(InIterB first, InIterE last)
     {
         return distance(first, last,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/detail/set_operation.hpp b/libs/algorithms/include/hpx/parallel/algorithms/detail/set_operation.hpp
index d04f4dc11e..83e5e6422d 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/detail/set_operation.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/detail/set_operation.hpp
@@ -10,8 +10,8 @@
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
 
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution_information.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/foreach_partitioner.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/detail/transfer.hpp b/libs/algorithms/include/hpx/parallel/algorithms/detail/transfer.hpp
index 9231e0fda7..2d7379ed88 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/detail/transfer.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/detail/transfer.hpp
@@ -109,7 +109,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
         //           returns \a FwdIter2 otherwise.
         //           The \a move algorithm returns the output iterator to the
         //           element in the destination range, one past the last element
-        //           transfered.
+        //           transferred.
         //
         template <typename Algo, typename ExPolicy, typename FwdIter1,
             typename FwdIter2,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/equal.hpp b/libs/algorithms/include/hpx/parallel/algorithms/equal.hpp
index 17b783f7a1..5f4f9f91f4 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/equal.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/equal.hpp
@@ -13,9 +13,9 @@
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -91,7 +91,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 difference_type1 count1 = std::distance(first1, last1);
 
-                // The specifcation of std::equal(_binary) states that if FwdIter1
+                // The specification of std::equal(_binary) states that if FwdIter1
                 // and FwdIter2 meet the requirements of RandomAccessIterator and
                 // last1 - first1 != last2 - first2 then no applications of the
                 // predicate p are made.
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp b/libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp
index 14c1fa69b3..0a18dc9094 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp
@@ -16,9 +16,9 @@
 #include <hpx/iterator_support/zip_iterator.hpp>
 #include <hpx/util/unwrap.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/inclusive_scan.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -145,7 +145,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     std::forward<ExPolicy>(policy),
                     make_zip_iterator(first, dest), count, init,
                     // step 1 performs first part of scan algorithm
-                    [op, HPX_CAPTURE_FORWARD(conv), last](
+                    [op, conv = std::forward<Conv>(conv), last](
                         zip_iterator part_begin, std::size_t part_size) -> T {
                         T part_init =
                             hpx::util::invoke(conv, get<0>(*part_begin++));
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/fill.hpp b/libs/algorithms/include/hpx/parallel/algorithms/fill.hpp
index 8520e57be4..282632e070 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/fill.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/fill.hpp
@@ -15,10 +15,10 @@
 #include <hpx/traits/is_value_proxy.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/projection_identity.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/find.hpp b/libs/algorithms/include/hpx/parallel/algorithms/find.hpp
index df15df016b..0fdcffcaef 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/find.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/find.hpp
@@ -14,9 +14,9 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/compare_projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -210,7 +210,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 util::cancellation_token<std::size_t> tok(count);
 
-                auto f1 = [HPX_CAPTURE_FORWARD(f), tok](FwdIter it,
+                auto f1 = [f = std::forward<F>(f), tok](FwdIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     util::loop_idx_n(base_idx, it, part_size, tok,
@@ -372,7 +372,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 util::cancellation_token<std::size_t> tok(count);
 
-                auto f1 = [HPX_CAPTURE_FORWARD(f), tok](FwdIter it,
+                auto f1 = [f = std::forward<F>(f), tok](FwdIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     util::loop_idx_n(base_idx, it, part_size, tok,
@@ -542,8 +542,9 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     std::greater<difference_type>>
                     tok(-1);
 
-                auto f1 = [count, diff, tok, first2, HPX_CAPTURE_FORWARD(op),
-                              HPX_CAPTURE_FORWARD(proj)](FwdIter it,
+                auto f1 = [count, diff, tok, first2,
+                              op = std::forward<Pred>(op),
+                              proj = std::forward<Proj>(proj)](FwdIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     FwdIter curr = it;
@@ -769,9 +770,9 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 util::cancellation_token<difference_type> tok(count);
 
-                auto f1 = [s_first, s_last, tok, HPX_CAPTURE_FORWARD(op),
-                              HPX_CAPTURE_FORWARD(proj1),
-                              HPX_CAPTURE_FORWARD(proj2)](FwdIter it,
+                auto f1 = [s_first, s_last, tok, op = std::forward<Pred>(op),
+                              proj1 = std::forward<Proj1>(proj1),
+                              proj2 = std::forward<Proj2>(proj2)](FwdIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     util::loop_idx_n(base_idx, it, part_size, tok,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp b/libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp
index 39a9d96e24..065194529f 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp
@@ -18,14 +18,14 @@
 #endif
 #include <hpx/functional/traits/is_callable.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 #include <hpx/traits/is_value_proxy.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 #include <hpx/type_support/identity.hpp>
-#include <hpx/util/annotated_function.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/foreach_partitioner.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/for_loop.hpp b/libs/algorithms/include/hpx/parallel/algorithms/for_loop.hpp
index 5de432d52e..9ff4ba4c56 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/for_loop.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/for_loop.hpp
@@ -17,19 +17,19 @@
 #include <hpx/functional/traits/get_function_annotation.hpp>
 #endif
 #include <hpx/assertion.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/type_support/unused.hpp>
-#include <hpx/util/annotated_function.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
 #include <hpx/parallel/algorithms/for_loop_induction.hpp>
 #include <hpx/parallel/algorithms/for_loop_reduction.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -50,8 +50,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
         ///////////////////////////////////////////////////////////////////////
         template <typename... Ts, std::size_t... Is>
         HPX_HOST_DEVICE HPX_FORCEINLINE void init_iteration(
-            hpx::util::tuple<Ts...>& args,
-            hpx::util::detail::pack_c<std::size_t, Is...>,
+            hpx::util::tuple<Ts...>& args, hpx::util::index_pack<Is...>,
             std::size_t part_index)
         {
             int const _sequencer[] = {
@@ -61,8 +60,8 @@ namespace hpx { namespace parallel { inline namespace v2 {
 
         template <typename... Ts, std::size_t... Is, typename F, typename B>
         HPX_HOST_DEVICE HPX_FORCEINLINE void invoke_iteration(
-            hpx::util::tuple<Ts...>& args,
-            hpx::util::detail::pack_c<std::size_t, Is...>, F&& f, B part_begin)
+            hpx::util::tuple<Ts...>& args, hpx::util::index_pack<Is...>, F&& f,
+            B part_begin)
         {
             hpx::util::invoke(std::forward<F>(f), part_begin,
                 hpx::util::get<Is>(args).iteration_value()...);
@@ -70,8 +69,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
 
         template <typename... Ts, std::size_t... Is>
         HPX_HOST_DEVICE HPX_FORCEINLINE void next_iteration(
-            hpx::util::tuple<Ts...>& args,
-            hpx::util::detail::pack_c<std::size_t, Is...>,
+            hpx::util::tuple<Ts...>& args, hpx::util::index_pack<Is...>,
             std::size_t part_index)
         {
             int const _sequencer[] = {
@@ -81,8 +79,8 @@ namespace hpx { namespace parallel { inline namespace v2 {
 
         template <typename... Ts, std::size_t... Is>
         HPX_HOST_DEVICE HPX_FORCEINLINE void exit_iteration(
-            hpx::util::tuple<Ts...>& args,
-            hpx::util::detail::pack_c<std::size_t, Is...>, std::size_t size)
+            hpx::util::tuple<Ts...>& args, hpx::util::index_pack<Is...>,
+            std::size_t size)
         {
             int const _sequencer[] = {
                 0, (hpx::util::get<Is>(args).exit_iteration(size), 0)...};
@@ -115,8 +113,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
                 B part_begin, std::size_t part_steps, std::size_t part_index)
             {
                 auto pack =
-                    typename hpx::util::detail::make_index_pack<sizeof...(
-                        Ts)>::type();
+                    typename hpx::util::make_index_pack<sizeof...(Ts)>::type();
                 detail::init_iteration(args_, pack, part_index);
 
                 while (part_steps != 0)
@@ -213,8 +210,9 @@ namespace hpx { namespace parallel { inline namespace v2 {
                     part_iterations<F, S, args_type>{
                         std::forward<F>(f), stride, args},
                     [=](std::vector<hpx::future<void>>&&) mutable -> void {
-                        auto pack = typename hpx::util::detail::make_index_pack<
-                            sizeof...(Ts)>::type();
+                        auto pack =
+                            typename hpx::util::make_index_pack<sizeof...(
+                                Ts)>::type();
                         // make sure live-out variables are properly set on
                         // return
                         detail::exit_iteration(args, pack, size);
@@ -227,7 +225,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
             std::size_t... Is, typename... Args>
         typename util::detail::algorithm_result<ExPolicy>::type for_loop(
             ExPolicy&& policy, B first, E last, S stride,
-            hpx::util::detail::pack_c<std::size_t, Is...>, Args&&... args)
+            hpx::util::index_pack<Is...>, Args&&... args)
         {
             // stride shall not be zero
             HPX_ASSERT(stride != 0);
@@ -264,7 +262,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
             std::size_t... Is, typename... Args>
         typename util::detail::algorithm_result<ExPolicy>::type for_loop_n(
             ExPolicy&& policy, B first, Size size, S stride,
-            hpx::util::detail::pack_c<std::size_t, Is...>, Args&&... args)
+            hpx::util::index_pack<Is...>, Args&&... args)
         {
             // Size should be non-negative
             HPX_ASSERT(size >= 0);
@@ -393,7 +391,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
         static_assert(sizeof...(Args) >= 1,
             "for_loop must be called with at least a function object");
 
-        using hpx::util::detail::make_index_pack;
+        using hpx::util::make_index_pack;
         return detail::for_loop(std::forward<ExPolicy>(policy), first, last, 1,
             typename make_index_pack<sizeof...(Args) - 1>::type(),
             std::forward<Args>(args)...);
@@ -592,7 +590,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
         static_assert(sizeof...(Args) >= 1,
             "for_loop_strided must be called with at least a function object");
 
-        using hpx::util::detail::make_index_pack;
+        using hpx::util::make_index_pack;
         return detail::for_loop(std::forward<ExPolicy>(policy), first, last,
             stride, typename make_index_pack<sizeof...(Args) - 1>::type(),
             std::forward<Args>(args)...);
@@ -794,7 +792,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
         static_assert(sizeof...(Args) >= 1,
             "for_loop_n must be called with at least a function object");
 
-        using hpx::util::detail::make_index_pack;
+        using hpx::util::make_index_pack;
         return detail::for_loop_n(std::forward<ExPolicy>(policy), first, size,
             1, typename make_index_pack<sizeof...(Args) - 1>::type(),
             std::forward<Args>(args)...);
@@ -999,7 +997,7 @@ namespace hpx { namespace parallel { inline namespace v2 {
             "for_loop_n_strided must be called with at least a function "
             "object");
 
-        using hpx::util::detail::make_index_pack;
+        using hpx::util::make_index_pack;
         return detail::for_loop_n(std::forward<ExPolicy>(policy), first, size,
             stride, typename make_index_pack<sizeof...(Args) - 1>::type(),
             std::forward<Args>(args)...);
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/for_loop_induction.hpp b/libs/algorithms/include/hpx/parallel/algorithms/for_loop_induction.hpp
index 430ca9a276..4a0ff20deb 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/for_loop_induction.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/for_loop_induction.hpp
@@ -12,7 +12,7 @@
 #include <hpx/config.hpp>
 #include <hpx/type_support/decay.hpp>
 
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
 
 #include <cstddef>
 #include <cstdlib>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/for_loop_reduction.hpp b/libs/algorithms/include/hpx/parallel/algorithms/for_loop_reduction.hpp
index 2c9059604a..6b35709775 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/for_loop_reduction.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/for_loop_reduction.hpp
@@ -16,7 +16,7 @@
 #include <hpx/runtime/get_worker_thread_num.hpp>
 #include <hpx/type_support/decay.hpp>
 
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
 
 #include <boost/shared_array.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/generate.hpp b/libs/algorithms/include/hpx/parallel/algorithms/generate.hpp
index c80b543cba..8863e3e9d1 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/generate.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/generate.hpp
@@ -15,10 +15,10 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/projection_identity.hpp>
 
@@ -58,7 +58,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return for_each_n<FwdIter>().call(
                     std::forward<ExPolicy>(policy), std::false_type(), first,
                     std::distance(first, last),
-                    [HPX_CAPTURE_FORWARD(f)](type& v) mutable { v = f(); },
+                    [f = std::forward<F>(f)](type& v) mutable { v = f(); },
                     util::projection_identity());
             }
         };
@@ -184,7 +184,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return for_each_n<FwdIter>().call(
                     std::forward<ExPolicy>(policy), std::false_type(), first,
                     count,
-                    [HPX_CAPTURE_FORWARD(f)](type& v) mutable { v = f(); },
+                    [f = std::forward<F>(f)](type& v) mutable { v = f(); },
                     util::projection_identity());
             }
         };
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/includes.hpp b/libs/algorithms/include/hpx/parallel/algorithms/includes.hpp
index e5cada6c3d..1971f82c48 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/includes.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/includes.hpp
@@ -13,9 +13,9 @@
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/cancellation_token.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -153,7 +153,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return util::partitioner<ExPolicy, bool>::call(
                     std::forward<ExPolicy>(policy), first2,
                     std::distance(first2, last2),
-                    [first1, last1, first2, last2, tok, HPX_CAPTURE_FORWARD(f)](
+                    [first1, last1, first2, last2, tok, f = std::forward<F>(f)](
                         FwdIter2 part_begin,
                         std::size_t part_count) mutable -> bool {
                         FwdIter2 part_end =
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp b/libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp
index 9d78c06500..32a3e2185d 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp
@@ -16,8 +16,8 @@
 #include <hpx/iterator_support/zip_iterator.hpp>
 #include <hpx/util/unwrap.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -141,7 +141,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     std::forward<ExPolicy>(policy),
                     make_zip_iterator(first, dest), count, init,
                     // step 1 performs first part of scan algorithm
-                    [op, last, HPX_CAPTURE_FORWARD(conv)](
+                    [op, last, conv = std::forward<Conv>(conv)](
                         zip_iterator part_begin, std::size_t part_size) -> T {
                         T part_init =
                             hpx::util::invoke(conv, get<0>(*part_begin));
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp b/libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp
index eb2ab34b39..c35703530c 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp
@@ -15,9 +15,9 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/lcos/future.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
@@ -80,8 +80,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 --count;
                 util::cancellation_token<std::size_t> tok(count);
 
-                auto f1 = [tok, first, HPX_CAPTURE_FORWARD(comp),
-                              HPX_CAPTURE_FORWARD(proj)](RandIter it,
+                auto f1 = [tok, first, comp = std::forward<Comp>(comp),
+                              proj = std::forward<Proj>(proj)](RandIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     util::loop_idx_n(base_idx, it, part_size, tok,
@@ -265,8 +265,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 --count;
                 util::cancellation_token<std::size_t> tok(count);
 
-                auto f1 = [tok, first, HPX_CAPTURE_FORWARD(comp),
-                              HPX_CAPTURE_FORWARD(proj)](RandIter it,
+                auto f1 = [tok, first, comp = std::forward<Comp>(comp),
+                              proj = std::forward<Proj>(proj)](RandIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable {
                     util::loop_idx_n(base_idx, it, part_size, tok,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/is_partitioned.hpp b/libs/algorithms/include/hpx/parallel/algorithms/is_partitioned.hpp
index 3300108bfd..2fb4c022b1 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/is_partitioned.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/is_partitioned.hpp
@@ -16,8 +16,8 @@
 #include <hpx/lcos/future.hpp>
 #include <hpx/type_support/unused.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/cancellation_token.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
@@ -89,7 +89,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     return result::get(true);
 
                 util::cancellation_token<> tok;
-                auto f1 = [tok, HPX_CAPTURE_FORWARD(pred)](Iter part_begin,
+                auto f1 = [tok, pred = std::forward<Pred>(pred)](
+                              Iter part_begin,
                               std::size_t part_count) mutable -> bool {
                     bool fst_bool = hpx::util::invoke(pred, *part_begin);
                     if (part_count == 1)
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp b/libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp
index 4bc7e78f8b..dd8f956410 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp
@@ -14,8 +14,8 @@
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/cancellation_token.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
@@ -65,7 +65,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     return result::get(true);
 
                 util::cancellation_token<> tok;
-                auto f1 = [tok, last, HPX_CAPTURE_FORWARD(pred)](
+                auto f1 = [tok, last, pred = std::forward<Pred>(pred)](
                               FwdIter part_begin,
                               std::size_t part_size) mutable -> bool {
                     FwdIter trail = part_begin++;
@@ -217,7 +217,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     return result::get(std::move(last));
 
                 util::cancellation_token<difference_type> tok(count);
-                auto f1 = [tok, last, HPX_CAPTURE_FORWARD(pred)](
+                auto f1 = [tok, last, pred = std::forward<Pred>(pred)](
                               FwdIter part_begin, std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     FwdIter trail = part_begin++;
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/lexicographical_compare.hpp b/libs/algorithms/include/hpx/parallel/algorithms/lexicographical_compare.hpp
index 7aebe5ada7..dc8b6a6f3e 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/lexicographical_compare.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/lexicographical_compare.hpp
@@ -14,11 +14,11 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
 #include <hpx/parallel/algorithms/mismatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/merge.hpp b/libs/algorithms/include/hpx/parallel/algorithms/merge.hpp
index 29e94e5d02..adfa9f58c4 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/merge.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/merge.hpp
@@ -14,11 +14,11 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/util/tagged_tuple.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
 #include <hpx/parallel/algorithms/detail/transfer.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/compare_projected.hpp>
@@ -621,8 +621,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
             Proj&& proj)
         {
             return execution::async_execute(policy.executor(),
-                [policy, first, middle, last, HPX_CAPTURE_FORWARD(comp),
-                    HPX_CAPTURE_FORWARD(proj)]() mutable -> RandIter {
+                [policy, first, middle, last, comp = std::forward<Comp>(comp),
+                    proj = std::forward<Proj>(proj)]() mutable -> RandIter {
                     try
                     {
                         parallel_inplace_merge_helper(policy, first, middle,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp b/libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp
index 78f14c54c1..fb7869c2de 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp
@@ -19,8 +19,8 @@
 #include <hpx/traits/segmented_iterator_traits.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/compare_projected.hpp>
@@ -127,8 +127,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     return sequential_min_element(
                         policy, it, part_count, f, proj);
                 };
-                auto f2 = [policy, HPX_CAPTURE_FORWARD(f),
-                              HPX_CAPTURE_FORWARD(proj)](
+                auto f2 = [policy, f = std::forward<F>(f),
+                              proj = std::forward<Proj>(proj)](
                               std::vector<FwdIter>&& positions) -> FwdIter {
                     return min_element::sequential_minmax_element_ind(
                         policy, positions.begin(), positions.size(), f, proj);
@@ -344,8 +344,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     return sequential_max_element(
                         policy, it, part_count, f, proj);
                 };
-                auto f2 = [policy, HPX_CAPTURE_FORWARD(f),
-                              HPX_CAPTURE_FORWARD(proj)](
+                auto f2 = [policy, f = std::forward<F>(f),
+                              proj = std::forward<Proj>(proj)](
                               std::vector<FwdIter>&& positions) -> FwdIter {
                     return max_element::sequential_minmax_element_ind(
                         policy, positions.begin(), positions.size(), f, proj);
@@ -582,7 +582,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                         policy, it, part_count, f, proj);
                 };
                 auto f2 =
-                    [policy, HPX_CAPTURE_FORWARD(f), HPX_CAPTURE_FORWARD(proj)](
+                    [policy, f = std::forward<F>(f),
+                        proj = std::forward<Proj>(proj)](
                         std::vector<result_type>&& positions) -> result_type {
                     return minmax_element::sequential_minmax_element_ind(
                         policy, positions.begin(), positions.size(), f, proj);
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp b/libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp
index 9692efe3a1..22830b4748 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp
@@ -13,9 +13,9 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -78,7 +78,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     difference_type1;
                 difference_type1 count1 = std::distance(first1, last1);
 
-                // The specifcation of std::mismatch(_binary) states that if FwdIter1
+                // The specification of std::mismatch(_binary) states that if FwdIter1
                 // and FwdIter2 meet the requirements of RandomAccessIterator and
                 // last1 - first1 != last2 - first2 then no applications of the
                 // predicate p are made.
@@ -100,7 +100,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 util::cancellation_token<std::size_t> tok(count1);
 
-                auto f1 = [tok, HPX_CAPTURE_FORWARD(f)](zip_iterator it,
+                auto f1 = [tok, f = std::forward<F>(f)](zip_iterator it,
                               std::size_t part_count,
                               std::size_t base_idx) mutable -> void {
                     util::loop_idx_n(base_idx, it, part_count, tok,
@@ -278,7 +278,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 util::cancellation_token<std::size_t> tok(count);
 
-                auto f1 = [tok, HPX_CAPTURE_FORWARD(f)](zip_iterator it,
+                auto f1 = [tok, f = std::forward<F>(f)](zip_iterator it,
                               std::size_t part_count,
                               std::size_t base_idx) mutable -> void {
                     util::loop_idx_n(base_idx, it, part_count, tok,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/move.hpp b/libs/algorithms/include/hpx/parallel/algorithms/move.hpp
index 0206511d75..7ed06f39d4 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/move.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/move.hpp
@@ -13,9 +13,9 @@
 #include <hpx/config.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/transfer.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/foreach_partitioner.hpp>
 #include <hpx/parallel/util/transfer.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/partition.hpp b/libs/algorithms/include/hpx/parallel/algorithms/partition.hpp
index c63338649c..be4f68503d 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/partition.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/partition.hpp
@@ -21,12 +21,12 @@
 #include <hpx/type_support/unused.hpp>
 #include <hpx/util/tagged_tuple.hpp>
 
+#include <hpx/execution/exception_list.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/exception_list.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_information.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -66,8 +66,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 if (chunks < 2)
                 {
                     return execution::async_execute(policy.executor(),
-                        [first, last, HPX_CAPTURE_FORWARD(f),
-                            HPX_CAPTURE_FORWARD(proj)]() -> RandIter {
+                        [first, last, f = std::forward<F>(f),
+                            proj = std::forward<Proj>(proj)]() -> RandIter {
                             return std::stable_partition(first, last,
                                 util::invoke_projected<F, Proj>(f, proj));
                         });
@@ -177,7 +177,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                         std::size_t chunk_size = execution::get_chunk_size(
                             policy.parameters(), policy.executor(),
-                            [] { return 0; }, cores, size);
+                            [](std::size_t) { return 0; }, cores, size);
 
                         std::size_t max_chunks =
                             execution::maximal_number_of_chunks(
@@ -568,7 +568,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 hpx::lcos::local::spinlock mutex_;
             };
 
-            // std::swap_ranges doens't support overlapped ranges in standard.
+            // std::swap_ranges doesn't support overlapped ranges in standard.
             // But, actually general implementations of std::swap_ranges are useful
             //     in specific cases.
             // The problem is that standard doesn't guarantee that implementation.
@@ -1154,8 +1154,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     hpx::util::tuple<FwdIter1, FwdIter2, FwdIter3>,
                     output_iterator_offset>;
 
-                auto f1 = [HPX_CAPTURE_FORWARD(pred),
-                              HPX_CAPTURE_FORWARD(proj)](
+                auto f1 = [pred = std::forward<Pred>(pred),
+                              proj = std::forward<Proj>(proj)](
                               zip_iterator part_begin,
                               std::size_t part_size) -> output_iterator_offset {
                     std::size_t true_count = 0;
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp b/libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp
index c316ed515b..38ba0bb26f 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp
@@ -14,10 +14,10 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/util/unwrap.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/accumulate.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/distance.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -73,12 +73,12 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return util::partitioner<ExPolicy, T>::call(
                     std::forward<ExPolicy>(policy), first,
                     detail::distance(first, last), std::move(f1),
-                    hpx::util::unwrapping(
-                        [HPX_CAPTURE_FORWARD(init), HPX_CAPTURE_FORWARD(r)](
-                            std::vector<T>&& results) -> T {
-                            return util::accumulate_n(hpx::util::begin(results),
-                                hpx::util::size(results), init, r);
-                        }));
+                    hpx::util::unwrapping([init = std::forward<T_>(init),
+                                              r = std::forward<Reduce>(r)](
+                                              std::vector<T>&& results) -> T {
+                        return util::accumulate_n(hpx::util::begin(results),
+                            hpx::util::size(results), init, r);
+                    }));
             }
         };
         /// \endcond
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/reduce_by_key.hpp b/libs/algorithms/include/hpx/parallel/algorithms/reduce_by_key.hpp
index 704006ddc4..139bccfe92 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/reduce_by_key.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/reduce_by_key.hpp
@@ -10,7 +10,7 @@
 #define HPX_PARALLEL_ALGORITHM_REDUCE_BY_KEY_DEC_2015
 //
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/execution.hpp>
+#include <hpx/execution/executors/execution.hpp>
 //
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/iterator_support/range.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/remove.hpp b/libs/algorithms/include/hpx/parallel/algorithms/remove.hpp
index 4586976bcf..40fd4de120 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/remove.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/remove.hpp
@@ -16,11 +16,11 @@
 #include <hpx/type_support/unused.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
 #include <hpx/parallel/algorithms/detail/transfer.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -101,8 +101,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     void, util::scan_partitioner_sequential_f3_tag>
                     scan_partitioner_type;
 
-                auto f1 = [HPX_CAPTURE_FORWARD(pred),
-                              HPX_CAPTURE_FORWARD(proj)](
+                auto f1 = [pred = std::forward<Pred>(pred),
+                              proj = std::forward<Proj>(proj)](
                               zip_iterator part_begin,
                               std::size_t part_size) -> std::size_t {
                     // MSVC complains if pred or proj is captured by ref below
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp b/libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp
index 82ead60533..8878f12658 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp
@@ -15,9 +15,9 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/copy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/projection_identity.hpp>
@@ -228,7 +228,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return copy_if<IterPair>().call(
                     std::forward<ExPolicy>(policy), std::false_type(), first,
                     last, dest,
-                    [HPX_CAPTURE_FORWARD(f)](value_type const& a) -> bool {
+                    [f = std::forward<F>(f)](value_type const& a) -> bool {
                         return !hpx::util::invoke(f, a);
                     },
                     std::forward<Proj>(proj));
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/replace.hpp b/libs/algorithms/include/hpx/parallel/algorithms/replace.hpp
index 553c9f6c42..1b44807e61 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/replace.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/replace.hpp
@@ -16,9 +16,9 @@
 #include <hpx/type_support/unused.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -80,7 +80,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return for_each_n<FwdIter>().call(
                     std::forward<ExPolicy>(policy), std::false_type(), first,
                     std::distance(first, last),
-                    [old_value, new_value, HPX_CAPTURE_FORWARD(proj)](
+                    [old_value, new_value, proj = std::forward<Proj>(proj)](
                         type& t) -> void {
                         if (hpx::util::invoke(proj, t) == old_value)
                         {
@@ -216,8 +216,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return for_each_n<FwdIter>().call(
                     std::forward<ExPolicy>(policy), std::false_type(), first,
                     std::distance(first, last),
-                    [new_value, HPX_CAPTURE_FORWARD(f),
-                        HPX_CAPTURE_FORWARD(proj)](type& t) -> void {
+                    [new_value, f = std::forward<F>(f),
+                        proj = std::forward<Proj>(proj)](type& t) -> void {
                         using hpx::util::invoke;
                         if (invoke(f, invoke(proj, t)))
                             t = new_value;
@@ -375,7 +375,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     std::forward<ExPolicy>(policy), std::false_type(),
                     hpx::util::make_zip_iterator(first, dest),
                     std::distance(first, last),
-                    [old_value, new_value, HPX_CAPTURE_FORWARD(proj)](
+                    [old_value, new_value, proj = std::forward<Proj>(proj)](
                         reference t) -> void {
                         using hpx::util::get;
                         if (hpx::util::invoke(proj, get<0>(t)) == old_value)
@@ -538,8 +538,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     std::forward<ExPolicy>(policy), std::false_type(),
                     hpx::util::make_zip_iterator(first, dest),
                     std::distance(first, last),
-                    [new_value, HPX_CAPTURE_FORWARD(f),
-                        HPX_CAPTURE_FORWARD(proj)](reference t) -> void {
+                    [new_value, f = std::forward<F>(f),
+                        proj = std::forward<Proj>(proj)](reference t) -> void {
                         using hpx::util::get;
                         using hpx::util::invoke;
                         if (invoke(f, invoke(proj, get<0>(t))))
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp b/libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp
index 7df9d9adac..19832ec843 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp
@@ -14,10 +14,10 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/copy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/projection_identity.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp b/libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp
index 0519cdb72a..fd3f763c16 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp
@@ -16,10 +16,10 @@
 #include <hpx/util/tagged_pair.hpp>
 #include <hpx/util/unwrap.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/copy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/reverse.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/transfer.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/search.hpp b/libs/algorithms/include/hpx/parallel/algorithms/search.hpp
index e0eb15c06f..71467b654e 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/search.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/search.hpp
@@ -12,10 +12,10 @@
 #include <hpx/config.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/compare_projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/zip_iterator.hpp>
@@ -86,17 +86,19 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 util::cancellation_token<difference_type> tok(count);
 
-                auto f1 = [diff, count, tok, s_first, HPX_CAPTURE_FORWARD(op),
-                              HPX_CAPTURE_FORWARD(proj1),
-                              HPX_CAPTURE_FORWARD(proj2)](FwdIter it,
+                auto f1 = [diff, count, tok, s_first,
+                              op = std::forward<Pred>(op),
+                              proj1 = std::forward<Proj1>(proj1),
+                              proj2 = std::forward<Proj2>(proj2)](FwdIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     FwdIter curr = it;
 
                     util::loop_idx_n(base_idx, it, part_size, tok,
                         [diff, count, s_first, &tok, &curr,
-                            HPX_CAPTURE_FORWARD(op), HPX_CAPTURE_FORWARD(proj1),
-                            HPX_CAPTURE_FORWARD(proj2)](
+                            op = std::forward<Pred>(op),
+                            proj1 = std::forward<Proj1>(proj1),
+                            proj2 = std::forward<Proj2>(proj2)](
                             reference v, std::size_t i) -> void {
                             ++curr;
                             if (hpx::util::invoke(op,
@@ -305,17 +307,19 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 util::cancellation_token<difference_type> tok(count);
 
-                auto f1 = [count, diff, tok, s_first, HPX_CAPTURE_FORWARD(op),
-                              HPX_CAPTURE_FORWARD(proj1),
-                              HPX_CAPTURE_FORWARD(proj2)](FwdIter it,
+                auto f1 = [count, diff, tok, s_first,
+                              op = std::forward<Pred>(op),
+                              proj1 = std::forward<Proj1>(proj1),
+                              proj2 = std::forward<Proj2>(proj2)](FwdIter it,
                               std::size_t part_size,
                               std::size_t base_idx) mutable -> void {
                     FwdIter curr = it;
 
                     util::loop_idx_n(base_idx, it, part_size, tok,
                         [count, diff, s_first, &tok, &curr,
-                            HPX_CAPTURE_FORWARD(op), HPX_CAPTURE_FORWARD(proj1),
-                            HPX_CAPTURE_FORWARD(proj2)](
+                            op = std::forward<Pred>(op),
+                            proj1 = std::forward<Proj1>(proj1),
+                            proj2 = std::forward<Proj2>(proj2)](
                             reference v, std::size_t i) -> void {
                             ++curr;
                             if (hpx::util::invoke(op,
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/set_difference.hpp b/libs/algorithms/include/hpx/parallel/algorithms/set_difference.hpp
index de708fc8b2..b06ece6079 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/set_difference.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/set_difference.hpp
@@ -13,10 +13,10 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/decay.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/copy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/set_operation.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/set_intersection.hpp b/libs/algorithms/include/hpx/parallel/algorithms/set_intersection.hpp
index 92ca91a76c..470406419f 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/set_intersection.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/set_intersection.hpp
@@ -13,10 +13,10 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/decay.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/copy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/set_operation.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/set_symmetric_difference.hpp b/libs/algorithms/include/hpx/parallel/algorithms/set_symmetric_difference.hpp
index 421eb0cf88..12087423ee 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/set_symmetric_difference.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/set_symmetric_difference.hpp
@@ -13,10 +13,10 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/decay.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/copy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/set_operation.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/set_union.hpp b/libs/algorithms/include/hpx/parallel/algorithms/set_union.hpp
index b825338b6a..f047acd79f 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/set_union.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/set_union.hpp
@@ -13,10 +13,10 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/decay.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/copy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/set_operation.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/sort.hpp b/libs/algorithms/include/hpx/parallel/algorithms/sort.hpp
index 60f386fa4d..bbfed4be4b 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/sort.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/sort.hpp
@@ -18,13 +18,13 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/decay.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/exception_list.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/exception_list.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_information.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/compare_projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -82,7 +82,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
             if (std::size_t(N) <= chunk_size)
             {
                 return execution::async_execute(policy.executor(),
-                    [first, last, HPX_CAPTURE_MOVE(comp)]() -> RandomIt {
+                    [first, last, comp = std::move(comp)]() -> RandomIt {
                         std::sort(first, last, comp);
                         return last;
                     });
@@ -187,8 +187,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 policy.parameters(), policy.executor(), cores, count);
 
             std::size_t chunk_size = execution::get_chunk_size(
-                policy.parameters(), policy.executor(), [] { return 0; }, cores,
-                count);
+                policy.parameters(), policy.executor(),
+                [](std::size_t) { return 0; }, cores, count);
 
             util::detail::adjust_chunk_size_and_max_chunks(
                 cores, count, max_chunks, chunk_size);
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/swap_ranges.hpp b/libs/algorithms/include/hpx/parallel/algorithms/swap_ranges.hpp
index 056413af19..4d3a2d8791 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/swap_ranges.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/swap_ranges.hpp
@@ -12,9 +12,9 @@
 #include <hpx/config.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/projection_identity.hpp>
 #include <hpx/parallel/util/zip_iterator.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/transform.hpp b/libs/algorithms/include/hpx/parallel/algorithms/transform.hpp
index 7158bcacfe..e6496930bc 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/transform.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/transform.hpp
@@ -19,13 +19,13 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/traits/is_callable.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
-#include <hpx/util/annotated_function.hpp>
 #include <hpx/util/tagged_pair.hpp>
 #include <hpx/util/tagged_tuple.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/transform_exclusive_scan.hpp b/libs/algorithms/include/hpx/parallel/algorithms/transform_exclusive_scan.hpp
index 7974d08635..a5dd74bed5 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/transform_exclusive_scan.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/transform_exclusive_scan.hpp
@@ -17,9 +17,9 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/unused.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/transform_inclusive_scan.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp b/libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp
index 24914c0c8f..da8827dd12 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp
@@ -16,9 +16,9 @@
 #include <hpx/functional/traits/is_callable.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/inclusive_scan.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce.hpp b/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce.hpp
index 0933a76e0f..c23143015f 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce.hpp
@@ -18,9 +18,9 @@
 #include <hpx/traits/segmented_iterator_traits.hpp>
 #include <hpx/util/unwrap.hpp>
 
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -78,7 +78,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 typedef
                     typename std::iterator_traits<FwdIter>::reference reference;
 
-                auto f1 = [r, HPX_CAPTURE_FORWARD(conv)](
+                auto f1 = [r, conv = std::forward<Convert>(conv)](
                               FwdIter part_begin, std::size_t part_size) -> T {
                     T val = hpx::util::invoke(conv, *part_begin);
                     return util::accumulate_n(++part_begin, --part_size,
@@ -94,12 +94,12 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return util::partitioner<ExPolicy, T>::call(
                     std::forward<ExPolicy>(policy), first,
                     std::distance(first, last), std::move(f1),
-                    hpx::util::unwrapping(
-                        [HPX_CAPTURE_FORWARD(init), HPX_CAPTURE_FORWARD(r)](
-                            std::vector<T>&& results) -> T {
-                            return util::accumulate_n(hpx::util::begin(results),
-                                hpx::util::size(results), init, r);
-                        }));
+                    hpx::util::unwrapping([init = std::forward<T_>(init),
+                                              r = std::forward<Reduce>(r)](
+                                              std::vector<T>&& results) -> T {
+                        return util::accumulate_n(hpx::util::begin(results),
+                            hpx::util::size(results), init, r);
+                    }));
             }
         };
 
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp b/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp
index 7feb8f1eb3..0dd8a12670 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp
@@ -18,8 +18,8 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/iterator_support/zip_iterator.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner.hpp>
@@ -146,7 +146,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
 
                 difference_type count = std::distance(first1, last1);
 
-                auto f1 = [op1, HPX_CAPTURE_FORWARD(op2)](
+                auto f1 = [op1, op2 = std::forward<Op2>(op2)](
                               zip_iterator part_begin,
                               std::size_t part_size) mutable -> T {
                     auto iters = part_begin.get_iterator_tuple();
@@ -206,7 +206,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 return util::partitioner<ExPolicy, T>::call(
                     std::forward<ExPolicy>(policy),
                     make_zip_iterator(first1, first2), count, std::move(f1),
-                    [HPX_CAPTURE_FORWARD(init), HPX_CAPTURE_FORWARD(op1)](
+                    [init = std::forward<T_>(init),
+                        op1 = std::forward<Op1>(op1)](
                         std::vector<hpx::future<T>>&& results) -> T {
                         T ret = init;
                         for (auto&& fut : results)
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp
index 3a4697953a..70f5476b54 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp
@@ -12,9 +12,9 @@
 #include <hpx/config.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner_with_cleanup.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp
index 132fc8ec65..f8bf5da9aa 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp
@@ -14,9 +14,9 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner_with_cleanup.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp
index df52c0c1e2..3ccbadb9af 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp
@@ -12,9 +12,9 @@
 #include <hpx/config.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner_with_cleanup.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp
index 9e894a500d..f1a2207eba 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp
@@ -14,9 +14,9 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp
index da644a1739..ce505b1a5f 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp
@@ -14,9 +14,9 @@
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
 #include <hpx/parallel/util/partitioner_with_cleanup.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/algorithms/unique.hpp b/libs/algorithms/include/hpx/parallel/algorithms/unique.hpp
index 1baf522f21..716345f758 100644
--- a/libs/algorithms/include/hpx/parallel/algorithms/unique.hpp
+++ b/libs/algorithms/include/hpx/parallel/algorithms/unique.hpp
@@ -14,11 +14,11 @@
 #include <hpx/type_support/unused.hpp>
 #include <hpx/util/tagged_pair.hpp>
 
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
 #include <hpx/parallel/algorithms/detail/transfer.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/tagspec.hpp>
 #include <hpx/parallel/traits/projected.hpp>
 #include <hpx/parallel/util/compare_projected.hpp>
@@ -103,8 +103,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     void, util::scan_partitioner_sequential_f3_tag>
                     scan_partitioner_type;
 
-                auto f1 = [HPX_CAPTURE_FORWARD(pred),
-                              HPX_CAPTURE_FORWARD(proj)](
+                auto f1 = [pred = std::forward<Pred>(pred),
+                              proj = std::forward<Proj>(proj)](
                               zip_iterator part_begin,
                               std::size_t part_size) -> std::size_t {
                     FwdIter base = get<0>(part_begin.get_iterator_tuple());
@@ -167,7 +167,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 };
 
                 auto f4 =
-                    [HPX_CAPTURE_MOVE(dest_ptr), first, count, flags](
+                    [dest_ptr = std::move(dest_ptr), first, count, flags](
                         std::vector<hpx::shared_future<std::size_t>>&&,
                         std::vector<hpx::future<void>>&&) mutable -> FwdIter {
                     if (!flags[count - 1])
@@ -408,8 +408,8 @@ namespace hpx { namespace parallel { inline namespace v1 {
                     std::pair<FwdIter1, FwdIter2>, std::size_t>
                     scan_partitioner_type;
 
-                auto f1 = [HPX_CAPTURE_FORWARD(pred),
-                              HPX_CAPTURE_FORWARD(proj)](
+                auto f1 = [pred = std::forward<Pred>(pred),
+                              proj = std::forward<Proj>(proj)](
                               zip_iterator part_begin,
                               std::size_t part_size) -> std::size_t {
                     FwdIter1 base = get<0>(part_begin.get_iterator_tuple());
diff --git a/libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp b/libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp
index a4bdeaa9ac..35a4bc6fd5 100644
--- a/libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp
+++ b/libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp
@@ -10,9 +10,9 @@
 #define HPX_PARALLEL_CONTAINER_ALGORITHM_FILL_FEB_23_2018_0057AM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_range.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 
 #include <hpx/parallel/algorithms/fill.hpp>
 
diff --git a/libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp b/libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp
index fdc0d76c85..e41e2bc10d 100644
--- a/libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp
+++ b/libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp
@@ -11,9 +11,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/concepts/concepts.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_range.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 
 #include <hpx/parallel/algorithms/find.hpp>
 #include <hpx/parallel/traits/projected.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp b/libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp
index 21ac78ccbb..af89de3a0f 100644
--- a/libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp
+++ b/libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp
@@ -10,9 +10,9 @@
 #define HPX_PARALLEL_CONTAINER_ALGORITHM_SEARCH_FEB_28_2018_0007AM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_range.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 
 #include <hpx/parallel/algorithms/search.hpp>
 #include <hpx/parallel/traits/projected.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/datapar.hpp b/libs/algorithms/include/hpx/parallel/datapar.hpp
index 9f4330b78f..f00187a412 100644
--- a/libs/algorithms/include/hpx/parallel/datapar.hpp
+++ b/libs/algorithms/include/hpx/parallel/datapar.hpp
@@ -11,7 +11,7 @@
 
 #if defined(HPX_HAVE_DATAPAR)
 
-#include <hpx/parallel/datapar/execution_policy.hpp>
+#include <hpx/execution/datapar/execution_policy.hpp>
 #include <hpx/parallel/datapar/iterator_helpers.hpp>
 #include <hpx/parallel/datapar/loop.hpp>
 #include <hpx/parallel/datapar/transform_loop.hpp>
diff --git a/libs/algorithms/include/hpx/parallel/datapar/iterator_helpers.hpp b/libs/algorithms/include/hpx/parallel/datapar/iterator_helpers.hpp
index c08ae302ba..9b17c6cd6a 100644
--- a/libs/algorithms/include/hpx/parallel/datapar/iterator_helpers.hpp
+++ b/libs/algorithms/include/hpx/parallel/datapar/iterator_helpers.hpp
@@ -10,10 +10,10 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_DATAPAR)
+#include <hpx/execution/parallel/traits/vector_pack_alignment_size.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_load_store.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_type.hpp>
 #include <hpx/functional/result_of.hpp>
-#include <hpx/parallel/traits/vector_pack_alignment_size.hpp>
-#include <hpx/parallel/traits/vector_pack_load_store.hpp>
-#include <hpx/parallel/traits/vector_pack_type.hpp>
 
 #include <cstddef>
 #include <iterator>
diff --git a/libs/algorithms/include/hpx/parallel/datapar/loop.hpp b/libs/algorithms/include/hpx/parallel/datapar/loop.hpp
index f054b36219..1ebe577ab7 100644
--- a/libs/algorithms/include/hpx/parallel/datapar/loop.hpp
+++ b/libs/algorithms/include/hpx/parallel/datapar/loop.hpp
@@ -10,14 +10,14 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_DATAPAR)
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/datapar/execution_policy_fwd.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/datapar/execution_policy_fwd.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_alignment_size.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_load_store.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_type.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/parallel/datapar/iterator_helpers.hpp>
-#include <hpx/parallel/traits/vector_pack_alignment_size.hpp>
-#include <hpx/parallel/traits/vector_pack_load_store.hpp>
-#include <hpx/parallel/traits/vector_pack_type.hpp>
 #include <hpx/parallel/util/loop.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 #include <hpx/type_support/decay.hpp>
 
 #include <algorithm>
@@ -129,7 +129,7 @@ namespace hpx { namespace parallel { namespace util {
                     datapar_loop_step<Begin>::call1(f, first);
                 }
 
-                static std::size_t HPX_CONSTEXPR_OR_CONST size =
+                static std::size_t constexpr size =
                     traits::vector_pack_size<V>::value;
 
                 End const lastV = last - (size + 1);
@@ -188,7 +188,7 @@ namespace hpx { namespace parallel { namespace util {
                     return std::make_pair(std::move(it1), std::move(it2));
                 }
 
-                static std::size_t HPX_CONSTEXPR_OR_CONST size =
+                static std::size_t constexpr size =
                     traits::vector_pack_size<V>::value;
 
                 InIter1 const last1V = last1 - (size + 1);
@@ -249,7 +249,7 @@ namespace hpx { namespace parallel { namespace util {
                     datapar_loop_step<InIter>::call1(f, first);
                 }
 
-                static std::size_t HPX_CONSTEXPR_OR_CONST size =
+                static std::size_t constexpr size =
                     traits::vector_pack_size<V>::value;
 
                 for (std::int64_t lenV = std::int64_t(count - (size + 1));
diff --git a/libs/algorithms/include/hpx/parallel/datapar/transform_loop.hpp b/libs/algorithms/include/hpx/parallel/datapar/transform_loop.hpp
index c50f609f6c..48e301d36c 100644
--- a/libs/algorithms/include/hpx/parallel/datapar/transform_loop.hpp
+++ b/libs/algorithms/include/hpx/parallel/datapar/transform_loop.hpp
@@ -11,14 +11,14 @@
 
 #if defined(HPX_HAVE_DATAPAR)
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/execution/datapar/execution_policy_fwd.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
-#include <hpx/parallel/datapar/execution_policy_fwd.hpp>
 #include <hpx/parallel/datapar/iterator_helpers.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/cancellation_token.hpp>
 #include <hpx/parallel/util/transform_loop.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 #include <hpx/type_support/decay.hpp>
 
 #include <algorithm>
@@ -55,7 +55,7 @@ namespace hpx { namespace parallel { namespace util {
                     datapar_transform_loop_step::call1(f, first, dest);
                 }
 
-                static std::size_t HPX_CONSTEXPR_OR_CONST size =
+                static constexpr std::size_t size =
                     traits::vector_pack_size<V>::value;
 
                 for (std::int64_t lenV = std::int64_t(count - (size + 1));
@@ -152,7 +152,7 @@ namespace hpx { namespace parallel { namespace util {
                     datapar_transform_loop_step::call1(f, first1, first2, dest);
                 }
 
-                static std::size_t HPX_CONSTEXPR_OR_CONST size =
+                static constexpr std::size_t size =
                     traits::vector_pack_size<V>::value;
 
                 for (std::int64_t lenV = std::int64_t(count - (size + 1));
diff --git a/libs/algorithms/include/hpx/parallel/datapar/zip_iterator.hpp b/libs/algorithms/include/hpx/parallel/datapar/zip_iterator.hpp
index 5e2ba5bd81..a7f558f47d 100644
--- a/libs/algorithms/include/hpx/parallel/datapar/zip_iterator.hpp
+++ b/libs/algorithms/include/hpx/parallel/datapar/zip_iterator.hpp
@@ -11,14 +11,14 @@
 
 #if defined(HPX_HAVE_DATAPAR)
 
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/iterator_support/zip_iterator.hpp>
+#include <hpx/type_support/pack.hpp>
 
+#include <hpx/execution/parallel/traits/vector_pack_alignment_size.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_load_store.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_type.hpp>
 #include <hpx/parallel/datapar/iterator_helpers.hpp>
-#include <hpx/parallel/traits/vector_pack_alignment_size.hpp>
-#include <hpx/parallel/traits/vector_pack_load_store.hpp>
-#include <hpx/parallel/traits/vector_pack_type.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -36,7 +36,7 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
         template <std::size_t... Is>
         static HPX_FORCEINLINE bool call(
             hpx::util::zip_iterator<Iter...> const& it,
-            hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::util::index_pack<Is...>)
         {
             auto const& t = it.get_iterator_tuple();
             bool const sequencer[] = {
@@ -49,15 +49,14 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
             hpx::util::zip_iterator<Iter...> const& it)
         {
             return call(it,
-                typename hpx::util::detail::make_index_pack<sizeof...(
-                    Iter)>::type());
+                typename hpx::util::make_index_pack<sizeof...(Iter)>::type());
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename... Iter>
     struct iterator_datapar_compatible_impl<hpx::util::zip_iterator<Iter...>>
-      : hpx::util::detail::all_of<std::is_arithmetic<
+      : hpx::util::all_of<std::is_arithmetic<
             typename std::iterator_traits<Iter>::value_type>...>
     {
     };
@@ -69,7 +68,7 @@ namespace hpx { namespace parallel { namespace traits {
     namespace detail {
         template <typename Tuple, typename... Iter, std::size_t... Is>
         Tuple aligned_pack(hpx::util::zip_iterator<Iter...> const& iter,
-            hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::util::index_pack<Is...>)
         {
             auto const& t = iter.get_iterator_tuple();
             return hpx::util::make_tuple(vector_pack_load<
@@ -80,7 +79,7 @@ namespace hpx { namespace parallel { namespace traits {
 
         template <typename Tuple, typename... Iter, std::size_t... Is>
         Tuple unaligned_pack(hpx::util::zip_iterator<Iter...> const& iter,
-            hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::util::index_pack<Is...>)
         {
             auto const& t = iter.get_iterator_tuple();
             return hpx::util::make_tuple(vector_pack_load<
@@ -99,8 +98,7 @@ namespace hpx { namespace parallel { namespace traits {
         static value_type aligned(hpx::util::zip_iterator<Iter...> const& iter)
         {
             return traits::detail::aligned_pack<value_type>(iter,
-                typename hpx::util::detail::make_index_pack<sizeof...(
-                    Iter)>::type());
+                typename hpx::util::make_index_pack<sizeof...(Iter)>::type());
         }
 
         template <typename... Iter>
@@ -108,8 +106,7 @@ namespace hpx { namespace parallel { namespace traits {
             hpx::util::zip_iterator<Iter...> const& iter)
         {
             return traits::detail::unaligned_pack<value_type>(iter,
-                typename hpx::util::detail::make_index_pack<sizeof...(
-                    Iter)>::type());
+                typename hpx::util::make_index_pack<sizeof...(Iter)>::type());
         }
     };
 
@@ -118,7 +115,7 @@ namespace hpx { namespace parallel { namespace traits {
         template <typename Tuple, typename... Iter, std::size_t... Is>
         void aligned_pack(Tuple const& value,
             hpx::util::zip_iterator<Iter...> const& iter,
-            hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::util::index_pack<Is...>)
         {
             auto const& t = iter.get_iterator_tuple();
             int const sequencer[] = {0,
@@ -134,7 +131,7 @@ namespace hpx { namespace parallel { namespace traits {
         template <typename Tuple, typename... Iter, std::size_t... Is>
         void unaligned_pack(Tuple const& value,
             hpx::util::zip_iterator<Iter...> const& iter,
-            hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::util::index_pack<Is...>)
         {
             auto const& t = iter.get_iterator_tuple();
             int const sequencer[] = {0,
@@ -156,8 +153,7 @@ namespace hpx { namespace parallel { namespace traits {
             V const& value, hpx::util::zip_iterator<Iter...> const& iter)
         {
             traits::detail::aligned_pack(value, iter,
-                typename hpx::util::detail::make_index_pack<sizeof...(
-                    Iter)>::type());
+                typename hpx::util::make_index_pack<sizeof...(Iter)>::type());
         }
 
         template <typename V, typename... Iter>
@@ -165,8 +161,7 @@ namespace hpx { namespace parallel { namespace traits {
             V const& value, hpx::util::zip_iterator<Iter...> const& iter)
         {
             traits::detail::unaligned_pack(value, iter,
-                typename hpx::util::detail::make_index_pack<sizeof...(
-                    Iter)>::type());
+                typename hpx::util::make_index_pack<sizeof...(Iter)>::type());
         }
     };
 }}}    // namespace hpx::parallel::traits
diff --git a/libs/algorithms/include/hpx/parallel/traits/projected.hpp b/libs/algorithms/include/hpx/parallel/traits/projected.hpp
index 16bb4bd81a..35e53c3866 100644
--- a/libs/algorithms/include/hpx/parallel/traits/projected.hpp
+++ b/libs/algorithms/include/hpx/parallel/traits/projected.hpp
@@ -8,16 +8,16 @@
 #define HPX_PARALLEL_TRAITS_PROJECTED_JUL_18_2015_1001PM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_load_store.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_type.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/functional/traits/is_callable.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
-#include <hpx/parallel/traits/vector_pack_load_store.hpp>
-#include <hpx/parallel/traits/vector_pack_type.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 #include <hpx/type_support/always_void.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <iterator>
 #include <type_traits>
@@ -190,14 +190,12 @@ namespace hpx { namespace parallel { namespace traits {
         };
 
         template <typename ExPolicy, typename F, typename... Projected>
-        struct is_indirect_callable<ExPolicy, F,
-            hpx::util::detail::pack<Projected...>,
+        struct is_indirect_callable<ExPolicy, F, hpx::util::pack<Projected...>,
             typename std::enable_if<
-                hpx::util::detail::all_of<
-                    is_projected_indirect<Projected>...>::value &&
+                hpx::util::all_of<is_projected_indirect<Projected>...>::value &&
                 (!hpx::parallel::execution::is_vectorpack_execution_policy<
                      ExPolicy>::value ||
-                    !hpx::util::detail::all_of<
+                    !hpx::util::all_of<
                         is_projected_zip_iterator<Projected>...>::value)>::type>
           : is_indirect_callable_impl<F,
                 typename projected_result_of_indirect<Projected>::type...>
@@ -209,14 +207,12 @@ namespace hpx { namespace parallel { namespace traits {
         // special handling because zip_iterator<>::reference is not a real
         // reference type.
         template <typename ExPolicy, typename F, typename... Projected>
-        struct is_indirect_callable<ExPolicy, F,
-            hpx::util::detail::pack<Projected...>,
+        struct is_indirect_callable<ExPolicy, F, hpx::util::pack<Projected...>,
             typename std::enable_if<
-                hpx::util::detail::all_of<
-                    is_projected_indirect<Projected>...>::value &&
+                hpx::util::all_of<is_projected_indirect<Projected>...>::value &&
                 hpx::parallel::execution::is_vectorpack_execution_policy<
                     ExPolicy>::value &&
-                hpx::util::detail::all_of<
+                hpx::util::all_of<
                     is_projected_zip_iterator<Projected>...>::value>::type>
           : is_indirect_callable_impl<F,
                 typename projected_result_of_vector_pack<Projected>::type...>
@@ -229,8 +225,7 @@ namespace hpx { namespace parallel { namespace traits {
     struct is_indirect_callable
       : detail::is_indirect_callable<typename hpx::util::decay<ExPolicy>::type,
             typename hpx::util::decay<F>::type,
-            hpx::util::detail::pack<
-                typename hpx::util::decay<Projected>::type...>>
+            hpx::util::pack<typename hpx::util::decay<Projected>::type...>>
     {
     };
 }}}    // namespace hpx::parallel::traits
diff --git a/libs/algorithms/include/hpx/parallel/util/detail/algorithm_result.hpp b/libs/algorithms/include/hpx/parallel/util/detail/algorithm_result.hpp
index d02e0498e8..485832a41a 100644
--- a/libs/algorithms/include/hpx/parallel/util/detail/algorithm_result.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/detail/algorithm_result.hpp
@@ -9,9 +9,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/concepts/concepts.hpp>
+#include <hpx/execution/execution_policy_fwd.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/execution_policy_fwd.hpp>
 #include <hpx/type_support/unused.hpp>
 
 #include <type_traits>
diff --git a/libs/algorithms/include/hpx/parallel/util/detail/chunk_size.hpp b/libs/algorithms/include/hpx/parallel/util/detail/chunk_size.hpp
index 65464b2054..1160358bd1 100644
--- a/libs/algorithms/include/hpx/parallel/util/detail/chunk_size.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/detail/chunk_size.hpp
@@ -14,10 +14,10 @@
 #include <hpx/lcos/future.hpp>
 #include <hpx/type_support/decay.hpp>
 
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/executors/execution_information.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 #include <hpx/parallel/util/detail/chunk_size_iterator.hpp>
 
 #include <algorithm>
@@ -127,8 +127,7 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
         std::advance(last, count);
 
         Stride stride = parallel::v1::detail::abs(s);
-        auto test_function = [&]() -> std::size_t {
-            std::size_t test_chunk_size = count / 100;
+        auto test_function = [&](std::size_t test_chunk_size) -> std::size_t {
             if (test_chunk_size == 0)
                 return 0;
 
@@ -197,8 +196,8 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
         while (count != 0)
         {
             std::size_t chunk_size = execution::get_chunk_size(
-                policy.parameters(), policy.executor(), []() { return 0; },
-                cores, count);
+                policy.parameters(), policy.executor(),
+                [](std::size_t) { return 0; }, cores, count);
 
             // make sure, chunk size and max_chunks are consistent
             adjust_chunk_size_and_max_chunks(
@@ -267,8 +266,7 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
 
         Stride stride = parallel::v1::detail::abs(s);
         std::size_t base_idx = 0;
-        auto test_function = [&]() -> std::size_t {
-            std::size_t test_chunk_size = count / 100;
+        auto test_function = [&](std::size_t test_chunk_size) -> std::size_t {
             if (test_chunk_size == 0)
                 return 0;
 
@@ -340,8 +338,8 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
         while (count != 0)
         {
             std::size_t chunk_size = execution::get_chunk_size(
-                policy.parameters(), policy.executor(), []() { return 0; },
-                cores, count);
+                policy.parameters(), policy.executor(),
+                [](std::size_t) { return 0; }, cores, count);
 
             // make sure, chunk size and max_chunks are consistent
             adjust_chunk_size_and_max_chunks(
diff --git a/libs/algorithms/include/hpx/parallel/util/detail/chunk_size_iterator.hpp b/libs/algorithms/include/hpx/parallel/util/detail/chunk_size_iterator.hpp
index 4a9f883e3d..36ea3a8515 100644
--- a/libs/algorithms/include/hpx/parallel/util/detail/chunk_size_iterator.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/detail/chunk_size_iterator.hpp
@@ -12,7 +12,7 @@
 #include <hpx/iterator_support/iterator_facade.hpp>
 #include <hpx/statistics/min.hpp>
 
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
 
 #include <algorithm>
 #include <cstddef>
diff --git a/libs/algorithms/include/hpx/parallel/util/detail/handle_local_exceptions.hpp b/libs/algorithms/include/hpx/parallel/util/detail/handle_local_exceptions.hpp
index 33e7a124e1..dbab08a947 100644
--- a/libs/algorithms/include/hpx/parallel/util/detail/handle_local_exceptions.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/detail/handle_local_exceptions.hpp
@@ -13,8 +13,8 @@
 #include <hpx/assertion.hpp>
 #include <hpx/async.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/hpx_finalize.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 
 #include <exception>
 #include <list>
diff --git a/libs/algorithms/include/hpx/parallel/util/detail/handle_remote_exceptions.hpp b/libs/algorithms/include/hpx/parallel/util/detail/handle_remote_exceptions.hpp
index 37c809a0c4..ed035a6b3f 100644
--- a/libs/algorithms/include/hpx/parallel/util/detail/handle_remote_exceptions.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/detail/handle_remote_exceptions.hpp
@@ -10,9 +10,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/hpx_finalize.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 
 #include <exception>
 #include <list>
diff --git a/libs/algorithms/include/hpx/parallel/util/detail/scoped_executor_parameters.hpp b/libs/algorithms/include/hpx/parallel/util/detail/scoped_executor_parameters.hpp
index 3c9739b4bc..bc7c42a638 100644
--- a/libs/algorithms/include/hpx/parallel/util/detail/scoped_executor_parameters.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/detail/scoped_executor_parameters.hpp
@@ -8,7 +8,7 @@
 #define HPX_PARALLEL_UTIL_DETAIL_SCOPED_EXECUTOR_PARAMETERS_APR_22_1221PM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 
 namespace hpx { namespace parallel { namespace util { namespace detail {
     ///////////////////////////////////////////////////////////////////////////
diff --git a/libs/algorithms/include/hpx/parallel/util/detail/select_partitioner.hpp b/libs/algorithms/include/hpx/parallel/util/detail/select_partitioner.hpp
index 60d717e74c..5fd2129531 100644
--- a/libs/algorithms/include/hpx/parallel/util/detail/select_partitioner.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/detail/select_partitioner.hpp
@@ -11,7 +11,7 @@
 #include <hpx/config.hpp>
 #include <hpx/lcos/future.hpp>
 
-#include <hpx/parallel/execution_policy.hpp>
+#include <hpx/execution/execution_policy.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace parallel { namespace util { namespace detail {
diff --git a/libs/algorithms/include/hpx/parallel/util/foreach_partitioner.hpp b/libs/algorithms/include/hpx/parallel/util/foreach_partitioner.hpp
index 19b20a0ed9..bf162ef235 100644
--- a/libs/algorithms/include/hpx/parallel/util/foreach_partitioner.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/foreach_partitioner.hpp
@@ -16,10 +16,10 @@
 #include <hpx/lcos/wait_all.hpp>
 #include <hpx/type_support/unused.hpp>
 
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 #include <hpx/parallel/util/detail/chunk_size.hpp>
 #include <hpx/parallel/util/detail/handle_local_exceptions.hpp>
 #include <hpx/parallel/util/detail/partitioner_iteration.hpp>
@@ -206,9 +206,9 @@ namespace hpx { namespace parallel { namespace util {
 #else
                 // wait for all tasks to finish
                 return hpx::dataflow(
-                    [last, HPX_CAPTURE_MOVE(errors),
-                        HPX_CAPTURE_MOVE(scoped_params),
-                        HPX_CAPTURE_FORWARD(f)](
+                    [last, errors = std::move(errors),
+                        scoped_params = std::move(scoped_params),
+                        f = std::forward<F>(f)](
                         std::vector<hpx::future<Result>>&& r1,
                         std::vector<hpx::future<Result>>&& r2) mutable
                     -> FwdIter {
diff --git a/libs/algorithms/include/hpx/parallel/util/loop.hpp b/libs/algorithms/include/hpx/parallel/util/loop.hpp
index eddfa4972b..369f3f35a1 100644
--- a/libs/algorithms/include/hpx/parallel/util/loop.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/loop.hpp
@@ -13,11 +13,11 @@
 #endif
 #include <hpx/assertion.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/parallel/util/cancellation_token.hpp>
 #include <hpx/parallel/util/projection_identity.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -39,7 +39,7 @@ namespace hpx { namespace parallel { namespace util {
     }
 
     template <typename ExPolicy, typename Iter>
-    HPX_HOST_DEVICE HPX_FORCEINLINE HPX_CONSTEXPR typename std::enable_if<
+    HPX_HOST_DEVICE HPX_FORCEINLINE constexpr typename std::enable_if<
         !execution::is_vectorpack_execution_policy<ExPolicy>::value, bool>::type
         loop_optimization(Iter, Iter)
     {
diff --git a/libs/algorithms/include/hpx/parallel/util/partitioner.hpp b/libs/algorithms/include/hpx/parallel/util/partitioner.hpp
index cc306fc382..527f965662 100644
--- a/libs/algorithms/include/hpx/parallel/util/partitioner.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/partitioner.hpp
@@ -18,9 +18,9 @@
 #include <hpx/lcos/wait_all.hpp>
 #include <hpx/type_support/unused.hpp>
 
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 #include <hpx/parallel/util/detail/chunk_size.hpp>
 #include <hpx/parallel/util/detail/handle_local_exceptions.hpp>
 #include <hpx/parallel/util/detail/partitioner_iteration.hpp>
@@ -407,8 +407,9 @@ namespace hpx { namespace parallel { namespace util {
 #else
                 // wait for all tasks to finish
                 return hpx::dataflow(
-                    [HPX_CAPTURE_MOVE(errors), HPX_CAPTURE_MOVE(scoped_params),
-                        HPX_CAPTURE_FORWARD(f)](
+                    [errors = std::move(errors),
+                        scoped_params = std::move(scoped_params),
+                        f = std::forward<F>(f)](
                         std::vector<hpx::future<Result>>&& r) mutable -> R {
                         HPX_UNUSED(scoped_params);
 
diff --git a/libs/algorithms/include/hpx/parallel/util/partitioner_with_cleanup.hpp b/libs/algorithms/include/hpx/parallel/util/partitioner_with_cleanup.hpp
index 5462de4ece..bbb15e7f96 100644
--- a/libs/algorithms/include/hpx/parallel/util/partitioner_with_cleanup.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/partitioner_with_cleanup.hpp
@@ -16,9 +16,9 @@
 #include <hpx/lcos/wait_all.hpp>
 #include <hpx/type_support/unused.hpp>
 
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 #include <hpx/parallel/util/detail/chunk_size.hpp>
 #include <hpx/parallel/util/detail/handle_local_exceptions.hpp>
 #include <hpx/parallel/util/detail/partitioner_iteration.hpp>
@@ -174,8 +174,10 @@ namespace hpx { namespace parallel { namespace util {
                 return hpx::make_ready_future();
 #else
                 return hpx::dataflow(
-                    [HPX_CAPTURE_MOVE(errors), HPX_CAPTURE_MOVE(scoped_params),
-                        HPX_CAPTURE_FORWARD(f), HPX_CAPTURE_FORWARD(cleanup)](
+                    [errors = std::move(errors),
+                        scoped_params = std::move(scoped_params),
+                        f = std::forward<F>(f),
+                        cleanup = std::forward<Cleanup>(cleanup)](
                         std::vector<hpx::future<Result>>&& r) mutable -> R {
                         HPX_UNUSED(scoped_params);
 
diff --git a/libs/algorithms/include/hpx/parallel/util/prefetching.hpp b/libs/algorithms/include/hpx/parallel/util/prefetching.hpp
index 2466e99bce..d5df55437c 100644
--- a/libs/algorithms/include/hpx/parallel/util/prefetching.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/prefetching.hpp
@@ -8,11 +8,12 @@
 #define HPX_PREFETCHING_LOOP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/concurrency/cache_line_data.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/iterator_support/traits/is_range.hpp>
 #include <hpx/parallel/util/loop.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -221,21 +222,17 @@ namespace hpx { namespace parallel { namespace util {
             std::size_t chunk_size_;
             std::size_t range_size_;
 
-            static HPX_CONSTEXPR_OR_CONST std::size_t sizeof_first_value_type =
-                sizeof(typename hpx::util::tuple_element<0,
-                    ranges_type>::type::type);
+            static constexpr std::size_t sizeof_first_value_type = sizeof(
+                typename hpx::util::tuple_element<0, ranges_type>::type::type);
 
         public:
-            // FIXME: cache line size is probably platform dependent
-            static HPX_CONSTEXPR_OR_CONST std::size_t cache_line_size = 64ull;
-
             prefetcher_context(Itr begin, Itr end, ranges_type const& rngs,
                 std::size_t p_factor = 1)
               : it_begin_(begin)
               , it_end_(end)
               , rngs_(rngs)
-              , chunk_size_(
-                    (p_factor * cache_line_size) / sizeof_first_value_type)
+              , chunk_size_((p_factor * threads::get_cache_line_size()) /
+                    sizeof_first_value_type)
               , range_size_(std::distance(begin, end))
             {
             }
@@ -268,16 +265,16 @@ namespace hpx { namespace parallel { namespace util {
 
         template <typename... Ts, std::size_t... Is>
         HPX_FORCEINLINE void prefetch_containers(
-            hpx::util::tuple<Ts...> const& t,
-            hpx::util::detail::pack_c<std::size_t, Is...>, std::size_t idx)
+            hpx::util::tuple<Ts...> const& t, hpx::util::index_pack<Is...>,
+            std::size_t idx)
         {
             prefetch_addresses((hpx::util::get<Is>(t).get())[idx]...);
         }
 #else
         template <typename... Ts, std::size_t... Is>
         HPX_FORCEINLINE void prefetch_containers(
-            hpx::util::tuple<Ts...> const& t,
-            hpx::util::detail::pack_c<std::size_t, Is...>, std::size_t idx)
+            hpx::util::tuple<Ts...> const& t, hpx::util::index_pack<Is...>,
+            std::size_t idx)
         {
             int const sequencer[] = {
                 (hpx::util::get<Is>(t).get()[idx], 0)..., 0};
@@ -291,9 +288,8 @@ namespace hpx { namespace parallel { namespace util {
         {
             typedef detail::prefetching_iterator<Itr, Ts...> iterator_type;
             typedef typename iterator_type::base_iterator type;
-            typedef
-                typename hpx::util::detail::make_index_pack<sizeof...(Ts)>::type
-                    index_pack_type;
+            typedef typename hpx::util::make_index_pack<sizeof...(Ts)>::type
+                index_pack_type;
 
             template <typename End, typename F>
             static iterator_type call(iterator_type it, End end, F&& f)
@@ -346,9 +342,8 @@ namespace hpx { namespace parallel { namespace util {
         {
             typedef detail::prefetching_iterator<Itr, Ts...> iterator_type;
             typedef typename iterator_type::base_iterator type;
-            typedef
-                typename hpx::util::detail::make_index_pack<sizeof...(Ts)>::type
-                    index_pack_type;
+            typedef typename hpx::util::make_index_pack<sizeof...(Ts)>::type
+                index_pack_type;
 
             template <typename F>
             static iterator_type call(
@@ -405,8 +400,7 @@ namespace hpx { namespace parallel { namespace util {
     {
         static_assert(hpx::traits::is_random_access_iterator<Itr>::value,
             "Iterators have to be of random access iterator category");
-        static_assert(
-            hpx::util::detail::all_of<hpx::traits::is_range<Ts>...>::value,
+        static_assert(hpx::util::all_of<hpx::traits::is_range<Ts>...>::value,
             "All variadic parameters have to represent ranges");
 
         typedef hpx::util::tuple<std::reference_wrapper<Ts const>...>
diff --git a/libs/algorithms/include/hpx/parallel/util/scan_partitioner.hpp b/libs/algorithms/include/hpx/parallel/util/scan_partitioner.hpp
index 561608efa5..45c4dcf39e 100644
--- a/libs/algorithms/include/hpx/parallel/util/scan_partitioner.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/scan_partitioner.hpp
@@ -17,9 +17,9 @@
 #include <hpx/errors.hpp>
 #include <hpx/lcos/wait_all.hpp>
 
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/chunk_size.hpp>
 #include <hpx/parallel/util/detail/handle_local_exceptions.hpp>
@@ -336,10 +336,10 @@ namespace hpx { namespace parallel { namespace util {
                 std::size_t count, T&& init, F1&& f1, F2&& f2, F3&& f3, F4&& f4)
             {
                 return execution::async_execute(policy.executor(),
-                    [first, count, HPX_CAPTURE_FORWARD(policy),
-                        HPX_CAPTURE_FORWARD(init), HPX_CAPTURE_FORWARD(f1),
-                        HPX_CAPTURE_FORWARD(f2), HPX_CAPTURE_FORWARD(f3),
-                        HPX_CAPTURE_FORWARD(f4)]() mutable -> R {
+                    [first, count, policy = std::forward<ExPolicy_>(policy),
+                        init = std::forward<T>(init), f1 = std::forward<F1>(f1),
+                        f2 = std::forward<F2>(f2), f3 = std::forward<F3>(f3),
+                        f4 = std::forward<F4>(f4)]() mutable -> R {
                         using partitioner_type =
                             scan_static_partitioner<ExPolicy, ScanPartTag, R,
                                 Result1, Result2>;
diff --git a/libs/algorithms/include/hpx/parallel/util/transfer.hpp b/libs/algorithms/include/hpx/parallel/util/transfer.hpp
index 8cab202481..ef4d60786b 100644
--- a/libs/algorithms/include/hpx/parallel/util/transfer.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/transfer.hpp
@@ -35,7 +35,6 @@ namespace hpx { namespace parallel { namespace util {
         template <typename Category, typename Enable = void>
         struct move_n_helper;
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
         ///////////////////////////////////////////////////////////////////////
         template <typename InIter, typename OutIter>
         HPX_FORCEINLINE static std::pair<InIter, OutIter> copy_memmove(
@@ -56,7 +55,6 @@ namespace hpx { namespace parallel { namespace util {
             std::advance(dest, count);
             return std::make_pair(first, dest);
         }
-#endif
 
         ///////////////////////////////////////////////////////////////////////
         // Customization point for optimizing copy operations
@@ -73,7 +71,6 @@ namespace hpx { namespace parallel { namespace util {
             }
         };
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
         template <typename Dummy>
         struct copy_helper<hpx::traits::trivially_copyable_pointer_tag, Dummy>
         {
@@ -84,7 +81,6 @@ namespace hpx { namespace parallel { namespace util {
                 return copy_memmove(first, std::distance(first, last), dest);
             }
         };
-#endif
     }    // namespace detail
 
     template <typename InIter, typename OutIter>
@@ -114,7 +110,6 @@ namespace hpx { namespace parallel { namespace util {
             }
         };
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
         template <typename Dummy>
         struct copy_n_helper<hpx::traits::trivially_copyable_pointer_tag, Dummy>
         {
@@ -125,7 +120,6 @@ namespace hpx { namespace parallel { namespace util {
                 return copy_memmove(first, count, dest);
             }
         };
-#endif
     }    // namespace detail
 
     template <typename InIter, typename OutIter>
@@ -179,7 +173,6 @@ namespace hpx { namespace parallel { namespace util {
             }
         };
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
         template <typename Dummy>
         struct move_helper<hpx::traits::trivially_copyable_pointer_tag, Dummy>
         {
@@ -190,7 +183,6 @@ namespace hpx { namespace parallel { namespace util {
                 return copy_memmove(first, std::distance(first, last), dest);
             }
         };
-#endif
     }    // namespace detail
 
     template <typename InIter, typename OutIter>
@@ -219,7 +211,6 @@ namespace hpx { namespace parallel { namespace util {
             }
         };
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
         template <typename Dummy>
         struct move_n_helper<hpx::traits::trivially_copyable_pointer_tag, Dummy>
         {
@@ -230,7 +221,6 @@ namespace hpx { namespace parallel { namespace util {
                 return copy_memmove(first, count, dest);
             }
         };
-#endif
     }    // namespace detail
 
     template <typename InIter, typename OutIter>
diff --git a/libs/algorithms/include/hpx/parallel/util/transform_loop.hpp b/libs/algorithms/include/hpx/parallel/util/transform_loop.hpp
index 22225f3fe3..f133c33147 100644
--- a/libs/algorithms/include/hpx/parallel/util/transform_loop.hpp
+++ b/libs/algorithms/include/hpx/parallel/util/transform_loop.hpp
@@ -9,9 +9,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/parallel/util/cancellation_token.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
 
 #include <algorithm>
 #include <cstddef>
diff --git a/libs/algorithms/tests/regressions/for_loop_2281.cpp b/libs/algorithms/tests/regressions/for_loop_2281.cpp
index 25f959dc8f..9c57167d04 100644
--- a/libs/algorithms/tests/regressions/for_loop_2281.cpp
+++ b/libs/algorithms/tests/regressions/for_loop_2281.cpp
@@ -26,7 +26,7 @@ int hpx_main()
         thread_ids.insert(hpx::this_thread::get_id());
     });
 
-    HPX_TEST(thread_ids.size() > std::size_t(1));
+    HPX_TEST_LT(std::size_t(1), thread_ids.size());
 
     thread_ids.clear();
 
@@ -36,7 +36,7 @@ int hpx_main()
             thread_ids.insert(hpx::this_thread::get_id());
         });
 
-    HPX_TEST(thread_ids.size() > std::size_t(1));
+    HPX_TEST_LT(std::size_t(1), thread_ids.size());
 
     return hpx::finalize();
 }
diff --git a/libs/algorithms/tests/unit/algorithms/exclusive_scan.cpp b/libs/algorithms/tests/unit/algorithms/exclusive_scan.cpp
index f3a6d5f778..33bb13032b 100644
--- a/libs/algorithms/tests/unit/algorithms/exclusive_scan.cpp
+++ b/libs/algorithms/tests/unit/algorithms/exclusive_scan.cpp
@@ -9,8 +9,6 @@
 #include <hpx/include/parallel_scan.hpp>
 #include <hpx/testing.hpp>
 
-#include <boost/iterator/counting_iterator.hpp>
-
 #include <cstddef>
 #include <iostream>
 #include <iterator>
diff --git a/libs/algorithms/tests/unit/algorithms/exclusive_scan2.cpp b/libs/algorithms/tests/unit/algorithms/exclusive_scan2.cpp
index f361f1034e..e1a2291cd8 100644
--- a/libs/algorithms/tests/unit/algorithms/exclusive_scan2.cpp
+++ b/libs/algorithms/tests/unit/algorithms/exclusive_scan2.cpp
@@ -9,8 +9,6 @@
 #include <hpx/include/parallel_scan.hpp>
 #include <hpx/testing.hpp>
 
-#include <boost/iterator/counting_iterator.hpp>
-
 #include <cstddef>
 #include <iostream>
 #include <iterator>
diff --git a/libs/algorithms/tests/unit/algorithms/exclusive_scan_bad_alloc.cpp b/libs/algorithms/tests/unit/algorithms/exclusive_scan_bad_alloc.cpp
index 0e5234091c..b803a322b9 100644
--- a/libs/algorithms/tests/unit/algorithms/exclusive_scan_bad_alloc.cpp
+++ b/libs/algorithms/tests/unit/algorithms/exclusive_scan_bad_alloc.cpp
@@ -9,8 +9,6 @@
 #include <hpx/include/parallel_scan.hpp>
 #include <hpx/testing.hpp>
 
-#include <boost/iterator/counting_iterator.hpp>
-
 #include <cstddef>
 #include <iostream>
 #include <iterator>
diff --git a/libs/algorithms/tests/unit/algorithms/exclusive_scan_exception.cpp b/libs/algorithms/tests/unit/algorithms/exclusive_scan_exception.cpp
index f7f4b6c9d4..c44b6653e7 100644
--- a/libs/algorithms/tests/unit/algorithms/exclusive_scan_exception.cpp
+++ b/libs/algorithms/tests/unit/algorithms/exclusive_scan_exception.cpp
@@ -9,8 +9,6 @@
 #include <hpx/include/parallel_scan.hpp>
 #include <hpx/testing.hpp>
 
-#include <boost/iterator/counting_iterator.hpp>
-
 #include <cstddef>
 #include <iostream>
 #include <iterator>
diff --git a/libs/algorithms/tests/unit/algorithms/exclusive_scan_validate.cpp b/libs/algorithms/tests/unit/algorithms/exclusive_scan_validate.cpp
index c5e0251c0d..83b6e99869 100644
--- a/libs/algorithms/tests/unit/algorithms/exclusive_scan_validate.cpp
+++ b/libs/algorithms/tests/unit/algorithms/exclusive_scan_validate.cpp
@@ -7,10 +7,9 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/parallel_scan.hpp>
+#include <hpx/iterator_support.hpp>
 #include <hpx/testing.hpp>
 
-#include <boost/iterator/counting_iterator.hpp>
-
 #include <iostream>
 #include <iterator>
 #include <string>
@@ -54,8 +53,8 @@ void test_exclusive_scan_validate(
 
     // test 1, fill array with numbers counting from 0, then run scan algorithm
     a.clear();
-    std::copy(boost::counting_iterator<int>(0),
-        boost::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
+    std::copy(hpx::util::counting_iterator<int>(0),
+        hpx::util::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
 #ifdef DUMP_VALUES
     std::cout << "\nValidating counting from 0 "
               << "\nInput : ";
@@ -82,14 +81,14 @@ void test_exclusive_scan_validate(
         // counting from zero,
         int value = b[i];    //-V108
         int expected_value = INITIAL_VAL + check_n_triangle(i - 1);
-        if (!HPX_TEST(value == expected_value))
+        if (!HPX_TEST_EQ(value, expected_value))
             break;
     }
 
     // test 2, fill array with numbers counting from 1, then run scan algorithm
     a.clear();
-    std::copy(boost::counting_iterator<int>(1),
-        boost::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
+    std::copy(hpx::util::counting_iterator<int>(1),
+        hpx::util::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
 #ifdef DUMP_VALUES
     std::cout << "\nValidating counting from 1 "
               << "\nInput : ";
@@ -116,7 +115,7 @@ void test_exclusive_scan_validate(
         // counting from 1, use i+1
         int value = b[i];    //-V108
         int expected_value = INITIAL_VAL + check_n_triangle(i);
-        if (!HPX_TEST(value == expected_value))
+        if (!HPX_TEST_EQ(value, expected_value))
             break;
     }
 
@@ -150,7 +149,7 @@ void test_exclusive_scan_validate(
         // counting from zero,
         int value = b[i];    //-V108
         int expected_value = INITIAL_VAL + check_n_const(i, FILL_VALUE);
-        if (!HPX_TEST(value == expected_value))
+        if (!HPX_TEST_EQ(value, expected_value))
             break;
     }
 }
diff --git a/libs/algorithms/tests/unit/algorithms/includes.cpp b/libs/algorithms/tests/unit/algorithms/includes.cpp
index 5be6d34627..3f55fd91de 100644
--- a/libs/algorithms/tests/unit/algorithms/includes.cpp
+++ b/libs/algorithms/tests/unit/algorithms/includes.cpp
@@ -42,7 +42,7 @@ void test_includes1(ExPolicy policy, IteratorTag)
     std::size_t first_value = gen();    //-V101
     std::iota(std::begin(c1), std::end(c1), first_value);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
@@ -94,7 +94,7 @@ void test_includes1_async(ExPolicy p, IteratorTag)
     std::uniform_int_distribution<> dist(0, c1.size() - start - 1);
     std::size_t end = start + dist(gen);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
@@ -173,7 +173,7 @@ void test_includes2(ExPolicy policy, IteratorTag)
     std::uniform_int_distribution<> dist(0, c1.size() - start - 1);
     std::size_t end = start + dist(gen);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
@@ -226,7 +226,7 @@ void test_includes2_async(ExPolicy p, IteratorTag)
     std::uniform_int_distribution<> dist(0, c1.size() - start - 1);
     std::size_t end = start + dist(gen);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
@@ -306,12 +306,12 @@ void test_includes_exception(ExPolicy policy, IteratorTag)
     std::uniform_int_distribution<> dist(0, c1.size() - start - 1);
     std::size_t end = start + dist(gen);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     if (start == end)
         ++end;
 
-    HPX_TEST(end <= c1.size());
+    HPX_TEST_LTE(end, c1.size());
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
@@ -355,12 +355,12 @@ void test_includes_exception_async(ExPolicy p, IteratorTag)
     std::uniform_int_distribution<> dist(0, c1.size() - start - 1);
     std::size_t end = start + dist(gen);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     if (start == end)
         ++end;
 
-    HPX_TEST(end <= c1.size());
+    HPX_TEST_LTE(end, c1.size());
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
@@ -436,12 +436,12 @@ void test_includes_bad_alloc(ExPolicy policy, IteratorTag)
     std::uniform_int_distribution<> dist(0, c1.size() - start - 1);
     std::size_t end = start + dist(gen);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     if (start == end)
         ++end;
 
-    HPX_TEST(end <= c1.size());
+    HPX_TEST_LTE(end, c1.size());
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
@@ -484,12 +484,12 @@ void test_includes_bad_alloc_async(ExPolicy p, IteratorTag)
     std::uniform_int_distribution<> dist(0, c1.size() - start - 1);
     std::size_t end = start + dist(gen);
 
-    HPX_TEST(start <= end);
+    HPX_TEST_LTE(start, end);
 
     if (start == end)
         ++end;
 
-    HPX_TEST(end <= c1.size());
+    HPX_TEST_LTE(end, c1.size());
 
     base_iterator start_it = boost::next(std::begin(c1), start);
     base_iterator end_it = boost::next(std::begin(c1), end);
diff --git a/libs/algorithms/tests/unit/algorithms/inclusive_scan_tests.hpp b/libs/algorithms/tests/unit/algorithms/inclusive_scan_tests.hpp
index d4e08e0d39..0bacdcfd1e 100644
--- a/libs/algorithms/tests/unit/algorithms/inclusive_scan_tests.hpp
+++ b/libs/algorithms/tests/unit/algorithms/inclusive_scan_tests.hpp
@@ -11,10 +11,9 @@
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/parallel_executors.hpp>
 #include <hpx/include/parallel_scan.hpp>
+#include <hpx/iterator_support.hpp>
 #include <hpx/testing.hpp>
 
-#include <boost/iterator/counting_iterator.hpp>
-
 #include <cstddef>
 #include <iostream>
 #include <iterator>
@@ -386,8 +385,8 @@ void test_inclusive_scan_validate(
 
     // test 1, fill array with numbers counting from 0, then run scan algorithm
     a.clear();
-    std::copy(boost::counting_iterator<int>(0),
-        boost::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
+    std::copy(hpx::util::counting_iterator<int>(0),
+        hpx::util::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
     b.resize(a.size());
     hpx::parallel::inclusive_scan(
         p, a.begin(), a.end(), b.begin(),
@@ -398,14 +397,14 @@ void test_inclusive_scan_validate(
         // counting from zero,
         int value = b[i];    //-V108
         int expected_value = check_n_triangle(i);
-        if (!HPX_TEST(value == expected_value))
+        if (!HPX_TEST_EQ(value, expected_value))
             break;
     }
 
     // test 2, fill array with numbers counting from 1, then run scan algorithm
     a.clear();
-    std::copy(boost::counting_iterator<int>(1),
-        boost::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
+    std::copy(hpx::util::counting_iterator<int>(1),
+        hpx::util::counting_iterator<int>(ARRAY_SIZE), std::back_inserter(a));
     b.resize(a.size());
     hpx::parallel::inclusive_scan(
         p, a.begin(), a.end(), b.begin(),
@@ -416,7 +415,7 @@ void test_inclusive_scan_validate(
         // counting from 1, use i+1
         int value = b[i];    //-V108
         int expected_value = check_n_triangle(i + 1);
-        HPX_TEST(value == expected_value);
+        HPX_TEST_EQ(value, expected_value);
         if (value != expected_value)
             break;
     }
@@ -433,7 +432,7 @@ void test_inclusive_scan_validate(
     {
         int value = b[i];    //-V108
         int expected_value = check_n_const(i + 1, FILL_VALUE);
-        HPX_TEST(value == expected_value);
+        HPX_TEST_EQ(value, expected_value);
         if (value != expected_value)
             break;
     }
diff --git a/libs/algorithms/tests/unit/algorithms/is_heap_tests.hpp b/libs/algorithms/tests/unit/algorithms/is_heap_tests.hpp
index a261a59002..ec321c01da 100644
--- a/libs/algorithms/tests/unit/algorithms/is_heap_tests.hpp
+++ b/libs/algorithms/tests/unit/algorithms/is_heap_tests.hpp
@@ -99,7 +99,7 @@ void test_is_heap(
             policy, iterator(std::begin(c)), iterator(std::end(c)));
         bool solution = std::is_heap(std::begin(c), std::end(c));
 
-        HPX_TEST(result == solution);
+        HPX_TEST_EQ(result, solution);
     }
     else
     {
@@ -135,7 +135,7 @@ void test_is_heap_with_pred(ExPolicy policy, IteratorTag, DataType, Pred pred,
             policy, iterator(std::begin(c)), iterator(std::end(c)), pred);
         bool solution = std::is_heap(std::begin(c), std::end(c), pred);
 
-        HPX_TEST(result == solution);
+        HPX_TEST_EQ(result, solution);
     }
     else
     {
@@ -171,7 +171,7 @@ void test_is_heap_async(
         bool result = f.get();
         bool solution = std::is_heap(std::begin(c), std::end(c));
 
-        HPX_TEST(result == solution);
+        HPX_TEST_EQ(result, solution);
     }
     else
     {
diff --git a/libs/algorithms/tests/unit/container_algorithms/is_heap_range.cpp b/libs/algorithms/tests/unit/container_algorithms/is_heap_range.cpp
index e201b6d006..901be2e632 100644
--- a/libs/algorithms/tests/unit/container_algorithms/is_heap_range.cpp
+++ b/libs/algorithms/tests/unit/container_algorithms/is_heap_range.cpp
@@ -71,7 +71,7 @@ void test_is_heap(ExPolicy policy, DataType)
     bool result = hpx::parallel::is_heap(policy, c);
     bool solution = std::is_heap(std::begin(c), std::end(c));
 
-    HPX_TEST(result == solution);
+    HPX_TEST_EQ(result, solution);
 }
 
 template <typename ExPolicy, typename DataType>
@@ -94,7 +94,7 @@ void test_is_heap_async(ExPolicy policy, DataType)
     bool result = f.get();
     bool solution = std::is_heap(std::begin(c), std::end(c));
 
-    HPX_TEST(result == solution);
+    HPX_TEST_EQ(result, solution);
 }
 
 template <typename DataType>
diff --git a/libs/algorithms/tests/unit/datapar_algorithms/foreach_datapar_zipiter.cpp b/libs/algorithms/tests/unit/datapar_algorithms/foreach_datapar_zipiter.cpp
index 27c391d5a2..fc70674563 100644
--- a/libs/algorithms/tests/unit/datapar_algorithms/foreach_datapar_zipiter.cpp
+++ b/libs/algorithms/tests/unit/datapar_algorithms/foreach_datapar_zipiter.cpp
@@ -55,7 +55,7 @@ void for_each_zipiter_test(ExPolicy&& policy, IteratorTag)
     auto result = hpx::parallel::for_each(
         std::forward<ExPolicy>(policy), begin, end, set_42());
 
-    HPX_TEST(result == end);
+    HPX_TEST_EQ(result, end);
 
     // verify values
     std::size_t count = 0;
diff --git a/libs/algorithms/tests/unit/datapar_algorithms/foreach_tests.hpp b/libs/algorithms/tests/unit/datapar_algorithms/foreach_tests.hpp
index 4c479df582..2f356871fa 100644
--- a/libs/algorithms/tests/unit/datapar_algorithms/foreach_tests.hpp
+++ b/libs/algorithms/tests/unit/datapar_algorithms/foreach_tests.hpp
@@ -68,7 +68,7 @@ void test_for_each(ExPolicy&& policy, IteratorTag)
     iterator result = hpx::parallel::for_each(std::forward<ExPolicy>(policy),
         iterator(std::begin(c)), iterator(std::end(c)), set_42());
 
-    HPX_TEST(result == iterator(std::end(c)));
+    HPX_TEST_EQ(result, iterator(std::end(c)));
 
     // verify values
     std::size_t count = 0;
@@ -92,7 +92,7 @@ void test_for_each_async(ExPolicy&& p, IteratorTag)
         iterator(std::begin(c)), iterator(std::end(c)), set_42());
     f.wait();
 
-    HPX_TEST(f.get() == iterator(std::end(c)));
+    HPX_TEST_EQ(f.get(), iterator(std::end(c)));
 
     // verify values
     std::size_t count = 0;
@@ -256,7 +256,7 @@ void test_for_each_n(ExPolicy policy, IteratorTag)
     iterator result = hpx::parallel::for_each_n(
         policy, iterator(std::begin(c)), c.size(), set_42());
     iterator end = iterator(std::end(c));
-    HPX_TEST(result == end);
+    HPX_TEST_EQ(result, end);
 
     // verify values
     std::size_t count = 0;
@@ -278,7 +278,7 @@ void test_for_each_n_async(ExPolicy p, IteratorTag)
 
     hpx::future<iterator> f = hpx::parallel::for_each_n(
         p, iterator(std::begin(c)), c.size(), set_42());
-    HPX_TEST(f.get() == iterator(std::end(c)));
+    HPX_TEST_EQ(f.get(), iterator(std::end(c)));
 
     // verify values
     std::size_t count = 0;
diff --git a/libs/all_modules.rst b/libs/all_modules.rst
index eae0c86d7f..5e21382b2c 100644
--- a/libs/all_modules.rst
+++ b/libs/all_modules.rst
@@ -17,12 +17,14 @@ All modules
    /libs/affinity/docs/index.rst
    /libs/algorithms/docs/index.rst
    /libs/allocator_support/docs/index.rst
+   /libs/asio/docs/index.rst
    /libs/assertion/docs/index.rst
    /libs/basic_execution/docs/index.rst
    /libs/batch_environments/docs/index.rst
    /libs/cache/docs/index.rst
    /libs/checkpoint/docs/index.rst
    /libs/collectives/docs/index.rst
+   /libs/command_line_handling/docs/index.rst
    /libs/compute/docs/index.rst
    /libs/compute_cuda/docs/index.rst
    /libs/concepts/docs/index.rst
@@ -38,24 +40,35 @@ All modules
    /libs/functional/docs/index.rst
    /libs/hardware/docs/index.rst
    /libs/hashing/docs/index.rst
+   /libs/io_service/docs/index.rst
    /libs/iterator_support/docs/index.rst
    /libs/local_lcos/docs/index.rst
    /libs/logging/docs/index.rst
    /libs/memory/docs/index.rst
+   /libs/naming_base/docs/index.rst
+   /libs/performance_counters/docs/index.rst
    /libs/plugin/docs/index.rst
+   /libs/prefix/docs/index.rst
    /libs/preprocessor/docs/index.rst
    /libs/program_options/docs/index.rst
    /libs/resiliency/docs/index.rst
    /libs/resource_partitioner/docs/index.rst
+   /libs/runtime_configuration/docs/index.rst
+   /libs/schedulers/docs/index.rst
    /libs/segmented_algorithms/docs/index.rst
    /libs/serialization/docs/index.rst
    /libs/static_reinit/docs/index.rst
    /libs/statistics/docs/index.rst
+   /libs/string_util/docs/index.rst
    /libs/synchronization/docs/index.rst
    /libs/testing/docs/index.rst
+   /libs/threading/docs/index.rst
+   /libs/thread_pools/docs/index.rst
    /libs/thread_support/docs/index.rst
+   /libs/threading_base/docs/index.rst
    /libs/threadmanager/docs/index.rst
    /libs/timing/docs/index.rst
    /libs/topology/docs/index.rst
    /libs/type_support/docs/index.rst
    /libs/util/docs/index.rst
+   /libs/version/docs/index.rst
diff --git a/libs/allocator_support/CMakeLists.txt b/libs/allocator_support/CMakeLists.txt
index ebb28b3053..d16d759eca 100644
--- a/libs/allocator_support/CMakeLists.txt
+++ b/libs/allocator_support/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(allocator_support_headers
   hpx/allocator_support/allocator_deleter.hpp
diff --git a/libs/allocator_support/README.rst b/libs/allocator_support/README.rst
index 3df2853cfd..22b4e64a39 100644
--- a/libs/allocator_support/README.rst
+++ b/libs/allocator_support/README.rst
@@ -12,4 +12,4 @@ allocator_support
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/allocator_support/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/allocator_support/docs/index.html>`__.
diff --git a/libs/allocator_support/include/hpx/allocator_support/internal_allocator.hpp b/libs/allocator_support/include/hpx/allocator_support/internal_allocator.hpp
index 110c1788fb..f651ed0944 100644
--- a/libs/allocator_support/include/hpx/allocator_support/internal_allocator.hpp
+++ b/libs/allocator_support/include/hpx/allocator_support/internal_allocator.hpp
@@ -95,14 +95,14 @@ namespace hpx { namespace util {
     };
 
     template <typename T>
-    HPX_CONSTEXPR bool operator==(
+    constexpr bool operator==(
         internal_allocator<T> const&, internal_allocator<T> const&)
     {
         return true;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator!=(
+    constexpr bool operator!=(
         internal_allocator<T> const&, internal_allocator<T> const&)
     {
         return false;
diff --git a/libs/asio/CMakeLists.txt b/libs/asio/CMakeLists.txt
new file mode 100644
index 0000000000..50c14fbf7a
--- /dev/null
+++ b/libs/asio/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(asio_headers
+  hpx/asio/asio_util.hpp
+  hpx/asio/map_hostnames.hpp
+  )
+
+set(asio_compat_headers
+  hpx/util/asio_util.hpp
+  hpx/util/map_hostnames.hpp
+  )
+
+set(asio_sources
+  asio_util.cpp
+  map_hostnames.cpp
+  )
+
+include(HPX_AddModule)
+add_hpx_module(asio
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${asio_sources}
+  HEADERS ${asio_headers}
+  COMPAT_HEADERS ${asio_compat_headers}
+  DEPENDENCIES
+    hpx_assertion
+    hpx_config
+    hpx_errors
+    hpx_functional
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/asio/README.rst b/libs/asio/README.rst
new file mode 100644
index 0000000000..a69f942759
--- /dev/null
+++ b/libs/asio/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+====
+asio
+====
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/asio/docs/index.html>`__.
diff --git a/libs/asio/docs/index.rst b/libs/asio/docs/index.rst
new file mode 100644
index 0000000000..2073bd120e
--- /dev/null
+++ b/libs/asio/docs/index.rst
@@ -0,0 +1,13 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_asio:
+
+====
+asio
+====
+
diff --git a/libs/asio/examples/CMakeLists.txt b/libs/asio/examples/CMakeLists.txt
new file mode 100644
index 0000000000..118217120e
--- /dev/null
+++ b/libs/asio/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.asio)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.asio)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_ASIO_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.asio)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.asio)
+  endif()
+endif()
diff --git a/hpx/util/asio_util.hpp b/libs/asio/include/hpx/asio/asio_util.hpp
similarity index 74%
rename from hpx/util/asio_util.hpp
rename to libs/asio/include/hpx/asio/asio_util.hpp
index 810b54b0c4..84252a7244 100644
--- a/hpx/util/asio_util.hpp
+++ b/libs/asio/include/hpx/asio/asio_util.hpp
@@ -25,8 +25,7 @@
 #undef VT1
 #undef VT2
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
     HPX_API_EXPORT bool get_endpoint(std::string const& addr,
         std::uint16_t port, boost::asio::ip::tcp::endpoint& ep);
@@ -36,8 +35,8 @@ namespace hpx { namespace util
 
     ///////////////////////////////////////////////////////////////////////////
     // properly resolve a give host name to the corresponding IP address
-    HPX_API_EXPORT boost::asio::ip::tcp::endpoint
-    resolve_hostname(std::string const& hostname, std::uint16_t port,
+    HPX_API_EXPORT boost::asio::ip::tcp::endpoint resolve_hostname(
+        std::string const& hostname, std::uint16_t port,
         boost::asio::io_service& io_service);
 
     ///////////////////////////////////////////////////////////////////////////
@@ -46,20 +45,19 @@ namespace hpx { namespace util
 
     ///////////////////////////////////////////////////////////////////////
     // Take an ip v4 or v6 address and "standardize" it for comparison checks
-    HPX_API_EXPORT std::string cleanup_ip_address(const std::string &addr);
+    HPX_API_EXPORT std::string cleanup_ip_address(const std::string& addr);
 
     typedef boost::asio::ip::tcp::resolver::iterator endpoint_iterator_type;
 
-    endpoint_iterator_type HPX_EXPORT connect_begin(
-        std::string const & address, std::uint16_t port,
-        boost::asio::io_service& io_service);
+    endpoint_iterator_type HPX_EXPORT connect_begin(std::string const& address,
+        std::uint16_t port, boost::asio::io_service& io_service);
 
     /// \brief Returns an iterator which when dereferenced will give an
     ///        endpoint suitable for a call to connect() related to this
     ///        locality
     template <typename Locality>
-    endpoint_iterator_type connect_begin(Locality const& loc,
-        boost::asio::io_service& io_service)
+    endpoint_iterator_type connect_begin(
+        Locality const& loc, boost::asio::io_service& io_service)
     {
         return connect_begin(loc.address(), loc.port(), io_service);
     }
@@ -69,35 +67,33 @@ namespace hpx { namespace util
         return endpoint_iterator_type();
     }
 
-    endpoint_iterator_type HPX_EXPORT accept_begin(
-        std::string const & address, std::uint16_t port,
-        boost::asio::io_service& io_service);
+    endpoint_iterator_type HPX_EXPORT accept_begin(std::string const& address,
+        std::uint16_t port, boost::asio::io_service& io_service);
 
     ///////////////////////////////////////////////////////////////////////////
     /// \brief Returns an iterator which when dereferenced will give an
     ///        endpoint suitable for a call to accept() related to this
     ///        locality
     template <typename Locality>
-    endpoint_iterator_type accept_begin(Locality const& loc,
-        boost::asio::io_service& io_service)
+    endpoint_iterator_type accept_begin(
+        Locality const& loc, boost::asio::io_service& io_service)
     {
         return accept_begin(loc.address(), loc.port(), io_service);
     }
 
-    inline endpoint_iterator_type accept_end() //-V524
+    inline endpoint_iterator_type accept_end()    //-V524
     {
         return endpoint_iterator_type();
     }
-}}
+}}    // namespace hpx::util
 
 #endif
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////
     // Addresses are supposed to have the format <hostname>[:port]
-    HPX_API_EXPORT bool split_ip_address(std::string const& v,
-        std::string& host, std::uint16_t& port);
-}}
+    HPX_API_EXPORT bool split_ip_address(
+        std::string const& v, std::string& host, std::uint16_t& port);
+}}    // namespace hpx::util
 
 #endif
diff --git a/hpx/util/map_hostnames.hpp b/libs/asio/include/hpx/asio/map_hostnames.hpp
similarity index 85%
rename from hpx/util/map_hostnames.hpp
rename to libs/asio/include/hpx/asio/map_hostnames.hpp
index 2991cb4ef6..9041d753d6 100644
--- a/hpx/util/map_hostnames.hpp
+++ b/libs/asio/include/hpx/asio/map_hostnames.hpp
@@ -15,22 +15,22 @@
 
 #if defined(HPX_MSVC_WARNING_PRAGMA)
 #pragma warning(push)
-#pragma warning(disable:4251)
+#pragma warning(disable : 4251)
 #endif
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
     // Try to map a given host name based on the list of mappings read from a
     // file
     struct HPX_EXPORT map_hostnames
     {
-        typedef util::function_nonser<
-            std::string(std::string const&)> transform_function_type;
+        typedef util::function_nonser<std::string(std::string const&)>
+            transform_function_type;
 
         map_hostnames(bool debug = false)
           : debug_(debug)
-        {}
+        {
+        }
 
         void use_suffix(std::string const& suffix)
         {
@@ -49,13 +49,13 @@ namespace hpx { namespace util
 
         std::string map(std::string host_name, std::uint16_t port) const;
 
-      private:
+    private:
         transform_function_type transform_;
         std::string suffix_;
         std::string prefix_;
         bool debug_;
     };
-}}
+}}    // namespace hpx::util
 
 #if defined(HPX_MSVC_WARNING_PRAGMA)
 #pragma warning(pop)
diff --git a/libs/asio/include_compatibility/hpx/util/asio_util.hpp b/libs/asio/include_compatibility/hpx/util/asio_util.hpp
new file mode 100644
index 0000000000..8a6ce7fcab
--- /dev/null
+++ b/libs/asio/include_compatibility/hpx/util/asio_util.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/asio/config/defines.hpp>
+#include <hpx/asio/asio_util.hpp>
+
+#if defined(HPX_ASIO_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/asio_util.hpp is deprecated, \
+    please include hpx/asio/asio_util.hpp instead")
+#else
+#warning "The header hpx/util/asio_util.hpp is deprecated, \
+    please include hpx/asio/asio_util.hpp instead"
+#endif
+#endif
diff --git a/libs/asio/include_compatibility/hpx/util/map_hostnames.hpp b/libs/asio/include_compatibility/hpx/util/map_hostnames.hpp
new file mode 100644
index 0000000000..f5fe3b4913
--- /dev/null
+++ b/libs/asio/include_compatibility/hpx/util/map_hostnames.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/asio/config/defines.hpp>
+#include <hpx/asio/map_hostnames.hpp>
+
+#if defined(HPX_ASIO_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/map_hostnames.hpp is deprecated, \
+    please include hpx/asio/map_hostnames.hpp instead")
+#else
+#warning "The header hpx/util/map_hostnames.hpp is deprecated, \
+    please include hpx/asio/map_hostnames.hpp instead"
+#endif
+#endif
diff --git a/src/util/asio_util.cpp b/libs/asio/src/asio_util.cpp
similarity index 71%
rename from src/util/asio_util.cpp
rename to libs/asio/src/asio_util.cpp
index 92f030dbe5..7772127957 100644
--- a/src/util/asio_util.cpp
+++ b/libs/asio/src/asio_util.cpp
@@ -6,22 +6,21 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstdint>
 #include <string>
 
-#include <boost/lexical_cast.hpp>
-
 #if defined(HPX_HAVE_NETWORKING)
-#include <hpx/assertion.hpp>
 #include <hpx/config/asio.hpp>
+#include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/util/asio_util.hpp>
 
 #include <boost/asio/io_service.hpp>
-#include <boost/asio/ip/host_name.hpp>
 #include <boost/asio/ip/address_v4.hpp>
 #include <boost/asio/ip/address_v6.hpp>
+#include <boost/asio/ip/host_name.hpp>
 #include <boost/asio/ip/tcp.hpp>
 #include <boost/system/error_code.hpp>
 
@@ -36,7 +35,7 @@
 
 #if defined(HPX_MSVC_WARNING_PRAGMA)
 #pragma warning(push)
-#pragma warning(disable:4073)
+#pragma warning(disable : 4073)
 #endif
 #pragma init_seg(lib)
 boost::asio::detail::winsock_init<>::manual manual_winsock_init;
@@ -46,8 +45,7 @@ boost::asio::detail::winsock_init<>::manual manual_winsock_init;
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
     bool get_endpoint(std::string const& addr, std::uint16_t port,
         boost::asio::ip::tcp::endpoint& ep)
@@ -55,13 +53,15 @@ namespace hpx { namespace util
         using namespace boost::asio::ip;
         boost::system::error_code ec;
         address_v4 addr4 = address_v4::from_string(addr.c_str(), ec);
-        if (!ec) {  // it's an IPV4 address
+        if (!ec)
+        {    // it's an IPV4 address
             ep = tcp::endpoint(address(addr4), port);
             return true;
         }
 
         address_v6 addr6 = address_v6::from_string(addr.c_str(), ec);
-        if (!ec) {  // it's an IPV6 address
+        if (!ec)
+        {    // it's an IPV6 address
             ep = tcp::endpoint(address(addr6), port);
             return true;
         }
@@ -76,9 +76,8 @@ namespace hpx { namespace util
 
     ///////////////////////////////////////////////////////////////////////////
     // properly resolve a give host name to the corresponding IP address
-    boost::asio::ip::tcp::endpoint
-    resolve_hostname(std::string const& hostname, std::uint16_t port,
-        boost::asio::io_service& io_service)
+    boost::asio::ip::tcp::endpoint resolve_hostname(std::string const& hostname,
+        std::uint16_t port, boost::asio::io_service& io_service)
     {
         using boost::asio::ip::tcp;
 
@@ -86,51 +85,54 @@ namespace hpx { namespace util
         exception_list errors;
 
         // try to directly create an endpoint from the address
-        try {
+        try
+        {
             tcp::endpoint ep;
             if (util::get_endpoint(hostname, port, ep))
                 return ep;
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // it's not an address, try to treat it as a host name
-        try {
+        try
+        {
             // resolve the given address
             tcp::resolver resolver(io_service);
-            tcp::resolver::query query(hostname,
-                std::to_string(port));
+            tcp::resolver::query query(hostname, std::to_string(port));
 
             boost::asio::ip::tcp::resolver::iterator it =
                 resolver.resolve(query);
             HPX_ASSERT(it != boost::asio::ip::tcp::resolver::iterator());
             return *it;
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // report errors
         std::ostringstream strm;
-        strm << errors.get_message() << " (while trying to resolve: "
-             << hostname << ":" << port << ")";
-        HPX_THROW_EXCEPTION(network_error, "util::resolve_hostname",
-            strm.str());
+        strm << errors.get_message()
+             << " (while trying to resolve: " << hostname << ":" << port << ")";
+        HPX_THROW_EXCEPTION(
+            network_error, "util::resolve_hostname", strm.str());
         return tcp::endpoint();
     }
 
     ///////////////////////////////////////////////////////////////////////////
     // return the public IP address of the local node
-    std::string
-    resolve_public_ip_address()
+    std::string resolve_public_ip_address()
     {
         using boost::asio::ip::tcp;
 
         // collect errors here
         exception_list errors;
 
-        try {
+        try
+        {
             boost::asio::io_service io_service;
             tcp::resolver resolver(io_service);
             tcp::resolver::query query(boost::asio::ip::host_name(), "");
@@ -138,16 +140,17 @@ namespace hpx { namespace util
             tcp::endpoint endpoint = *it;
             return endpoint.address().to_string();
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // report errors
         std::ostringstream strm;
         strm << errors.get_message()
-                << " (while trying to resolve public ip address)";
-        HPX_THROW_EXCEPTION(network_error, "util::resolve_public_ip_address",
-            strm.str());
+             << " (while trying to resolve public ip address)";
+        HPX_THROW_EXCEPTION(
+            network_error, "util::resolve_public_ip_address", strm.str());
         return "";
     }
 
@@ -155,7 +158,7 @@ namespace hpx { namespace util
     // Take an ip v4 or v6 address and "standardize" it for comparison checks
     // note that this code doesn't work as expected if we use the boost
     // inet_pton functions on linux. see issue #2177 for further info
-    std::string cleanup_ip_address(const std::string &addr)
+    std::string cleanup_ip_address(const std::string& addr)
     {
         char buf[sizeof(struct in6_addr)];
         int i = 0, domain[2] = {AF_INET, AF_INET6};
@@ -186,20 +189,21 @@ namespace hpx { namespace util
         }
 
 #if defined(HPX_WINDOWS)
-       if (boost::asio::detail::socket_ops::inet_ntop(
-            domain[i], buf, str, INET6_ADDRSTRLEN, scope_id, ec) == nullptr) {
+        if (boost::asio::detail::socket_ops::inet_ntop(
+                domain[i], buf, str, INET6_ADDRSTRLEN, scope_id, ec) == nullptr)
+        {
 #else
-       if (inet_ntop(domain[i], buf, str, INET6_ADDRSTRLEN) == nullptr) {
+        if (inet_ntop(domain[i], buf, str, INET6_ADDRSTRLEN) == nullptr)
+        {
 #endif
-           HPX_THROW_EXCEPTION(bad_parameter, "cleanup_ip_address",
-               "inet_ntop failure");
-       }
-       return std::string(str);
+            HPX_THROW_EXCEPTION(
+                bad_parameter, "cleanup_ip_address", "inet_ntop failure");
+        }
+        return std::string(str);
     }
 
-    endpoint_iterator_type connect_begin(std::string const & address,
-        std::uint16_t port,
-        boost::asio::io_service& io_service)
+    endpoint_iterator_type connect_begin(std::string const& address,
+        std::uint16_t port, boost::asio::io_service& io_service)
     {
         using boost::asio::ip::tcp;
 
@@ -209,53 +213,54 @@ namespace hpx { namespace util
         std::string port_str(std::to_string(port));
 
         // try to directly create an endpoint from the address
-        try {
+        try
+        {
             tcp::endpoint ep;
             if (util::get_endpoint(address, port, ep))
             {
 #if BOOST_VERSION < 106600
-                return endpoint_iterator_type(tcp::resolver::iterator::create(
-                    ep, address, port_str));
+                return endpoint_iterator_type(
+                    tcp::resolver::iterator::create(ep, address, port_str));
 #else
-                return endpoint_iterator_type(tcp::resolver::results_type::create(
-                    ep, address, port_str));
+                return endpoint_iterator_type(
+                    tcp::resolver::results_type::create(ep, address, port_str));
 #endif
-}
+            }
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // it's not an address, try to treat it as a host name
-        try {
+        try
+        {
             // resolve the given address
             tcp::resolver resolver(io_service);
             tcp::resolver::query query(
-                !address.empty() ?
-                    address :
-                    boost::asio::ip::host_name(),
+                !address.empty() ? address : boost::asio::ip::host_name(),
                 port_str);
 
             return endpoint_iterator_type(resolver.resolve(query));
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // report errors
         std::ostringstream strm;
-        strm << errors.get_message() << " (while trying to connect to: "
-             << address << ":" << port << ")";
+        strm << errors.get_message()
+             << " (while trying to connect to: " << address << ":" << port
+             << ")";
 
-        HPX_THROW_EXCEPTION(network_error, "connect_begin",
-            strm.str());
+        HPX_THROW_EXCEPTION(network_error, "connect_begin", strm.str());
 
         return endpoint_iterator_type();
     }
 
-    endpoint_iterator_type accept_begin(std::string const & address,
-        std::uint16_t port,
-        boost::asio::io_service& io_service)
+    endpoint_iterator_type accept_begin(std::string const& address,
+        std::uint16_t port, boost::asio::io_service& io_service)
     {
         using boost::asio::ip::tcp;
 
@@ -265,7 +270,8 @@ namespace hpx { namespace util
         std::string port_str(std::to_string(port));
 
         // try to directly create an endpoint from the address
-        try {
+        try
+        {
             tcp::endpoint ep;
             if (util::get_endpoint(address, port, ep))
             {
@@ -278,82 +284,90 @@ namespace hpx { namespace util
 #endif
             }
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // it's not an address, try to treat it as a host name
-        try {
+        try
+        {
             // resolve the given address
             tcp::resolver resolver(io_service);
             tcp::resolver::query query(address, port_str);
 
             return endpoint_iterator_type(resolver.resolve(query));
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // it's not a host name either, create a custom iterator allowing to
         // filter the returned endpoints, for this we use "localhost" as the
         // address to enumerate endpoints
-        try {
+        try
+        {
             // resolve the given address
             tcp::resolver resolver(io_service);
             tcp::resolver::query query(boost::asio::ip::host_name(), port_str);
 
             return endpoint_iterator_type(resolver.resolve(query));
         }
-        catch (boost::system::system_error const&) {
+        catch (boost::system::system_error const&)
+        {
             errors.add(std::current_exception());
         }
 
         // report errors
         std::ostringstream strm;
-        strm << errors.get_message() << " (while trying to resolve: "
-             << address << ":" << port << ")";
+        strm << errors.get_message() << " (while trying to resolve: " << address
+             << ":" << port << ")";
 
-        HPX_THROW_EXCEPTION(network_error, "accept_begin",
-            strm.str());
+        HPX_THROW_EXCEPTION(network_error, "accept_begin", strm.str());
         return endpoint_iterator_type();
     }
-}}
+}}    // namespace hpx::util
 
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////
     // Addresses are supposed to have the format <hostname>[:port]
-    bool split_ip_address(std::string const& v, std::string& host,
-        std::uint16_t& port)
+    bool split_ip_address(
+        std::string const& v, std::string& host, std::uint16_t& port)
     {
         std::string::size_type p = v.find_first_of(':');
 
         std::string tmp_host;
         std::uint16_t tmp_port = 0;
 
-        try {
-            if (p != std::string::npos) {
+        try
+        {
+            if (p != std::string::npos)
+            {
                 tmp_host = v.substr(0, p);
-                tmp_port = boost::lexical_cast<std::uint16_t>(v.substr(p+1));
+                tmp_port =
+                    hpx::util::from_string<std::uint16_t>(v.substr(p + 1));
             }
-            else {
+            else
+            {
                 tmp_host = v;
             }
 
-            if (!tmp_host.empty()) {
+            if (!tmp_host.empty())
+            {
                 host = tmp_host;
                 if (tmp_port)
                     port = tmp_port;
             }
         }
-        catch (boost::bad_lexical_cast const& /*e*/) {
+        catch (hpx::util::bad_lexical_cast const& /*e*/)
+        {
             // port number is invalid
             return false;
         }
         return true;
     }
-}}
-
+}}    // namespace hpx::util
diff --git a/src/util/map_hostnames.cpp b/libs/asio/src/map_hostnames.cpp
similarity index 69%
rename from src/util/map_hostnames.cpp
rename to libs/asio/src/map_hostnames.cpp
index 7db18d6f3e..3427e1e2c5 100644
--- a/src/util/map_hostnames.cpp
+++ b/libs/asio/src/map_hostnames.cpp
@@ -4,10 +4,10 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#include <hpx/errors.hpp>
 #include <hpx/config/asio.hpp>
-#include <hpx/util/map_hostnames.hpp>
-#include <hpx/util/asio_util.hpp>
+#include <hpx/asio/asio_util.hpp>
+#include <hpx/asio/map_hostnames.hpp>
+#include <hpx/errors.hpp>
 
 #include <cstdint>
 #include <iostream>
@@ -18,39 +18,41 @@
 #include <boost/asio/ip/tcp.hpp>
 #endif
 
-namespace hpx { namespace util
-{
-    std::string map_hostnames::map(std::string host_name,
-        std::uint16_t port) const
+namespace hpx { namespace util {
+    std::string map_hostnames::map(
+        std::string host_name, std::uint16_t port) const
     {
-        if (host_name == "localhost") {
+        if (host_name == "localhost")
+        {
             // map local host to loopback ip address (that's a quick hack
             // which will be removed as soon as we figure out why name
             // resolution does not handle this anymore)
-            if (debug_) {
-                std::cerr << "resolved: 'localhost' to: 127.0.0.1"
-                          << std::endl;
+            if (debug_)
+            {
+                std::cerr << "resolved: 'localhost' to: 127.0.0.1" << std::endl;
             }
             return "127.0.0.1";
         }
 
 #if defined(HPX_HAVE_NETWORKING)
-        if (!!transform_) {   // If the transform is not empty
+        if (!!transform_)
+        {    // If the transform is not empty
             host_name = transform_(host_name);
-            if (debug_) {
+            if (debug_)
+            {
                 std::cerr << "host_name(transformed): " << host_name
-                    << std::endl;
+                          << std::endl;
             }
         }
 
         // do full host name resolution
         boost::asio::io_service io_service;
-        boost::asio::ip::tcp::endpoint ep =
-            util::resolve_hostname(prefix_ + host_name + suffix_,
-                port, io_service);
+        boost::asio::ip::tcp::endpoint ep = util::resolve_hostname(
+            prefix_ + host_name + suffix_, port, io_service);
 
         std::string resolved_addr(util::get_endpoint_name(ep));
-        if (debug_) {
+        if (debug_)
+        {
             std::cerr << "resolved: '" << prefix_ + host_name + suffix_
                       << "' to: " << resolved_addr << std::endl;
         }
@@ -59,5 +61,4 @@ namespace hpx { namespace util
         return "127.0.0.1";
 #endif
     }
-}}
-
+}}    // namespace hpx::util
diff --git a/libs/asio/tests/CMakeLists.txt b/libs/asio/tests/CMakeLists.txt
new file mode 100644
index 0000000000..dc36c2798a
--- /dev/null
+++ b/libs/asio/tests/CMakeLists.txt
@@ -0,0 +1,42 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_ASIO_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_ASIO_WITH_TESTS)
+  if (HPX_WITH_TESTS_UNIT)
+    add_hpx_pseudo_target(tests.unit.modules.asio)
+    add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.asio)
+    add_subdirectory(unit)
+  endif()
+
+  if (HPX_WITH_TESTS_REGRESSIONS)
+    add_hpx_pseudo_target(tests.regressions.modules.asio)
+    add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.asio)
+    add_subdirectory(regressions)
+  endif()
+
+  if (HPX_WITH_TESTS_BENCHMARKS)
+    add_hpx_pseudo_target(tests.performance.modules.asio)
+    add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.asio)
+    add_subdirectory(performance)
+  endif()
+
+  if (HPX_WITH_TESTS_HEADERS)
+    add_hpx_header_tests(
+      modules.asio
+      HEADERS ${asio_headers}
+      HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+      NOLIBS
+      DEPENDENCIES hpx_asio)
+  endif()
+endif()
diff --git a/libs/resource_partitioner/tests/unit/CMakeLists.txt.bak b/libs/asio/tests/performance/CMakeLists.txt
similarity index 100%
rename from libs/resource_partitioner/tests/unit/CMakeLists.txt.bak
rename to libs/asio/tests/performance/CMakeLists.txt
diff --git a/libs/asio/tests/regressions/CMakeLists.txt b/libs/asio/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/asio/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/python/hpx/__init__.py b/libs/asio/tests/unit/CMakeLists.txt
similarity index 82%
rename from python/hpx/__init__.py
rename to libs/asio/tests/unit/CMakeLists.txt
index b4914cf08a..e050627465 100644
--- a/python/hpx/__init__.py
+++ b/libs/asio/tests/unit/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (c) 2011 Bryce Lelbach
+# Copyright (c) 2019 The STE||AR-Group
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
diff --git a/libs/assertion/CMakeLists.txt b/libs/assertion/CMakeLists.txt
index 2fd9b765a5..e9533ae4fd 100644
--- a/libs/assertion/CMakeLists.txt
+++ b/libs/assertion/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/assertion/README.rst b/libs/assertion/README.rst
index e5ecadc4b5..0a50cd46a1 100644
--- a/libs/assertion/README.rst
+++ b/libs/assertion/README.rst
@@ -13,4 +13,4 @@ This library is part of HPX. It implements ``HPX_ASSERT`` and ``HPX_ASSERT_MSG``
 which are useful to implement error handling for debug builds.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/assert/docs/index.html>`_.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/assert/docs/index.html>`_.
diff --git a/libs/assertion/include/hpx/assertion/current_function.hpp b/libs/assertion/include/hpx/assertion/current_function.hpp
index 6c28b697fc..4f9705ad84 100644
--- a/libs/assertion/include/hpx/assertion/current_function.hpp
+++ b/libs/assertion/include/hpx/assertion/current_function.hpp
@@ -17,7 +17,7 @@
 
 namespace hpx { namespace assertion { namespace detail {
 
-    HPX_CXX14_CONSTEXPR inline void current_function_helper()
+    constexpr inline void current_function_helper()
     {
 #if defined(__GNUC__) || (defined(__MWERKS__) && (__MWERKS__ >= 0x3000)) ||    \
     (defined(__ICC) && (__ICC >= 600)) || defined(__ghs__) ||                  \
diff --git a/libs/basic_execution/CMakeLists.txt b/libs/basic_execution/CMakeLists.txt
index 25358f1bf0..440c3112d9 100644
--- a/libs/basic_execution/CMakeLists.txt
+++ b/libs/basic_execution/CMakeLists.txt
@@ -4,10 +4,9 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(basic_execution_headers
-  hpx/basic_execution.hpp
   hpx/basic_execution/agent_base.hpp
   hpx/basic_execution/agent_ref.hpp
   hpx/basic_execution/context_base.hpp
@@ -17,7 +16,9 @@ set(basic_execution_headers
 )
 
 set(basic_execution_compat_headers
+  hpx/synchronization/detail/yield_k.hpp
   hpx/util/register_locks.hpp
+  hpx/util/yield_while.hpp
 )
 
 set(basic_execution_sources
@@ -31,6 +32,7 @@ add_hpx_module(basic_execution
   COMPATIBILITY_HEADERS ON
   DEPRECATION_WARNINGS
   FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
   SOURCES ${basic_execution_sources}
   HEADERS ${basic_execution_headers}
   COMPAT_HEADERS ${basic_execution_compat_headers}
diff --git a/libs/basic_execution/README.rst b/libs/basic_execution/README.rst
index e28b97d226..f6aa2ce44f 100644
--- a/libs/basic_execution/README.rst
+++ b/libs/basic_execution/README.rst
@@ -13,4 +13,4 @@ Basic Execution
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/basic_execution/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/basic_execution/docs/index.html>`__.
diff --git a/libs/basic_execution/include/hpx/basic_execution.hpp b/libs/basic_execution/include/hpx/basic_execution.hpp
deleted file mode 100644
index 169d05a154..0000000000
--- a/libs/basic_execution/include/hpx/basic_execution.hpp
+++ /dev/null
@@ -1,17 +0,0 @@
-//  Copyright (c) 2019 Thomas Heller
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef HPX_BASIC_EXECUTION_HPP
-#define HPX_BASIC_EXECUTION_HPP
-
-#include <hpx/basic_execution/agent_base.hpp>
-#include <hpx/basic_execution/agent_ref.hpp>
-#include <hpx/basic_execution/context_base.hpp>
-#include <hpx/basic_execution/register_locks.hpp>
-#include <hpx/basic_execution/resource_base.hpp>
-#include <hpx/basic_execution/this_thread.hpp>
-
-#endif
diff --git a/libs/basic_execution/include/hpx/basic_execution/agent_ref.hpp b/libs/basic_execution/include/hpx/basic_execution/agent_ref.hpp
index 4c08cc090c..9fb64f8348 100644
--- a/libs/basic_execution/include/hpx/basic_execution/agent_ref.hpp
+++ b/libs/basic_execution/include/hpx/basic_execution/agent_ref.hpp
@@ -31,12 +31,10 @@ namespace hpx { namespace basic_execution {
         }
 
         constexpr agent_ref(agent_ref const&) noexcept = default;
-        HPX_CXX14_CONSTEXPR agent_ref& operator=(
-            agent_ref const&) noexcept = default;
+        constexpr agent_ref& operator=(agent_ref const&) noexcept = default;
 
         constexpr agent_ref(agent_ref&&) noexcept = default;
-        HPX_CXX14_CONSTEXPR agent_ref& operator=(
-            agent_ref&&) noexcept = default;
+        constexpr agent_ref& operator=(agent_ref&&) noexcept = default;
 
         constexpr explicit operator bool() const noexcept
         {
diff --git a/libs/basic_execution/include/hpx/basic_execution/register_locks.hpp b/libs/basic_execution/include/hpx/basic_execution/register_locks.hpp
index 6d33d2d07e..93f18bc390 100644
--- a/libs/basic_execution/include/hpx/basic_execution/register_locks.hpp
+++ b/libs/basic_execution/include/hpx/basic_execution/register_locks.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2014 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2014 Thomas Heller
 //
 //  SPDX-License-Identifier: BSL-1.0
@@ -38,6 +38,7 @@ namespace hpx { namespace util {
     HPX_API_EXPORT void verify_no_locks();
     HPX_API_EXPORT void force_error_on_lock();
     HPX_API_EXPORT void enable_lock_detection();
+    HPX_API_EXPORT void disable_lock_detection();
     HPX_API_EXPORT void ignore_lock(void const* lock);
     HPX_API_EXPORT void reset_ignored(void const* lock);
     HPX_API_EXPORT void ignore_all_locks();
@@ -123,6 +124,7 @@ namespace hpx { namespace util {
     inline void verify_no_locks() {}
     inline void force_error_on_lock() {}
     inline void enable_lock_detection() {}
+    inline void disable_lock_detection() {}
     inline void ignore_lock(void const* /*lock*/) {}
     inline void reset_ignored(void const* /*lock*/) {}
 
diff --git a/libs/basic_execution/include/hpx/basic_execution/this_thread.hpp b/libs/basic_execution/include/hpx/basic_execution/this_thread.hpp
index 4f132c4e5a..8ac8124b01 100644
--- a/libs/basic_execution/include/hpx/basic_execution/this_thread.hpp
+++ b/libs/basic_execution/include/hpx/basic_execution/this_thread.hpp
@@ -12,6 +12,10 @@
 #include <hpx/basic_execution/agent_ref.hpp>
 #include <hpx/timing/steady_clock.hpp>
 
+#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
+#include <hpx/errors/throw_exception.hpp>
+#endif
+
 #include <chrono>
 #include <cstddef>
 #include <cstdint>
@@ -58,4 +62,46 @@ namespace hpx { namespace basic_execution { namespace this_thread {
     }
 }}}    // namespace hpx::basic_execution::this_thread
 
+namespace hpx { namespace util {
+    namespace detail {
+#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
+        HPX_API_EXPORT extern bool spinlock_break_on_deadlock;
+        HPX_API_EXPORT extern std::size_t spinlock_deadlock_detection_limit;
+#endif
+
+        inline void yield_k(std::size_t k, const char* thread_name)
+        {
+#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
+            if (k > 32 && spinlock_break_on_deadlock &&
+                k > spinlock_deadlock_detection_limit)
+            {
+                HPX_THROW_EXCEPTION(
+                    deadlock, thread_name, "possible deadlock detected");
+            }
+#endif
+            hpx::basic_execution::this_thread::yield_k(k, thread_name);
+        }
+    }    // namespace detail
+
+    template <typename Predicate>
+    inline void yield_while(Predicate&& predicate,
+        const char* thread_name = nullptr, bool allow_timed_suspension = true)
+    {
+        if (allow_timed_suspension)
+        {
+            for (std::size_t k = 0; predicate(); ++k)
+            {
+                detail::yield_k(k, thread_name);
+            }
+        }
+        else
+        {
+            for (std::size_t k = 0; predicate(); ++k)
+            {
+                detail::yield_k(k % 32, thread_name);
+            }
+        }
+    }
+}}    // namespace hpx::util
+
 #endif
diff --git a/libs/basic_execution/include_compatibility/hpx/synchronization/detail/yield_k.hpp b/libs/basic_execution/include_compatibility/hpx/synchronization/detail/yield_k.hpp
new file mode 100644
index 0000000000..fea3c25f92
--- /dev/null
+++ b/libs/basic_execution/include_compatibility/hpx/synchronization/detail/yield_k.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Mikael Simberg
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/basic_execution/config/defines.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
+
+#if defined(HPX_BASIC_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/synchronization/detail/yield_k.hpp is deprecated, \
+    please include hpx/basic_execution/this_thread.hpp instead")
+#else
+#warning "The header hpx/synchronization/detail/yield_k.hpp is deprecated, \
+    please include hpx/basic_execution/this_thread.hpp instead"
+#endif
+#endif
diff --git a/libs/basic_execution/include_compatibility/hpx/util/yield_while.hpp b/libs/basic_execution/include_compatibility/hpx/util/yield_while.hpp
new file mode 100644
index 0000000000..771cc75991
--- /dev/null
+++ b/libs/basic_execution/include_compatibility/hpx/util/yield_while.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Mikael Simberg
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/basic_execution/config/defines.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
+
+#if defined(HPX_BASIC_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/yield_while.hpp is deprecated, \
+    please include hpx/basic_execution/this_thread.hpp instead")
+#else
+#warning "The header hpx/util/yield_while.hpp is deprecated, \
+    please include hpx/basic_execution/this_thread.hpp instead"
+#endif
+#endif
diff --git a/libs/basic_execution/src/register_locks.cpp b/libs/basic_execution/src/register_locks.cpp
index 70603ef2f7..ee183fb688 100644
--- a/libs/basic_execution/src/register_locks.cpp
+++ b/libs/basic_execution/src/register_locks.cpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2014 Thomas Heller
 //
 //  SPDX-License-Identifier: BSL-1.0
@@ -70,7 +70,7 @@ namespace hpx { namespace util {
                 bool ignore_all_locks_;
             };
 
-            static HPX_NATIVE_TLS held_locks_data held_locks_;
+            static thread_local held_locks_data held_locks_;
 
             static bool lock_detection_enabled_;
 
@@ -100,7 +100,7 @@ namespace hpx { namespace util {
             }
         };
 
-        HPX_NATIVE_TLS register_locks::held_locks_data
+        thread_local register_locks::held_locks_data
             register_locks::held_locks_;
         bool register_locks::lock_detection_enabled_ = false;
 
@@ -126,6 +126,11 @@ namespace hpx { namespace util {
         detail::register_locks::lock_detection_enabled_ = true;
     }
 
+    void disable_lock_detection()
+    {
+        detail::register_locks::lock_detection_enabled_ = false;
+    }
+
     static registered_locks_error_handler_type registered_locks_error_handler;
 
     void set_registered_locks_error_handler(
diff --git a/libs/basic_execution/tests/unit/CMakeLists.txt b/libs/basic_execution/tests/unit/CMakeLists.txt
index 4a86b0e67b..bea515105e 100644
--- a/libs/basic_execution/tests/unit/CMakeLists.txt
+++ b/libs/basic_execution/tests/unit/CMakeLists.txt
@@ -16,6 +16,7 @@ foreach(test ${tests})
 
   # add example executable
   add_hpx_executable(${test}_test
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      NOLIBS
                      DEPENDENCIES
diff --git a/libs/basic_execution/tests/unit/execution_context.cpp b/libs/basic_execution/tests/unit/execution_context.cpp
index eda6cbdad6..a0c543c7d3 100644
--- a/libs/basic_execution/tests/unit/execution_context.cpp
+++ b/libs/basic_execution/tests/unit/execution_context.cpp
@@ -165,11 +165,11 @@ void test_sleep()
     auto now = std::chrono::steady_clock::now();
     auto sleep_duration = std::chrono::milliseconds(100);
     hpx::basic_execution::this_thread::sleep_for(sleep_duration);
-    HPX_TEST(std::chrono::steady_clock::now() >= now + sleep_duration);
+    HPX_TEST(now + sleep_duration <= std::chrono::steady_clock::now());
 
     auto sleep_time = sleep_duration * 2 + std::chrono::steady_clock::now();
     hpx::basic_execution::this_thread::sleep_until(sleep_time);
-    HPX_TEST(std::chrono::steady_clock::now() >= now + sleep_duration * 2);
+    HPX_TEST(now + sleep_duration * 2 <= std::chrono::steady_clock::now());
 }
 
 int main()
diff --git a/libs/batch_environments/CMakeLists.txt b/libs/batch_environments/CMakeLists.txt
index 12aeacdd89..7e40ec8423 100644
--- a/libs/batch_environments/CMakeLists.txt
+++ b/libs/batch_environments/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -39,10 +39,12 @@ add_hpx_module(batch_environments
   HEADERS ${batch_environments_headers}
   COMPAT_HEADERS ${batch_environments_compat_headers}
   DEPENDENCIES
+    hpx_asio
     hpx_assertion
     hpx_config
     hpx_errors
     hpx_format
+    hpx_string_util
     hpx_util
   CMAKE_SUBDIRS examples tests
 )
diff --git a/libs/batch_environments/README.rst b/libs/batch_environments/README.rst
index 137e9945ab..d3a25f63ec 100644
--- a/libs/batch_environments/README.rst
+++ b/libs/batch_environments/README.rst
@@ -13,4 +13,4 @@ batch_environments
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/batch_environments/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/batch_environments/docs/index.html>`__.
diff --git a/libs/batch_environments/docs/index.rst b/libs/batch_environments/docs/index.rst
index d645abbe92..320320fe9d 100644
--- a/libs/batch_environments/docs/index.rst
+++ b/libs/batch_environments/docs/index.rst
@@ -11,3 +11,14 @@
 batch_environments
 ==================
 
+This module allows for the detection of execution as batch jobs, a series of
+programs executed without user intervention. All data is preselected and will
+be executed according to preset parameters, such as date or completion of
+another task. Batch environments are especially useful for executing repetitive
+tasks.
+
+|hpx| supports the creation of batch jobs through the Portable Batch System
+(PBS) and SLURM.
+
+For more information on batch environments, see :ref:`running_on_batch_systems`
+and the :ref:`API reference <libs_batch_environments_api>` for the module.
diff --git a/libs/batch_environments/src/alps_environment.cpp b/libs/batch_environments/src/alps_environment.cpp
index 30788178a9..d77fbb0550 100644
--- a/libs/batch_environments/src/alps_environment.cpp
+++ b/libs/batch_environments/src/alps_environment.cpp
@@ -6,7 +6,7 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/batch_environments/alps_environment.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <string>
@@ -25,7 +25,7 @@ namespace hpx { namespace util { namespace batch_environments {
         if (valid_)
         {
             // Initialize our node number
-            node_num_ = safe_lexical_cast<std::size_t>(node_num);
+            node_num_ = from_string<std::size_t>(node_num);
 
             // Get the number of threads
             char* num_threads = std::getenv("ALPS_APP_DEPTH");
@@ -34,7 +34,7 @@ namespace hpx { namespace util { namespace batch_environments {
                 valid_ = false;
                 return;
             }
-            num_threads_ = safe_lexical_cast<std::size_t>(num_threads);
+            num_threads_ = from_string<std::size_t>(num_threads);
 
             // Get the number of localities
             char* total_num_threads = std::getenv("PBS_NP");
@@ -44,8 +44,7 @@ namespace hpx { namespace util { namespace batch_environments {
                 return;
             }
             num_localities_ =
-                safe_lexical_cast<std::size_t>(total_num_threads) /
-                num_threads_;
+                from_string<std::size_t>(total_num_threads) / num_threads_;
         }
     }
 }}}    // namespace hpx::util::batch_environments
diff --git a/libs/batch_environments/src/batch_environment.cpp b/libs/batch_environments/src/batch_environment.cpp
index 1308f2ab47..cdf33dc45c 100644
--- a/libs/batch_environments/src/batch_environment.cpp
+++ b/libs/batch_environments/src/batch_environment.cpp
@@ -5,11 +5,11 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/config/asio.hpp>
 #include <hpx/batch_environments/alps_environment.hpp>
 #include <hpx/batch_environments/batch_environment.hpp>
 #include <hpx/batch_environments/pbs_environment.hpp>
 #include <hpx/batch_environments/slurm_environment.hpp>
-#include <hpx/config/asio.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/util/asio_util.hpp>
 
diff --git a/libs/batch_environments/src/pbs_environment.cpp b/libs/batch_environments/src/pbs_environment.cpp
index f91b8fc419..af625ab190 100644
--- a/libs/batch_environments/src/pbs_environment.cpp
+++ b/libs/batch_environments/src/pbs_environment.cpp
@@ -8,7 +8,7 @@
 #include <hpx/batch_environments/pbs_environment.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/format.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <fstream>
@@ -30,8 +30,7 @@ namespace hpx { namespace util { namespace batch_environments {
         if (valid_)
         {
             // Initialize our node number
-            node_num_ =
-                safe_lexical_cast<std::size_t>(node_num, std::size_t(1));
+            node_num_ = from_string<std::size_t>(node_num, std::size_t(1));
 
             if (nodelist.empty())
             {
@@ -51,7 +50,7 @@ namespace hpx { namespace util { namespace batch_environments {
             {
                 // Initialize number of cores to run on
                 num_threads_ =
-                    safe_lexical_cast<std::size_t>(thread_num, std::size_t(-1));
+                    from_string<std::size_t>(thread_num, std::size_t(-1));
             }
         }
     }
diff --git a/libs/batch_environments/src/slurm_environment.cpp b/libs/batch_environments/src/slurm_environment.cpp
index 819044e34a..6e8502acea 100644
--- a/libs/batch_environments/src/slurm_environment.cpp
+++ b/libs/batch_environments/src/slurm_environment.cpp
@@ -5,17 +5,15 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/batch_environments/slurm_environment.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/util/from_string.hpp>
 
 #define BOOST_SPIRIT_USE_PHOENIX_V3
 
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
 #include <boost/fusion/include/pair.hpp>
 #include <boost/phoenix/bind.hpp>
 #include <boost/phoenix/core.hpp>
@@ -41,7 +39,7 @@ namespace hpx { namespace util { namespace batch_environments {
         if (valid_)
         {
             // Initialize our node number
-            node_num_ = safe_lexical_cast<std::size_t>(node_num);
+            node_num_ = from_string<std::size_t>(node_num);
 
             // Retrieve number of localities
             retrieve_number_of_localities(debug);
@@ -65,7 +63,7 @@ namespace hpx { namespace util { namespace batch_environments {
         char* total_num_tasks = std::getenv("SLURM_STEP_NUM_TASKS");
         if (total_num_tasks)
         {
-            num_localities_ = safe_lexical_cast<std::size_t>(total_num_tasks);
+            num_localities_ = from_string<std::size_t>(total_num_tasks);
         }
         else
         {
@@ -86,15 +84,14 @@ namespace hpx { namespace util { namespace batch_environments {
         if (slurm_step_tasks_per_node)
         {
             std::vector<std::string> tokens;
-            boost::split(
-                tokens, slurm_step_tasks_per_node, boost::is_any_of(","));
+            hpx::string_util::split(tokens, slurm_step_tasks_per_node,
+                hpx::string_util::is_any_of(","));
 
             char* slurm_node_id = std::getenv("SLURM_NODEID");
             HPX_ASSERT(slurm_node_id != nullptr);
             if (slurm_node_id)
             {
-                std::size_t node_id =
-                    safe_lexical_cast<std::size_t>(slurm_node_id);
+                std::size_t node_id = from_string<std::size_t>(slurm_node_id);
                 std::size_t task_count = 0;
                 for (auto& token : tokens)
                 {
@@ -105,7 +102,7 @@ namespace hpx { namespace util { namespace batch_environments {
                         HPX_ASSERT(token[token.size() - 1] == ')');
                         std::size_t begin = paren_pos + 2;
                         std::size_t end = token.size() - 1;
-                        task_count += safe_lexical_cast<std::size_t>(
+                        task_count += from_string<std::size_t>(
                             token.substr(paren_pos + 2, end - begin));
                     }
                     else
@@ -115,7 +112,7 @@ namespace hpx { namespace util { namespace batch_environments {
 
                     if (task_count > node_id)
                     {
-                        num_tasks_ = safe_lexical_cast<std::size_t>(
+                        num_tasks_ = from_string<std::size_t>(
                             token.substr(0, paren_pos));
                         break;
                     }
@@ -180,11 +177,10 @@ namespace hpx { namespace util { namespace batch_environments {
                         }
                         else
                         {
-                            using hpx::util::safe_lexical_cast;
                             std::size_t begin =
-                                safe_lexical_cast<std::size_t>(range[0]);
+                                from_string<std::size_t>(range[0]);
                             std::size_t end =
-                                safe_lexical_cast<std::size_t>(range[1]);
+                                from_string<std::size_t>(range[1]);
                             if (begin > end)
                                 std::swap(begin, end);
 
@@ -310,7 +306,7 @@ namespace hpx { namespace util { namespace batch_environments {
     {
         char* slurm_cpus_per_task = std::getenv("SLURM_CPUS_PER_TASK");
         if (slurm_cpus_per_task)
-            num_threads_ = safe_lexical_cast<std::size_t>(slurm_cpus_per_task);
+            num_threads_ = from_string<std::size_t>(slurm_cpus_per_task);
         else
         {
             char* slurm_job_cpus_on_node =
@@ -319,15 +315,15 @@ namespace hpx { namespace util { namespace batch_environments {
             if (slurm_job_cpus_on_node)
             {
                 std::vector<std::string> tokens;
-                boost::split(
-                    tokens, slurm_job_cpus_on_node, boost::is_any_of(","));
+                hpx::string_util::split(tokens, slurm_job_cpus_on_node,
+                    hpx::string_util::is_any_of(","));
 
                 char* slurm_node_id = std::getenv("SLURM_NODEID");
                 HPX_ASSERT(slurm_node_id != nullptr);
                 if (slurm_node_id)
                 {
                     std::size_t node_id =
-                        safe_lexical_cast<std::size_t>(slurm_node_id);
+                        from_string<std::size_t>(slurm_node_id);
                     std::size_t task_count = 0;
                     for (auto& token : tokens)
                     {
@@ -338,7 +334,7 @@ namespace hpx { namespace util { namespace batch_environments {
                             HPX_ASSERT(token[token.size() - 1] == ')');
                             std::size_t begin = paren_pos + 2;
                             std::size_t end = token.size() - 1;
-                            task_count += safe_lexical_cast<std::size_t>(
+                            task_count += from_string<std::size_t>(
                                 token.substr(paren_pos + 2, end - begin));
                         }
                         else
@@ -347,7 +343,7 @@ namespace hpx { namespace util { namespace batch_environments {
                         }
                         if (task_count > node_id)
                         {
-                            num_threads_ = safe_lexical_cast<std::size_t>(
+                            num_threads_ = from_string<std::size_t>(
                                                token.substr(0, paren_pos)) /
                                 num_tasks_;
                             break;
diff --git a/libs/batch_environments/tests/unit/CMakeLists.txt b/libs/batch_environments/tests/unit/CMakeLists.txt
index c937b99bc0..cd7a787252 100644
--- a/libs/batch_environments/tests/unit/CMakeLists.txt
+++ b/libs/batch_environments/tests/unit/CMakeLists.txt
@@ -16,6 +16,7 @@ foreach(test ${tests})
   source_group("Source Files" FILES ${sources})
 
   add_hpx_executable(${test}_test
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${test}_FLAGS}
                      EXCLUDE_FROM_ALL
diff --git a/libs/cache/CMakeLists.txt b/libs/cache/CMakeLists.txt
index 41ef79d3aa..2ddceb82ae 100644
--- a/libs/cache/CMakeLists.txt
+++ b/libs/cache/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/cache/README.rst b/libs/cache/README.rst
index 14672a24b1..26deba1102 100644
--- a/libs/cache/README.rst
+++ b/libs/cache/README.rst
@@ -13,4 +13,4 @@ cache
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/cache/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/cache/docs/index.html>`__.
diff --git a/libs/cache/include/hpx/cache/local_cache.hpp b/libs/cache/include/hpx/cache/local_cache.hpp
index 3bb7542c0a..06946b279b 100644
--- a/libs/cache/include/hpx/cache/local_cache.hpp
+++ b/libs/cache/include/hpx/cache/local_cache.hpp
@@ -180,7 +180,7 @@ namespace hpx { namespace util { namespace cache {
         ///
         /// \returns    This function returns \a true if successful. It returns
         ///             \a false if the new \a max_size is smaller than the
-        ///             current limit and the cache could not be shrinked to
+        ///             current limit and the cache could not be shrunk to
         ///             the new maximum size.
         bool reserve(size_type max_size)
         {
diff --git a/libs/cache/tests/unit/local_lru_cache.cpp b/libs/cache/tests/unit/local_lru_cache.cpp
index b63730349e..985c32699d 100644
--- a/libs/cache/tests/unit/local_lru_cache.cpp
+++ b/libs/cache/tests/unit/local_lru_cache.cpp
@@ -38,17 +38,17 @@ void test_lru_insert()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     // there should be 3 items in the cache
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -59,7 +59,7 @@ void test_lru_insert_with_touch()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert 3 items into the cache
     int i = 0;
@@ -68,25 +68,25 @@ void test_lru_insert_with_touch()
     for (/**/; i < 3 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 
     // now touch the first item
     std::string white;
     HPX_TEST(c.get_entry("white", white));
-    HPX_TEST(white == "255,255,255");
+    HPX_TEST_EQ(white, "255,255,255");
 
     // add two more items
     for (i = 0; i < 2 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 == c.size());
+        HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
     }
 
     // there should be 3 items in the cache, and white should be there as well
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
     HPX_TEST(c.holds_key("white"));
 }
 
@@ -98,19 +98,19 @@ void test_lru_clear()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     c.clear();
 
     // there should be no items in the cache
-    HPX_TEST(0 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(0), c.size());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -137,13 +137,13 @@ void test_lru_erase_one()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     entry_type blue;
@@ -153,7 +153,7 @@ void test_lru_erase_one()
 
     // there should be 2 items in the cache
     HPX_TEST(!c.get_entry("blue", blue));
-    HPX_TEST(2 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(2), c.size());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -164,7 +164,7 @@ void test_lru_update()
 
     cache_type c(4);    // this time we can hold 4 items
 
-    HPX_TEST(4 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.capacity());
 
     // insert 3 items into the cache
     int i = 0;
@@ -173,22 +173,22 @@ void test_lru_update()
     for (/**/; i < 3 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     // there should be 3 items in the cache
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 
     // now update some items
     HPX_TEST(c.update("black", "255,0,0"));    // isn't in the cache
-    HPX_TEST(4 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.size());
 
     HPX_TEST(c.update("yellow", "255,0,0"));
-    HPX_TEST(4 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.size());
 
     std::string yellow;
     HPX_TEST(c.get_entry("yellow", yellow));
-    HPX_TEST(yellow == "255,0,0");
+    HPX_TEST_EQ(yellow, "255,0,0");
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/libs/cache/tests/unit/local_mru_cache.cpp b/libs/cache/tests/unit/local_mru_cache.cpp
index 92183c1bcd..dc3944efa5 100644
--- a/libs/cache/tests/unit/local_mru_cache.cpp
+++ b/libs/cache/tests/unit/local_mru_cache.cpp
@@ -42,17 +42,17 @@ void test_mru_insert()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     // there should be 3 items in the cache
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -65,7 +65,7 @@ void test_mru_insert_with_touch()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert 3 items into the cache
     int i = 0;
@@ -74,30 +74,30 @@ void test_mru_insert_with_touch()
     for (/**/; i < 3 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 
     // now touch the first two items (will now be ejected first, even if they
     // are the oldest)
     std::string white;
     HPX_TEST(c.get_entry("white", white));
-    HPX_TEST(white == "255,255,255");
+    HPX_TEST_EQ(white, "255,255,255");
 
     std::string yellow;
     HPX_TEST(c.get_entry("yellow", yellow));
-    HPX_TEST(yellow == "255,255,0");
+    HPX_TEST_EQ(yellow, "255,255,0");
 
     // add two more items
     for (i = 0; i < 2 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 == c.size());
+        HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
     }
 
     // there should be 3 items in the cache, and green should be there as well
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
     HPX_TEST(c.holds_key("green"));
     HPX_TEST(c.holds_key("green"));
     HPX_TEST(c.holds_key("green"));
@@ -113,19 +113,19 @@ void test_mru_clear()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     c.clear();
 
     // there should be no items in the cache
-    HPX_TEST(0 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(0), c.size());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -154,13 +154,13 @@ void test_mru_erase_one()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     entry_type black;
@@ -170,7 +170,7 @@ void test_mru_erase_one()
 
     // there should be 2 items in the cache
     HPX_TEST(!c.get_entry("black", black));
-    HPX_TEST(2 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(2), c.size());
 
     entry_type white, yellow;
     HPX_TEST(c.get_entry("white", white));
@@ -187,7 +187,7 @@ void test_mru_update()
 
     cache_type c(4);    // this time we can hold 4 items
 
-    HPX_TEST(4 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.capacity());
 
     // insert 3 items into the cache
     int i = 0;
@@ -196,22 +196,22 @@ void test_mru_update()
     for (/**/; i < 3 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     // there should be 3 items in the cache
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 
     // now update some items
     HPX_TEST(c.update("black", "255,0,0"));    // isn't in the cache
-    HPX_TEST(4 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.size());
 
     HPX_TEST(c.update("yellow", "255,0,0"));
-    HPX_TEST(4 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.size());
 
     std::string yellow;
     HPX_TEST(c.get_entry("yellow", yellow));
-    HPX_TEST(yellow == "255,0,0");
+    HPX_TEST_EQ(yellow, "255,0,0");
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/libs/cache/tests/unit/local_statistics.cpp b/libs/cache/tests/unit/local_statistics.cpp
index 9816be08b9..eb5cc72d4d 100644
--- a/libs/cache/tests/unit/local_statistics.cpp
+++ b/libs/cache/tests/unit/local_statistics.cpp
@@ -10,6 +10,7 @@
 #include <hpx/hpx_main.hpp>
 #include <hpx/testing.hpp>
 
+#include <cstddef>
 #include <functional>
 #include <map>
 #include <string>
@@ -45,24 +46,24 @@ void test_statistics_insert()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     // there should be 3 items in the cache
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 
     // retrieve statistics
     statistics::local_statistics const& stats = c.get_statistics();
-    HPX_TEST(0 == stats.hits());
-    HPX_TEST(0 == stats.misses());
-    HPX_TEST(6 == stats.insertions());
-    HPX_TEST(3 == stats.evictions());
+    HPX_TEST_EQ(static_cast<std::size_t>(0), stats.hits());
+    HPX_TEST_EQ(static_cast<std::size_t>(0), stats.misses());
+    HPX_TEST_EQ(static_cast<std::size_t>(6), stats.insertions());
+    HPX_TEST_EQ(static_cast<std::size_t>(3), stats.evictions());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -78,7 +79,7 @@ void test_statistics_insert_with_touch()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert 3 items into the cache
     int i = 0;
@@ -87,21 +88,21 @@ void test_statistics_insert_with_touch()
     for (/**/; i < 3 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 
     // now touch the first item
     std::string white;
     HPX_TEST(c.get_entry("white", white));
-    HPX_TEST(white == "255,255,255");
+    HPX_TEST_EQ(white, "255,255,255");
 
     // add two more items
     for (i = 0; i < 2 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 == c.size());
+        HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
     }
 
     // provoke a miss
@@ -109,15 +110,15 @@ void test_statistics_insert_with_touch()
     HPX_TEST(!c.get_entry("yellow", yellow));
 
     // there should be 3 items in the cache, and white should be there as well
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
     HPX_TEST(c.holds_key("white"));    // does not call the entry's touch()
 
     // retrieve statistics
     statistics::local_statistics const& stats = c.get_statistics();
-    HPX_TEST(1 == stats.hits());
-    HPX_TEST(1 == stats.misses());
-    HPX_TEST(5 == stats.insertions());
-    HPX_TEST(2 == stats.evictions());
+    HPX_TEST_EQ(static_cast<std::size_t>(1), stats.hits());
+    HPX_TEST_EQ(static_cast<std::size_t>(1), stats.misses());
+    HPX_TEST_EQ(static_cast<std::size_t>(5), stats.insertions());
+    HPX_TEST_EQ(static_cast<std::size_t>(2), stats.evictions());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -133,7 +134,7 @@ void test_statistics_update()
 
     cache_type c(4);    // this time we can hold 4 items
 
-    HPX_TEST(4 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.capacity());
 
     // insert 3 items into the cache
     int i = 0;
@@ -142,29 +143,29 @@ void test_statistics_update()
     for (/**/; i < 3 && d->key != nullptr; ++d, ++i)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     // there should be 3 items in the cache
-    HPX_TEST(3 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.size());
 
     // now update some items
     HPX_TEST(c.update("black", "255,0,0"));    // isn't in the cache
-    HPX_TEST(4 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.size());
 
     HPX_TEST(c.update("yellow", "255,0,0"));
-    HPX_TEST(4 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(4), c.size());
 
     std::string yellow;
     HPX_TEST(c.get_entry("yellow", yellow));
-    HPX_TEST(yellow == "255,0,0");
+    HPX_TEST_EQ(yellow, "255,0,0");
 
     // retrieve statistics
     statistics::local_statistics const& stats = c.get_statistics();
-    HPX_TEST(2 == stats.hits());
-    HPX_TEST(1 == stats.misses());
-    HPX_TEST(4 == stats.insertions());
-    HPX_TEST(0 == stats.evictions());
+    HPX_TEST_EQ(static_cast<std::size_t>(2), stats.hits());
+    HPX_TEST_EQ(static_cast<std::size_t>(1), stats.misses());
+    HPX_TEST_EQ(static_cast<std::size_t>(4), stats.insertions());
+    HPX_TEST_EQ(static_cast<std::size_t>(0), stats.evictions());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -196,13 +197,13 @@ void test_statistics_erase_one()
 
     cache_type c(3);
 
-    HPX_TEST(3 == c.capacity());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(3), c.capacity());
 
     // insert all items into the cache
     for (data* d = &cache_entries[0]; d->key != nullptr; ++d)
     {
         HPX_TEST(c.insert(d->key, d->value));
-        HPX_TEST(3 >= c.size());
+        HPX_TEST_LTE(c.size(), static_cast<cache_type::size_type>(3));
     }
 
     entry_type blue;
@@ -212,14 +213,14 @@ void test_statistics_erase_one()
 
     // there should be 2 items in the cache
     HPX_TEST(!c.get_entry("blue", blue));
-    HPX_TEST(2 == c.size());
+    HPX_TEST_EQ(static_cast<cache_type::size_type>(2), c.size());
 
     // retrieve statistics
     statistics::local_statistics const& stats = c.get_statistics();
-    HPX_TEST(1 == stats.hits());
-    HPX_TEST(1 == stats.misses());
-    HPX_TEST(6 == stats.insertions());
-    HPX_TEST(4 == stats.evictions());
+    HPX_TEST_EQ(static_cast<std::size_t>(1), stats.hits());
+    HPX_TEST_EQ(static_cast<std::size_t>(1), stats.misses());
+    HPX_TEST_EQ(static_cast<std::size_t>(6), stats.insertions());
+    HPX_TEST_EQ(static_cast<std::size_t>(4), stats.evictions());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/libs/checkpoint/CMakeLists.txt b/libs/checkpoint/CMakeLists.txt
index bcccf80778..ea71f228f0 100644
--- a/libs/checkpoint/CMakeLists.txt
+++ b/libs/checkpoint/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/checkpoint/README.rst b/libs/checkpoint/README.rst
index 9ae9128241..d0542d6ab2 100644
--- a/libs/checkpoint/README.rst
+++ b/libs/checkpoint/README.rst
@@ -13,4 +13,4 @@ checkpoint
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/checkpoint/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/checkpoint/docs/index.html>`__.
diff --git a/libs/checkpoint/docs/index.rst b/libs/checkpoint/docs/index.rst
index a2771ca712..72656bcc65 100644
--- a/libs/checkpoint/docs/index.rst
+++ b/libs/checkpoint/docs/index.rst
@@ -12,26 +12,22 @@ checkpoint
 ==========
 
 A common need of users is to periodically backup an application. This practice
-provides resiliency and potential restart points in code. We have developed the
+provides resiliency and potential restart points in code. |hpx| utilizes the
 concept of a ``checkpoint`` to support this use case.
 
 Found in ``hpx/util/checkpoint.hpp``, ``checkpoint``\ s are defined as objects
-which hold a serialized version of an object or set of objects at a particular
+that hold a serialized version of an object or set of objects at a particular
 moment in time. This representation can be stored in memory for later use or it
 can be written to disk for storage and/or recovery at a later point. In order to
-create and fill this object with data we use a function called
-``save_checkpoint``. In code the function looks like this:
-
-.. code-block:: c++
+create and fill this object with data, users must use a function called
+``save_checkpoint``. In code the function looks like this::
 
     hpx::future<hpx::util::checkpoint> hpx::util::save_checkpoint(a, b, c, ...);
 
-``save_checkpoint`` takes arbitrary data containers such as int, double, float,
-vector, and future and serializes them into a newly created ``checkpoint``
-object. This function returns a ``future`` to a ``checkpoint`` containing the
-data. Let us look a simple use case below:
-
-.. code-block:: c++
+``save_checkpoint`` takes arbitrary data containers, such as ``int``,
+``double``, ``float``, ``vector``, and ``future``, and serializes them into a
+newly created ``checkpoint`` object. This function returns a ``future`` to a
+``checkpoint`` containing the data. Here's an example of a simple use case::
 
     using hpx::util::checkpoint;
     using hpx::util::save_checkpoint;
@@ -39,7 +35,7 @@ data. Let us look a simple use case below:
     std::vector<int> vec{1,2,3,4,5};
     hpx::future<checkpoint> save_checkpoint(vec);
 
-Once the future is ready the checkpoint object will contain the ``vector``
+Once the future is ready, the checkpoint object will contain the ``vector``
 ``vec`` and its five elements.
 
 It is also possible to modify the launch policy used by ``save_checkpoint``.
@@ -60,7 +56,7 @@ follow the launch policy). An example of these features can be found below:
    :start-after: //[check_test_1
    :end-before: //]
 
-Now that we can create ``checkpoint`` s we now must be able to restore the
+Once users can create ``checkpoint``\ s they must now be able to restore the
 objects they contain into memory. This is accomplished by the function
 ``restore_checkpoint``. This function takes a ``checkpoint`` and fills its data
 into the containers it is provided. It is important to remember that the
@@ -73,13 +69,13 @@ containers must be ordered in the same way they were placed into the
    :end-before: //]
 
 The core utility of ``checkpoint`` is in its ability to make certain data
-persistent. Often this means that the data is needed to be stored in an object,
-such as a file, for later use. For these cases we have provided two solutions:
-stream operator overloads and access iterators.
+persistent. Often, this means that the data needs to be stored in an object,
+such as a file, for later use. |hpx| has two solutions for these issues: stream
+operator overloads and access iterators.
 
-We have created the two stream overloads ``operator<<`` and ``operator>>`` to
-stream data out of and into ``checkpoint``. You can see an example of the
-overloads in use below:
+|hpx| contains two stream overloads, ``operator<<`` and ``operator>>``, to stream
+data out of and into ``checkpoint``. Here is an example of the overloads in
+use below:
 
 .. literalinclude:: ../../../../libs/checkpoint/tests/unit/checkpoint.cpp
    :language: c++
@@ -88,20 +84,20 @@ overloads in use below:
 
 This is the primary way to move data into and out of a ``checkpoint``. It is
 important to note, however, that users should be cautious when using a stream
-operator to load data an another function to remove it (or vice versa). Both
+operator to load data and another function to remove it (or vice versa). Both
 ``operator<<`` and ``operator>>`` rely on a ``.write()`` and a ``.read()``
 function respectively. In order to know how much data to read from the
 ``std::istream``, the ``operator<<`` will write the size of the ``checkpoint``
 before writing the ``checkpoint`` data. Correspondingly, the ``operator>>`` will
-read the size of the stored data before reading the data into new instance of
+read the size of the stored data before reading the data into a new instance of
 ``checkpoint``. As long as the user employs the ``operator<<`` and
-``operator>>`` to stream the data this detail can be ignored.
+``operator>>`` to stream the data, this detail can be ignored.
 
 .. important::
 
    Be careful when mixing ``operator<<`` and ``operator>>`` with other
    facilities to read and write to a ``checkpoint``. ``operator<<`` writes an
-   extra variable and ``operator>>`` reads this variable back separately. Used
+   extra variable, and ``operator>>`` reads this variable back separately. Used
    together the user will not encounter any issues and can safely ignore this
    detail.
 
diff --git a/libs/checkpoint/tests/unit/checkpoint.cpp b/libs/checkpoint/tests/unit/checkpoint.cpp
index 7a6392b33d..8e8efba43c 100644
--- a/libs/checkpoint/tests/unit/checkpoint.cpp
+++ b/libs/checkpoint/tests/unit/checkpoint.cpp
@@ -165,9 +165,9 @@ int main()
     int a8_2, b8_2, c8_2;
     restore_checkpoint(archive8, a8_2, b8_2, c8_2);
 
-    HPX_TEST(a8 == a8_2);
-    HPX_TEST(b8 == b8_2);
-    HPX_TEST(c8 == c8_2);
+    HPX_TEST_EQ(a8, a8_2);
+    HPX_TEST_EQ(b8, b8_2);
+    HPX_TEST_EQ(c8, c8_2);
 
     // Cleanup
     std::remove("checkpoint_test_file.txt");
@@ -188,9 +188,9 @@ int main()
     restore_checkpoint(archive9, a9_1, b9_1, c9_1);
     //]
 
-    HPX_TEST(a9 == a9_1);
-    HPX_TEST(b9 == b9_1);
-    HPX_TEST(c9 == c9_1);
+    HPX_TEST_EQ(a9, a9_1);
+    HPX_TEST_EQ(b9, b9_1);
+    HPX_TEST_EQ(c9, c9_1);
 
     // Cleanup
     std::remove("test_file_9.txt");
diff --git a/libs/collectives/CMakeLists.txt b/libs/collectives/CMakeLists.txt
index 7e972fe715..ac8f4146cb 100644
--- a/libs/collectives/CMakeLists.txt
+++ b/libs/collectives/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -71,12 +71,16 @@ add_hpx_module(collectives
       hpx_local_lcos
       hpx_logging
       hpx_memory
+      hpx_performance_counters
       hpx_preprocessor
       hpx_program_options
+      hpx_runtime_configuration
       hpx_serialization
       hpx_synchronization
       hpx_timing
+      hpx_threading
       hpx_thread_support
+      hpx_threading_base
       hpx_threadmanager
       hpx_topology
       hpx_type_support
diff --git a/libs/collectives/README.rst b/libs/collectives/README.rst
index 6fff3b35c4..bb4db9af3f 100644
--- a/libs/collectives/README.rst
+++ b/libs/collectives/README.rst
@@ -13,4 +13,4 @@ Collectives
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/collectives/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/collectives/docs/index.html>`__.
diff --git a/libs/collectives/include/hpx/collectives/all_reduce.hpp b/libs/collectives/include/hpx/collectives/all_reduce.hpp
index 0350b8238f..904c01c650 100644
--- a/libs/collectives/include/hpx/collectives/all_reduce.hpp
+++ b/libs/collectives/include/hpx/collectives/all_reduce.hpp
@@ -197,7 +197,7 @@ namespace hpx { namespace lcos {
             {
                 std::unique_lock<mutex_type> l(mtx_);
 
-                auto on_ready = [this, HPX_CAPTURE_MOVE(op)](
+                auto on_ready = [this, op = std::move(op)](
                                     hpx::shared_future<void> f) mutable -> T {
                     f.get();    // propagate any exceptions
 
@@ -268,7 +268,7 @@ namespace hpx { namespace lcos {
                 basename, hpx::unmanaged(target), site);
 
             return result.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(target), HPX_CAPTURE_MOVE(basename)](
+                [target = std::move(target), basename = std::move(basename)](
                     hpx::future<bool>&& f) -> hpx::id_type {
                     bool result = f.get();
                     if (!result)
@@ -326,7 +326,7 @@ namespace hpx { namespace lcos {
             this_site = static_cast<std::size_t>(hpx::get_locality_id());
 
         auto all_reduce_data =
-            [HPX_CAPTURE_FORWARD(op), this_site](hpx::future<hpx::id_type>&& f,
+            [op = std::forward<F>(op), this_site](hpx::future<hpx::id_type>&& f,
                 hpx::future<T>&& local_result) mutable -> hpx::future<T> {
             using func_type = typename std::decay<F>::type;
             using action_type = typename detail::all_reduce_server<
@@ -338,7 +338,7 @@ namespace hpx { namespace lcos {
                 local_result.get(), std::forward<F>(op));
 
             return result.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](hpx::future<T>&& f) -> T {
+                [id = std::move(id)](hpx::future<T>&& f) -> T {
                     HPX_UNUSED(id);
                     return f.get();
                 });
@@ -390,7 +390,8 @@ namespace hpx { namespace lcos {
 
         using arg_type = typename std::decay<T>::type;
         auto all_reduce_data_direct =
-            [HPX_CAPTURE_FORWARD(op), HPX_CAPTURE_FORWARD(local_result),
+            [op = std::forward<F>(op),
+                local_result = std::forward<T>(local_result),
                 this_site](hpx::future<hpx::id_type>&& f) mutable
             -> hpx::future<arg_type> {
             using func_type = typename std::decay<F>::type;
@@ -403,7 +404,7 @@ namespace hpx { namespace lcos {
                 std::forward<T>(local_result), std::forward<F>(op));
 
             return result.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](hpx::future<arg_type>&& f) -> arg_type {
+                [id = std::move(id)](hpx::future<arg_type>&& f) -> arg_type {
                     HPX_UNUSED(id);
                     return f.get();
                 });
diff --git a/libs/collectives/include/hpx/collectives/all_to_all.hpp b/libs/collectives/include/hpx/collectives/all_to_all.hpp
index 2b62743a8f..c8ff55554f 100644
--- a/libs/collectives/include/hpx/collectives/all_to_all.hpp
+++ b/libs/collectives/include/hpx/collectives/all_to_all.hpp
@@ -253,7 +253,7 @@ namespace hpx { namespace lcos {
                 basename, hpx::unmanaged(target), site);
 
             return result.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(target), HPX_CAPTURE_MOVE(basename)](
+                [target = std::move(target), basename = std::move(basename)](
                     hpx::future<bool>&& f) -> hpx::id_type {
                     bool result = f.get();
                     if (!result)
@@ -321,7 +321,7 @@ namespace hpx { namespace lcos {
                 async(action_type(), id, this_site, local_result.get());
 
             return result.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](
+                [id = std::move(id)](
                     hpx::future<std::vector<T>>&& f) -> std::vector<T> {
                     HPX_UNUSED(id);
                     return f.get();
@@ -373,9 +373,9 @@ namespace hpx { namespace lcos {
 
         using arg_type = typename util::decay<T>::type;
 
-        auto all_to_all_data_direct = [HPX_CAPTURE_FORWARD(local_result),
-                                          this_site](
-                                          hpx::future<hpx::id_type>&& f)
+        auto all_to_all_data_direct =
+            [local_result = std::forward<T>(local_result), this_site](
+                hpx::future<hpx::id_type>&& f)
             -> hpx::future<std::vector<arg_type>> {
             using action_type =
                 typename detail::all_to_all_server<arg_type>::get_result_action;
@@ -386,7 +386,7 @@ namespace hpx { namespace lcos {
                 async(action_type(), id, this_site, std::move(local_result));
 
             return result.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(id)](hpx::future<std::vector<arg_type>>&& f)
+                [id = std::move(id)](hpx::future<std::vector<arg_type>>&& f)
                     -> std::vector<arg_type> {
                     HPX_UNUSED(id);
                     return f.get();
diff --git a/libs/collectives/include/hpx/collectives/broadcast.hpp b/libs/collectives/include/hpx/collectives/broadcast.hpp
index ed6fb88f69..83a57f9829 100644
--- a/libs/collectives/include/hpx/collectives/broadcast.hpp
+++ b/libs/collectives/include/hpx/collectives/broadcast.hpp
@@ -130,7 +130,6 @@ namespace hpx { namespace lcos {
 #include <hpx/config.hpp>
 #include <hpx/apply.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/lcos/detail/async_colocated.hpp>
@@ -145,6 +144,7 @@ namespace hpx { namespace lcos {
 #include <hpx/serialization/vector.hpp>
 #include <hpx/traits/extract_action.hpp>
 #include <hpx/traits/promise_local_result.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/calculate_fanout.hpp>
 
 #include <cstddef>
@@ -278,8 +278,7 @@ namespace hpx { namespace lcos {
         struct make_broadcast_action_impl;
 
         template <typename Action, std::size_t... Is>
-        struct make_broadcast_action_impl<Action,
-            util::detail::pack_c<std::size_t, Is...>>
+        struct make_broadcast_action_impl<Action, util::index_pack<Is...>>
         {
             typedef
                 typename broadcast_result<Action>::action_result action_result;
@@ -297,14 +296,14 @@ namespace hpx { namespace lcos {
         template <typename Action>
         struct make_broadcast_action
           : make_broadcast_action_impl<Action,
-                typename util::detail::make_index_pack<Action::arity>::type>
+                typename util::make_index_pack<Action::arity>::type>
         {
         };
 
         template <typename Action>
         struct make_broadcast_action<broadcast_with_index<Action>>
           : make_broadcast_action_impl<broadcast_with_index<Action>,
-                typename util::detail::make_index_pack<Action::arity - 1>::type>
+                typename util::make_index_pack<Action::arity - 1>::type>
         {
         };
 
@@ -312,8 +311,7 @@ namespace hpx { namespace lcos {
         struct make_broadcast_apply_action_impl;
 
         template <typename Action, std::size_t... Is>
-        struct make_broadcast_apply_action_impl<Action,
-            util::detail::pack_c<std::size_t, Is...>>
+        struct make_broadcast_apply_action_impl<Action, util::index_pack<Is...>>
         {
             typedef
                 typename broadcast_result<Action>::action_result action_result;
@@ -330,14 +328,14 @@ namespace hpx { namespace lcos {
         template <typename Action>
         struct make_broadcast_apply_action
           : make_broadcast_apply_action_impl<Action,
-                typename util::detail::make_index_pack<Action::arity>::type>
+                typename util::make_index_pack<Action::arity>::type>
         {
         };
 
         template <typename Action>
         struct make_broadcast_apply_action<broadcast_with_index<Action>>
           : make_broadcast_apply_action_impl<broadcast_with_index<Action>,
-                typename util::detail::make_index_pack<Action::arity - 1>::type>
+                typename util::make_index_pack<Action::arity - 1>::type>
         {
         };
 
diff --git a/libs/collectives/include/hpx/collectives/detail/latch.hpp b/libs/collectives/include/hpx/collectives/detail/latch.hpp
index 414d03f417..d88611ea38 100644
--- a/libs/collectives/include/hpx/collectives/detail/latch.hpp
+++ b/libs/collectives/include/hpx/collectives/detail/latch.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2016 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -8,16 +8,14 @@
 #define HPX_LCOS_SERVER_LATCH_APR_19_2015_0956AM
 
 #include <hpx/config.hpp>
+#include <hpx/custom_exception_info.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/lcos/base_lco_with_value.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/runtime/components/server/managed_component_base.hpp>
 #include <hpx/runtime/components/server/runtime_support.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/synchronization/latch.hpp>
-
-#include <boost/exception/diagnostic_information.hpp>
-#include <boost/exception/exception.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 
 #include <cstddef>
 #include <exception>
@@ -112,11 +110,11 @@ namespace hpx { namespace lcos { namespace server {
                 latch_.abort_all();
                 std::rethrow_exception(e);
             }
-            catch (boost::exception const& be)
+            catch (std::exception const& e)
             {
                 // rethrow again, but this time using the native hpx mechanics
                 HPX_THROW_EXCEPTION(hpx::no_success, "latch::set_exception",
-                    boost::diagnostic_information(be));
+                    hpx::diagnostic_information(e));
             }
         }
 
diff --git a/libs/collectives/include/hpx/collectives/fold.hpp b/libs/collectives/include/hpx/collectives/fold.hpp
index 5335910ece..03b3c0b28e 100644
--- a/libs/collectives/include/hpx/collectives/fold.hpp
+++ b/libs/collectives/include/hpx/collectives/fold.hpp
@@ -160,7 +160,6 @@ namespace hpx { namespace lcos {
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/lcos/detail/async_colocated.hpp>
 #include <hpx/lcos/future.hpp>
@@ -174,6 +173,7 @@ namespace hpx { namespace lcos {
 #include <hpx/traits/extract_action.hpp>
 #include <hpx/traits/promise_local_result.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <utility>
@@ -246,8 +246,7 @@ namespace hpx { namespace lcos {
         struct make_fold_action_impl;
 
         template <typename Action, std::size_t... Is>
-        struct make_fold_action_impl<Action,
-            util::detail::pack_c<std::size_t, Is...>>
+        struct make_fold_action_impl<Action, util::index_pack<Is...>>
         {
             typedef typename fold_result<Action>::type action_result;
 
@@ -269,14 +268,14 @@ namespace hpx { namespace lcos {
         template <typename Action>
         struct make_fold_action
           : make_fold_action_impl<Action,
-                typename util::detail::make_index_pack<Action::arity>::type>
+                typename util::make_index_pack<Action::arity>::type>
         {
         };
 
         template <typename Action>
         struct make_fold_action<fold_with_index<Action>>
           : make_fold_action_impl<fold_with_index<Action>,
-                typename util::detail::make_index_pack<Action::arity - 1>::type>
+                typename util::make_index_pack<Action::arity - 1>::type>
         {
         };
 
diff --git a/libs/collectives/include/hpx/collectives/reduce.hpp b/libs/collectives/include/hpx/collectives/reduce.hpp
index 8cdebbf4d0..1f6324ecc9 100644
--- a/libs/collectives/include/hpx/collectives/reduce.hpp
+++ b/libs/collectives/include/hpx/collectives/reduce.hpp
@@ -76,7 +76,6 @@ namespace hpx { namespace lcos {
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/lcos/detail/async_colocated.hpp>
 #include <hpx/lcos/future.hpp>
@@ -90,6 +89,7 @@ namespace hpx { namespace lcos {
 #include <hpx/traits/extract_action.hpp>
 #include <hpx/traits/promise_local_result.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/calculate_fanout.hpp>
 
 #include <cstddef>
@@ -163,8 +163,7 @@ namespace hpx { namespace lcos {
         struct make_reduce_action_impl;
 
         template <typename Action, std::size_t... Is>
-        struct make_reduce_action_impl<Action,
-            util::detail::pack_c<std::size_t, Is...>>
+        struct make_reduce_action_impl<Action, util::index_pack<Is...>>
         {
             typedef typename reduce_result<Action>::type action_result;
 
@@ -186,14 +185,14 @@ namespace hpx { namespace lcos {
         template <typename Action>
         struct make_reduce_action
           : make_reduce_action_impl<Action,
-                typename util::detail::make_index_pack<Action::arity>::type>
+                typename util::make_index_pack<Action::arity>::type>
         {
         };
 
         template <typename Action>
         struct make_reduce_action<reduce_with_index<Action>>
           : make_reduce_action_impl<reduce_with_index<Action>,
-                typename util::detail::make_index_pack<Action::arity - 1>::type>
+                typename util::make_index_pack<Action::arity - 1>::type>
         {
         };
 
diff --git a/libs/collectives/include/hpx/collectives/spmd_block.hpp b/libs/collectives/include/hpx/collectives/spmd_block.hpp
index 2925d3fdf0..22bd150a60 100644
--- a/libs/collectives/include/hpx/collectives/spmd_block.hpp
+++ b/libs/collectives/include/hpx/collectives/spmd_block.hpp
@@ -10,17 +10,17 @@
 #include <hpx/collectives/barrier.hpp>
 #include <hpx/collectives/broadcast.hpp>
 #include <hpx/concepts/concepts.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/execution/execution.hpp>
 #include <hpx/functional/first_argument.hpp>
 #include <hpx/functional/traits/is_action.hpp>
 #include <hpx/hashing/jenkins_hash.hpp>
 #include <hpx/include/plain_actions.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/execution.hpp>
 #include <hpx/runtime/get_locality_id.hpp>
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/serialization/serialize.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <boost/range/irange.hpp>
 
@@ -140,8 +140,8 @@ namespace hpx { namespace lcos {
         }
 
         template <typename... I>
-        typename std::enable_if<util::detail::all_of<
-            typename std::is_integral<I>::type...>::value>::type
+        typename std::enable_if<
+            util::all_of<typename std::is_integral<I>::type...>::value>::type
         sync_images(I... i)
         {
             std::set<std::size_t> images = {(std::size_t) i...};
@@ -204,7 +204,7 @@ namespace hpx { namespace lcos {
 
         template <typename... I>
         typename std::enable_if<
-            util::detail::all_of<typename std::is_integral<I>::type...>::value,
+            util::all_of<typename std::is_integral<I>::type...>::value,
             hpx::future<void>>::type
         sync_images(hpx::launch::async_policy const& policy, I... i) const
         {
diff --git a/libs/collectives/src/barrier.cpp b/libs/collectives/src/barrier.cpp
index 44ec2b6c76..c493b2919c 100644
--- a/libs/collectives/src/barrier.cpp
+++ b/libs/collectives/src/barrier.cpp
@@ -13,9 +13,9 @@
 #include <hpx/runtime/components/server/component_heap.hpp>
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/runtime/threads/run_as_hpx_thread.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 #include <hpx/state.hpp>
 #include <hpx/type_support/unused.hpp>
-#include <hpx/util/runtime_configuration.hpp>
 
 #include <cstddef>
 #include <string>
@@ -140,7 +140,7 @@ namespace hpx { namespace lcos {
                 hpx::intrusive_ptr<wrapping_type> node = node_;
                 hpx::when_all(f, wait(hpx::launch::async))
                     .then(hpx::launch::sync,
-                        [HPX_CAPTURE_MOVE(node)](hpx::future<void> f) {
+                        [node = std::move(node)](hpx::future<void> f) {
                             HPX_UNUSED(node);
                             f.get();
                         })
diff --git a/libs/collectives/src/detail/barrier_node.cpp b/libs/collectives/src/detail/barrier_node.cpp
index 07991a8c0f..592a2054ad 100644
--- a/libs/collectives/src/detail/barrier_node.cpp
+++ b/libs/collectives/src/detail/barrier_node.cpp
@@ -13,6 +13,7 @@
 #include <hpx/memory/intrusive_ptr.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/runtime/launch_policy.hpp>
+#include <hpx/util/from_string.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <cstddef>
@@ -51,9 +52,10 @@ namespace hpx { namespace lcos { namespace detail {
       , base_name_(base_name)
       , rank_(rank)
       , num_(num)
-      , arity_(std::stol(get_config_entry("hpx.lcos.collectives.arity", 32)))
-      , cut_off_(
-            std::stol(get_config_entry("hpx.lcos.collectives.cut_off", -1)))
+      , arity_(hpx::util::from_string<std::size_t>(
+            get_config_entry("hpx.lcos.collectives.arity", 32)))
+      , cut_off_(hpx::util::from_string<std::size_t>(
+            get_config_entry("hpx.lcos.collectives.cut_off", -1)))
       , local_barrier_(num)
     {
         if (num_ >= cut_off_)
@@ -141,7 +143,7 @@ namespace hpx { namespace lcos { namespace detail {
         if (rank_ == 0)
         {
             return future.then(hpx::launch::sync,
-                [HPX_CAPTURE_MOVE(this_)](hpx::future<void>&& f) {
+                [this_ = std::move(this_)](hpx::future<void>&& f) {
                     // Trigger possible errors...
                     f.get();
 
@@ -162,7 +164,7 @@ namespace hpx { namespace lcos { namespace detail {
         }
 
         return future.then(hpx::launch::sync,
-            [HPX_CAPTURE_MOVE(this_)](hpx::future<void>&& f) {
+            [this_ = std::move(this_)](hpx::future<void>&& f) {
                 // Trigger possible errors...
                 f.get();
 
@@ -195,7 +197,7 @@ namespace hpx { namespace lcos { namespace detail {
         hpx::intrusive_ptr<barrier_node> this_(this);
         // Once we know that all our children entered the barrier, we flag ourself
         return hpx::when_all(futures).then(
-            hpx::launch::sync, [HPX_CAPTURE_MOVE(this_)](hpx::future<void> f) {
+            hpx::launch::sync, [this_ = std::move(this_)](hpx::future<void> f) {
                 // Trigger possible errors...
                 f.get();
                 return this_->gather_promise_.get_future();
@@ -224,7 +226,7 @@ namespace hpx { namespace lcos { namespace detail {
         // Once we notified our children, we mark ourself ready.
         hpx::intrusive_ptr<barrier_node> this_(this);
         hpx::when_all(futures).then(
-            hpx::launch::sync, [HPX_CAPTURE_MOVE(this_)](future<void> f) {
+            hpx::launch::sync, [this_ = std::move(this_)](future<void> f) {
                 // Trigger possible errors...
                 f.get();
                 this_->broadcast_promise_.set_value();
diff --git a/libs/collectives/tests/performance/osu/osu_bcast.cpp b/libs/collectives/tests/performance/osu/osu_bcast.cpp
index d34a165849..d60ca2c1d3 100644
--- a/libs/collectives/tests/performance/osu/osu_bcast.cpp
+++ b/libs/collectives/tests/performance/osu/osu_bcast.cpp
@@ -14,8 +14,6 @@
 #include <hpx/local_lcos/and_gate.hpp>
 #include <hpx/util/serializable_any.hpp>
 
-#include <boost/assert.hpp>
-
 #include <cstddef>
 #include <memory>
 #include <numeric>
diff --git a/libs/collectives/tests/performance/osu/osu_bw.cpp b/libs/collectives/tests/performance/osu/osu_bw.cpp
index bde0ba9ae4..25bf4d953c 100644
--- a/libs/collectives/tests/performance/osu/osu_bw.cpp
+++ b/libs/collectives/tests/performance/osu/osu_bw.cpp
@@ -68,7 +68,7 @@ double ireceive(hpx::naming::id_type dest, std::size_t loop, std::size_t size,
     // align used buffers on page boundaries
     unsigned long align_size = getpagesize();
     (void) align_size;
-    HPX_TEST(align_size <= MAX_ALIGNMENT);
+    HPX_TEST_LTE(align_size, static_cast<unsigned long>(MAX_ALIGNMENT));
 
     std::unique_ptr<char[]> send_buffer(new char[size]);
     std::memset(send_buffer.get(), 'a', size);
diff --git a/libs/collectives/tests/performance/osu/osu_latency.cpp b/libs/collectives/tests/performance/osu/osu_latency.cpp
index 82800d9f37..2b8bd41779 100644
--- a/libs/collectives/tests/performance/osu/osu_latency.cpp
+++ b/libs/collectives/tests/performance/osu/osu_latency.cpp
@@ -93,7 +93,7 @@ double receive_double(
     }
 
     double elapsed = t.elapsed();
-    return (elapsed * 1e6) / (2 * loop * window_size);
+    return (elapsed * 1e6) / static_cast<double>(2 * loop * window_size);
 }
 double receive(hpx::naming::id_type dest, char* send_buffer, std::size_t size,
     std::size_t loop, std::size_t window_size)
@@ -124,7 +124,7 @@ double receive(hpx::naming::id_type dest, char* send_buffer, std::size_t size,
     }
 
     double elapsed = t.elapsed();
-    return (elapsed * 1e6) / (2 * loop * window_size);
+    return (elapsed * 1e6) / static_cast<double>(2 * loop * window_size);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/libs/collectives/tests/performance/osu/osu_multi_lat.cpp b/libs/collectives/tests/performance/osu/osu_multi_lat.cpp
index 061f48e35a..c1ea4c5608 100644
--- a/libs/collectives/tests/performance/osu/osu_multi_lat.cpp
+++ b/libs/collectives/tests/performance/osu/osu_multi_lat.cpp
@@ -77,7 +77,7 @@ double ireceive(
 
     // align used buffers on page boundaries
     unsigned long align_size = getpagesize();
-    HPX_TEST(align_size <= MAX_ALIGNMENT);
+    HPX_TEST_LTE(align_size, static_cast<unsigned long>(MAX_ALIGNMENT));
 
     char* aligned_send_buffer = align_buffer(send_buffer, align_size);
     std::memset(aligned_send_buffer, 'a', size);
@@ -106,7 +106,7 @@ double ireceive(
     }
 
     double elapsed = t.elapsed();
-    return (elapsed * 1e6) / (2 * loop * window_size);
+    return (elapsed * 1e6) / static_cast<double>(2 * loop * window_size);
 }
 HPX_PLAIN_ACTION(ireceive);
 
diff --git a/libs/collectives/tests/performance/osu/osu_scatter.cpp b/libs/collectives/tests/performance/osu/osu_scatter.cpp
index 44cf0877c3..fec92567d1 100644
--- a/libs/collectives/tests/performance/osu/osu_scatter.cpp
+++ b/libs/collectives/tests/performance/osu/osu_scatter.cpp
@@ -11,8 +11,6 @@
 #include <hpx/include/iostreams.hpp>
 #include <hpx/serialization/serialize_buffer.hpp>
 
-#include <boost/assert.hpp>
-
 #include <cstddef>
 #include <memory>
 #include <utility>
diff --git a/libs/collectives/tests/regressions/barrier_hang.cpp b/libs/collectives/tests/regressions/barrier_hang.cpp
index 5c7b4b5b42..367d53eb52 100644
--- a/libs/collectives/tests/regressions/barrier_hang.cpp
+++ b/libs/collectives/tests/regressions/barrier_hang.cpp
@@ -5,10 +5,10 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/collectives.hpp>
+#include <hpx/execution/execution.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_main.hpp>
-#include <hpx/parallel/execution.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/testing.hpp>
 
 #include <atomic>
diff --git a/libs/command_line_handling/CMakeLists.txt b/libs/command_line_handling/CMakeLists.txt
new file mode 100644
index 0000000000..2f6e878f5a
--- /dev/null
+++ b/libs/command_line_handling/CMakeLists.txt
@@ -0,0 +1,52 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(command_line_handling_headers
+  hpx/command_line_handling/command_line_handling.hpp
+  hpx/command_line_handling/parse_command_line.hpp
+)
+
+set(command_line_handling_compat_headers
+  hpx/util/command_line_handling.hpp
+  hpx/util/parse_command_line.hpp
+)
+
+set(command_line_handling_sources
+  command_line_handling.cpp
+  parse_command_line.cpp
+)
+
+include(HPX_AddModule)
+add_hpx_module(command_line_handling
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${command_line_handling_sources}
+  HEADERS ${command_line_handling_headers}
+  COMPAT_HEADERS ${command_line_handling_compat_headers}
+  DEPENDENCIES
+    hpx_allocator_support
+    hpx_assertion
+    hpx_affinity
+    hpx_basic_execution
+    hpx_batch_environments
+    hpx_concurrency
+    hpx_config
+    hpx_datastructures
+    hpx_errors
+    hpx_execution
+    hpx_memory
+    hpx_prefix
+    hpx_program_options
+    hpx_runtime_configuration
+    hpx_version
+  CMAKE_SUBDIRS
+)
diff --git a/libs/command_line_handling/README.rst b/libs/command_line_handling/README.rst
new file mode 100644
index 0000000000..a7a5ce1ccc
--- /dev/null
+++ b/libs/command_line_handling/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+=====================
+command_line_handling
+=====================
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/command_line_handling/docs/index.html>`__.
diff --git a/libs/command_line_handling/docs/index.rst b/libs/command_line_handling/docs/index.rst
new file mode 100644
index 0000000000..46d066ecbb
--- /dev/null
+++ b/libs/command_line_handling/docs/index.rst
@@ -0,0 +1,13 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_command_line_handling:
+
+=====================
+command_line_handling
+=====================
+
diff --git a/hpx/util/command_line_handling.hpp b/libs/command_line_handling/include/hpx/command_line_handling/command_line_handling.hpp
similarity index 80%
rename from hpx/util/command_line_handling.hpp
rename to libs/command_line_handling/include/hpx/command_line_handling/command_line_handling.hpp
index 74d5ee46eb..f1400df71f 100644
--- a/hpx/util/command_line_handling.hpp
+++ b/libs/command_line_handling/include/hpx/command_line_handling/command_line_handling.hpp
@@ -8,12 +8,12 @@
 #define HPX_UTIL_COMMAND_LINE_HANDLING_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/program_options.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
-#include <hpx/functional/function.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/util/manage_config.hpp>
-#include <hpx/util/runtime_configuration.hpp>
 
 #include <cstddef>
 #include <string>
@@ -21,8 +21,7 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     namespace detail {
         HPX_EXPORT bool check_mpi_environment(runtime_configuration const& cfg);
     }
@@ -46,20 +45,21 @@ namespace hpx { namespace util
     struct command_line_handling
     {
         command_line_handling()
-          : rtcfg_(nullptr, runtime_mode_default),
-            node_(std::size_t(-1)),
-            num_threads_(1),
-            num_cores_(1),
-            num_localities_(1),
-            pu_step_(1),
-            pu_offset_(std::size_t(-1)),
-            numa_sensitive_(0),
-            use_process_mask_(false),
-            cmd_line_parsed_(false),
-            info_printed_(false),
-            version_printed_(false),
-            parse_result_(0)
-        {}
+          : rtcfg_(nullptr, runtime_mode_default)
+          , node_(std::size_t(-1))
+          , num_threads_(1)
+          , num_cores_(1)
+          , num_localities_(1)
+          , pu_step_(1)
+          , pu_offset_(std::size_t(-1))
+          , numa_sensitive_(0)
+          , use_process_mask_(false)
+          , cmd_line_parsed_(false)
+          , info_printed_(false)
+          , version_printed_(false)
+          , parse_result_(0)
+        {
+        }
 
         int call(hpx::program_options::options_description const& desc_cmdline,
             int argc, char** argv);
@@ -68,9 +68,8 @@ namespace hpx { namespace util
         util::runtime_configuration rtcfg_;
 
         std::vector<std::string> ini_config_;
-        util::function_nonser<
-            int(hpx::program_options::variables_map& vm)
-        > hpx_main_f_;
+        util::function_nonser<int(hpx::program_options::variables_map& vm)>
+            hpx_main_f_;
 
         std::size_t node_;
         std::size_t num_threads_;
@@ -108,6 +107,6 @@ namespace hpx { namespace util
         std::vector<std::string> preprocess_config_settings(
             int argc, char** argv);
     };
-}}
+}}    // namespace hpx::util
 
 #endif /*HPX_UTIL_COMMAND_LINE_HANDLING_HPP*/
diff --git a/hpx/util/parse_command_line.hpp b/libs/command_line_handling/include/hpx/command_line_handling/parse_command_line.hpp
similarity index 73%
rename from hpx/util/parse_command_line.hpp
rename to libs/command_line_handling/include/hpx/command_line_handling/parse_command_line.hpp
index e398129de0..cf7e68bd8d 100644
--- a/hpx/util/parse_command_line.hpp
+++ b/libs/command_line_handling/include/hpx/command_line_handling/parse_command_line.hpp
@@ -8,8 +8,8 @@
 #define HPX_UTIL_PARSE_COMMAND_LINE_NOV_30_2011_0652PM
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 
 #include <hpx/program_options.hpp>
 
@@ -18,8 +18,7 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     enum commandline_error_mode
     {
         return_on_error,
@@ -47,31 +46,19 @@ namespace hpx { namespace util
         hpx::program_options::options_description* visible = nullptr,
         std::vector<std::string>* unregistered_options = nullptr);
 
-    ///////////////////////////////////////////////////////////////////////////
-    // retrieve the command line arguments for the current locality
-    HPX_API_EXPORT bool retrieve_commandline_arguments(
-        hpx::program_options::options_description const& app_options,
-        hpx::program_options::variables_map& vm);
-
-    ///////////////////////////////////////////////////////////////////////////
-    // retrieve the command line arguments for the current locality
-    HPX_API_EXPORT bool retrieve_commandline_arguments(
-        std::string const& appname, hpx::program_options::variables_map& vm);
-
     ///////////////////////////////////////////////////////////////////////////
     HPX_API_EXPORT std::string reconstruct_command_line(
-        hpx::program_options::variables_map const &vm);
+        hpx::program_options::variables_map const& vm);
 
     ///////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
+    namespace detail {
         inline std::string enquote(std::string const& arg)
         {
             if (arg.find_first_of(" \t\"") != std::string::npos)
                 return std::string("\"") + arg + "\"";
             return arg;
         }
-    }
-}}
+    }    // namespace detail
+}}       // namespace hpx::util
 
 #endif
diff --git a/libs/command_line_handling/include_compatibility/hpx/util/command_line_handling.hpp b/libs/command_line_handling/include_compatibility/hpx/util/command_line_handling.hpp
new file mode 100644
index 0000000000..ac05a2132c
--- /dev/null
+++ b/libs/command_line_handling/include_compatibility/hpx/util/command_line_handling.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/command_line_handling/config/defines.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
+
+#if defined(HPX_COMMAND_LINE_HANDLING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/util/command_line_handling.hpp is deprecated, \
+    please include hpx/command_line_handling/command_line_handling.hpp instead")
+#else
+#warning "The header hpx/util/command_line_handling.hpp is deprecated, \
+    please include hpx/command_line_handling/command_line_handling.hpp instead"
+#endif
+#endif
diff --git a/libs/command_line_handling/include_compatibility/hpx/util/parse_command_line.hpp b/libs/command_line_handling/include_compatibility/hpx/util/parse_command_line.hpp
new file mode 100644
index 0000000000..6ae8c37dd4
--- /dev/null
+++ b/libs/command_line_handling/include_compatibility/hpx/util/parse_command_line.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/command_line_handling/config/defines.hpp>
+#include <hpx/command_line_handling/parse_command_line.hpp>
+
+#if defined(HPX_COMMAND_LINE_HANDLING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/parse_command_line.hpp is deprecated, \
+    please include hpx/command_line_handling/parse_command_line.hpp instead")
+#else
+#warning "The header hpx/util/parse_command_line.hpp is deprecated, \
+    please include hpx/command_line_handling/parse_command_line.hpp instead"
+#endif
+#endif
diff --git a/src/util/command_line_handling.cpp b/libs/command_line_handling/src/command_line_handling.cpp
similarity index 78%
rename from src/util/command_line_handling.cpp
rename to libs/command_line_handling/src/command_line_handling.cpp
index f21d5c0eeb..eab8dad79d 100644
--- a/src/util/command_line_handling.cpp
+++ b/libs/command_line_handling/src/command_line_handling.cpp
@@ -4,35 +4,31 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 
+#include <hpx/config/asio.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/batch_environments.hpp>
-#include <hpx/config/asio.hpp>
+#include <hpx/command_line_handling/parse_command_line.hpp>
+#include <hpx/debugging.hpp>
 #include <hpx/format.hpp>
 #include <hpx/functional/detail/reset_function.hpp>
-#include <hpx/plugins/parcelport/mpi/mpi_environment.hpp>
-#include <hpx/plugins/plugin_registry_base.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-#include <hpx/runtime.hpp>
-#include <hpx/runtime/parcelset/parcelhandler.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/runtime/threads/threadmanager.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 #include <hpx/topology/topology.hpp>
 #include <hpx/util/asio_util.hpp>
-#include <hpx/util/debugging.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/util/get_entry_as.hpp>
 #include <hpx/util/init_logging.hpp>
 #include <hpx/util/manage_config.hpp>
 #include <hpx/util/map_hostnames.hpp>
-#include <hpx/util/parse_command_line.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
 #include <hpx/util/sed_transform.hpp>
 #include <hpx/version.hpp>
 
-#include <boost/asio/ip/host_name.hpp>
 #include <hpx/program_options/options_description.hpp>
 #include <hpx/program_options/variables_map.hpp>
+#include <boost/asio/ip/host_name.hpp>
 #include <boost/tokenizer.hpp>
 
 #include <algorithm>
@@ -48,10 +44,30 @@
 #include <utility>
 #include <vector>
 
-namespace hpx { namespace util
-{
-    namespace detail
-    {
+namespace hpx { namespace util {
+    namespace detail {
+        std::string runtime_configuration_string(
+            util::command_line_handling const& cfg)
+        {
+            std::ostringstream strm;
+
+            // runtime mode
+            strm << "  {mode}: " << get_runtime_mode_name(cfg.rtcfg_.mode_)
+                 << "\n";
+
+            if (cfg.num_localities_ != 1)
+                strm << "  {localities}: " << cfg.num_localities_ << "\n";
+
+            // default scheduler used for this run
+            strm << "  {scheduler}: " << cfg.queuing_ << "\n";
+
+            // amount of threads and cores configured for this run
+            strm << "  {os-threads}: " << cfg.num_threads_ << "\n";
+            strm << "  {cores}: " << cfg.num_cores_ << "\n";
+
+            return strm.str();
+        }
+
         ///////////////////////////////////////////////////////////////////////
         int print_version(std::ostream& out)
         {
@@ -60,13 +76,14 @@ namespace hpx { namespace util
             return 1;
         }
 
-        int print_info(std::ostream& out, util::command_line_handling const& cfg)
+        int print_info(
+            std::ostream& out, util::command_line_handling const& cfg)
         {
             out << "Static configuration:\n---------------------\n";
             out << hpx::configuration_string() << std::endl;
 
             out << "Runtime configuration:\n----------------------\n";
-            out << hpx::runtime_configuration_string(cfg) << std::endl;
+            out << runtime_configuration_string(cfg) << std::endl;
 
             return 1;
         }
@@ -78,7 +95,7 @@ namespace hpx { namespace util
             std::string::size_type pos = 0;
             while ((pos = str.find_first_of(s, pos)) != std::string::npos)
             {
-                str.replace (pos, 1, r);
+                str.replace(pos, 1, r);
                 pos += inc;
             }
         }
@@ -100,47 +117,40 @@ namespace hpx { namespace util
             std::size_t threads, std::size_t batch_threads)
         {
             std::cerr << "hpx::init: command line warning: --hpx:threads "
-                    "used when running with "
-                << batch_name
-                << ", requesting a larger number of threads ("
-                << threads
-                << ") than cores have been assigned by "
-                << batch_name
-                << " ("
-                << batch_threads
-                << "), the application might not run properly."
-                << std::endl;
+                         "used when running with "
+                      << batch_name
+                      << ", requesting a larger number of threads (" << threads
+                      << ") than cores have been assigned by " << batch_name
+                      << " (" << batch_threads
+                      << "), the application might not run properly."
+                      << std::endl;
         }
 
         void report_locality_warning_batch(std::string const& batch_name,
             std::size_t batch_localities, std::size_t num_localities)
         {
             std::cerr << "hpx::init: command line warning: "
-                    "--hpx:localities used when running with "
-                << batch_name
-                << ", requesting a different number of localities ("
-                << num_localities
-                << ") than have been assigned by "
-                << batch_name
-                << " ("
-                << batch_localities
-                << "), the application might not run properly."
-                << std::endl;
+                         "--hpx:localities used when running with "
+                      << batch_name
+                      << ", requesting a different number of localities ("
+                      << num_localities << ") than have been assigned by "
+                      << batch_name << " (" << batch_localities
+                      << "), the application might not run properly."
+                      << std::endl;
         }
 
         void report_locality_warning(std::string const& batch_name,
             std::size_t cmdline_localities, std::size_t num_localities)
         {
             std::cerr << "hpx::init: command line warning: "
-                    "--hpx:localities used when running with "
-                << batch_name
-                << ", requesting a different number of localities ("
-                << num_localities
-                << ") than have been assigned on the command line "
-                << " ("
-                << cmdline_localities
-                << "), the application might not run properly."
-                << std::endl;
+                         "--hpx:localities used when running with "
+                      << batch_name
+                      << ", requesting a different number of localities ("
+                      << num_localities
+                      << ") than have been assigned on the command line "
+                      << " (" << cmdline_localities
+                      << "), the application might not run properly."
+                      << std::endl;
         }
 
         std::string convert_to_log_file(std::string const& dest)
@@ -173,15 +183,15 @@ namespace hpx { namespace util
                     num_localities = cfg_num_localities;
             }
 
-            if (!initial && env.found_batch_environment() &&
-                using_nodelist && (batch_localities != num_localities) &&
-                (num_localities != 1))
+            if (!initial && env.found_batch_environment() && using_nodelist &&
+                (batch_localities != num_localities) && (num_localities != 1))
             {
-                detail::report_locality_warning_batch(env.get_batch_name(),
-                    batch_localities, num_localities);
+                detail::report_locality_warning_batch(
+                    env.get_batch_name(), batch_localities, num_localities);
             }
 
-            if (vm.count("hpx:localities")) {
+            if (vm.count("hpx:localities"))
+            {
                 std::size_t localities = vm["hpx:localities"].as<std::size_t>();
 
                 if (localities == 0)
@@ -194,8 +204,8 @@ namespace hpx { namespace util
                     using_nodelist && (localities != num_localities) &&
                     (num_localities != 1))
                 {
-                    detail::report_locality_warning(env.get_batch_name(),
-                        localities, num_localities);
+                    detail::report_locality_warning(
+                        env.get_batch_name(), localities, num_localities);
                 }
                 num_localities = localities;
             }
@@ -246,7 +256,7 @@ namespace hpx { namespace util
                 std::string affinity_desc;
 
                 std::vector<std::string> bind_affinity =
-                    vm["hpx:bind"].as<std::vector<std::string> >();
+                    vm["hpx:bind"].as<std::vector<std::string>>();
                 for (std::string const& s : bind_affinity)
                 {
                     if (!affinity_desc.empty())
@@ -292,7 +302,8 @@ namespace hpx { namespace util
                     vm["hpx:numa-sensitive"].as<std::size_t>();
                 if (numa_sensitive > 2)
                 {
-                    throw hpx::detail::command_line_error("Invalid argument "
+                    throw hpx::detail::command_line_error(
+                        "Invalid argument "
                         "value for --hpx:numa-sensitive. Allowed values are "
                         "0, 1, or 2");
                 }
@@ -300,12 +311,12 @@ namespace hpx { namespace util
             }
 
             // use either cfgmap value or default
-            return cfgmap.get_value<std::size_t>("hpx.numa_sensitive", default_);
+            return cfgmap.get_value<std::size_t>(
+                "hpx.numa_sensitive", default_);
         }
 
         ///////////////////////////////////////////////////////////////////////
-        std::size_t get_number_of_default_threads(
-            bool use_process_mask)
+        std::size_t get_number_of_default_threads(bool use_process_mask)
         {
             if (use_process_mask)
             {
@@ -350,10 +361,11 @@ namespace hpx { namespace util
 
             // assuming we assign the first N cores ...
             std::size_t core = 0;
-            for(; core < num_cores; ++core)
+            for (; core < num_cores; ++core)
             {
                 batch_threads -= top.get_number_of_core_pus(core);
-                if(batch_threads == 0) break;
+                if (batch_threads == 0)
+                    break;
             }
 
             return core + 1;
@@ -372,8 +384,7 @@ namespace hpx { namespace util
                 get_number_of_default_threads(use_process_mask);
             const std::size_t init_cores =
                 get_number_of_default_cores(env, use_process_mask);
-            const std::size_t batch_threads =
-                env.retrieve_number_of_threads();
+            const std::size_t batch_threads = env.retrieve_number_of_threads();
 
             std::size_t default_threads = init_threads;
 
@@ -405,7 +416,7 @@ namespace hpx { namespace util
             else
             {
                 default_threads =
-                    hpx::util::safe_lexical_cast<std::size_t>(threads_str);
+                    hpx::util::from_string<std::size_t>(threads_str);
             }
 
             std::size_t threads = cfgmap.get_value<std::size_t>(
@@ -432,23 +443,24 @@ namespace hpx { namespace util
                 }
                 else
                 {
-                    threads =
-                        hpx::util::safe_lexical_cast<std::size_t>(threads_str);
+                    threads = hpx::util::from_string<std::size_t>(threads_str);
                 }
 
                 if (threads == 0)
                 {
-                    throw hpx::detail::command_line_error("Number of --hpx:threads "
-                        "must be greater than 0");
+                    throw hpx::detail::command_line_error(
+                        "Number of --hpx:threads must be greater than 0");
                 }
 
 #if defined(HPX_HAVE_MAX_CPU_COUNT)
                 if (threads > HPX_HAVE_MAX_CPU_COUNT)
                 {
+                    // clang-format off
                     throw hpx::detail::command_line_error("Requested more than "
                         HPX_PP_STRINGIZE(HPX_HAVE_MAX_CPU_COUNT)" --hpx:threads "
                         "to use for this application, use the option "
                         "-DHPX_WITH_MAX_CPU_COUNT=<N> when configuring HPX.");
+                    // clang-format on
                 }
 #endif
             }
@@ -467,21 +479,23 @@ namespace hpx { namespace util
 #if defined(HPX_HAVE_MAX_CPU_COUNT)
             if (min_os_threads > HPX_HAVE_MAX_CPU_COUNT)
             {
-                throw hpx::detail::command_line_error("Requested more than "
-                    HPX_PP_STRINGIZE(HPX_HAVE_MAX_CPU_COUNT)
-                    " hpx.force_min_os_threads "
-                    "to use for this application, use the option "
-                    "-DHPX_WITH_MAX_CPU_COUNT=<N> when configuring HPX.");
+                throw hpx::detail::command_line_error(
+                    "Requested more than " HPX_PP_STRINGIZE(
+                        HPX_HAVE_MAX_CPU_COUNT) " hpx.force_min_os_threads "
+                                                "to use for this application, "
+                                                "use the option "
+                                                "-DHPX_WITH_MAX_CPU_COUNT=<N> "
+                                                "when configuring HPX.");
             }
 #endif
 
             threads = (std::max)(threads, min_os_threads);
 
-            if (!initial && env.found_batch_environment() &&
-                using_nodelist && (threads > batch_threads))
+            if (!initial && env.found_batch_environment() && using_nodelist &&
+                (threads > batch_threads))
             {
-                detail::report_thread_warning(env.get_batch_name(),
-                    threads, batch_threads);
+                detail::report_thread_warning(
+                    env.get_batch_name(), threads, batch_threads);
             }
             return threads;
         }
@@ -490,7 +504,8 @@ namespace hpx { namespace util
             hpx::program_options::variables_map& vm, std::size_t num_threads,
             util::batch_environment& env, bool use_process_mask)
         {
-            std::string cores_str = cfgmap.get_value<std::string>("hpx.cores", "");
+            std::string cores_str =
+                cfgmap.get_value<std::string>("hpx.cores", "");
             if ("all" == cores_str)
             {
                 cfgmap.config_["hpx.cores"] = std::to_string(
@@ -509,8 +524,7 @@ namespace hpx { namespace util
                 }
                 else
                 {
-                    num_cores =
-                        hpx::util::safe_lexical_cast<std::size_t>(cores_str);
+                    num_cores = hpx::util::from_string<std::size_t>(cores_str);
                 }
             }
 
@@ -519,8 +533,8 @@ namespace hpx { namespace util
 
         ///////////////////////////////////////////////////////////////////////
 #if !defined(HPX_HAVE_NETWORKING)
-        void check_networking_option(hpx::program_options::variables_map& vm,
-            char const* option)
+        void check_networking_option(
+            hpx::program_options::variables_map& vm, char const* option)
         {
             if (vm.count(option) != 0)
             {
@@ -550,26 +564,26 @@ namespace hpx { namespace util
 #endif
         }
 
-        bool detect_mpi_environment(util::runtime_configuration const& cfg,
-            char const* default_env)
+        bool detect_mpi_environment(
+            util::runtime_configuration const& cfg, char const* default_env)
         {
 #if defined(__bgq__)
             // If running on BG/Q, we can safely assume to always run in an
             // MPI environment
             return true;
 #else
-            std::string mpi_environment_strings = cfg.get_entry(
-                "hpx.parcel.mpi.env", default_env);
+            std::string mpi_environment_strings =
+                cfg.get_entry("hpx.parcel.mpi.env", default_env);
 
-            typedef
-                boost::tokenizer<boost::char_separator<char> >
-                tokenizer;
+            typedef boost::tokenizer<boost::char_separator<char>> tokenizer;
             boost::char_separator<char> sep(";,: ");
             tokenizer tokens(mpi_environment_strings, sep);
-            for(tokenizer::iterator it = tokens.begin(); it != tokens.end(); ++it)
+            for (tokenizer::iterator it = tokens.begin(); it != tokens.end();
+                 ++it)
             {
-                char *env = std::getenv(it->c_str());
-                if(env) return true;
+                char* env = std::getenv(it->c_str());
+                if (env)
+                    return true;
             }
             return false;
 #endif
@@ -587,7 +601,8 @@ namespace hpx { namespace util
             // The bottom line is that we use the MPI parcelport either when the
             // application was executed using mpirun or if the tcp/ip parcelport
             // was disabled.
-            if (!detail::detect_mpi_environment(cfg, HPX_HAVE_PARCELPORT_MPI_ENV) &&
+            if (!detail::detect_mpi_environment(
+                    cfg, HPX_HAVE_PARCELPORT_MPI_ENV) &&
                 get_entry_as(cfg, "hpx.parcel.tcp.enable", 1))
             {
                 return false;
@@ -598,7 +613,7 @@ namespace hpx { namespace util
             return false;
 #endif
         }
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////
     std::size_t get_num_high_priority_queues(
@@ -712,9 +727,10 @@ namespace hpx { namespace util
 
         bool debug_clp = node != std::size_t(-1) && vm.count("hpx:debug-clp");
 
-        if (vm.count("hpx:ini")) {
+        if (vm.count("hpx:ini"))
+        {
             std::vector<std::string> cfg =
-                vm["hpx:ini"].as<std::vector<std::string> >();
+                vm["hpx:ini"].as<std::vector<std::string>>();
             std::copy(cfg.begin(), cfg.end(), std::back_inserter(ini_config));
             cfgmap.add(cfg);
         }
@@ -729,33 +745,34 @@ namespace hpx { namespace util
 
         // The AGAS host name and port number are pre-initialized from
         //the command line
-        std::string agas_host =
-            cfgmap.get_value<std::string>("hpx.agas.address",
-                rtcfg_.get_entry("hpx.agas.address", ""));
+        std::string agas_host = cfgmap.get_value<std::string>(
+            "hpx.agas.address", rtcfg_.get_entry("hpx.agas.address", ""));
         std::uint16_t agas_port =
             cfgmap.get_value<std::uint16_t>("hpx.agas.port",
-                boost::lexical_cast<std::uint16_t>(
-                    rtcfg_.get_entry("hpx.agas.port", HPX_INITIAL_IP_PORT)
-                ));
+                hpx::util::from_string<std::uint16_t>(
+                    rtcfg_.get_entry("hpx.agas.port", HPX_INITIAL_IP_PORT)));
 
-        if (vm.count("hpx:agas")) {
+        if (vm.count("hpx:agas"))
+        {
             if (!util::split_ip_address(
-                vm["hpx:agas"].as<std::string>(), agas_host, agas_port))
+                    vm["hpx:agas"].as<std::string>(), agas_host, agas_port))
             {
-                std::cerr
-                    << "hpx::init: command line warning: illegal port "
-                        "number given, using default value instead."
-                    << std::endl;
+                std::cerr << "hpx::init: command line warning: illegal port "
+                             "number given, using default value instead."
+                          << std::endl;
             }
         }
 
         // Check command line arguments.
 
-        if (vm.count("hpx:iftransform")) {
-            util::sed_transform iftransform(vm["hpx:iftransform"].as<std::string>());
+        if (vm.count("hpx:iftransform"))
+        {
+            util::sed_transform iftransform(
+                vm["hpx:iftransform"].as<std::string>());
 
             // Check for parsing failures
-            if (!iftransform) {
+            if (!iftransform)
+            {
                 throw hpx::detail::command_line_error(hpx::util::format(
                     "Could not parse --hpx:iftransform argument '{1}'",
                     vm["hpx:iftransform"].as<std::string>()));
@@ -771,9 +788,10 @@ namespace hpx { namespace util
         std::vector<std::string> nodelist;
 
 #if defined(HPX_HAVE_NETWORKING)
-        if(vm.count("hpx:nodefile"))
+        if (vm.count("hpx:nodefile"))
         {
-            if (vm.count("hpx:nodes")) {
+            if (vm.count("hpx:nodes"))
+            {
                 throw hpx::detail::command_line_error(
                     "Ambiguous command line options. "
                     "Do not specify more than one of the --hpx:nodefile and "
@@ -787,13 +805,16 @@ namespace hpx { namespace util
                 if (debug_clp)
                     std::cerr << "opened: " << node_file << std::endl;
                 std::string line;
-                while (std::getline(ifs, line)) {
-                    if (!line.empty()) {
+                while (std::getline(ifs, line))
+                {
+                    if (!line.empty())
+                    {
                         nodelist.push_back(line);
                     }
                 }
             }
-            else {
+            else
+            {
                 if (debug_clp)
                     std::cerr << "failed opening: " << node_file << std::endl;
 
@@ -802,8 +823,9 @@ namespace hpx { namespace util
                     "Could not open nodefile: '{}'", node_file));
             }
         }
-        else if (vm.count("hpx:nodes")) {
-            nodelist = vm["hpx:nodes"].as<std::vector<std::string> >();
+        else if (vm.count("hpx:nodes"))
+        {
+            nodelist = vm["hpx:nodes"].as<std::vector<std::string>>();
         }
 #endif
         use_process_mask_ =
@@ -815,17 +837,28 @@ namespace hpx { namespace util
                  vm.count("hpx:ignore-batch-env")) == 0) &&
             !use_process_mask_;
 
+#if defined(__APPLE__)
+        if (use_process_mask_)
+        {
+            std::cerr
+                << "Warning: enabled process mask for thread binding, but "
+                   "thread binding is not supported on macOS. Ignoring option."
+                << std::endl;
+            use_process_mask_ = false;
+        }
+#endif
+
         bool have_mpi = detail::check_mpi_environment(rtcfg_);
 
-        util::batch_environment env(nodelist, have_mpi, debug_clp,
-            enable_batch_env);
+        util::batch_environment env(
+            nodelist, have_mpi, debug_clp, enable_batch_env);
 
 #if defined(HPX_HAVE_NETWORKING)
-        if(!nodelist.empty())
+        if (!nodelist.empty())
         {
             using_nodelist = true;
-            ini_config.emplace_back("hpx.nodes!=" + env.init_from_nodelist(
-                nodelist, agas_host));
+            ini_config.emplace_back(
+                "hpx.nodes!=" + env.init_from_nodelist(nodelist, agas_host));
         }
 
         // let the batch environment decide about the AGAS host
@@ -843,15 +876,14 @@ namespace hpx { namespace util
 
         // handling number of localities, those might have already been initialized
         // from MPI environment
-        num_localities_ = detail::handle_num_localities(cfgmap, vm, env,
-            using_nodelist, num_localities_, initial);
+        num_localities_ = detail::handle_num_localities(
+            cfgmap, vm, env, using_nodelist, num_localities_, initial);
 
         // Determine our network port, use arbitrary port if running on one
         // locality.
         hpx_host = cfgmap.get_value<std::string>("hpx.parcel.address",
-                env.host_name(
-                    rtcfg_.get_entry("hpx.parcel.address", HPX_INITIAL_IP_ADDRESS)
-                ));
+            env.host_name(rtcfg_.get_entry(
+                "hpx.parcel.address", HPX_INITIAL_IP_ADDRESS)));
 
         // we expect dynamic connections if:
         //  - --hpx:expect-connecting-localities or
@@ -864,18 +896,18 @@ namespace hpx { namespace util
         if (vm.count("hpx:expect-connecting-localities"))
             expect_connections = true;
 
-        ini_config.emplace_back(std::string("hpx.expect_connecting_localities=") +
+        ini_config.emplace_back(
+            std::string("hpx.expect_connecting_localities=") +
             (expect_connections ? "1" : "0"));
 
         if (num_localities_ != 1 || expect_connections)
         {
-            initial_hpx_port =
-                boost::lexical_cast<std::uint16_t>(
-                    rtcfg_.get_entry("hpx.parcel.port", HPX_INITIAL_IP_PORT));
+            initial_hpx_port = hpx::util::from_string<std::uint16_t>(
+                rtcfg_.get_entry("hpx.parcel.port", HPX_INITIAL_IP_PORT));
         }
 
-        hpx_port = cfgmap.get_value<std::uint16_t>("hpx.parcel.port",
-            initial_hpx_port);
+        hpx_port = cfgmap.get_value<std::uint16_t>(
+            "hpx.parcel.port", initial_hpx_port);
 
         run_agas_server = vm.count("hpx:run-agas-server") != 0;
         if (node == std::size_t(-1))
@@ -887,13 +919,15 @@ namespace hpx { namespace util
 
         // If the user has not specified an explicit runtime mode we
         // retrieve it from the command line.
-        if (hpx::runtime_mode_default == rtcfg_.mode_) {
+        if (hpx::runtime_mode_default == rtcfg_.mode_)
+        {
 #if defined(HPX_HAVE_NETWORKING)
             // The default mode is console, i.e. all workers need to be
             // started with --worker/-w.
             rtcfg_.mode_ = hpx::runtime_mode_console;
             if (vm.count("hpx:console") + vm.count("hpx:worker") +
-                vm.count("hpx:connect") > 1)
+                    vm.count("hpx:connect") >
+                1)
             {
                 throw hpx::detail::command_line_error(
                     "Ambiguous command line options. "
@@ -903,7 +937,8 @@ namespace hpx { namespace util
 
             // In these cases we default to executing with an empty
             // hpx_main, except if specified otherwise.
-            if (vm.count("hpx:worker")) {
+            if (vm.count("hpx:worker"))
+            {
                 rtcfg_.mode_ = hpx::runtime_mode_worker;
 
 #if !defined(HPX_HAVE_RUN_MAIN_EVERYWHERE)
@@ -916,7 +951,8 @@ namespace hpx { namespace util
                 }
 #endif
             }
-            else if (vm.count("hpx:connect")) {
+            else if (vm.count("hpx:connect"))
+            {
                 rtcfg_.mode_ = hpx::runtime_mode_connect;
             }
 #else
@@ -927,12 +963,12 @@ namespace hpx { namespace util
 #if defined(HPX_HAVE_NETWORKING)
         // we initialize certain settings if --node is specified (or data
         // has been retrieved from the environment)
-        if (rtcfg_.mode_ == hpx::runtime_mode_connect) {
+        if (rtcfg_.mode_ == hpx::runtime_mode_connect)
+        {
             // when connecting we need to select a unique port
             hpx_port = cfgmap.get_value<std::uint16_t>("hpx.parcel.port",
-                boost::lexical_cast<std::uint16_t>(
-                    rtcfg_.get_entry("hpx.parcel.port", HPX_CONNECTING_IP_PORT)
-                ));
+                hpx::util::from_string<std::uint16_t>(rtcfg_.get_entry(
+                    "hpx.parcel.port", HPX_CONNECTING_IP_PORT)));
 
 #if !defined(HPX_HAVE_RUN_MAIN_EVERYWHERE)
             // do not execute any explicit hpx_main except if asked
@@ -944,10 +980,13 @@ namespace hpx { namespace util
             }
 #endif
         }
-        else if (node != std::size_t(-1) || vm.count("hpx:node")) {
+        else if (node != std::size_t(-1) || vm.count("hpx:node"))
+        {
             // command line overwrites the environment
-            if (vm.count("hpx:node")) {
-                if (vm.count("hpx:agas")) {
+            if (vm.count("hpx:node"))
+            {
+                if (vm.count("hpx:agas"))
+                {
                     throw hpx::detail::command_line_error(
                         "Command line option --hpx:node "
                         "is not compatible with --hpx:agas");
@@ -955,13 +994,16 @@ namespace hpx { namespace util
                 node = vm["hpx:node"].as<std::size_t>();
             }
 
-            if (!vm.count("hpx:worker")) {
-                if (env.agas_node() == node) {
+            if (!vm.count("hpx:worker"))
+            {
+                if (env.agas_node() == node)
+                {
                     // console node, by default runs AGAS
                     run_agas_server = true;
                     rtcfg_.mode_ = hpx::runtime_mode_console;
                 }
-                else {
+                else
+                {
                     // don't use port zero for non-console localities
                     if (hpx_port == 0 && node != 0)
                         hpx_port = HPX_INITIAL_IP_PORT;
@@ -986,22 +1028,24 @@ namespace hpx { namespace util
             // worker and the node number is zero
             if (!vm.count("hpx:worker") || node != 0)
             {
-                ini_config.emplace_back("hpx.locality!=" + std::to_string(node));
+                ini_config.emplace_back(
+                    "hpx.locality!=" + std::to_string(node));
             }
         }
 
-        if (vm.count("hpx:hpx")) {
-            if (!util::split_ip_address(vm["hpx:hpx"].as<std::string>(),
-                    hpx_host, hpx_port))
+        if (vm.count("hpx:hpx"))
+        {
+            if (!util::split_ip_address(
+                    vm["hpx:hpx"].as<std::string>(), hpx_host, hpx_port))
             {
-                std::cerr
-                    << "hpx::init: command line warning: illegal port "
-                        "number given, using default value instead."
-                    << std::endl;
+                std::cerr << "hpx::init: command line warning: illegal port "
+                             "number given, using default value instead."
+                          << std::endl;
             }
         }
 
-        if ((vm.count("hpx:connect") || rtcfg_.mode_ == hpx::runtime_mode_connect) &&
+        if ((vm.count("hpx:connect") ||
+                rtcfg_.mode_ == hpx::runtime_mode_connect) &&
             hpx_host == "127.0.0.1")
         {
             hpx_host = hpx::util::resolve_public_ip_address();
@@ -1019,38 +1063,78 @@ namespace hpx { namespace util
 
         affinity_bind_ = detail::handle_affinity_bind(cfgmap, vm, "");
         if (!affinity_bind_.empty())
+        {
+#if defined(__APPLE__)
+            std::cerr << "Warning: thread binding set to \"" << affinity_bind_
+                      << "\" but thread binding is not supported on macOS. "
+                         "Ignoring option."
+                      << std::endl;
+            affinity_bind_ = "";
+#else
             ini_config.emplace_back("hpx.bind!=" + affinity_bind_);
+#endif
+        }
 
         pu_step_ = detail::handle_pu_step(cfgmap, vm, 1);
+#if defined(__APPLE__)
+        if (pu_step_ != 1)
+        {
+            std::cerr << "Warning: PU step set to \"" << pu_step_
+                      << "\" but thread binding is not supported on macOS. "
+                         "Ignoring option."
+                      << std::endl;
+            pu_step_ = 1;
+        }
+#endif
         ini_config.emplace_back("hpx.pu_step=" + std::to_string(pu_step_));
 
         pu_offset_ = detail::handle_pu_offset(cfgmap, vm, std::size_t(-1));
         if (pu_offset_ != std::size_t(-1))
-            ini_config.emplace_back("hpx.pu_offset=" + std::to_string(pu_offset_));
+        {
+#if defined(__APPLE__)
+            std::cerr << "Warning: PU offset set to \"" << pu_offset_
+                      << "\" but thread binding is not supported on macOS. "
+                         "Ignoring option."
+                      << std::endl;
+            pu_offset_ = std::size_t(-1);
+            ini_config.emplace_back("hpx.pu_offset=0");
+#else
+            ini_config.emplace_back(
+                "hpx.pu_offset=" + std::to_string(pu_offset_));
+#endif
+        }
         else
+        {
             ini_config.emplace_back("hpx.pu_offset=0");
+        }
 
-        numa_sensitive_ = detail::handle_numa_sensitive(cfgmap, vm,
-            affinity_bind_.empty() ? 0 : 1);
+        numa_sensitive_ = detail::handle_numa_sensitive(
+            cfgmap, vm, affinity_bind_.empty() ? 0 : 1);
         ini_config.emplace_back(
             "hpx.numa_sensitive=" + std::to_string(numa_sensitive_));
 
         // default affinity mode is now 'balanced' (only if no pu-step or
         // pu-offset is given)
-        if (pu_step_ == 1 && pu_offset_ == std::size_t(-1) && affinity_bind_.empty())
+        if (pu_step_ == 1 && pu_offset_ == std::size_t(-1) &&
+            affinity_bind_.empty())
         {
+#if defined(__APPLE__)
+            affinity_bind_ = "none";
+#else
             affinity_bind_ = "balanced";
+#endif
             ini_config.emplace_back("hpx.bind!=" + affinity_bind_);
         }
 
         // handle number of cores and threads
-        num_threads_ = detail::handle_num_threads(
-            cfgmap, rtcfg_, vm, env, using_nodelist, initial, use_process_mask_);
+        num_threads_ = detail::handle_num_threads(cfgmap, rtcfg_, vm, env,
+            using_nodelist, initial, use_process_mask_);
         num_cores_ = detail::handle_num_cores(
             cfgmap, vm, num_threads_, env, use_process_mask_);
 
         // Set number of cores and OS threads in configuration.
-        ini_config.emplace_back("hpx.os_threads=" + std::to_string(num_threads_));
+        ini_config.emplace_back(
+            "hpx.os_threads=" + std::to_string(num_threads_));
         ini_config.emplace_back("hpx.cores=" + std::to_string(num_cores_));
 
         // map host names to ip addresses, if requested
@@ -1058,7 +1142,8 @@ namespace hpx { namespace util
         agas_host = mapnames.map(agas_host, agas_port);
 
         // sanity checks
-        if (num_localities_ == 1 && !vm.count("hpx:agas") && !vm.count("hpx:node"))
+        if (num_localities_ == 1 && !vm.count("hpx:agas") &&
+            !vm.count("hpx:node"))
         {
             // We assume we have to run the AGAS server if the number of
             // localities to run on is not specified (or is '1')
@@ -1069,21 +1154,25 @@ namespace hpx { namespace util
         }
 
 #if defined(HPX_HAVE_NETWORKING)
-        if (hpx_host == agas_host && hpx_port == agas_port) {
+        if (hpx_host == agas_host && hpx_port == agas_port)
+        {
             // we assume that we need to run the agas server if the user
             // asked for the same network addresses for HPX and AGAS
             run_agas_server = rtcfg_.mode_ != runtime_mode_connect;
         }
-        else if (run_agas_server) {
+        else if (run_agas_server)
+        {
             // otherwise, if the user instructed us to run the AGAS server,
             // we set the AGAS network address to the same value as the HPX
             // network address
-            if (agas_host == HPX_INITIAL_IP_ADDRESS) {
+            if (agas_host == HPX_INITIAL_IP_ADDRESS)
+            {
                 agas_host = hpx_host;
                 agas_port = hpx_port;
             }
         }
-        else if (env.found_batch_environment()) {
+        else if (env.found_batch_environment())
+        {
             // in batch mode, if the network addresses are different and we
             // should not run the AGAS server we assume to be in worker mode
             rtcfg_.mode_ = hpx::runtime_mode_worker;
@@ -1105,12 +1194,14 @@ namespace hpx { namespace util
         ini_config.emplace_back("hpx.agas.address=" + agas_host);
         ini_config.emplace_back("hpx.agas.port=" + std::to_string(agas_port));
 
-        if (run_agas_server) {
+        if (run_agas_server)
+        {
             ini_config.emplace_back("hpx.agas.service_mode=bootstrap");
         }
 
         // we can't run the AGAS server while connecting
-        if (run_agas_server && rtcfg_.mode_ == runtime_mode_connect) {
+        if (run_agas_server && rtcfg_.mode_ == runtime_mode_connect)
+        {
             throw hpx::detail::command_line_error(
                 "Command line option error: can't run AGAS server"
                 "while connecting to a running application.");
@@ -1134,11 +1225,12 @@ namespace hpx { namespace util
             get_runtime_mode_name(rtcfg_.mode_));
 
         bool noshutdown_evaluate = false;
-        if (vm.count("hpx:print-counter-at")) {
+        if (vm.count("hpx:print-counter-at"))
+        {
             std::vector<std::string> print_counters_at =
-                vm["hpx:print-counter-at"].as<std::vector<std::string> >();
+                vm["hpx:print-counter-at"].as<std::vector<std::string>>();
 
-            for (std::string const& s: print_counters_at)
+            for (std::string const& s : print_counters_at)
             {
                 if (0 == std::string("startup").find(s))
                 {
@@ -1160,12 +1252,14 @@ namespace hpx { namespace util
                 throw hpx::detail::command_line_error(hpx::util::format(
                     "Invalid argument for option --hpx:print-counter-at: "
                     "'{1}', allowed values: 'startup', 'shutdown' (default), "
-                    "'noshutdown'", s));
+                    "'noshutdown'",
+                    s));
             }
         }
 
         // if any counters have to be evaluated, always print at the end
-        if (vm.count("hpx:print-counter") || vm.count("hpx:print-counter-reset"))
+        if (vm.count("hpx:print-counter") ||
+            vm.count("hpx:print-counter-reset"))
         {
             if (!noshutdown_evaluate)
                 ini_config.emplace_back("hpx.print_counter.shutdown!=1");
@@ -1173,10 +1267,12 @@ namespace hpx { namespace util
                 ini_config.emplace_back("hpx.print_counter.reset!=1");
         }
 
-        if (debug_clp) {
+        if (debug_clp)
+        {
             std::cerr << "Configuration before runtime start:\n";
             std::cerr << "-----------------------------------\n";
-            for (std::string const& s : ini_config) {
+            for (std::string const& s : ini_config)
+            {
                 std::cerr << s << std::endl;
             }
             std::cerr << "-----------------------------------\n";
@@ -1191,7 +1287,8 @@ namespace hpx { namespace util
         std::vector<std::string>& ini_config)
     {
 #if defined(HPX_HAVE_LOGGING)
-        if (vm.count("hpx:debug-hpx-log")) {
+        if (vm.count("hpx:debug-hpx-log"))
+        {
             ini_config.emplace_back("hpx.logging.console.destination=" +
                 detail::convert_to_log_file(
                     vm["hpx:debug-hpx-log"].as<std::string>()));
@@ -1202,7 +1299,8 @@ namespace hpx { namespace util
             ini_config.emplace_back("hpx.logging.level=5");
         }
 
-        if (vm.count("hpx:debug-agas-log")) {
+        if (vm.count("hpx:debug-agas-log"))
+        {
             ini_config.emplace_back("hpx.logging.console.agas.destination=" +
                 detail::convert_to_log_file(
                     vm["hpx:debug-agas-log"].as<std::string>()));
@@ -1213,7 +1311,8 @@ namespace hpx { namespace util
             ini_config.emplace_back("hpx.logging.agas.level=5");
         }
 
-        if (vm.count("hpx:debug-parcel-log")) {
+        if (vm.count("hpx:debug-parcel-log"))
+        {
             ini_config.emplace_back("hpx.logging.console.parcel.destination=" +
                 detail::convert_to_log_file(
                     vm["hpx:debug-parcel-log"].as<std::string>()));
@@ -1224,7 +1323,8 @@ namespace hpx { namespace util
             ini_config.emplace_back("hpx.logging.parcel.level=5");
         }
 
-        if (vm.count("hpx:debug-timing-log")) {
+        if (vm.count("hpx:debug-timing-log"))
+        {
             ini_config.emplace_back("hpx.logging.console.timing.destination=" +
                 detail::convert_to_log_file(
                     vm["hpx:debug-timing-log"].as<std::string>()));
@@ -1235,8 +1335,10 @@ namespace hpx { namespace util
             ini_config.emplace_back("hpx.logging.timing.level=1");
         }
 
-        if (vm.count("hpx:debug-app-log")) {
-            ini_config.emplace_back("hpx.logging.console.application.destination=" +
+        if (vm.count("hpx:debug-app-log"))
+        {
+            ini_config.emplace_back(
+                "hpx.logging.console.application.destination=" +
                 detail::convert_to_log_file(
                     vm["hpx:debug-app-log"].as<std::string>()));
             ini_config.emplace_back("hpx.logging.application.destination=" +
@@ -1246,16 +1348,16 @@ namespace hpx { namespace util
             ini_config.emplace_back("hpx.logging.application.level=5");
         }
 #else
-        if (vm.count("hpx:debug-hpx-log") ||
-            vm.count("hpx:debug-agas-log") ||
+        if (vm.count("hpx:debug-hpx-log") || vm.count("hpx:debug-agas-log") ||
             vm.count("hpx:debug-parcel-log") ||
-            vm.count("hpx:debug-timing-log") ||
-            vm.count("hpx:debug-app-log"))
+            vm.count("hpx:debug-timing-log") || vm.count("hpx:debug-app-log"))
         {
+            // clang-format off
             throw hpx::detail::command_line_error(
                 "Command line option error: can't enable logging while it "
                 "was disabled at configuration time. Please re-configure "
                 "HPX using the option -DHPX_WITH_LOGGING=On.");
+            // clang-format on
         }
 #endif
     }
@@ -1268,7 +1370,7 @@ namespace hpx { namespace util
         for (int i = 0; i < argc; ++i)
         {
             // quote only if it contains whitespace
-            std::string arg(argv[i]); //-V108
+            std::string arg(argv[i]);    //-V108
             cmd_line += detail::encode_and_enquote(arg);
 
             if ((i + 1) != argc)
@@ -1286,11 +1388,13 @@ namespace hpx { namespace util
     {
         std::string unregistered_options_cmd_line;
 
-        if (!unregistered_options.empty()) {
+        if (!unregistered_options.empty())
+        {
             typedef std::vector<std::string>::const_iterator iterator_type;
 
-            iterator_type  end = unregistered_options.end();
-            for (iterator_type  it = unregistered_options.begin(); it != end; ++it)
+            iterator_type end = unregistered_options.end();
+            for (iterator_type it = unregistered_options.begin(); it != end;
+                 ++it)
                 unregistered_options_cmd_line +=
                     " " + detail::encode_and_enquote(*it);
 
@@ -1310,27 +1414,33 @@ namespace hpx { namespace util
     bool command_line_handling::handle_help_options(
         hpx::program_options::options_description const& help)
     {
-        if (vm_.count("hpx:help")) {
+        if (vm_.count("hpx:help"))
+        {
             std::string help_option(vm_["hpx:help"].as<std::string>());
-            if (0 == std::string("minimal").find(help_option)) {
+            if (0 == std::string("minimal").find(help_option))
+            {
                 // print static help only
                 std::cout << help << std::endl;
                 return true;
             }
-            else if (0 == std::string("full").find(help_option)) {
+            else if (0 == std::string("full").find(help_option))
+            {
                 // defer printing help until after dynamic part has been
                 // acquired
                 std::ostringstream strm;
                 strm << help << std::endl;
-                ini_config_.emplace_back("hpx.cmd_line_help!=" +
-                    detail::encode_string(strm.str()));
+                ini_config_.emplace_back(
+                    "hpx.cmd_line_help!=" + detail::encode_string(strm.str()));
                 ini_config_.emplace_back(
                     "hpx.cmd_line_help_option!=" + help_option);
             }
-            else {
-                throw hpx::detail::command_line_error(hpx::util::format(
-                    "Invalid argument for option --hpx:help: '{1}', allowed values: "
-                    "'minimal' (default) and 'full'", help_option));
+            else
+            {
+                throw hpx::detail::command_line_error(
+                    hpx::util::format("Invalid argument for option --hpx:help: "
+                                      "'{1}', allowed values: "
+                                      "'minimal' (default) and 'full'",
+                        help_option));
             }
         }
         return false;
@@ -1339,17 +1449,21 @@ namespace hpx { namespace util
     void command_line_handling::handle_attach_debugger()
     {
 #if defined(_POSIX_VERSION) || defined(HPX_WINDOWS)
-        if(vm_.count("hpx:attach-debugger"))
+        if (vm_.count("hpx:attach-debugger"))
         {
             std::string option = vm_["hpx:attach-debugger"].as<std::string>();
             if (option != "off" && option != "startup" &&
-                option != "exception" && option != "test-failure") {
+                option != "exception" && option != "test-failure")
+            {
+                // clang-format off
                 std::cerr <<
                     "hpx::init: command line warning: --hpx:attach-debugger: "
                     "invalid option: " << option << ". Allowed values are "
                     "'off', 'startup', 'exception' or 'test-failure'" << std::endl;
+                // clang-format on
             }
-            else {
+            else
+            {
                 if (option == "startup")
                     attach_debugger();
 
@@ -1369,12 +1483,8 @@ namespace hpx { namespace util
 
         // extract all command line arguments from configuration settings and
         // remove them from this list
-        auto it = std::stable_partition(
-            ini_config_.begin(), ini_config_.end(),
-            [](std::string const& e)
-            {
-                return e.find("--hpx:") != 0;
-            });
+        auto it = std::stable_partition(ini_config_.begin(), ini_config_.end(),
+            [](std::string const& e) { return e.find("--hpx:") != 0; });
 
         std::move(it, ini_config_.end(), std::back_inserter(options));
         ini_config_.erase(it, ini_config_.end());
@@ -1408,8 +1518,8 @@ namespace hpx { namespace util
 
     ///////////////////////////////////////////////////////////////////////////
     int command_line_handling::call(
-        hpx::program_options::options_description const& desc_cmdline,
-        int argc, char** argv)
+        hpx::program_options::options_description const& desc_cmdline, int argc,
+        char** argv)
     {
         // set the flag signaling that command line parsing has been done
         cmd_line_parsed_ = true;
@@ -1448,8 +1558,7 @@ namespace hpx { namespace util
             // command line handling.
             hpx::program_options::variables_map prevm;
             if (!util::parse_commandline(rtcfg_, desc_cmdline, argv[0], args,
-                    prevm, std::size_t(-1), error_mode,
-                    rtcfg_.mode_))
+                    prevm, std::size_t(-1), error_mode, rtcfg_.mode_))
             {
                 return -1;
             }
@@ -1468,8 +1577,9 @@ namespace hpx { namespace util
             // Make sure any aliases defined on the command line get used
             // for the option analysis below.
             std::vector<std::string> cfg;
-            if (prevm.count("hpx:ini")) {
-                cfg = prevm["hpx:ini"].as<std::vector<std::string> >();
+            if (prevm.count("hpx:ini"))
+            {
+                cfg = prevm["hpx:ini"].as<std::vector<std::string>>();
                 cfgmap.add(cfg);
             }
 
@@ -1487,13 +1597,9 @@ namespace hpx { namespace util
             rtcfg_.reconfigure(cfg);
         }
 
-        // initialize logging
-        util::detail::init_logging(
-            rtcfg_, rtcfg_.mode_ == runtime_mode_console);
-
         // load plugin modules (after first pass of command line handling,
         // so that settings given on command line could propagate to modules)
-        std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+        std::vector<std::shared_ptr<plugins::plugin_registry_base>>
             plugin_registries = rtcfg_.load_modules();
 
         // Re-run program option analysis, ini settings (such as aliases)
@@ -1503,22 +1609,6 @@ namespace hpx { namespace util
         if (node_ == std::size_t(-1))
             node_ = 0;
 
-#if defined(HPX_HAVE_NETWORKING)
-#if defined(HPX_HAVE_PARCELPORT_MPI)
-        // getting localities from MPI environment (support mpirun)
-        if (detail::check_mpi_environment(rtcfg_))
-        {
-            mpi_environment::init(&argc, &argv, *this);
-            num_localities_ = static_cast<std::size_t>(mpi_environment::size());
-        }
-#endif
-
-        if (num_localities_ != 1 || node_ != 0 || rtcfg_.enable_networking())
-        {
-            parcelset::parcelhandler::init(&argc, &argv, *this);
-        }
-#endif
-
         for (std::shared_ptr<plugins::plugin_registry_base>& reg :
             plugin_registries)
         {
@@ -1530,9 +1620,9 @@ namespace hpx { namespace util
         hpx::program_options::options_description help;
         std::vector<std::string> unregistered_options;
 
-        if (!util::parse_commandline(rtcfg_, desc_cmdline,
-                argv[0], args, vm_, node_, error_mode, rtcfg_.mode_,
-                &help, &unregistered_options))
+        if (!util::parse_commandline(rtcfg_, desc_cmdline, argv[0], args, vm_,
+                node_, error_mode | util::report_missing_config_file,
+                rtcfg_.mode_, &help, &unregistered_options))
         {
             return -1;
         }
@@ -1553,11 +1643,13 @@ namespace hpx { namespace util
 
         // help can be printed only after the runtime mode has been set
         if (handle_help_options(help))
-            return 1;     // exit application gracefully
+            return 1;    // exit application gracefully
 
         // print version/copyright information
-        if (vm_.count("hpx:version")) {
-            if(!version_printed_){
+        if (vm_.count("hpx:version"))
+        {
+            if (!version_printed_)
+            {
                 detail::print_version(std::cout);
                 version_printed_ = true;
             }
@@ -1565,8 +1657,10 @@ namespace hpx { namespace util
         }
 
         // print configuration information (static and dynamic)
-        if (vm_.count("hpx:info")) {
-            if(!info_printed_){
+        if (vm_.count("hpx:info"))
+        {
+            if (!info_printed_)
+            {
                 detail::print_info(std::cout, *this);
                 info_printed_ = true;
             }
@@ -1576,4 +1670,4 @@ namespace hpx { namespace util
         // all is good
         return 0;
     }
-}}
+}}    // namespace hpx::util
diff --git a/src/util/parse_command_line.cpp b/libs/command_line_handling/src/parse_command_line.cpp
similarity index 87%
rename from src/util/parse_command_line.cpp
rename to libs/command_line_handling/src/parse_command_line.cpp
index 694066c4d5..3daa1711a5 100644
--- a/src/util/parse_command_line.cpp
+++ b/libs/command_line_handling/src/parse_command_line.cpp
@@ -4,12 +4,12 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/command_line_handling/parse_command_line.hpp>
 #include <hpx/datastructures/any.hpp>
+#include <hpx/errors.hpp>
 #include <hpx/filesystem.hpp>
-#include <hpx/runtime.hpp>
-#include <hpx/util/ini.hpp>
-#include <hpx/util/parse_command_line.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cctype>
 #include <cstddef>
@@ -21,13 +21,10 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
-    namespace detail
-    {
+namespace hpx { namespace util {
+    namespace detail {
         ///////////////////////////////////////////////////////////////////////
-        inline std::string
-        trim_whitespace (std::string const &s)
+        inline std::string trim_whitespace(std::string const& s)
         {
             using size_type = std::string::size_type;
 
@@ -53,7 +50,7 @@ namespace hpx { namespace util
 
             if (s.size() < hpx_prefix_len ||
                 s.compare(0, hpx_prefix_len, hpx_prefix) != 0 ||
-                !std::isdigit(s[hpx_prefix_len]))  // -V557
+                !std::isdigit(s[hpx_prefix_len]))    // -V557
             {
                 return false;
             }
@@ -63,21 +60,24 @@ namespace hpx { namespace util
             if (p == std::string::npos)
                 return false;
 
-            if (hpx::util::safe_lexical_cast(
-                    s.substr(hpx_prefix_len, p-hpx_prefix_len),
+            if (hpx::util::from_string<std::size_t>(
+                    s.substr(hpx_prefix_len, p - hpx_prefix_len),
                     std::size_t(-1)) == node)
             {
                 // this option is for the current locality only
                 std::string::size_type p1 = s.find_first_of('=', p);
-                if (p1 != std::string::npos) {
+                if (p1 != std::string::npos)
+                {
                     // the option has a value
-                    std::string o("hpx:" + trim_whitespace(s.substr(p+1, p1-p-1)));
-                    std::string v(trim_whitespace(s.substr(p1+1)));
+                    std::string o(
+                        "hpx:" + trim_whitespace(s.substr(p + 1, p1 - p - 1)));
+                    std::string v(trim_whitespace(s.substr(p1 + 1)));
                     opt = std::make_pair(o, v);
                 }
-                else {
+                else
+                {
                     // no value
-                    std::string o("hpx:" + trim_whitespace(s.substr(p+1)));
+                    std::string o("hpx:" + trim_whitespace(s.substr(p + 1)));
                     opt = std::make_pair(o, std::string());
                 }
                 return true;
@@ -101,51 +101,61 @@ namespace hpx { namespace util
             if (opt.size() < 2 || opt[0] != '-')
                 return result;
 
-            util::section const* sec = ini.get_section("hpx.commandline.aliases");
+            util::section const* sec =
+                ini.get_section("hpx.commandline.aliases");
             if (nullptr == sec)
-                return result;     // no alias mappings are defined
+                return result;    // no alias mappings are defined
 
             // we found shortcut option definitions, try to find mapping
             std::string expand_to;
             std::string::size_type start_at = 2;
             bool long_option = false;
-            if (opt.size() > 2 && opt[1] != '-') {
+            if (opt.size() > 2 && opt[1] != '-')
+            {
                 // short option with value: first two letters have to match
-                expand_to = trim_whitespace(sec->get_entry(opt.substr(0, start_at), ""));
+                expand_to = trim_whitespace(
+                    sec->get_entry(opt.substr(0, start_at), ""));
             }
-            else {
+            else
+            {
                 // short option (no value) or long option
-                if (opt[1] == '-') {
+                if (opt[1] == '-')
+                {
                     start_at = opt.find_last_of('=');
                     long_option = true;
                 }
 
-                if (start_at != std::string::npos) {
+                if (start_at != std::string::npos)
+                {
                     expand_to = trim_whitespace(
                         sec->get_entry(opt.substr(0, start_at), ""));
                 }
-                else {
+                else
+                {
                     expand_to = trim_whitespace(sec->get_entry(opt, ""));
                 }
             }
 
             if (expand_to.size() < 2 || expand_to.substr(0, 2) != "--")
-                return result;     // no sensible alias is defined for this option
+                return result;    // no sensible alias is defined for this option
             expand_to.erase(0, 2);
 
             std::string::size_type p = expand_to.find_first_of('=');
-            if (p != std::string::npos) {
+            if (p != std::string::npos)
+            {
                 // the option alias defines its own value
                 std::string o(trim_whitespace(expand_to.substr(0, p)));
-                std::string v(trim_whitespace(expand_to.substr(p+1)));
+                std::string v(trim_whitespace(expand_to.substr(p + 1)));
                 result = std::make_pair(o, v);
             }
-            else if (start_at != std::string::npos && start_at < opt.size()) {
+            else if (start_at != std::string::npos && start_at < opt.size())
+            {
                 // extract value from original option
-                result = std::make_pair(expand_to,
-                    opt.substr(start_at + (long_option ? 1 : 0)));
+                result = std::make_pair(
+                    expand_to, opt.substr(start_at + (long_option ? 1 : 0)));
             }
-            else {
+            else
+            {
                 // no value
                 result = std::make_pair(expand_to, std::string());
             }
@@ -160,14 +170,18 @@ namespace hpx { namespace util
         struct option_parser
         {
             option_parser(util::section const& ini, std::size_t node)
-              : ini_(ini), node_(node)
-            {}
+              : ini_(ini)
+              , node_(node)
+            {
+            }
 
-            std::pair<std::string, std::string> operator()(std::string const& s) const
+            std::pair<std::string, std::string> operator()(
+                std::string const& s) const
             {
                 // handle special syntax for configuration files @filename
                 if ('@' == s[0])
-                    return std::make_pair(std::string("hpx:options-file"), s.substr(1));
+                    return std::make_pair(
+                        std::string("hpx:options-file"), s.substr(1));
 
                 // handle node specific options
                 std::pair<std::string, std::string> opt;
@@ -188,10 +202,10 @@ namespace hpx { namespace util
         ///////////////////////////////////////////////////////////////////////
         hpx::program_options::basic_command_line_parser<char>&
         get_commandline_parser(
-            hpx::program_options::basic_command_line_parser<char>& p,
-            int mode)
+            hpx::program_options::basic_command_line_parser<char>& p, int mode)
         {
-            if ((mode & ~util::report_missing_config_file) == util::allow_unregistered)
+            if ((mode & ~util::report_missing_config_file) ==
+                util::allow_unregistered)
                 return p.allow_unregistered();
             return p;
         }
@@ -199,24 +213,28 @@ namespace hpx { namespace util
         ///////////////////////////////////////////////////////////////////////
         // Read all options from a given config file, parse and add them to the
         // given variables_map
-        bool read_config_file_options(std::string const &filename,
-            hpx::program_options::options_description const &desc,
-            hpx::program_options::variables_map &vm,
-            util::section const& rtcfg, std::size_t node, int error_mode)
+        bool read_config_file_options(std::string const& filename,
+            hpx::program_options::options_description const& desc,
+            hpx::program_options::variables_map& vm, util::section const& rtcfg,
+            std::size_t node, int error_mode)
         {
             std::ifstream ifs(filename.c_str());
-            if (!ifs.is_open()) {
-                if (error_mode & util::report_missing_config_file) {
-                    std::cerr << "hpx::init: command line warning: command line "
-                          "options file not found (" << filename << ")"
-                        << std::endl;
+            if (!ifs.is_open())
+            {
+                if (error_mode & util::report_missing_config_file)
+                {
+                    std::cerr
+                        << "hpx::init: command line warning: command line "
+                           "options file not found ("
+                        << filename << ")" << std::endl;
                 }
                 return false;
             }
 
             std::vector<std::string> options;
             std::string line;
-            while (std::getline(ifs, line)) {
+            while (std::getline(ifs, line))
+            {
                 // skip empty lines
                 std::string::size_type pos = line.find_first_not_of(" \t");
                 if (pos == std::string::npos)
@@ -226,9 +244,11 @@ namespace hpx { namespace util
                 line = trim_whitespace(line);
 
                 // skip comment lines
-                if ('#' != line[0]) {
+                if ('#' != line[0])
+                {
                     std::string::size_type p1 = line.find_first_of(" \t");
-                    if (p1 != std::string::npos) {
+                    if (p1 != std::string::npos)
+                    {
                         // rebuild the line connecting the parts with a '='
                         line = trim_whitespace(line.substr(0, p1)) + '=' +
                             trim_whitespace(line.substr(p1));
@@ -240,18 +260,19 @@ namespace hpx { namespace util
             // add options to parsed settings
             if (!options.empty())
             {
-                using hpx::program_options::value;
-                using hpx::program_options::store;
                 using hpx::program_options::basic_command_line_parser;
                 using hpx::program_options::command_line_parser;
+                using hpx::program_options::store;
+                using hpx::program_options::value;
                 using namespace hpx::program_options::command_line_style;
 
                 store(detail::get_commandline_parser(
-                        command_line_parser(options)
-                            .options(desc)
-                            .style(unix_style)
-                            .extra_parser(detail::option_parser(rtcfg, node)),
-                        error_mode).run(),
+                          command_line_parser(options)
+                              .options(desc)
+                              .style(unix_style)
+                              .extra_parser(detail::option_parser(rtcfg, node)),
+                          error_mode)
+                          .run(),
                     vm);
                 notify(vm);
             }
@@ -269,12 +290,13 @@ namespace hpx { namespace util
             if (appname.empty())
                 return;
 
-            filesystem::path dir (filesystem::initial_path());
-            filesystem::path app (appname);
+            filesystem::path dir(filesystem::initial_path());
+            filesystem::path app(appname);
             appname = filesystem::basename(app.filename());
 
             // walk up the hierarchy, trying to find a file <appname>.cfg
-            while (!dir.empty()) {
+            while (!dir.empty())
+            {
                 filesystem::path filename = dir / (appname + ".cfg");
                 bool result = read_config_file_options(filename.string(),
                     desc_cfgfile, vm, ini, node,
@@ -282,10 +304,10 @@ namespace hpx { namespace util
                 if (result)
                     break;    // break on the first options file found
 
-                // Boost filesystem and C++17 filesystem behave differently
-                // here. Boost filesystem returns an empty path for
-                // "/".parent_path() whereas C++17 filesystem will keep
-                // returning "/".
+                    // Boost filesystem and C++17 filesystem behave differently
+                    // here. Boost filesystem returns an empty path for
+                    // "/".parent_path() whereas C++17 filesystem will keep
+                    // returning "/".
 #if !defined(HPX_FILESYSTEM_HAVE_BOOST_FILESYSTEM_COMPATIBILITY)
                 auto dir_prev = dir;
                 dir = dir.parent_path();    // chop off last directory part
@@ -303,19 +325,20 @@ namespace hpx { namespace util
             util::section const& ini, std::size_t node, int error_mode)
         {
             using hpx::program_options::options_description;
-            if (vm.count("hpx:options-file")) {
-                std::vector<std::string> const &cfg_files =
-                    vm["hpx:options-file"].as<std::vector<std::string> >();
+            if (vm.count("hpx:options-file"))
+            {
+                std::vector<std::string> const& cfg_files =
+                    vm["hpx:options-file"].as<std::vector<std::string>>();
 
                 for (std::string const& cfg_file : cfg_files)
                 {
                     // parse a single config file and store the results
-                    read_config_file_options(cfg_file, desc_cfgfile, vm, ini,
-                        node, error_mode);
+                    read_config_file_options(
+                        cfg_file, desc_cfgfile, vm, ini, node, error_mode);
                 }
             }
         }
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
     // parse the command line
@@ -327,16 +350,18 @@ namespace hpx { namespace util
         hpx::program_options::options_description* visible,
         std::vector<std::string>* unregistered_options)
     {
+        using hpx::program_options::basic_command_line_parser;
+        using hpx::program_options::command_line_parser;
         using hpx::program_options::options_description;
+        using hpx::program_options::parsed_options;
         using hpx::program_options::positional_options_description;
-        using hpx::program_options::value;
         using hpx::program_options::store;
-        using hpx::program_options::command_line_parser;
-        using hpx::program_options::parsed_options;
-        using hpx::program_options::basic_command_line_parser;
+        using hpx::program_options::value;
         using namespace hpx::program_options::command_line_style;
 
-        try {
+        try
+        {
+            // clang-format off
             options_description cmdline_options(
                 "HPX options (allowed on command line only)");
             cmdline_options.add_options()
@@ -353,10 +378,13 @@ namespace hpx { namespace util
             options_description hpx_options(
                 "HPX options (additionally allowed in an options file)");
             options_description hidden_options("Hidden options");
+            // clang-format on
 
-            switch (mode) {
+            switch (mode)
+            {
             case runtime_mode_default:
 #if defined(HPX_HAVE_NETWORKING)
+                // clang-format off
                 hpx_options.add_options()
                     ("hpx:worker", "run this instance in worker mode")
                     ("hpx:console", "run this instance in console mode")
@@ -367,6 +395,7 @@ namespace hpx { namespace util
                 hpx_options.add_options()
                     ("hpx:console", "run this instance in console mode")
                 ;
+                // clang-format on
 #endif
                 break;
 
@@ -377,18 +406,22 @@ namespace hpx { namespace util
                 // If the runtime for this application is always run in
                 // worker mode, silently ignore the worker option for
                 // hpx_pbs compatibility.
+                // clang-format off
                 hidden_options.add_options()
                     ("hpx:worker", "run this instance in worker mode")
                     ("hpx:console", "run this instance in console mode")
                     ("hpx:connect", "run this instance in worker mode, "
                         "but connecting late")
                 ;
+                // clang-format on
                 break;
 #else
             case runtime_mode_console:
+                // clang-format off
                 hidden_options.add_options()
                     ("hpx:console", "run this instance in console mode")
                 ;
+                // clang-format on
                 break;
 #endif
 
@@ -399,6 +432,7 @@ namespace hpx { namespace util
             }
 
             // general options definitions
+            // clang-format off
             hpx_options.add_options()
                 ("hpx:run-hpx-main",
                   "run the hpx_main function, regardless of locality mode")
@@ -607,6 +641,7 @@ namespace hpx { namespace util
             hidden_options.add_options()
                 ("hpx:ignore", "this option will be silently ignored")
             ;
+            // clang-format off
 
             // construct the overall options description and parse the
             // command line
@@ -748,45 +783,6 @@ namespace hpx { namespace util
             visible, unregistered_options);
     }
 
-    ///////////////////////////////////////////////////////////////////////////
-    // retrieve the command line arguments for the current locality
-    bool retrieve_commandline_arguments(
-        hpx::program_options::options_description const& app_options,
-        hpx::program_options::variables_map& vm)
-    {
-        // The command line for this application instance is available from
-        // this configuration section:
-        //
-        //     [hpx]
-        //     cmd_line=....
-        //
-        std::string cmdline;
-        std::size_t node = std::size_t(-1);
-
-        hpx::util::section& cfg = hpx::get_runtime().get_config();
-        if (cfg.has_entry("hpx.cmd_line"))
-            cmdline = cfg.get_entry("hpx.cmd_line");
-        if (cfg.has_entry("hpx.locality"))
-            node = hpx::util::safe_lexical_cast<std::size_t>
-                (cfg.get_entry("hpx.locality"));
-
-        return parse_commandline(cfg, app_options, cmdline, vm, node,
-            allow_unregistered);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // retrieve the command line arguments for the current locality
-    bool retrieve_commandline_arguments(
-        std::string const& appname, hpx::program_options::variables_map& vm)
-    {
-        using hpx::program_options::options_description;
-
-        options_description desc_commandline(
-            "Usage: " + appname +  " [options]");
-
-        return retrieve_commandline_arguments(desc_commandline, vm);
-    }
-
     ///////////////////////////////////////////////////////////////////////////
     std::string embed_in_quotes(std::string const& s)
     {
diff --git a/libs/compute/CMakeLists.txt b/libs/compute/CMakeLists.txt
index f3c60134d9..e081838827 100644
--- a/libs/compute/CMakeLists.txt
+++ b/libs/compute/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -14,7 +14,6 @@ set(compute_headers
   hpx/compute/detail/target_distribution_policy.hpp
   hpx/compute/host/block_allocator.hpp
   hpx/compute/host/block_executor.hpp
-  hpx/compute/host/default_executor.hpp
   hpx/compute/host/get_targets.hpp
   hpx/compute/host.hpp
   hpx/compute/host/numa_domains.hpp
@@ -49,11 +48,15 @@ add_hpx_module(compute
     hpx_execution
     hpx_hardware
     hpx_memory
+    hpx_performance_counters
     hpx_plugin
     hpx_program_options
     hpx_resource_partitioner
+    hpx_runtime_configuration
     hpx_serialization
     hpx_synchronization
+    hpx_threading
+    hpx_threading_base
     hpx_threadmanager
     hpx_type_support
   CMAKE_SUBDIRS examples tests
diff --git a/libs/compute/README.rst b/libs/compute/README.rst
index 17d9fbcb7c..391d680a66 100644
--- a/libs/compute/README.rst
+++ b/libs/compute/README.rst
@@ -13,4 +13,4 @@ compute
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/compute/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/compute/docs/index.html>`__.
diff --git a/libs/compute/include/hpx/compute/detail/iterator.hpp b/libs/compute/include/hpx/compute/detail/iterator.hpp
index ce91e62c49..39ef471e48 100644
--- a/libs/compute/include/hpx/compute/detail/iterator.hpp
+++ b/libs/compute/include/hpx/compute/detail/iterator.hpp
@@ -63,6 +63,7 @@ namespace hpx { namespace compute { namespace detail {
         {
         }
 
+        // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
         HPX_HOST_DEVICE iterator& operator=(iterator const& other)
         {
             this->base_type::operator=(other);
diff --git a/libs/compute/include/hpx/compute/host.hpp b/libs/compute/include/hpx/compute/host.hpp
index 5b08bc8ee1..c9cadc7dab 100644
--- a/libs/compute/include/hpx/compute/host.hpp
+++ b/libs/compute/include/hpx/compute/host.hpp
@@ -11,7 +11,6 @@
 
 #include <hpx/compute/host/block_allocator.hpp>
 #include <hpx/compute/host/block_executor.hpp>
-#include <hpx/compute/host/default_executor.hpp>
 #include <hpx/compute/host/get_targets.hpp>
 #include <hpx/compute/host/numa_domains.hpp>
 #include <hpx/compute/host/target.hpp>
diff --git a/libs/compute/include/hpx/compute/host/block_allocator.hpp b/libs/compute/include/hpx/compute/host/block_allocator.hpp
index 99f25ac74d..09ad60a18c 100644
--- a/libs/compute/include/hpx/compute/host/block_allocator.hpp
+++ b/libs/compute/include/hpx/compute/host/block_allocator.hpp
@@ -15,11 +15,11 @@
 #include <hpx/compute/host/block_executor.hpp>
 #include <hpx/compute/host/target.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
 #include <hpx/functional/invoke_fused.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
 #include <hpx/parallel/util/cancellation_token.hpp>
 #include <hpx/parallel/util/partitioner_with_cleanup.hpp>
 #include <hpx/runtime/threads/executors/thread_pool_attached_executors.hpp>
diff --git a/libs/compute/include/hpx/compute/host/block_executor.hpp b/libs/compute/include/hpx/compute/host/block_executor.hpp
index 575fd63860..b01315b655 100644
--- a/libs/compute/include/hpx/compute/host/block_executor.hpp
+++ b/libs/compute/include/hpx/compute/host/block_executor.hpp
@@ -9,16 +9,16 @@
 
 #include <hpx/config.hpp>
 #include <hpx/compute/host/target.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
+#include <hpx/execution/executors/thread_pool_attached_executors.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/iterator_support/iterator_range.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/when_all.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
-#include <hpx/parallel/executors/thread_pool_attached_executors.hpp>
-#include <hpx/traits/executor_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <algorithm>
diff --git a/libs/compute/include/hpx/compute/host/default_executor.hpp b/libs/compute/include/hpx/compute/host/default_executor.hpp
deleted file mode 100644
index 1c8650178d..0000000000
--- a/libs/compute/include/hpx/compute/host/default_executor.hpp
+++ /dev/null
@@ -1,108 +0,0 @@
-//  Copyright (c) 2016 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef HPX_COMPUTE_HOST_DEFAULT_EXECUTOR_HPP
-#define HPX_COMPUTE_HOST_DEFAULT_EXECUTOR_HPP
-
-#include <hpx/config.hpp>
-#include <hpx/lcos/future.hpp>
-#include <hpx/traits/executor_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
-
-#include <hpx/compute/host/target.hpp>
-
-#include <type_traits>
-#include <vector>
-
-namespace hpx { namespace compute { namespace host {
-    struct default_executor
-    {
-        default_executor(host::target& target)
-        //         : target_(target)
-        {
-        }
-
-        /// \cond NOINTERNAL
-        bool operator==(default_executor const& rhs) const noexcept
-        {
-            return true;
-        }
-
-        bool operator!=(default_executor const& rhs) const noexcept
-        {
-            return !(*this == rhs);
-        }
-
-        default_executor const& context() const noexcept
-        {
-            return *this;
-        }
-        /// \endcond
-
-        template <typename F, typename... Ts>
-        void post(F&& f, Ts&&... ts)
-        {
-        }
-
-        template <typename F, typename... Ts>
-        hpx::future<void> async_execute(F&& f, Ts&&... ts)
-        {
-            return hpx::future<void>();
-        }
-
-        template <typename F, typename... Ts>
-        static void sync_execute(F&& f, Ts&&... ts)
-        {
-        }
-
-        template <typename F, typename Shape, typename... Ts>
-        static std::vector<hpx::future<void>> bulk_async_execute(
-            F&& f, Shape const& shape, Ts&&... ts)
-        {
-            return std::vector<hpx::future<void>>();
-        }
-
-        template <typename F, typename Shape, typename... Ts>
-        static void bulk_sync_execute(F&& f, Shape const& shape, Ts&&... ts)
-        {
-        }
-
-    private:
-        //       host::target& target_;
-    };
-}}}    // namespace hpx::compute::host
-
-namespace hpx { namespace parallel { namespace execution {
-    template <>
-    struct executor_execution_category<compute::host::default_executor>
-    {
-        typedef parallel::execution::parallel_execution_tag type;
-    };
-
-    template <>
-    struct is_one_way_executor<compute::host::default_executor> : std::true_type
-    {
-    };
-
-    template <>
-    struct is_two_way_executor<compute::host::default_executor> : std::true_type
-    {
-    };
-
-    template <>
-    struct is_bulk_one_way_executor<compute::host::default_executor>
-      : std::true_type
-    {
-    };
-
-    template <>
-    struct is_bulk_two_way_executor<compute::host::default_executor>
-      : std::true_type
-    {
-    };
-}}}    // namespace hpx::parallel::execution
-
-#endif
diff --git a/libs/compute/include/hpx/compute/host/target.hpp b/libs/compute/include/hpx/compute/host/target.hpp
index 790ce70e9f..4ad008231f 100644
--- a/libs/compute/include/hpx/compute/host/target.hpp
+++ b/libs/compute/include/hpx/compute/host/target.hpp
@@ -30,7 +30,8 @@ namespace hpx { namespace compute { namespace host {
         struct native_handle_type
         {
             native_handle_type()
-              : mask_(hpx::threads::get_topology().get_machine_affinity_mask())
+              : mask_(
+                    hpx::threads::create_topology().get_machine_affinity_mask())
             {
             }
 
diff --git a/libs/compute/include/hpx/compute/vector.hpp b/libs/compute/include/hpx/compute/vector.hpp
index 8d0955e360..fff90b76df 100644
--- a/libs/compute/include/hpx/compute/vector.hpp
+++ b/libs/compute/include/hpx/compute/vector.hpp
@@ -169,10 +169,11 @@ namespace hpx { namespace compute {
             if (this == &other)
                 return *this;
 
-            pointer data =
-                alloc_traits::allocate(other.alloc_, other.capacity_);
+            allocator_type tmp_alloc = other.alloc_;
+
+            pointer data = alloc_traits::allocate(tmp_alloc, other.capacity_);
             hpx::parallel::util::copy(other.begin(), other.end(),
-                iterator(data, 0, alloc_traits::target(other.alloc_)));
+                iterator(data, 0, alloc_traits::target(tmp_alloc)));
 
             if (data_ != nullptr)
             {
@@ -182,7 +183,7 @@ namespace hpx { namespace compute {
 
             size_ = other.size_;
             capacity_ = other.capacity_;
-            alloc_ = other.alloc_;
+            alloc_ = std::move(tmp_alloc);
             data_ = std::move(data);
 
             return *this;
diff --git a/libs/compute/src/numa_domains.cpp b/libs/compute/src/numa_domains.cpp
index 1a7176418c..3690b5b7c9 100644
--- a/libs/compute/src/numa_domains.cpp
+++ b/libs/compute/src/numa_domains.cpp
@@ -9,7 +9,6 @@
 #include <hpx/compute/host/numa_domains.hpp>
 #include <hpx/compute/host/target.hpp>
 #include <hpx/resource_partitioner/detail/partitioner.hpp>
-#include <hpx/runtime.hpp>
 #include <hpx/runtime/get_os_thread_count.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 #include <hpx/topology/topology.hpp>
@@ -20,7 +19,7 @@
 namespace hpx { namespace compute { namespace host {
     std::vector<target> numa_domains()
     {
-        auto const& topo = hpx::threads::get_topology();
+        auto const& topo = hpx::threads::create_topology();
 
         std::size_t numa_nodes = topo.get_number_of_numa_nodes();
         if (numa_nodes == 0)
diff --git a/libs/compute/tests/regressions/for_each_value_proxy.cpp b/libs/compute/tests/regressions/for_each_value_proxy.cpp
index 7e66d6965c..a61dbf23bc 100644
--- a/libs/compute/tests/regressions/for_each_value_proxy.cpp
+++ b/libs/compute/tests/regressions/for_each_value_proxy.cpp
@@ -39,6 +39,7 @@ public:
         return *this;
     }
 
+    // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
     test_value_proxy& operator=(test_value_proxy const& other)
     {
         p_ = other.p_;
diff --git a/libs/compute_cuda/CMakeLists.txt b/libs/compute_cuda/CMakeLists.txt
index 1b379a0849..21e9e8257b 100644
--- a/libs/compute_cuda/CMakeLists.txt
+++ b/libs/compute_cuda/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -59,7 +59,3 @@ add_hpx_module(compute_cuda
     hpx_serialization
   CMAKE_SUBDIRS examples tests
 )
-
-include(HPX_PrintSummary)
-create_configuration_summary(
-  "  Module configuration summary (compute_cuda):" "compute_cuda")
diff --git a/libs/compute_cuda/README.rst b/libs/compute_cuda/README.rst
index 9f49dae34a..1425f22d50 100644
--- a/libs/compute_cuda/README.rst
+++ b/libs/compute_cuda/README.rst
@@ -13,4 +13,4 @@ compute_cuda
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/compute_cuda/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/compute_cuda/docs/index.html>`__.
diff --git a/libs/compute_cuda/examples/cuda_future_helper.h b/libs/compute_cuda/examples/cuda_future_helper.h
index aa59601b95..9d5ebcf043 100644
--- a/libs/compute_cuda/examples/cuda_future_helper.h
+++ b/libs/compute_cuda/examples/cuda_future_helper.h
@@ -243,7 +243,7 @@ namespace hpx { namespace compute { namespace util
 
         // -------------------------------------------------------------------------
         // launch a task on our stream and pass the error code through from
-        // cuda back to te caller, otherwise this function mimics the
+        // cuda back to the caller, otherwise this function mimics the
         // behaviour of apply.
         template <typename Func, typename... Args>
         cudaError_t apply_pass_through(Func&& cuda_function, Args&&... args) {
@@ -262,9 +262,6 @@ namespace hpx { namespace compute { namespace util
 
         template <typename... Args>
         auto memcpy_apply(Args&&... args)
-#if !defined(HPX_HAVE_CXX14_RETURN_TYPE_DEDUCTION)
-            -> decltype(apply(cudaMemcpyAsync, std::forward<Args>(args)...))
-#endif
         {
             return apply(cudaMemcpyAsync, std::forward<Args>(args)...);
         }
@@ -278,9 +275,6 @@ namespace hpx { namespace compute { namespace util
 
         template <typename... Args>
         auto memset_apply(Args&&... args)
-#if !defined(HPX_HAVE_CXX14_RETURN_TYPE_DEDUCTION)
-            -> decltype(apply(cudaMemsetAsync, std::forward<Args>(args)...))
-#endif
         {
             return apply(cudaMemsetAsync, std::forward<Args>(args)...);
         }
diff --git a/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor.hpp b/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor.hpp
index 473847f869..7c2590f530 100644
--- a/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor.hpp
+++ b/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor.hpp
@@ -10,7 +10,7 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_CUDA)
-#include <hpx/traits/executor_traits.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
 
 #include <hpx/compute/cuda/concurrent_executor_parameters.hpp>
 #include <hpx/compute/cuda/default_executor.hpp>
diff --git a/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor_parameters.hpp b/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor_parameters.hpp
index 714f5ddf70..02d097396b 100644
--- a/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor_parameters.hpp
+++ b/libs/compute_cuda/include/hpx/compute/cuda/concurrent_executor_parameters.hpp
@@ -10,7 +10,7 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_CUDA)    // && defined(__CUDACC__)
-#include <hpx/traits/is_executor_parameters.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 
 #include <cstddef>
 #include <type_traits>
diff --git a/libs/compute_cuda/include/hpx/compute/cuda/default_executor.hpp b/libs/compute_cuda/include/hpx/compute/cuda/default_executor.hpp
index d0e6d10167..00133e2535 100644
--- a/libs/compute_cuda/include/hpx/compute/cuda/default_executor.hpp
+++ b/libs/compute_cuda/include/hpx/compute/cuda/default_executor.hpp
@@ -12,15 +12,15 @@
 #if defined(HPX_HAVE_CUDA)
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/iterator_support/traits/is_range.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/traits/executor_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/type_support/decay.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
+#include <hpx/execution/executors/execution.hpp>
 
 #include <hpx/compute/cuda/allocator.hpp>
 #include <hpx/compute/cuda/default_executor_parameters.hpp>
diff --git a/libs/compute_cuda/include/hpx/compute/cuda/default_executor_parameters.hpp b/libs/compute_cuda/include/hpx/compute/cuda/default_executor_parameters.hpp
index 8ea62a6488..4b1d9f6639 100644
--- a/libs/compute_cuda/include/hpx/compute/cuda/default_executor_parameters.hpp
+++ b/libs/compute_cuda/include/hpx/compute/cuda/default_executor_parameters.hpp
@@ -11,7 +11,7 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_CUDA)
-#include <hpx/traits/is_executor_parameters.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 
 #include <cstddef>
 #include <type_traits>
diff --git a/libs/compute_cuda/include/hpx/compute/cuda/target.hpp b/libs/compute_cuda/include/hpx/compute/cuda/target.hpp
index 8303b76899..f9936376d9 100644
--- a/libs/compute_cuda/include/hpx/compute/cuda/target.hpp
+++ b/libs/compute_cuda/include/hpx/compute/cuda/target.hpp
@@ -13,17 +13,21 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_CUDA)
+#include <hpx/allocator_support/allocator_deleter.hpp>
+#include <hpx/assertion.hpp>
 #include <hpx/compute/cuda/get_targets.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/find_here.hpp>
-#include <hpx/runtime/runtime_fwd.hpp>
+#include <hpx/runtime_fwd.hpp>
 #include <hpx/synchronization/spinlock.hpp>
+#include <hpx/traits/future_access.hpp>
 
 #include <hpx/serialization/serialization_fwd.hpp>
 
 #include <cuda_runtime.h>
 
 #include <cstddef>
+#include <memory>
 #include <mutex>
 #include <string>
 #include <utility>
@@ -32,6 +36,133 @@
 #include <hpx/config/warnings_prefix.hpp>
 
 namespace hpx { namespace compute { namespace cuda {
+
+    ///////////////////////////////////////////////////////////////////////////
+    namespace detail {
+        struct runtime_registration_wrapper
+        {
+            runtime_registration_wrapper(hpx::runtime* rt);
+            ~runtime_registration_wrapper();
+
+            hpx::runtime* rt_;
+        };
+
+        template <typename Allocator>
+        struct future_data;
+
+        template <typename Allocator>
+        struct release_on_exit
+        {
+            release_on_exit(future_data<Allocator>* data)
+              : data_(data)
+            {
+            }
+
+            ~release_on_exit()
+            {
+                // release the shared state
+                lcos::detail::intrusive_ptr_release(data_);
+            }
+
+            future_data<Allocator>* data_;
+        };
+
+        template <typename Allocator>
+        struct future_data
+          : lcos::detail::future_data_allocator<void, Allocator>
+        {
+            using init_no_addref =
+                typename lcos::detail::future_data_allocator<void,
+                    Allocator>::init_no_addref;
+            using other_allocator = typename std::allocator_traits<
+                Allocator>::template rebind_alloc<future_data>;
+
+            static void CUDART_CB stream_callback(
+                cudaStream_t stream, cudaError_t error, void* user_data)
+            {
+                future_data* this_ = static_cast<future_data*>(user_data);
+
+                runtime_registration_wrapper wrap(this_->rt_);
+                release_on_exit<Allocator> on_exit(this_);
+
+                if (error != cudaSuccess)
+                {
+                    this_->set_exception(HPX_GET_EXCEPTION(kernel_error,
+                        "cuda::detail::future_data::stream_callback()",
+                        std::string("cudaStreamAddCallback failed: ") +
+                            cudaGetErrorString(error)));
+                    return;
+                }
+
+                this_->set_data(hpx::util::unused);
+            }
+
+            future_data()
+              : rt_(hpx::get_runtime_ptr())
+            {
+            }
+
+            future_data(init_no_addref no_addref, other_allocator const& alloc,
+                cudaStream_t stream)
+              : lcos::detail::future_data_allocator<void, Allocator>(
+                    no_addref, alloc)
+              , rt_(hpx::get_runtime_ptr())
+            {
+                init(stream);
+            }
+
+            void init(cudaStream_t stream)
+            {
+                // Hold on to the shared state on behalf of the cuda runtime
+                // right away as the callback could be called immediately.
+                lcos::detail::intrusive_ptr_add_ref(this);
+
+                cudaError_t error =
+                    cudaStreamAddCallback(stream, stream_callback, this, 0);
+                if (error != cudaSuccess)
+                {
+                    // callback was not called, release object
+                    lcos::detail::intrusive_ptr_release(this);
+
+                    // report error
+                    HPX_THROW_EXCEPTION(kernel_error,
+                        "cuda::detail::future_data::future_data()",
+                        std::string("cudaStreamAddCallback failed: ") +
+                            cudaGetErrorString(error));
+                }
+            }
+
+        private:
+            hpx::runtime* rt_;
+        };
+
+        HPX_API_EXPORT hpx::future<void> get_future(cudaStream_t);
+
+        template <typename Allocator>
+        hpx::future<void> get_future(Allocator const& a, cudaStream_t stream)
+        {
+            using shared_state = future_data<Allocator>;
+
+            using other_allocator = typename std::allocator_traits<
+                Allocator>::template rebind_alloc<shared_state>;
+            using traits = std::allocator_traits<other_allocator>;
+
+            using init_no_addref = typename shared_state::init_no_addref;
+
+            using unique_ptr = std::unique_ptr<shared_state,
+                util::allocator_deleter<other_allocator>>;
+
+            other_allocator alloc(a);
+            unique_ptr p(traits::allocate(alloc, 1),
+                hpx::util::allocator_deleter<other_allocator>{alloc});
+
+            traits::construct(alloc, p.get(), init_no_addref{}, alloc, stream);
+
+            return hpx::traits::future_access<future<void>>::create(
+                p.release(), false);
+        }
+    }    // namespace detail
+
     ///////////////////////////////////////////////////////////////////////////
     struct target
     {
@@ -176,6 +307,12 @@ namespace hpx { namespace compute { namespace cuda {
 
         hpx::future<void> get_future() const;
 
+        template <typename Allocator>
+        hpx::future<void> get_future(Allocator const& alloc) const
+        {
+            return detail::get_future(alloc, handle_.get_stream());
+        }
+
         static std::vector<target> get_local_targets()
         {
             return cuda::get_local_targets();
@@ -204,6 +341,7 @@ namespace hpx { namespace compute { namespace cuda {
         hpx::id_type locality_;
     };
 
+    using detail::get_future;
     HPX_API_EXPORT target& get_default_target();
 }}}    // namespace hpx::compute::cuda
 
diff --git a/libs/compute_cuda/include/hpx/compute/cuda/transfer.hpp b/libs/compute_cuda/include/hpx/compute/cuda/transfer.hpp
index 36ffdbe74b..9cd2b11460 100644
--- a/libs/compute_cuda/include/hpx/compute/cuda/transfer.hpp
+++ b/libs/compute_cuda/include/hpx/compute/cuda/transfer.hpp
@@ -51,13 +51,9 @@ namespace hpx { namespace traits {
     template <typename T>
     struct pointer_category<
         compute::detail::iterator<T, compute::cuda::allocator<T>>,
-        compute::detail::iterator<T, compute::cuda::allocator<T>>
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
-        ,
+        compute::detail::iterator<T, compute::cuda::allocator<T>>,
         typename std::enable_if<!std::is_trivially_copyable<
-            typename hpx::util::decay<T>::type>::value>::type
-#endif
-        >
+            typename hpx::util::decay<T>::type>::value>::type>
     {
         typedef cuda_copyable_pointer_tag type;
     };
@@ -65,11 +61,8 @@ namespace hpx { namespace traits {
     template <typename Source, typename T>
     struct pointer_category<Source,
         compute::detail::iterator<T, compute::cuda::allocator<T>>,
-        typename std::enable_if<
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
-            !std::is_trivially_copyable<
-                typename hpx::util::decay<T>::type>::value &&
-#endif
+        typename std::enable_if<!std::is_trivially_copyable<typename hpx::util::
+                                        decay<T>::type>::value &&
             !std::is_same<Source,
                 compute::detail::iterator<T,
                     compute::cuda::allocator<T>>>::value>::type>
@@ -86,11 +79,8 @@ namespace hpx { namespace traits {
     template <typename T, typename U, typename Dest>
     struct pointer_category<
         compute::detail::iterator<T, compute::cuda::allocator<U>>, Dest,
-        typename std::enable_if<
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
-            !std::is_trivially_copyable<
-                typename hpx::util::decay<T>::type>::value &&
-#endif
+        typename std::enable_if<!std::is_trivially_copyable<typename hpx::util::
+                                        decay<T>::type>::value &&
             !std::is_same<Dest,
                 compute::detail::iterator<T,
                     compute::cuda::allocator<U>>>::value>::type>
@@ -104,7 +94,6 @@ namespace hpx { namespace traits {
         typedef cuda_copyable_pointer_tag_to_host type;
     };
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
     struct trivially_cuda_copyable_pointer_tag : cuda_copyable_pointer_tag
     {
     };
@@ -162,11 +151,9 @@ namespace hpx { namespace traits {
 
         typedef trivially_cuda_copyable_pointer_tag_to_host type;
     };
-#endif
 }}    // namespace hpx::traits
 
 namespace hpx { namespace parallel { namespace util { namespace detail {
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
     template <typename Dummy>
     struct copy_helper<hpx::traits::trivially_cuda_copyable_pointer_tag, Dummy>
     {
@@ -322,7 +309,6 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
 #endif
         }
     };
-#endif
 
     ///////////////////////////////////////////////////////////////////////////
     // Customization point for copy-synchronize operations
@@ -359,7 +345,6 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
         }
     };
 
-#if defined(HPX_HAVE_CXX11_STD_IS_TRIVIALLY_COPYABLE)
     template <typename Dummy>
     struct copy_synchronize_helper<
         hpx::traits::trivially_cuda_copyable_pointer_tag, Dummy>
@@ -392,7 +377,6 @@ namespace hpx { namespace parallel { namespace util { namespace detail {
             dest.target().synchronize();
         }
     };
-#endif
 }}}}    // namespace hpx::parallel::util::detail
 
 #endif
diff --git a/libs/compute_cuda/src/cuda_target.cpp b/libs/compute_cuda/src/cuda_target.cpp
index 1812b82c7f..33d0c9b2fe 100644
--- a/libs/compute_cuda/src/cuda_target.cpp
+++ b/libs/compute_cuda/src/cuda_target.cpp
@@ -8,14 +8,16 @@
 
 #if defined(HPX_HAVE_CUDA)
 
+#include <hpx/allocator_support/internal_allocator.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/compute/cuda/target.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
 #include <hpx/runtime/find_here.hpp>
 #include <hpx/runtime/naming/id_type_impl.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/runtime_fwd.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/traits/future_access.hpp>
 
 #if !defined(HPX_COMPUTE_DEVICE_CODE)
 #if defined(HPX_HAVE_MORE_THAN_64_THREADS)
@@ -29,6 +31,7 @@
 #endif
 
 #include <cstddef>
+#include <memory>
 #include <string>
 #include <utility>
 
@@ -36,107 +39,30 @@
 
 namespace hpx { namespace compute { namespace cuda {
     namespace detail {
-        struct runtime_registration_wrapper
+        runtime_registration_wrapper::runtime_registration_wrapper(
+            hpx::runtime* rt)
+          : rt_(rt)
         {
-            runtime_registration_wrapper(hpx::runtime* rt)
-              : rt_(rt)
-            {
-                HPX_ASSERT(rt);
-
-                // Register this thread with HPX, this should be done once for
-                // each external OS-thread intended to invoke HPX functionality.
-                // Calling this function more than once on the same thread will
-                // report an error.
-                hpx::error_code ec(hpx::lightweight);    // ignore errors
-                hpx::register_thread(rt_, "cuda", ec);
-            }
-            ~runtime_registration_wrapper()
-            {
-                // Unregister the thread from HPX, this should be done once in
-                // the end before the external thread exists.
-                hpx::unregister_thread(rt_);
-            }
-
-            hpx::runtime* rt_;
-        };
-
-        ///////////////////////////////////////////////////////////////////////
-        struct future_data : lcos::detail::future_data<void>
-        {
-        private:
-            static void CUDART_CB stream_callback(
-                cudaStream_t stream, cudaError_t error, void* user_data);
-
-        public:
-            future_data();
-
-            void init(cudaStream_t stream);
-
-        private:
-            hpx::runtime* rt_;
-        };
-
-        struct release_on_exit
-        {
-            release_on_exit(future_data* data)
-              : data_(data)
-            {
-            }
-
-            ~release_on_exit()
-            {
-                // release the shared state
-                lcos::detail::intrusive_ptr_release(data_);
-            }
-
-            future_data* data_;
-        };
-
-        ///////////////////////////////////////////////////////////////////////
-        void CUDART_CB future_data::stream_callback(
-            cudaStream_t stream, cudaError_t error, void* user_data)
-        {
-            future_data* this_ = static_cast<future_data*>(user_data);
-
-            runtime_registration_wrapper wrap(this_->rt_);
-            release_on_exit on_exit(this_);
-
-            if (error != cudaSuccess)
-            {
-                this_->set_exception(HPX_GET_EXCEPTION(kernel_error,
-                    "cuda::detail::future_data::stream_callback()",
-                    std::string("cudaStreamAddCallback failed: ") +
-                        cudaGetErrorString(error)));
-                return;
-            }
-
-            this_->set_data(hpx::util::unused);
+            HPX_ASSERT(rt);
+
+            // Register this thread with HPX, this should be done once for
+            // each external OS-thread intended to invoke HPX functionality.
+            // Calling this function more than once on the same thread will
+            // report an error.
+            hpx::error_code ec(hpx::lightweight);    // ignore errors
+            hpx::register_thread(rt_, "cuda", ec);
         }
 
-        future_data::future_data()
-          : rt_(hpx::get_runtime_ptr())
+        runtime_registration_wrapper::~runtime_registration_wrapper()
         {
+            // Unregister the thread from HPX, this should be done once in
+            // the end before the external thread exists.
+            hpx::unregister_thread(rt_);
         }
 
-        void future_data::init(cudaStream_t stream)
+        hpx::future<void> get_future(cudaStream_t stream)
         {
-            // Hold on to the shared state on behalf of the cuda runtime
-            // right away as the callback could be called immediately.
-            lcos::detail::intrusive_ptr_add_ref(this);
-
-            cudaError_t error =
-                cudaStreamAddCallback(stream, stream_callback, this, 0);
-            if (error != cudaSuccess)
-            {
-                // callback was not called, release object
-                lcos::detail::intrusive_ptr_release(this);
-
-                // report error
-                HPX_THROW_EXCEPTION(kernel_error,
-                    "cuda::detail::future_data::future_data()",
-                    std::string("cudaStreamAddCallback failed: ") +
-                        cudaGetErrorString(error));
-            }
+            return get_future(hpx::util::internal_allocator<>{}, stream);
         }
     }    // namespace detail
 
@@ -304,14 +230,7 @@ namespace hpx { namespace compute { namespace cuda {
 
     hpx::future<void> target::get_future() const
     {
-        typedef detail::future_data shared_state_type;
-
-        // make sure shared state stays alive even if the callback is invoked
-        // during initialization
-        hpx::intrusive_ptr<shared_state_type> p(new shared_state_type());
-        p->init(handle_.get_stream());
-        return hpx::traits::future_access<hpx::future<void>>::create(
-            std::move(p));
+        return detail::get_future(handle_.get_stream());
     }
 
     target& get_default_target()
diff --git a/libs/compute_cuda/src/get_cuda_targets.cpp b/libs/compute_cuda/src/get_cuda_targets.cpp
index dd13b25826..84b6d859b7 100644
--- a/libs/compute_cuda/src/get_cuda_targets.cpp
+++ b/libs/compute_cuda/src/get_cuda_targets.cpp
@@ -14,10 +14,10 @@
 #include <hpx/runtime/actions/plain_action.hpp>
 #include <hpx/runtime/find_here.hpp>
 #include <hpx/runtime/naming/id_type.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/serialization/vector.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 
 #include <hpx/compute/cuda/target.hpp>
 
diff --git a/libs/concepts/CMakeLists.txt b/libs/concepts/CMakeLists.txt
index cf5ec778d9..c7f584891b 100644
--- a/libs/concepts/CMakeLists.txt
+++ b/libs/concepts/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(concepts_headers
   hpx/concepts/concepts.hpp
diff --git a/libs/concepts/README.rst b/libs/concepts/README.rst
index 1b98c404ff..c8ae9c3640 100644
--- a/libs/concepts/README.rst
+++ b/libs/concepts/README.rst
@@ -13,4 +13,4 @@ concepts
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/concepts/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/concepts/docs/index.html>`__.
diff --git a/libs/concurrency/CMakeLists.txt b/libs/concurrency/CMakeLists.txt
index 8448c1f99f..24c6d35470 100644
--- a/libs/concurrency/CMakeLists.txt
+++ b/libs/concurrency/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/concurrency/README.rst b/libs/concurrency/README.rst
index 96f2203332..42981c7b32 100644
--- a/libs/concurrency/README.rst
+++ b/libs/concurrency/README.rst
@@ -12,4 +12,4 @@ concurrency
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/concurrency/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/concurrency/docs/index.html>`__.
diff --git a/libs/concurrency/include/hpx/concurrency/cache_line_data.hpp b/libs/concurrency/include/hpx/concurrency/cache_line_data.hpp
index 40f477d619..043a6a6d81 100644
--- a/libs/concurrency/include/hpx/concurrency/cache_line_data.hpp
+++ b/libs/concurrency/include/hpx/concurrency/cache_line_data.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2019 Hartmut Kaiser
+//  Copyright (c) 2019-2020 Hartmut Kaiser
 //  Copyright (c) 2019 Thomas Heller
 //
 //  SPDX-License-Identifier: BSL-1.0
@@ -23,8 +23,14 @@ namespace hpx {
         {
 #if defined(HPX_HAVE_CXX17_HARDWARE_DESTRUCTIVE_INTERFERENCE_SIZE)
             return std::hardware_destructive_interference_size;
+#else
+#if defined(__s390__) || defined(__s390x__)
+            return 256;    // assume 256 byte cache-line size
+#elif defined(powerpc) || defined(__powerpc__) || defined(__ppc__)
+            return 128;    // assume 128 byte cache-line size
 #else
             return 64;    // assume 64 byte cache-line size
+#endif
 #endif
         }
     }    // namespace threads
@@ -45,6 +51,7 @@ namespace hpx {
             template <typename Data>
             struct needs_padding
               : std::integral_constant<bool,
+                    // NOLINTNEXTLINE(bugprone-sizeof-expression)
                     detail::get_cache_line_padding_size(sizeof(Data)) != 0>
             {
             };
@@ -84,6 +91,7 @@ namespace hpx {
 
             //  cppcheck-suppress unusedVariable
             char cacheline_pad[detail::get_cache_line_padding_size(
+                // NOLINTNEXTLINE(bugprone-sizeof-expression)
                 sizeof(Data))];
         };
 
@@ -105,7 +113,7 @@ namespace hpx {
             {
             }
 
-            // no ned to pad to cache line size
+            // no need to pad to cache line size
             Data data_;
         };
 
diff --git a/libs/concurrency/include/hpx/concurrency/concurrentqueue.hpp b/libs/concurrency/include/hpx/concurrency/concurrentqueue.hpp
index 9b87bc4c64..7f6aeaee01 100644
--- a/libs/concurrency/include/hpx/concurrency/concurrentqueue.hpp
+++ b/libs/concurrency/include/hpx/concurrency/concurrentqueue.hpp
@@ -1611,6 +1611,7 @@ private:
         // arrays of Blocks all be properly aligned (not just the first one). We use a union to force
         // this.
         union {
+            // NOLINTNEXTLINE(bugprone-sizeof-expression)
             char elements[sizeof(T) * BLOCK_SIZE];
             details::max_align_t dummy;
         };
@@ -2898,6 +2899,7 @@ private:
             auto raw = static_cast<char*>((Traits::malloc)(
                 sizeof(BlockIndexHeader) +
                 std::alignment_of<BlockIndexEntry>::value - 1 + sizeof(BlockIndexEntry) * entryCount +
+                // NOLINTNEXTLINE(bugprone-sizeof-expression)
                 std::alignment_of<BlockIndexEntry*>::value - 1 + sizeof(BlockIndexEntry*) * nextBlockIndexCapacity));
             if (raw == nullptr) {
                 return false;
diff --git a/libs/concurrency/include/hpx/concurrency/deque.hpp b/libs/concurrency/include/hpx/concurrency/deque.hpp
index 911d05d3d5..f12c8e406d 100644
--- a/libs/concurrency/include/hpx/concurrency/deque.hpp
+++ b/libs/concurrency/include/hpx/concurrency/deque.hpp
@@ -27,8 +27,7 @@
 
 #include <atomic>
 #include <cstddef>
-#include <iostream>
-#include <thread>
+#include <memory>
 #include <type_traits>
 
 namespace boost { namespace lockfree {
@@ -81,14 +80,15 @@ namespace boost { namespace lockfree {
     template <typename T>
     struct deque_anchor    //-V690
     {
-        typedef deque_node<T> node;
-        typedef typename node::pointer node_pointer;
-        typedef typename node::atomic_pointer atomic_node_pointer;
+        using node = deque_node<T>;
+        using node_pointer = typename node::pointer;
+        using atomic_node_pointer = typename node::atomic_pointer;
 
-        typedef typename node::tag_t tag_t;
+        using tag_t = typename node::tag_t;
 
-        typedef tagged_ptr_pair<node, node> pair;
-        typedef std::atomic<pair> atomic_pair;
+        using anchor = deque_anchor<T>;
+        using pair = tagged_ptr_pair<node, node>;
+        using atomic_pair = std::atomic<pair>;
 
     private:
         atomic_pair pair_;
@@ -197,22 +197,24 @@ namespace boost { namespace lockfree {
         HPX_NON_COPYABLE(deque);
 
     public:
-        typedef deque_node<T> node;
-        typedef typename node::pointer node_pointer;
-        typedef typename node::atomic_pointer atomic_node_pointer;
+        using node = deque_node<T>;
 
-        typedef typename node::tag_t tag_t;
+        using node_pointer = typename node::pointer;
+        using atomic_node_pointer = typename node::atomic_pointer;
 
-        typedef deque_anchor<T> anchor;
-        typedef typename anchor::pair anchor_pair;
-        typedef typename anchor::atomic_pair atomic_anchor_pair;
+        using tag_t = typename node::tag_t;
 
-        typedef typename Alloc::template rebind<node>::other node_allocator;
+        using anchor = deque_anchor<T>;
+        using anchor_pair = typename anchor::pair;
+        using atomic_anchor_pair = typename anchor::atomic_pair;
 
-        typedef typename std::conditional<
+        using node_allocator =
+            typename std::allocator_traits<Alloc>::template rebind_alloc<node>;
+
+        using pool = typename std::conditional<
             std::is_same<freelist_t, caching_freelist_t>::value,
             caching_freelist<node, node_allocator>,
-            static_freelist<node, node_allocator>>::type pool;
+            static_freelist<node, node_allocator>>::type;
 
     private:
         anchor anchor_;
diff --git a/libs/concurrency/include/hpx/concurrency/spinlock.hpp b/libs/concurrency/include/hpx/concurrency/spinlock.hpp
index a5d23f0c06..a04f18f577 100644
--- a/libs/concurrency/include/hpx/concurrency/spinlock.hpp
+++ b/libs/concurrency/include/hpx/concurrency/spinlock.hpp
@@ -24,17 +24,10 @@ namespace hpx { namespace util {
         HPX_NON_COPYABLE(spinlock);
 
     private:
-#if defined(HPX_HAVE_CXX11_NSDMI)
         boost::detail::spinlock m = BOOST_DETAIL_SPINLOCK_INIT;
-#else
-        boost::detail::spinlock m;
-#endif
 
     public:
         spinlock(char const* /*desc*/ = nullptr)
-#if !defined(HPX_HAVE_CXX11_NSDMI)
-          : m(BOOST_DETAIL_SPINLOCK_INIT)
-#endif
         {
             HPX_ITT_SYNC_CREATE(this, "util::spinlock", "");
         }
diff --git a/libs/concurrency/src/thread_name.cpp b/libs/concurrency/src/thread_name.cpp
index 0553c706ec..232a80c545 100644
--- a/libs/concurrency/src/thread_name.cpp
+++ b/libs/concurrency/src/thread_name.cpp
@@ -12,7 +12,7 @@
 namespace hpx { namespace detail {
     std::string& thread_name()
     {
-        static HPX_NATIVE_TLS std::string thread_name_;
+        static thread_local std::string thread_name_;
         return thread_name_;
     }
 }}    // namespace hpx::detail
diff --git a/libs/config/CMakeLists.txt b/libs/config/CMakeLists.txt
index ca2c58a0e5..e3cfa00f95 100644
--- a/libs/config/CMakeLists.txt
+++ b/libs/config/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/config/README.rst b/libs/config/README.rst
index 5f07d92df9..aaa35847a7 100644
--- a/libs/config/README.rst
+++ b/libs/config/README.rst
@@ -13,4 +13,4 @@ This library is part of HPX. It contains macros that identify features of a comp
 as well as platform independent macros to control inlinining, export sets and more.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/config/docs/index.html>`_.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/config/docs/index.html>`_.
diff --git a/libs/config/cmake/templates/config_version.hpp.in b/libs/config/cmake/templates/config_version.hpp.in
index 8ab102fc97..3f146b4099 100644
--- a/libs/config/cmake/templates/config_version.hpp.in
+++ b/libs/config/cmake/templates/config_version.hpp.in
@@ -18,11 +18,11 @@
 #include <boost/version.hpp>
 
 /// Evaluates to the major version of HPX
-#define HPX_VERSION_MAJOR        @HPX_VERSION_MAJOR@u
+#define HPX_VERSION_MAJOR        @HPX_VERSION_MAJOR@
 /// Evaluates to the minor version of HPX
-#define HPX_VERSION_MINOR        @HPX_VERSION_MINOR@u
+#define HPX_VERSION_MINOR        @HPX_VERSION_MINOR@
 /// Evaluates to the subminor version of HPX
-#define HPX_VERSION_SUBMINOR     @HPX_VERSION_SUBMINOR@u
+#define HPX_VERSION_SUBMINOR     @HPX_VERSION_SUBMINOR@
 
 /// Evaluates to the HPX version:
 /// ``HPX_VERSION_FULL & 0xFF0000 == HPX_VERSION_MAJOR``
diff --git a/libs/config/include/hpx/config.hpp b/libs/config/include/hpx/config.hpp
index c86e3d43cf..7271e7706e 100644
--- a/libs/config/include/hpx/config.hpp
+++ b/libs/config/include/hpx/config.hpp
@@ -263,7 +263,7 @@
 
 /// By default we capture only 5 levels of stack back trace on suspension
 #if !defined(HPX_HAVE_THREAD_BACKTRACE_DEPTH)
-#  define HPX_HAVE_THREAD_BACKTRACE_DEPTH 5
+#  define HPX_HAVE_THREAD_BACKTRACE_DEPTH 20
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -322,8 +322,13 @@
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
+// Set defaults for components
+#if !defined(HPX_COMPONENT_NAME_DEFAULT)
+#  define HPX_COMPONENT_NAME_DEFAULT hpx
+#endif
+
 #if !defined(HPX_COMPONENT_NAME)
-#  define HPX_COMPONENT_NAME hpx
+#  define HPX_COMPONENT_NAME HPX_COMPONENT_NAME_DEFAULT
 #endif
 
 #if !defined(HPX_COMPONENT_STRING)
@@ -339,8 +344,12 @@
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
+#if !defined(HPX_PLUGIN_NAME_DEFAULT)
+#  define HPX_PLUGIN_NAME_DEFAULT hpx
+#endif
+
 #if !defined(HPX_PLUGIN_NAME)
-#  define HPX_PLUGIN_NAME hpx
+#  define HPX_PLUGIN_NAME HPX_PLUGIN_NAME_DEFAULT
 #endif
 
 #if !defined(HPX_PLUGIN_STRING)
@@ -352,6 +361,14 @@
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
+#if defined(HPX_PREFIX_DEFAULT) && !defined(HPX_PREFIX)
+#  define HPX_PREFIX HPX_PREFIX_DEFAULT
+#endif
+
+#if defined(HPX_APPLICATION_NAME_DEFAULT) && !defined(HPX_APPLICATION_NAME)
+#  define HPX_APPLICATION_NAME HPX_APPLICATION_NAME_DEFAULT
+#endif
+
 #if !defined(HPX_APPLICATION_STRING)
 #  if defined(HPX_APPLICATION_NAME)
 #    define HPX_APPLICATION_STRING HPX_PP_STRINGIZE(HPX_APPLICATION_NAME)
diff --git a/libs/config/include/hpx/config/attributes.hpp b/libs/config/include/hpx/config/attributes.hpp
index d345ae28e2..8053391522 100644
--- a/libs/config/include/hpx/config/attributes.hpp
+++ b/libs/config/include/hpx/config/attributes.hpp
@@ -44,30 +44,14 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 // handle [[noreturn]]
-#if defined(HPX_HAVE_CXX11_NORETURN_ATTRIBUTE)
-#   define HPX_NORETURN [[noreturn]]
-#else
-#  if defined(_MSC_VER)
-#    define HPX_NORETURN __declspec(noreturn)
-#  elif defined(__GNUC__)
-#    define HPX_NORETURN __attribute__ ((__noreturn__))
-#  else
-#    define HPX_NORETURN
-#  endif
-#endif
+#define HPX_NORETURN [[noreturn]]
 
 ///////////////////////////////////////////////////////////////////////////////
 // handle [[deprecated]]
 #if defined(HPX_HAVE_DEPRECATION_WARNINGS)
 #  define HPX_DEPRECATED_MSG \
    "This functionality is deprecated and will be removed in the future."
-#  if defined(HPX_HAVE_CXX14_DEPRECATED_ATTRIBUTE)
-#    define HPX_DEPRECATED(x) [[deprecated(x)]]
-#  elif defined(HPX_MSVC)
-#    define HPX_DEPRECATED(x) __declspec(deprecated(x))
-#  elif defined(__GNUC__)
-#    define HPX_DEPRECATED(x) __attribute__((__deprecated__(x)))
-#  endif
+#  define HPX_DEPRECATED(x) [[deprecated(x)]]
 #endif
 
 #if !defined(HPX_DEPRECATED)
@@ -88,6 +72,14 @@
 #else
 #   define HPX_FALLTHROUGH
 #endif
+
+///////////////////////////////////////////////////////////////////////////////
+// handle empty_bases
+#if defined(_MSC_VER)
+#  define HPX_EMPTY_BASES __declspec(empty_bases)
+#else
+#  define HPX_EMPTY_BASES
+#endif
 // clang-format on
 
 #endif
diff --git a/libs/config/include/hpx/config/compiler_native_tls.hpp b/libs/config/include/hpx/config/compiler_native_tls.hpp
index 8076634613..50331d742d 100644
--- a/libs/config/include/hpx/config/compiler_native_tls.hpp
+++ b/libs/config/include/hpx/config/compiler_native_tls.hpp
@@ -4,46 +4,19 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+// hpxinspect:nodeprecated_macros
+
 #if !defined(HPX_COMPILER_NATIVE_TLS)
 #define HPX_COMPILER_NATIVE_TLS
 
 #include <hpx/config/defines.hpp>
 
-#if defined(DOXYGEN)
 /// This macro is replaced with the compiler specific keyword attribute to mark
 /// a variable as thread local. For more details see
 /// `<https://en.cppreference.com/w/cpp/keyword/thread_local`__.
-#define HPX_NATIVE_TLS
-#else
-
-// don't #include ciso646 for MSVC as it contains '#define and &&' and similar
-#if !defined(_MSC_VER)
-#include <ciso646>
-#endif
-
-// clang-format off
-#if defined(__has_feature)
-#  if __has_feature(cxx_thread_local)
-#    define HPX_NATIVE_TLS thread_local
-#  endif
-#elif defined(HPX_HAVE_CXX11_THREAD_LOCAL)
-#  define HPX_NATIVE_TLS thread_local
-#endif
-
-#if !defined(HPX_NATIVE_TLS)
-#  if defined(_GLIBCXX_HAVE_TLS)
-#    define HPX_NATIVE_TLS __thread
-#  elif defined(HPX_WINDOWS)
-#    define HPX_NATIVE_TLS __declspec(thread)
-#  elif defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__))
-#    define HPX_NATIVE_TLS __thread
-#  elif defined(__clang__) && defined(HPX_COMPUTE_DEVICE_CODE)
-#    define HPX_NATIVE_TLS __thread
-#  else
-#    error "Native thread local storage is not supported for this platform, please undefine HPX_HAVE_NATIVE_TLS"
-#  endif
-#endif
-// clang-format on
-#endif
+///
+/// This macro is deprecated. It is always replaced with the ``thread_local``
+/// keyword. Prefer using ``thread_local`` directly instead.
+#define HPX_NATIVE_TLS thread_local
 
 #endif
diff --git a/libs/config/include/hpx/config/constexpr.hpp b/libs/config/include/hpx/config/constexpr.hpp
index 1b7301348f..8706226ac0 100644
--- a/libs/config/include/hpx/config/constexpr.hpp
+++ b/libs/config/include/hpx/config/constexpr.hpp
@@ -5,42 +5,31 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+// hpxinspect:nodeprecated_macros
+
 #ifndef HPX_CONFIG_CONSTEXPR_HPP
 #define HPX_CONFIG_CONSTEXPR_HPP
 
 #include <hpx/config/defines.hpp>
 
-#if defined(DOXYGEN)
 /// This macro evaluates to ``constexpr`` if the compiler supports it.
-#define HPX_CONSTEXPR
-/// This macro evaluates to ``constexpr`` if the compiler supports it, ``const``
-/// otherwise.
-#define HPX_CONSTEXPR_OR_CONST
-/// This macro evaluates to ``constexpr`` if the compiler supports C++14
-/// constexpr.
-#define HPX_CXX14_CONSTEXPR
-/// This macro evaluates to ``static :c:macro:HPX_CONSTEXPR_OR_CONST``.
-#define HPX_STATIC_CONSTEXPR
-#else
-
-// clang-format off
-#if defined(HPX_HAVE_CXX11_CONSTEXPR) && !defined(HPX_MSVC_NVCC) &&            \
-    !(defined(__NVCC__) && defined(__clang__))
-#   define HPX_CONSTEXPR constexpr
-#   define HPX_CONSTEXPR_OR_CONST constexpr
-#else
-#   define HPX_CONSTEXPR
-#   define HPX_CONSTEXPR_OR_CONST const
-#endif
+///
+/// This macro is deprecated. It is always replaced with the ``constexpr``
+/// keyword. Prefer using ``constexpr`` directly instead.
+#define HPX_CONSTEXPR constexpr
 
-#ifdef HPX_HAVE_CXX14_CONSTEXPR
-#   define HPX_CXX14_CONSTEXPR constexpr
-#else
-#   define HPX_CXX14_CONSTEXPR
-#endif
-// clang-format on
+///  This macro evaluates to ``constexpr`` if the compiler supports it, ``const``
+/// otherwise.
+///
+/// This macro is deprecated. It is always replaced with the ``constexpr``
+/// keyword. Prefer using ``constexpr`` directly instead.
+#define HPX_CONSTEXPR_OR_CONST constexpr
 
-#define HPX_STATIC_CONSTEXPR static HPX_CONSTEXPR_OR_CONST
-#endif
+///  This macro evaluates to ``static constexpr`` if the compiler supports it,
+/// ``static const`` otherwise.
+///
+/// This macro is deprecated. It is always replaced with the ``static
+/// constexpr`` keyword. Prefer using ``static constexpr`` directly instead.
+#define HPX_STATIC_CONSTEXPR static constexpr
 
 #endif
diff --git a/libs/config/include/hpx/config/lambda_capture.hpp b/libs/config/include/hpx/config/lambda_capture.hpp
index 1c73245ed1..540069075f 100644
--- a/libs/config/include/hpx/config/lambda_capture.hpp
+++ b/libs/config/include/hpx/config/lambda_capture.hpp
@@ -4,29 +4,27 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+// hpxinspect:nodeprecated_macros
+
 #ifndef HPX_CONFIG_LAMBDA_CAPTURE_HPP
 #define HPX_CONFIG_LAMBDA_CAPTURE_HPP
 
 #include <hpx/config/defines.hpp>
 
-#if defined(DOXYGEN)
-/// Evaluates to ``var = std::forward<decltype(var)>(var)`` if the compiler
-/// supports C++14 Lambdas. Defaults to ``var``.
-#define HPX_CAPTURE_FORWARD(var)
-/// Evaluates to ``var = std::move(var)`` if the compiler supports C++14
-/// Lambdas. Defaults to `var`.
-#define HPX_CAPTURE_MOVE(var)
-#else
-
 #include <utility>
 
-#if defined(HPX_HAVE_CXX14_LAMBDAS)
+/// Evaluates to ``var = std::forward<decltype(var)>(var)`` if the compiler
+/// supports C++14 Lambdas. Defaults to ``var``.
+///
+/// This macro is deprecated. Prefer using ``var =
+/// std::forward<decltype(var)>(var)`` directly instead.
 #define HPX_CAPTURE_FORWARD(var) var = std::forward<decltype(var)>(var)
+
+///  Evaluates to ``var = std::move(var)`` if the compiler supports C++14
+/// Lambdas. Defaults to `var`.
+///
+/// This macro is deprecated. Prefer using ``var = std::move(var)`` directly
+/// instead.
 #define HPX_CAPTURE_MOVE(var) var = std::move(var)
-#else
-#define HPX_CAPTURE_FORWARD(var) var
-#define HPX_CAPTURE_MOVE(var) var
-#endif
-#endif
 
 #endif
diff --git a/libs/config/include/hpx/config/threads_stack.hpp b/libs/config/include/hpx/config/threads_stack.hpp
index 8cc204f94e..e2911ccea0 100644
--- a/libs/config/include/hpx/config/threads_stack.hpp
+++ b/libs/config/include/hpx/config/threads_stack.hpp
@@ -27,11 +27,7 @@
 #    if defined(HPX_INTEL_VERSION)
 #      define HPX_THREADS_STACK_OVERHEAD 0x2800
 #    else
-#      if defined(HPX_GCC_VERSION) && HPX_GCC_VERSION >= 40900 && HPX_GCC_VERSION < 50000
-#        define HPX_THREADS_STACK_OVERHEAD 0x1000
-#      else
-#        define HPX_THREADS_STACK_OVERHEAD 0x800
-#      endif
+#      define HPX_THREADS_STACK_OVERHEAD 0x800
 #    endif
 #  endif
 #endif
diff --git a/libs/coroutines/CMakeLists.txt b/libs/coroutines/CMakeLists.txt
index 27929b151e..0093b81cba 100644
--- a/libs/coroutines/CMakeLists.txt
+++ b/libs/coroutines/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -57,6 +57,7 @@ set(coroutines_sources
   detail/context_base.cpp
   detail/coroutine_impl.cpp
   detail/coroutine_self.cpp
+  detail/posix_utility.cpp
   detail/tss.cpp
   swapcontext.cpp
   )
diff --git a/libs/coroutines/README.rst b/libs/coroutines/README.rst
index e7ff35526b..a441071d32 100644
--- a/libs/coroutines/README.rst
+++ b/libs/coroutines/README.rst
@@ -12,4 +12,4 @@ coroutines
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/coroutines/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/coroutines/docs/index.html>`__.
diff --git a/libs/coroutines/include/hpx/coroutines/coroutine.hpp b/libs/coroutines/include/hpx/coroutines/coroutine.hpp
index 58c258f673..f567b88eda 100644
--- a/libs/coroutines/include/hpx/coroutines/coroutine.hpp
+++ b/libs/coroutines/include/hpx/coroutines/coroutine.hpp
@@ -47,6 +47,7 @@
 #include <utility>
 
 namespace hpx { namespace threads { namespace coroutines {
+
     /////////////////////////////////////////////////////////////////////////////
     class coroutine
     {
diff --git a/libs/coroutines/include/hpx/coroutines/detail/context_base.hpp b/libs/coroutines/include/hpx/coroutines/detail/context_base.hpp
index ecc702bf57..95045d294e 100644
--- a/libs/coroutines/include/hpx/coroutines/detail/context_base.hpp
+++ b/libs/coroutines/include/hpx/coroutines/detail/context_base.hpp
@@ -62,29 +62,9 @@
         HPX_COROUTINE_NUM_HEAPS / 4 + HPX_COROUTINE_NUM_HEAPS / 4) /**/
 
 namespace hpx { namespace threads { namespace coroutines { namespace detail {
-    //////////////////////////////////////////////////////////////////////////
-    //
-    struct allocation_counters
-    {
-        allocation_counters()
-        {
-            for (std::size_t i = 0; i < HPX_COROUTINE_NUM_ALL_HEAPS; ++i)
-            {
-                m_allocation_counter[i].store(0);
-            }
-        }
-
-        std::atomic<std::uint64_t>& get(std::size_t i)
-        {
-            return m_allocation_counter[i % HPX_COROUTINE_NUM_ALL_HEAPS];
-        }
-
-        std::atomic<std::uint64_t>
-            m_allocation_counter[HPX_COROUTINE_NUM_ALL_HEAPS];
-    };
 
     /////////////////////////////////////////////////////////////////////////////
-    HPX_CONSTEXPR std::ptrdiff_t const default_stack_size = -1;
+    constexpr std::ptrdiff_t const default_stack_size = -1;
 
     template <typename CoroutineImpl>
     class context_base : public default_context_impl<CoroutineImpl>
@@ -173,25 +153,17 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
             this->init();
             HPX_ASSERT(is_ready());
             do_invoke();
-            // TODO: could use a binary or here to eliminate
-            // shortcut evaluation (and a branch), but maybe the compiler is
-            // smart enough to do it anyway as there are no side effects.
-            if (m_exit_status)
+
+            if (m_exit_status != ctx_not_exited)
             {
                 if (m_exit_status == ctx_exited_return)
                     return;
                 if (m_exit_status == ctx_exited_abnormally)
                 {
+                    HPX_ASSERT(m_type_info);
                     std::rethrow_exception(m_type_info);
-                    //std::type_info const* tinfo = nullptr;
-                    //std::swap(m_type_info, tinfo);
-                    //throw abnormal_exit(tinfo ? *tinfo :
-                    //      typeid(unknown_exception_tag));
-                }
-                else
-                {
-                    HPX_ASSERT(0 && "unknown exit status");
                 }
+                HPX_ASSERT_MSG(false, "unknown exit status");
             }
         }
 
@@ -218,6 +190,7 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
 #if defined(HPX_HAVE_ADDRESS_SANITIZER)
             this->finish_switch_fiber(this->asan_fake_stack, m_caller);
 #endif
+            m_exit_status = ctx_not_exited;
 
             HPX_ASSERT(running());
         }
@@ -275,18 +248,18 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
         // global coroutine state
         enum context_state
         {
-            ctx_running,    // context running.
-            ctx_ready,      // context at yield point.
-            ctx_exited      // context is finished.
+            ctx_running = 0,    // context running.
+            ctx_ready,          // context at yield point.
+            ctx_exited          // context is finished.
         };
 
     protected:
         // exit request state
         enum context_exit_state
         {
-            ctx_exit_not_requested,    // exit not requested.
-            ctx_exit_pending,          // exit requested.
-            ctx_exit_signaled          // exit request delivered.
+            ctx_exit_not_requested = 0,    // exit not requested.
+            ctx_exit_pending,              // exit requested.
+            ctx_exit_signaled              // exit request delivered.
         };
 
         // exit status
@@ -363,7 +336,6 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
             ctx_type;
         ctx_type m_caller;
 
-        static HPX_EXPORT allocation_counters m_allocation_counters;
         context_state m_state;
         context_exit_state m_exit_state;
         context_exit_status m_exit_status;
diff --git a/libs/coroutines/include/hpx/coroutines/detail/context_generic_context.hpp b/libs/coroutines/include/hpx/coroutines/detail/context_generic_context.hpp
index 65bfee4324..8c01554ffb 100644
--- a/libs/coroutines/include/hpx/coroutines/detail/context_generic_context.hpp
+++ b/libs/coroutines/include/hpx/coroutines/detail/context_generic_context.hpp
@@ -44,13 +44,13 @@
 
 extern "C" {
 void* __splitstack_makecontext(
-    std::size_t, void * [HPX_COROUTINES_SEGMENTS], std::size_t*);
-void __splitstack_releasecontext(void * [HPX_COROUTINES_SEGMENTS]);
-void __splitstack_resetcontext(void * [HPX_COROUTINES_SEGMENTS]);
+    std::size_t, void* [HPX_COROUTINES_SEGMENTS], std::size_t*);
+void __splitstack_releasecontext(void* [HPX_COROUTINES_SEGMENTS]);
+void __splitstack_resetcontext(void* [HPX_COROUTINES_SEGMENTS]);
 void __splitstack_block_signals_context(
-    void * [HPX_COROUTINES_SEGMENTS], int* new_value, int* old_value);
-void __splitstack_getcontext(void * [HPX_COROUTINES_SEGMENTS]);
-void __splitstack_setcontext(void * [HPX_COROUTINES_SEGMENTS]);
+    void* [HPX_COROUTINES_SEGMENTS], int* new_value, int* old_value);
+void __splitstack_getcontext(void* [HPX_COROUTINES_SEGMENTS]);
+void __splitstack_setcontext(void* [HPX_COROUTINES_SEGMENTS]);
 }
 
 #if !defined(SIGSTKSZ)
@@ -65,7 +65,7 @@ namespace hpx { namespace threads { namespace coroutines {
     // some platforms need special preparation of the main thread
     struct prepare_main_thread
     {
-        HPX_CONSTEXPR prepare_main_thread() {}
+        constexpr prepare_main_thread() {}
     };
 
     namespace detail { namespace generic_context {
diff --git a/libs/coroutines/include/hpx/coroutines/detail/context_linux_x86.hpp b/libs/coroutines/include/hpx/coroutines/detail/context_linux_x86.hpp
index ffe9577865..87ce8e6ae2 100644
--- a/libs/coroutines/include/hpx/coroutines/detail/context_linux_x86.hpp
+++ b/libs/coroutines/include/hpx/coroutines/detail/context_linux_x86.hpp
@@ -83,7 +83,7 @@ namespace hpx { namespace threads { namespace coroutines {
     // some platforms need special preparation of the main thread
     struct prepare_main_thread
     {
-        HPX_CONSTEXPR prepare_main_thread() {}
+        constexpr prepare_main_thread() {}
     };
 
     namespace detail { namespace lx {
diff --git a/libs/coroutines/include/hpx/coroutines/detail/context_posix.hpp b/libs/coroutines/include/hpx/coroutines/detail/context_posix.hpp
index 1c7a2047fa..6096d6b658 100644
--- a/libs/coroutines/include/hpx/coroutines/detail/context_posix.hpp
+++ b/libs/coroutines/include/hpx/coroutines/detail/context_posix.hpp
@@ -170,7 +170,7 @@ namespace hpx { namespace threads { namespace coroutines {
     // some platforms need special preparation of the main thread
     struct prepare_main_thread
     {
-        HPX_CONSTEXPR prepare_main_thread() {}
+        constexpr prepare_main_thread() {}
     };
 
     namespace detail { namespace posix {
diff --git a/libs/coroutines/include/hpx/coroutines/detail/context_windows_fibers.hpp b/libs/coroutines/include/hpx/coroutines/detail/context_windows_fibers.hpp
index 33cf76930b..d6f0de2c06 100644
--- a/libs/coroutines/include/hpx/coroutines/detail/context_windows_fibers.hpp
+++ b/libs/coroutines/include/hpx/coroutines/detail/context_windows_fibers.hpp
@@ -239,7 +239,7 @@ namespace hpx { namespace threads { namespace coroutines {
                 return stacksize_;
             }
 
-            HPX_CXX14_CONSTEXPR void reset_stack() noexcept {}
+            constexpr void reset_stack() noexcept {}
 
             void rebind_stack() noexcept
             {
diff --git a/libs/coroutines/include/hpx/coroutines/detail/coroutine_impl.hpp b/libs/coroutines/include/hpx/coroutines/detail/coroutine_impl.hpp
index 11a40c5e71..7084d75a1a 100644
--- a/libs/coroutines/include/hpx/coroutines/detail/coroutine_impl.hpp
+++ b/libs/coroutines/include/hpx/coroutines/detail/coroutine_impl.hpp
@@ -49,6 +49,7 @@
 #include <utility>
 
 namespace hpx { namespace threads { namespace coroutines { namespace detail {
+
     ///////////////////////////////////////////////////////////////////////////
     // This type augments the context_base type with the type of the stored
     // functor.
@@ -80,6 +81,7 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
         HPX_EXPORT ~coroutine_impl();
 #endif
 
+        // execute the coroutine using normal context switching
         HPX_EXPORT void operator()() noexcept;
 
     public:
@@ -92,13 +94,13 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
         {
             return m_result;
         }
-        arg_type* args()
+        arg_type* args() noexcept
         {
             HPX_ASSERT(m_arg);
             return m_arg;
         };
 
-        void bind_args(arg_type* arg)
+        void bind_args(arg_type* arg) noexcept
         {
             m_arg = arg;
         }
@@ -113,6 +115,8 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
         void reset()
         {
             this->reset_stack();
+            m_result = result_type(terminated, invalid_thread_id);
+            m_arg = nullptr;
             m_fun.reset();    // just reset the bound function
             this->super_type::reset();
         }
@@ -120,6 +124,8 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
         void rebind(functor_type&& f, thread_id_type id)
         {
             this->rebind_stack();    // count how often a coroutines object was reused
+            m_result = result_type(unknown, invalid_thread_id);
+            m_arg = nullptr;
             m_fun = std::move(f);
             this->super_type::rebind_base(id);
         }
@@ -127,7 +133,6 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
     private:
         result_type m_result;
         arg_type* m_arg;
-
         functor_type m_fun;
     };
 }}}}    // namespace hpx::threads::coroutines::detail
diff --git a/libs/coroutines/include/hpx/coroutines/stackless_coroutine.hpp b/libs/coroutines/include/hpx/coroutines/stackless_coroutine.hpp
index 3b07f8d31e..23a4848922 100644
--- a/libs/coroutines/include/hpx/coroutines/stackless_coroutine.hpp
+++ b/libs/coroutines/include/hpx/coroutines/stackless_coroutine.hpp
@@ -233,8 +233,8 @@ namespace hpx { namespace threads { namespace coroutines {
 
 namespace hpx { namespace threads { namespace coroutines {
 
-    HPX_FORCEINLINE stackless_coroutine::result_type stackless_coroutine::
-    operator()(arg_type arg)
+    HPX_FORCEINLINE stackless_coroutine::result_type
+    stackless_coroutine::operator()(arg_type arg)
     {
         HPX_ASSERT(is_ready());
 
diff --git a/libs/coroutines/include/hpx/coroutines/thread_enums.hpp b/libs/coroutines/include/hpx/coroutines/thread_enums.hpp
index 2b5a04c249..07d68faae3 100644
--- a/libs/coroutines/include/hpx/coroutines/thread_enums.hpp
+++ b/libs/coroutines/include/hpx/coroutines/thread_enums.hpp
@@ -193,7 +193,7 @@ namespace hpx { namespace threads {
     ///////////////////////////////////////////////////////////////////////////
     struct thread_schedule_hint
     {
-        thread_schedule_hint()
+        thread_schedule_hint() noexcept
           : mode(thread_schedule_hint_mode_none)
           , hint(-1)
         {
@@ -205,7 +205,8 @@ namespace hpx { namespace threads {
         {
         }
 
-        thread_schedule_hint(thread_schedule_hint_mode mode, std::int16_t hint)
+        thread_schedule_hint(
+            thread_schedule_hint_mode mode, std::int16_t hint) noexcept
           : mode(mode)
           , hint(hint)
         {
diff --git a/libs/coroutines/include/hpx/coroutines/thread_id_type.hpp b/libs/coroutines/include/hpx/coroutines/thread_id_type.hpp
index 41dbae2d07..b5c582e3a5 100644
--- a/libs/coroutines/include/hpx/coroutines/thread_id_type.hpp
+++ b/libs/coroutines/include/hpx/coroutines/thread_id_type.hpp
@@ -17,6 +17,7 @@
 #include <iosfwd>
 
 namespace hpx { namespace threads {
+
     struct thread_id
     {
     private:
@@ -35,6 +36,9 @@ namespace hpx { namespace threads {
         thread_id(thread_id const&) = default;
         thread_id& operator=(thread_id const&) = default;
 
+        thread_id(thread_id&& rhs) noexcept = default;
+        thread_id& operator=(thread_id&& rhs) noexcept = default;
+
         explicit constexpr operator bool() const noexcept
         {
             return nullptr != thrd_;
@@ -45,7 +49,7 @@ namespace hpx { namespace threads {
             return thrd_;
         }
 
-        HPX_CXX14_CONSTEXPR void reset() noexcept
+        constexpr void reset() noexcept
         {
             thrd_ = nullptr;
         }
@@ -86,25 +90,25 @@ namespace hpx { namespace threads {
             return lhs.thrd_ != rhs.thrd_;
         }
 
-        friend HPX_CXX14_CONSTEXPR bool operator<(
+        friend constexpr bool operator<(
             thread_id const& lhs, thread_id const& rhs) noexcept
         {
             return std::less<void const*>{}(lhs.thrd_, rhs.thrd_);
         }
 
-        friend HPX_CXX14_CONSTEXPR bool operator>(
+        friend constexpr bool operator>(
             thread_id const& lhs, thread_id const& rhs) noexcept
         {
             return std::less<void const*>{}(rhs.thrd_, lhs.thrd_);
         }
 
-        friend HPX_CXX14_CONSTEXPR bool operator<=(
+        friend constexpr bool operator<=(
             thread_id const& lhs, thread_id const& rhs) noexcept
         {
             return !(rhs > lhs);
         }
 
-        friend HPX_CXX14_CONSTEXPR bool operator>=(
+        friend constexpr bool operator>=(
             thread_id const& lhs, thread_id const& rhs) noexcept
         {
             return !(rhs < lhs);
@@ -122,7 +126,7 @@ namespace hpx { namespace threads {
         thread_id_repr thrd_;
     };
 
-    HPX_CONSTEXPR_OR_CONST thread_id invalid_thread_id;
+    constexpr thread_id invalid_thread_id;
 
 }}    // namespace hpx::threads
 
diff --git a/libs/coroutines/src/detail/context_base.cpp b/libs/coroutines/src/detail/context_base.cpp
index d4fb46bfdd..119d1fc07a 100644
--- a/libs/coroutines/src/detail/context_base.cpp
+++ b/libs/coroutines/src/detail/context_base.cpp
@@ -16,8 +16,4 @@ namespace hpx { namespace threads { namespace coroutines { namespace detail {
 
     template class context_base<coroutine_impl>;
 
-    // initialize static allocation counter
-    template <typename CoroutineImpl>
-    allocation_counters context_base<CoroutineImpl>::m_allocation_counters;
-
 }}}}    // namespace hpx::threads::coroutines::detail
diff --git a/libs/coroutines/src/detail/coroutine_self.cpp b/libs/coroutines/src/detail/coroutine_self.cpp
index 06f557a6e3..e8259dc336 100644
--- a/libs/coroutines/src/detail/coroutine_self.cpp
+++ b/libs/coroutines/src/detail/coroutine_self.cpp
@@ -14,7 +14,7 @@
 namespace hpx { namespace threads { namespace coroutines { namespace detail {
     coroutine_self*& coroutine_self::local_self()
     {
-        HPX_NATIVE_TLS coroutine_self* local_self_ = nullptr;
+        static thread_local coroutine_self* local_self_ = nullptr;
         return local_self_;
     }
 }}}}    // namespace hpx::threads::coroutines::detail
diff --git a/libs/coroutines/src/detail/posix_utility.cpp b/libs/coroutines/src/detail/posix_utility.cpp
new file mode 100644
index 0000000000..e0f6580b81
--- /dev/null
+++ b/libs/coroutines/src/detail/posix_utility.cpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2005-2017 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Adelstein-Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#if defined(__linux) || defined(linux) || defined(__linux__) ||                \
+    defined(__FreeBSD__) || defined(__APPLE__)
+#include <hpx/coroutines/detail/posix_utility.hpp>
+
+namespace hpx { namespace threads { namespace coroutines { namespace detail {
+    namespace posix {
+        ///////////////////////////////////////////////////////////////////////
+        // this global (urghhh) variable is used to control whether guard pages
+        // will be used or not
+        HPX_EXPORT bool use_guard_pages = true;
+}}}}}    // namespace hpx::threads::coroutines::detail::posix
+#endif
diff --git a/libs/coroutines/src/swapcontext.s b/libs/coroutines/src/swapcontext.s
index 42db3ad042..4a24b93c4e 100644
--- a/libs/coroutines/src/swapcontext.s
+++ b/libs/coroutines/src/swapcontext.s
@@ -1,25 +1,25 @@
-//  (C) Copyright Giovanni P. Deretta 2005. 
+//  (C) Copyright Giovanni P. Deretta 2005.
 //  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. 
-//  (See accompanying file LICENSE_1_0.txt or copy at 
+//  Distributed under the Boost Software License, Version 1.0.
+//  (See accompanying file LICENSE_1_0.txt or copy at
 //  http://www.boost.org/LICENSE_1_0.txt)
-/* 
+/*
     EAX is &from.sp
     EDX is to.sp
     This is the simplest version of swapcontext
     It saves registers on the old stack,
-    saves the old stack pointer, 
+    saves the old stack pointer,
     load the new stack pointer,
     pop registers from the new stack
      and returns to new caller.
-    EAX is simpy passed to the function it returns to.
+    EAX is simply passed to the function it returns to.
     The first time EAX is the first parameter of the trampoline.
     Otherwise it is simply discarded.
     NOTE: This function should work on any IA32 CPU.
-    NOTE: The biggest penality is the last jump that
+    NOTE: The biggest penalty is the last jump that
     will be always mispredicted (~50 cycles on P4).
     We try to make its address available as soon as possible
-    to try to reduce the penality. Doing a ret instead of a 
+    to try to reduce the penalty. Doing a ret instead of a
     'add $4, %esp'
     'jmp *%ecx'
     really kills performance.
@@ -58,7 +58,7 @@ swapcontext_stack:
   This optimization gives a 50% performance bonus on a plain
   'invoke and yield' test.
   NOTE: both subroutines work even if they are used in the
-   wrong place. 
+   wrong place.
  */
     .align 16
     .globl swapcontext_stack2,
diff --git a/libs/coroutines/src/swapcontext32.ipp b/libs/coroutines/src/swapcontext32.ipp
index 6aae6e813b..aa1be9f684 100644
--- a/libs/coroutines/src/swapcontext32.ipp
+++ b/libs/coroutines/src/swapcontext32.ipp
@@ -52,7 +52,7 @@
    load the new stack pointer,
    pop registers from the new stack
    and returns to new caller.
-   EAX is simpy passed to the function it returns to.
+   EAX is simply passed to the function it returns to.
    The first time EAX is the first parameter of the trampoline.
    Otherwise it is simply discarded.
    NOTE: This function should work on any IA32 CPU.
diff --git a/libs/coroutines/src/swapcontext64.s b/libs/coroutines/src/swapcontext64.s
index 48b8ef5a23..4f7feeae46 100644
--- a/libs/coroutines/src/swapcontext64.s
+++ b/libs/coroutines/src/swapcontext64.s
@@ -13,14 +13,14 @@
     load the new stack pointer,
     pop registers from the new stack
      and returns to new caller.
-    EAX is simpy passed to the function it returns to.
+    EAX is simply passed to the function it returns to.
     The first time EAX is the first parameter of the trampoline.
     Otherwise it is simply discarded.
     NOTE: This function should work on any IA32 CPU.
-    NOTE: The biggest penality is the last jump that
+    NOTE: The biggest penalty is the last jump that
     will be always mispredicted (~50 cycles on P4).
     We try to make its address available as soon as possible
-    to try to reduce the penality. Doing a ret instead of a
+    to try to reduce the penalty. Doing a ret instead of a
     'add $4, %esp'
     'jmp *%ecx'
     really kills performance.
diff --git a/libs/create_library_skeleton.py b/libs/create_library_skeleton.py
index 59be6bbdd8..8bf8c6febd 100755
--- a/libs/create_library_skeleton.py
+++ b/libs/create_library_skeleton.py
@@ -22,7 +22,7 @@ lib_name_upper = lib_name.upper()
 header_str = '=' * len(lib_name)
 
 # CMake minimum version
-cmake_version = '3.3.2'
+cmake_version = '3.13'
 
 cmake_header = f'''# Copyright (c) 2019 The STE||AR-Group
 #
@@ -94,10 +94,6 @@ add_hpx_module({lib_name}
   DEPENDENCIES
   CMAKE_SUBDIRS examples tests
 )
-
-include(HPX_PrintSummary)
-create_configuration_summary(
-  "  Module configuration summary ({lib_name}):" "{lib_name}")
 '''
 
 examples_cmakelists_template = cmake_header + f'''
@@ -267,7 +263,7 @@ if(HPX_WITH_TESTS)
   endif()
 
   if (HPX_WITH_TESTS_HEADERS)
-    add_custom_target(tests.headers.modules)
+    add_hpx_pseudo_target(tests.headers.modules)
     add_hpx_pseudo_dependencies(tests.headers tests.headers.modules)
   endif()
 endif()
diff --git a/libs/datastructures/CMakeLists.txt b/libs/datastructures/CMakeLists.txt
index 2dc5a23520..3cdbfd964e 100644
--- a/libs/datastructures/CMakeLists.txt
+++ b/libs/datastructures/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 # Compatibility with using Boost.FileSystem, introduced in V1.4.0
 hpx_option(HPX_DATASTRUCTURES_WITH_ADAPT_STD_TUPLE
@@ -19,20 +19,21 @@ endif()
 
 set(datastructures_headers
   hpx/datastructures/any.hpp
+  hpx/datastructures/member_pack.hpp
   hpx/datastructures/optional.hpp
   hpx/datastructures/tuple.hpp
-  hpx/datastructures/detail/pack.hpp
   hpx/datastructures/traits/supports_streaming_with_any.hpp
   hpx/datastructures/traits/is_tuple_like.hpp
 )
 
 set(datastructures_compat_headers
+  hpx/datastructures/detail/pack.hpp
+  hpx/traits/supports_streaming_with_any.hpp
+  hpx/traits/is_tuple_like.hpp
   hpx/util/detail/pack.hpp
   hpx/util/any.hpp
   hpx/util/optional.hpp
   hpx/util/tuple.hpp
-  hpx/traits/supports_streaming_with_any.hpp
-  hpx/traits/is_tuple_like.hpp
 )
 
 set(datastructures_sources)
diff --git a/libs/datastructures/README.rst b/libs/datastructures/README.rst
index 698f9f2073..8b4190b586 100644
--- a/libs/datastructures/README.rst
+++ b/libs/datastructures/README.rst
@@ -13,4 +13,4 @@ datastructures
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/datastructures/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/datastructures/docs/index.html>`__.
diff --git a/libs/datastructures/include/hpx/datastructures/any.hpp b/libs/datastructures/include/hpx/datastructures/any.hpp
index 6b31582a42..bc4de9abea 100644
--- a/libs/datastructures/include/hpx/datastructures/any.hpp
+++ b/libs/datastructures/include/hpx/datastructures/any.hpp
@@ -420,7 +420,7 @@ namespace hpx { namespace util {
 
             // this is constexpr starting C++14 only as older gcc's complain
             // about the constructor not having an empty body
-            HPX_CXX14_CONSTEXPR fxn_ptr()
+            constexpr fxn_ptr()
             {
                 base_type::get_type = Vtable::get_type;
                 base_type::static_delete = Vtable::static_delete;
@@ -444,7 +444,7 @@ namespace hpx { namespace util {
 
             // this is constexpr starting C++14 only as older gcc's complain
             // about the constructor not having an empty body
-            HPX_CXX14_CONSTEXPR fxn_ptr()
+            constexpr fxn_ptr()
             {
                 base_type::get_type = Vtable::get_type;
                 base_type::static_delete = Vtable::static_delete;
@@ -470,7 +470,7 @@ namespace hpx { namespace util {
 
             // this is constexpr starting C++14 only as older gcc's complain
             // about the constructor not having an empty body
-            HPX_CXX14_CONSTEXPR fxn_ptr()
+            constexpr fxn_ptr()
             {
                 base_type::get_type = Vtable::get_type;
                 base_type::static_delete = Vtable::static_delete;
@@ -492,7 +492,7 @@ namespace hpx { namespace util {
 
             // this is constexpr starting C++14 only as older gcc's complain
             // about the constructor not having an empty body
-            HPX_CXX14_CONSTEXPR fxn_ptr()
+            constexpr fxn_ptr()
             {
                 base_type::get_type = Vtable::get_type;
                 base_type::static_delete = Vtable::static_delete;
@@ -526,12 +526,12 @@ namespace hpx { namespace util {
         struct get_table
         {
             using is_small =
+                // NOLINTNEXTLINE(bugprone-sizeof-expression)
                 std::integral_constant<bool, (sizeof(T) <= sizeof(void*))>;
 
             template <typename IArch, typename OArch, typename Char,
                 typename Copyable>
-            HPX_CONSTEXPR static fxn_ptr_table<IArch, OArch, Char, Copyable>*
-            get()
+            static constexpr fxn_ptr_table<IArch, OArch, Char, Copyable>* get()
             {
                 using fxn_type = typename fxns<is_small,
                     Copyable>::template type<T, IArch, OArch, Char>;
@@ -602,7 +602,7 @@ namespace hpx { namespace util {
     {
     public:
         // constructors
-        HPX_CONSTEXPR basic_any() noexcept
+        constexpr basic_any() noexcept
           : table(detail::any::get_table<detail::any::empty>::template get<void,
                 void, void, std::true_type>())
           , object(nullptr)
@@ -822,7 +822,7 @@ namespace hpx { namespace util {
     {
     public:
         // constructors
-        HPX_CONSTEXPR basic_any() noexcept
+        constexpr basic_any() noexcept
           : table(detail::any::get_table<detail::any::empty>::template get<void,
                 void, Char, std::true_type>())
           , object(nullptr)
@@ -944,6 +944,7 @@ namespace hpx { namespace util {
 
     public:
         // copy assignment operator
+        // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
         basic_any& operator=(basic_any const& x)
         {
             basic_any(x).swap(*this);
@@ -951,6 +952,7 @@ namespace hpx { namespace util {
         }
 
         // move assignment
+        // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
         basic_any& operator=(basic_any&& rhs) noexcept
         {
             rhs.swap(*this);
@@ -1044,7 +1046,7 @@ namespace hpx { namespace util {
     {
     public:
         // constructors
-        HPX_CONSTEXPR basic_any() noexcept
+        constexpr basic_any() noexcept
           : table(detail::any::get_table<detail::any::empty>::template get<void,
                 void, void, std::false_type>())
           , object(nullptr)
@@ -1231,7 +1233,7 @@ namespace hpx { namespace util {
     {
     public:
         // constructors
-        HPX_CONSTEXPR basic_any() noexcept
+        constexpr basic_any() noexcept
           : table(detail::any::get_table<detail::any::empty>::template get<void,
                 void, Char, std::false_type>())
           , object(nullptr)
diff --git a/libs/datastructures/include/hpx/datastructures/detail/pack.hpp b/libs/datastructures/include/hpx/datastructures/detail/pack.hpp
deleted file mode 100644
index e32437ddc3..0000000000
--- a/libs/datastructures/include/hpx/datastructures/detail/pack.hpp
+++ /dev/null
@@ -1,164 +0,0 @@
-//  Copyright (c) 2014-2016 Agustin Berge
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#ifndef HPX_UTIL_DETAIL_PACK_HPP
-#define HPX_UTIL_DETAIL_PACK_HPP
-
-#include <hpx/config.hpp>
-
-#include <cstddef>
-#include <type_traits>
-
-namespace hpx { namespace util { namespace detail {
-    struct empty
-    {
-    };
-
-    template <typename... Ts>
-    struct pack
-    {
-        typedef pack type;
-        static const std::size_t size = sizeof...(Ts);
-    };
-
-    template <typename T, T... Vs>
-    struct pack_c
-    {
-        typedef pack_c type;
-        static const std::size_t size = sizeof...(Vs);
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    template <typename Left, typename Right>
-    struct make_index_pack_join;
-
-    template <std::size_t... Left, std::size_t... Right>
-    struct make_index_pack_join<pack_c<std::size_t, Left...>,
-        pack_c<std::size_t, Right...>>
-      : pack_c<std::size_t, Left..., (sizeof...(Left) + Right)...>
-    {
-    };
-
-    template <std::size_t N>
-    struct make_index_pack
-      : make_index_pack_join<typename make_index_pack<N / 2>::type,
-            typename make_index_pack<N - N / 2>::type>
-    {
-    };
-
-    template <>
-    struct make_index_pack<0> : pack_c<std::size_t>
-    {
-    };
-
-    template <>
-    struct make_index_pack<1> : pack_c<std::size_t, 0>
-    {
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Workaround for clang bug [https://bugs.llvm.org/show_bug.cgi?id=35077]
-    template <typename T>
-    struct is_true : std::integral_constant<bool, (bool) T::value>
-    {
-    };
-
-    template <typename T>
-    struct is_false : std::integral_constant<bool, !(bool) T::value>
-    {
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    template <typename... Ts>
-    struct _always_true : std::true_type
-    {
-    };
-
-    template <typename... Ts>
-    struct _always_false : std::false_type
-    {
-    };
-
-    template <typename... Ts>
-    static std::false_type _all_of(...);
-
-    template <typename... Ts>
-    static auto _all_of(int)
-        -> _always_true<typename std::enable_if<is_true<Ts>::value>::type...>;
-
-    template <typename... Ts>
-    struct all_of : decltype(detail::_all_of<Ts...>(0))
-    {
-    };
-
-    template <>
-    struct all_of<>    // <fake-type>
-      : std::true_type
-    {
-    };
-
-    template <typename... Ts>
-    static std::true_type _any_of(...);
-
-    template <typename... Ts>
-    static auto _any_of(int)
-        -> _always_false<typename std::enable_if<is_false<Ts>::value>::type...>;
-
-    template <typename... Ts>
-    struct any_of : decltype(detail::_any_of<Ts...>(0))
-    {
-    };
-
-    template <>
-    struct any_of<>    // <fake-type>
-      : std::false_type
-    {
-    };
-
-    template <typename... Ts>
-    struct none_of : std::integral_constant<bool, !any_of<Ts...>::value>
-    {
-    };
-
-    template <typename T, typename... Ts>
-    struct contains : any_of<std::is_same<T, Ts>...>
-    {
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-    template <std::size_t I, typename T>
-    struct indexed
-    {
-        typedef T type;
-    };
-
-    template <typename Ts, typename Is>
-    struct indexer;
-
-    template <typename... Ts, std::size_t... Is>
-    struct indexer<pack<Ts...>, pack_c<std::size_t, Is...>> : indexed<Is, Ts>...
-    {
-    };
-
-    template <std::size_t I, typename Ts>
-    struct at_index_impl
-    {
-        static empty check_(...);
-
-        template <std::size_t J, typename T>
-        static indexed<J, T> check_(indexed<J, T> const&);
-
-        typedef decltype(check_<I>(
-            indexer<Ts, typename make_index_pack<Ts::size>::type>())) type;
-    };
-
-    template <std::size_t I, typename... Ts>
-    struct at_index : at_index_impl<I, pack<Ts...>>::type
-    {
-    };
-}}}    // namespace hpx::util::detail
-
-#endif
diff --git a/libs/datastructures/include/hpx/datastructures/member_pack.hpp b/libs/datastructures/include/hpx/datastructures/member_pack.hpp
new file mode 100644
index 0000000000..6245a79ff1
--- /dev/null
+++ b/libs/datastructures/include/hpx/datastructures/member_pack.hpp
@@ -0,0 +1,136 @@
+//  Copyright (c) 2020 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_UTIL_MEMBER_PACK_HPP
+#define HPX_UTIL_MEMBER_PACK_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/type_support/pack.hpp>
+
+#include <cstddef>    // for size_t
+#include <type_traits>
+#include <utility>
+
+namespace hpx { namespace util {
+
+    namespace detail {
+
+        template <std::size_t I, typename T,
+            bool Empty = std::is_empty<T>::value && !std::is_final<T>::value>
+        struct member_leaf
+        {
+            T member;
+
+            member_leaf() = default;
+
+            template <typename U>
+            explicit constexpr member_leaf(std::piecewise_construct_t, U&& v)
+              : member(std::forward<U>(v))
+            {
+            }
+        };
+
+        template <std::size_t I, typename T>
+        struct member_leaf<I, T, /*Empty*/ true> : T
+        {
+            member_leaf() = default;
+
+            template <typename U>
+            explicit constexpr member_leaf(std::piecewise_construct_t, U&& v)
+              : T(std::forward<U>(v))
+            {
+            }
+        };
+
+        template <std::size_t I, typename T>
+        T member_type(member_leaf<I, T> const& /*leaf*/) noexcept;
+
+        template <std::size_t I, typename T>
+        static constexpr T& member_get(member_leaf<I, T, false>& leaf) noexcept
+        {
+            return leaf.member;
+        }
+        template <std::size_t I, typename T>
+        static constexpr T& member_get(member_leaf<I, T, true>& leaf) noexcept
+        {
+            return leaf;
+        }
+        template <std::size_t I, typename T>
+        static constexpr T const& member_get(
+            member_leaf<I, T, false> const& leaf) noexcept
+        {
+            return leaf.member;
+        }
+        template <std::size_t I, typename T>
+        static constexpr T const& member_get(
+            member_leaf<I, T, true> const& leaf) noexcept
+        {
+            return leaf;
+        }
+
+    }    // namespace detail
+
+    ///////////////////////////////////////////////////////////////////////
+    template <typename Is, typename... Ts>
+    struct HPX_EMPTY_BASES member_pack;
+
+    template <std::size_t... Is, typename... Ts>
+    struct HPX_EMPTY_BASES member_pack<util::index_pack<Is...>, Ts...>
+      : detail::member_leaf<Is, Ts>...
+    {
+        member_pack() = default;
+
+        template <typename... Us>
+        explicit constexpr member_pack(std::piecewise_construct_t, Us&&... us)
+          : detail::member_leaf<Is, Ts>(
+                std::piecewise_construct, std::forward<Us>(us))...
+        {
+        }
+
+        template <std::size_t I>
+            constexpr decltype(auto) get() & noexcept
+        {
+            return detail::member_get<I>(*this);
+        }
+        template <std::size_t I>
+        constexpr decltype(auto) get() const& noexcept
+        {
+            return detail::member_get<I>(*this);
+        }
+        template <std::size_t I>
+            constexpr decltype(auto) get() && noexcept
+        {
+            using T = decltype(detail::member_type<I>(*this));
+            return std::forward<T>(detail::member_get<I>(*this));
+        }
+        template <std::size_t I>
+        constexpr decltype(auto) get() const&& noexcept
+        {
+            using T = decltype(detail::member_type<I>(*this));
+            return std::forward<T>(detail::member_get<I>(*this));
+        }
+    };
+
+    template <typename... Ts>
+    using member_pack_for =
+        member_pack<typename util::make_index_pack<sizeof...(Ts)>::type, Ts...>;
+
+}}    // namespace hpx::util
+
+///////////////////////////////////////////////////////////////////////////////
+namespace hpx { namespace serialization {
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename Archive, std::size_t... Is, typename... Ts>
+    HPX_FORCEINLINE void serialize(Archive& ar,
+        ::hpx::util::member_pack<util::index_pack<Is...>, Ts...>& mp,
+        unsigned int const /*version*/ = 0)
+    {
+        int sequencer[] = {((ar & mp.template get<Is>()), 0)...};
+        (void) sequencer;
+    }
+}}    // namespace hpx::serialization
+
+#endif /*HPX_UTIL_MEMBER_PACK_HPP*/
diff --git a/libs/datastructures/include/hpx/datastructures/optional.hpp b/libs/datastructures/include/hpx/datastructures/optional.hpp
index 4f6537de87..ec67b47319 100644
--- a/libs/datastructures/include/hpx/datastructures/optional.hpp
+++ b/libs/datastructures/include/hpx/datastructures/optional.hpp
@@ -22,14 +22,14 @@ namespace hpx { namespace util {
         struct init
         {
         };
-        HPX_CONSTEXPR explicit nullopt_t(nullopt_t::init) {}
+        constexpr explicit nullopt_t(nullopt_t::init) {}
     };
-    HPX_CONSTEXPR nullopt_t nullopt{nullopt_t::init()};
+    constexpr nullopt_t nullopt{nullopt_t::init()};
 
     struct in_place_t
     {
     };
-    HPX_CONSTEXPR struct in_place_t in_place
+    constexpr struct in_place_t in_place
     {
     };
 
@@ -61,12 +61,12 @@ namespace hpx { namespace util {
     public:
         using value_type = T;
 
-        HPX_CONSTEXPR optional() noexcept
+        constexpr optional() noexcept
           : empty_(true)
         {
         }
 
-        HPX_CONSTEXPR optional(nullopt_t) noexcept
+        constexpr optional(nullopt_t) noexcept
           : empty_(true)
         {
         }
@@ -196,7 +196,7 @@ namespace hpx { namespace util {
         }
 
         ///////////////////////////////////////////////////////////////////////
-        HPX_CONSTEXPR T const* operator->() const noexcept
+        constexpr T const* operator->() const noexcept
         {
             return reinterpret_cast<T const*>(&storage_);
         }
@@ -206,7 +206,7 @@ namespace hpx { namespace util {
             return reinterpret_cast<T*>(&storage_);
         }
 
-        HPX_CONSTEXPR T const& operator*() const noexcept
+        constexpr T const& operator*() const noexcept
         {
             return *reinterpret_cast<T const*>(&storage_);
         }
@@ -216,12 +216,12 @@ namespace hpx { namespace util {
             return *reinterpret_cast<T*>(&storage_);
         }
 
-        HPX_CONSTEXPR explicit operator bool() const noexcept
+        constexpr explicit operator bool() const noexcept
         {
             return !empty_;
         }
 
-        HPX_CONSTEXPR bool has_value() const
+        constexpr bool has_value() const
         {
             return !empty_;
         }
@@ -247,7 +247,7 @@ namespace hpx { namespace util {
         }
 
         template <typename U>
-        HPX_CXX14_CONSTEXPR T value_or(U&& value) const
+        constexpr T value_or(U&& value) const
         {
             if (empty_)
                 return std::forward<U>(value);
@@ -309,8 +309,7 @@ namespace hpx { namespace util {
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename T>
-    HPX_CONSTEXPR bool operator==(
-        optional<T> const& lhs, optional<T> const& rhs)
+    constexpr bool operator==(optional<T> const& lhs, optional<T> const& rhs)
     {
         return (bool(lhs) != bool(rhs)) ?
             false :
@@ -318,180 +317,177 @@ namespace hpx { namespace util {
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator!=(
-        optional<T> const& lhs, optional<T> const& rhs)
+    constexpr bool operator!=(optional<T> const& lhs, optional<T> const& rhs)
     {
         return !(lhs == rhs);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<(optional<T> const& lhs, optional<T> const& rhs)
+    constexpr bool operator<(optional<T> const& lhs, optional<T> const& rhs)
     {
         return (!bool(rhs)) ? false : (!bool(lhs)) ? true : *rhs < *lhs;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>=(
-        optional<T> const& lhs, optional<T> const& rhs)
+    constexpr bool operator>=(optional<T> const& lhs, optional<T> const& rhs)
     {
         return !(lhs < rhs);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>(optional<T> const& lhs, optional<T> const& rhs)
+    constexpr bool operator>(optional<T> const& lhs, optional<T> const& rhs)
     {
         return (!bool(lhs)) ? false : (!bool(rhs)) ? true : *rhs > *lhs;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<=(
-        optional<T> const& lhs, optional<T> const& rhs)
+    constexpr bool operator<=(optional<T> const& lhs, optional<T> const& rhs)
     {
         return !(lhs > rhs);
     }
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename T>
-    HPX_CONSTEXPR bool operator==(optional<T> const& opt, nullopt_t) noexcept
+    constexpr bool operator==(optional<T> const& opt, nullopt_t) noexcept
     {
         return !bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator==(nullopt_t, optional<T> const& opt) noexcept
+    constexpr bool operator==(nullopt_t, optional<T> const& opt) noexcept
     {
         return !bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator!=(optional<T> const& opt, nullopt_t) noexcept
+    constexpr bool operator!=(optional<T> const& opt, nullopt_t) noexcept
     {
         return bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator!=(nullopt_t, optional<T> const& opt) noexcept
+    constexpr bool operator!=(nullopt_t, optional<T> const& opt) noexcept
     {
         return bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<(optional<T> const& opt, nullopt_t) noexcept
+    constexpr bool operator<(optional<T> const& opt, nullopt_t) noexcept
     {
         return false;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<(nullopt_t, optional<T> const& opt) noexcept
+    constexpr bool operator<(nullopt_t, optional<T> const& opt) noexcept
     {
         return bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>=(optional<T> const& opt, nullopt_t) noexcept
+    constexpr bool operator>=(optional<T> const& opt, nullopt_t) noexcept
     {
         return true;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>=(nullopt_t, optional<T> const& opt) noexcept
+    constexpr bool operator>=(nullopt_t, optional<T> const& opt) noexcept
     {
         return !bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>(optional<T> const& opt, nullopt_t) noexcept
+    constexpr bool operator>(optional<T> const& opt, nullopt_t) noexcept
     {
         return bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>(nullopt_t, optional<T> const& opt) noexcept
+    constexpr bool operator>(nullopt_t, optional<T> const& opt) noexcept
     {
         return false;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<=(optional<T> const& opt, nullopt_t) noexcept
+    constexpr bool operator<=(optional<T> const& opt, nullopt_t) noexcept
     {
         return !bool(opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<=(nullopt_t, optional<T> const& opt) noexcept
+    constexpr bool operator<=(nullopt_t, optional<T> const& opt) noexcept
     {
         return true;
     }
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename T>
-    HPX_CONSTEXPR bool operator==(optional<T> const& opt, T const& value)
+    constexpr bool operator==(optional<T> const& opt, T const& value)
     {
         return bool(opt) ? (*opt == value) : false;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator==(T const& value, optional<T> const& opt)
+    constexpr bool operator==(T const& value, optional<T> const& opt)
     {
         return bool(opt) ? (value == *opt) : false;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator!=(optional<T> const& opt, T const& value)
+    constexpr bool operator!=(optional<T> const& opt, T const& value)
     {
         return !(opt == value);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator!=(T const& value, optional<T> const& opt)
+    constexpr bool operator!=(T const& value, optional<T> const& opt)
     {
         return !(value == *opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<(optional<T> const& opt, T const& value)
+    constexpr bool operator<(optional<T> const& opt, T const& value)
     {
         return bool(opt) ? (*opt < value) : true;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<(T const& value, optional<T> const& opt)
+    constexpr bool operator<(T const& value, optional<T> const& opt)
     {
         return bool(opt) ? (value < *opt) : false;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>=(optional<T> const& opt, T const& value)
+    constexpr bool operator>=(optional<T> const& opt, T const& value)
     {
         return !(*opt < value);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>=(T const& value, optional<T> const& opt)
+    constexpr bool operator>=(T const& value, optional<T> const& opt)
     {
         return !(value < *opt);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>(optional<T> const& opt, T const& value)
+    constexpr bool operator>(optional<T> const& opt, T const& value)
     {
         return bool(opt) ? (*opt > value) : false;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator>(T const& value, optional<T> const& opt)
+    constexpr bool operator>(T const& value, optional<T> const& opt)
     {
         return bool(opt) ? (value > *opt) : true;
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<=(optional<T> const& opt, T const& value)
+    constexpr bool operator<=(optional<T> const& opt, T const& value)
     {
         return !(*opt > value);
     }
 
     template <typename T>
-    HPX_CONSTEXPR bool operator<=(T const& value, optional<T> const& opt)
+    constexpr bool operator<=(T const& value, optional<T> const& opt)
     {
         return !(value > *opt);
     }
@@ -505,20 +501,19 @@ namespace hpx { namespace util {
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename T>
-    HPX_CONSTEXPR optional<typename std::decay<T>::type> make_optional(T&& v)
+    constexpr optional<typename std::decay<T>::type> make_optional(T&& v)
     {
         return optional<typename std::decay<T>::type>(std::forward<T>(v));
     }
 
     template <typename T, typename... Ts>
-    HPX_CONSTEXPR optional<T> make_optional(Ts&&... ts)
+    constexpr optional<T> make_optional(Ts&&... ts)
     {
         return optional<T>(in_place, std::forward<Ts>(ts)...);
     }
 
     template <typename T, typename U, typename... Ts>
-    HPX_CONSTEXPR optional<T> make_optional(
-        std::initializer_list<U> il, Ts&&... ts)
+    constexpr optional<T> make_optional(std::initializer_list<U> il, Ts&&... ts)
     {
         return optional<T>(in_place, il, std::forward<Ts>(ts)...);
     }
@@ -529,7 +524,7 @@ namespace std {
     template <typename T>
     struct hash<hpx::util::optional<T>>
     {
-        HPX_CONSTEXPR std::size_t operator()(
+        constexpr std::size_t operator()(
             ::hpx::util::optional<T> const& arg) const
         {
             return arg ? std::hash<T>{}(*arg) : std::size_t{};
diff --git a/libs/datastructures/include/hpx/datastructures/tuple.hpp b/libs/datastructures/include/hpx/datastructures/tuple.hpp
index a32dc44687..ca45d916a7 100644
--- a/libs/datastructures/include/hpx/datastructures/tuple.hpp
+++ b/libs/datastructures/include/hpx/datastructures/tuple.hpp
@@ -11,10 +11,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/datastructures/config/defines.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/datastructures/member_pack.hpp>
 #include <hpx/type_support/decay.hpp>
-
-#include <boost/array.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <algorithm>
 #include <array>
@@ -50,22 +49,22 @@ namespace hpx { namespace util {
     namespace adl_barrier {
 
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type&
             get(Tuple& t) noexcept;
 
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type const&
             get(Tuple const& t) noexcept;
 
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type&&
             get(Tuple&& t) noexcept;
 
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type const&&
             get(Tuple const&& t) noexcept;
     }    // namespace adl_barrier
@@ -74,7 +73,7 @@ namespace hpx { namespace util {
 }}    // namespace hpx::util
 
 #if defined(HPX_DATASTRUCTURES_HAVE_ADAPT_STD_TUPLE)
-// Adapt hpx::util::tuple to be useable with std::tuple
+// Adapt hpx::util::tuple to be usable with std::tuple
 namespace std {
 
     template <typename... Ts>
@@ -98,283 +97,34 @@ namespace hpx { namespace util {
     namespace detail {
 
         ///////////////////////////////////////////////////////////////////////
-        template <std::size_t I, typename T, typename Enable = void>
-        struct tuple_member    //-V690
+        template <typename Indices, typename TTuple, typename UTuple,
+            typename Enable = void>
+        struct are_tuples_compatible_impl : std::false_type
         {
-        public:
-            template <typename U = T,
-                typename EnableDefault = typename std::enable_if<
-                    std::is_constructible<U>::value>::type>
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member()
-              : _value()
-            {
-            }
-
-            template <typename U,
-                typename = typename std::enable_if<!std::is_same<tuple_member,
-                    typename std::decay<U>::type>::value>::type>
-            explicit HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member(U&& value)
-              : _value(std::forward<U>(value))
-            {
-            }
-
-#if !defined(__NVCC__) && !defined(__CUDACC__)
-            tuple_member(tuple_member const&) = default;
-            tuple_member(tuple_member&&) = default;
-#else
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member(
-                tuple_member const& other)
-              : _value(other.value())
-            {
-            }
-
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member(tuple_member&& other)
-              : _value(std::forward<T>(other.value()))
-            {
-            }
-#endif
-
-            HPX_HOST_DEVICE T& value() noexcept
-            {
-                return _value;
-            }
-            HPX_HOST_DEVICE T const& value() const noexcept
-            {
-                return _value;
-            }
-
-        private:
-            T _value;
         };
 
-        template <std::size_t I, typename T>
-        struct tuple_member<I, T,
-            typename std::enable_if<std::is_empty<T>::value
-#if defined(HPX_HAVE_CXX14_STD_IS_FINAL)
-                && !std::is_final<T>::value
-#endif
-                >::type> : T
-        {
-        public:
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member()
-              : T()
-            {
-            }
-
-            template <typename U,
-                typename = typename std::enable_if<!std::is_same<tuple_member,
-                    typename std::decay<U>::type>::value>::type>
-            explicit HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member(U&& value)
-              : T(std::forward<U>(value))
-            {
-            }
-
-#if !defined(__NVCC__) && !defined(__CUDACC__)
-            tuple_member(tuple_member const&) = default;
-            tuple_member(tuple_member&&) = default;
-#else
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member(
-                tuple_member const& other)
-              : T(other.value())
-            {
-            }
-
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_member(tuple_member&& other)
-              : T(std::forward<T>(other.value()))
-            {
-            }
-#endif
-
-            HPX_HOST_DEVICE T& value() noexcept
-            {
-                return *this;
-            }
-            HPX_HOST_DEVICE T const& value() const noexcept
-            {
-                return *this;
-            }
-        };
-
-        ///////////////////////////////////////////////////////////////////////
-        template <typename Indices, typename TTuple, typename UTuple>
-        struct are_tuples_compatible_impl;
-
         template <std::size_t... Is, typename... Ts, typename UTuple>
-        struct are_tuples_compatible_impl<detail::pack_c<std::size_t, Is...>,
-            tuple<Ts...>, UTuple>
+        struct are_tuples_compatible_impl<util::index_pack<Is...>, tuple<Ts...>,
+            UTuple,
+            typename std::enable_if<tuple_size<typename std::remove_reference<
+                                        UTuple>::type>::value ==
+                util::pack<Ts...>::size>::type>
+          : util::all_of<std::is_convertible<
+                decltype(util::get<Is>(std::declval<UTuple>())), Ts>...>
         {
-            using no_type = char (&)[1];
-            using yes_type = char (&)[2];
-
-            static no_type call(...);
-            static yes_type call(Ts...);
-
-            static bool const value =
-                sizeof(call(util::get<Is>(std::declval<UTuple>())...)    //-V510
-                    ) == sizeof(yes_type);
-
-            using type = std::integral_constant<bool, value>;
         };
 
-        template <typename TTuple, typename UTuple, typename Enable = void>
-        struct are_tuples_compatible : std::false_type
-        {
-        };
+        template <typename TTuple, typename UTuple>
+        struct are_tuples_compatible;
 
         template <typename... Ts, typename UTuple>
-        struct are_tuples_compatible<tuple<Ts...>, UTuple,
-            typename std::enable_if<tuple_size<typename std::remove_reference<
-                                        UTuple>::type>::value ==
-                detail::pack<Ts...>::size>::type>
+        struct are_tuples_compatible<tuple<Ts...>, UTuple>
           : are_tuples_compatible_impl<
-                typename detail::make_index_pack<sizeof...(Ts)>::type,
+                typename util::make_index_pack<sizeof...(Ts)>::type,
                 tuple<Ts...>, UTuple>
         {
         };
 
-        template <typename TTuple, typename UTuple>
-        struct are_tuples_compatible_not_same
-          : std::conditional<std::is_same<typename std::decay<TTuple>::type,
-                                 typename std::decay<UTuple>::type>::value,
-                std::false_type, are_tuples_compatible<TTuple, UTuple>>::type
-        {
-        };
-
-        ///////////////////////////////////////////////////////////////////////
-        template <typename Is, typename... Ts>
-        struct tuple_impl;
-
-        template <std::size_t... Is, typename... Ts>
-        struct tuple_impl<detail::pack_c<std::size_t, Is...>, Ts...>
-          : tuple_member<Is, Ts>...
-        {
-            // 20.4.2.1, tuple construction
-            template <typename Dependent = void,
-                typename Enable = typename std::enable_if<
-                    hpx::util::detail::all_of<
-                        std::is_constructible<Ts>...>::value,
-                    Dependent>::type>
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_impl()
-              : tuple_member<Is, Ts>()...
-            {
-            }
-
-            template <typename... Us,
-                typename Enable =
-                    typename std::enable_if<detail::pack<Us...>::size ==
-                        detail::pack<Ts...>::size>::type>
-            explicit HPX_CONSTEXPR HPX_HOST_DEVICE tuple_impl(Us&&... vs)
-              : tuple_member<Is, Ts>(std::forward<Us>(vs))...
-            {
-            }
-
-#if !defined(__NVCC__) && !defined(__CUDACC__)
-            tuple_impl(tuple_impl const&) = default;
-            tuple_impl(tuple_impl&&) = default;
-#else
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_impl(tuple_impl const& other)
-              : tuple_member<Is, Ts>(
-                    static_cast<tuple_member<Is, Ts> const&>(other))...
-            {
-            }
-
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_impl(tuple_impl&& other)
-              : tuple_member<Is, Ts>(
-                    static_cast<tuple_member<Is, Ts>&&>(other))...
-            {
-            }
-#endif
-
-            template <typename UTuple,
-                typename Enable =
-                    typename std::enable_if<are_tuples_compatible_not_same<
-                        tuple<Ts...>, UTuple&&>::value>::type>
-            HPX_CONSTEXPR HPX_HOST_DEVICE tuple_impl(UTuple&& other)
-              : tuple_member<Is, Ts>(
-                    util::get<Is>(std::forward<UTuple>(other)))...
-            {
-            }
-
-            HPX_HOST_DEVICE tuple_impl& operator=(tuple_impl const& other)
-            {
-                int const _sequencer[] = {
-                    ((this->get<Is>() = other.template get<Is>()), 0)...};
-                (void) _sequencer;
-                return *this;
-            }
-
-            HPX_HOST_DEVICE tuple_impl& operator=(tuple_impl&& other)
-            {
-                int const _sequencer[] = {((this->get<Is>() = std::forward<Ts>(
-                                                other.template get<Is>())),
-                    0)...};
-                (void) _sequencer;
-                return *this;
-            }
-
-            template <typename UTuple>
-            HPX_HOST_DEVICE tuple_impl& operator=(UTuple&& other)
-            {
-                int const _sequencer[] = {((this->get<Is>() = util::get<Is>(
-                                                std::forward<UTuple>(other))),
-                    0)...};
-                (void) _sequencer;
-                return *this;
-            }
-
-            HPX_HOST_DEVICE void swap(tuple_impl& other)
-            {
-                using std::swap;
-                int const _sequencer[] = {
-                    ((swap(this->get<Is>(), other.template get<Is>())), 0)...};
-                (void) _sequencer;
-            }
-
-            template <std::size_t I>
-            HPX_HOST_DEVICE typename detail::at_index<I, Ts...>::type&
-            get() noexcept
-            {
-                return static_cast<tuple_member<I,
-                    typename detail::at_index<I, Ts...>::type>&>(*this)
-                    .value();
-            }
-
-            template <std::size_t I>
-            HPX_HOST_DEVICE typename detail::at_index<I, Ts...>::type const&
-            get() const noexcept
-            {
-                return static_cast<tuple_member<I,
-                    typename detail::at_index<I, Ts...>::type> const&>(*this)
-                    .value();
-            }
-
-#if defined(HPX_DATASTRUCTURES_HAVE_ADAPT_STD_TUPLE)
-            HPX_HOST_DEVICE
-            operator std::tuple<Ts...>() const&
-            {
-                return std::make_tuple(get<Is>()...);
-            }
-
-            HPX_HOST_DEVICE
-            operator std::tuple<Ts...>() &&
-            {
-                return std::make_tuple(std::move(get<Is>())...);
-            }
-
-            HPX_HOST_DEVICE
-            operator std::tuple<Ts...>() &
-            {
-                return std::make_tuple(get<Is>()...);
-            }
-
-            HPX_HOST_DEVICE
-            operator std::tuple<Ts...>() const&&
-            {
-                return std::make_tuple(std::move(get<Is>())...);
-            }
-#endif
-        };
-
         ///////////////////////////////////////////////////////////////////////
         struct ignore_type
         {
@@ -394,17 +144,17 @@ namespace hpx { namespace util {
 
         // constexpr tuple();
         // Value initializes each element.
-        HPX_CONSTEXPR HPX_HOST_DEVICE tuple() {}
+        constexpr HPX_HOST_DEVICE tuple() {}
 
         // tuple(const tuple& u) = default;
         // Initializes each element of *this with the corresponding element
         // of u.
-        HPX_CONSTEXPR HPX_HOST_DEVICE tuple(tuple const& /*other*/) = default;
+        constexpr tuple(tuple const& /*other*/) = default;
 
         // tuple(tuple&& u) = default;
         // For all i, initializes the ith element of *this with
         // std::forward<Ti>(get<i>(u)).
-        HPX_CONSTEXPR HPX_HOST_DEVICE tuple(tuple&& /*other*/) = default;
+        constexpr tuple(tuple&& /*other*/) = default;
 
         // 20.4.2.2, tuple assignment
 
@@ -440,10 +190,7 @@ namespace hpx { namespace util {
     template <typename... Ts>
     class tuple
     {
-    public:    // exposition-only
-        detail::tuple_impl<
-            typename detail::make_index_pack<sizeof...(Ts)>::type, Ts...>
-            _impl;
+        using index_pack = typename util::make_index_pack<sizeof...(Ts)>::type;
 
     public:
         // 20.4.2.1, tuple construction
@@ -452,18 +199,18 @@ namespace hpx { namespace util {
         // Value initializes each element.
         template <typename Dependent = void,
             typename Enable = typename std::enable_if<
-                hpx::util::detail::all_of<std::is_constructible<Ts>...>::value,
+                util::all_of<std::is_constructible<Ts>...>::value,
                 Dependent>::type>
-        HPX_CONSTEXPR HPX_HOST_DEVICE tuple()
-          : _impl()
+        constexpr HPX_HOST_DEVICE tuple()
+          : _members()
         {
         }
 
         // explicit constexpr tuple(const Types&...);
         // Initializes each element with the value of the corresponding
         // parameter.
-        explicit HPX_CONSTEXPR HPX_HOST_DEVICE tuple(Ts const&... vs)
-          : _impl(vs...)
+        explicit constexpr HPX_HOST_DEVICE tuple(Ts const&... vs)
+          : _members(std::piecewise_construct, vs...)
         {
         }
 
@@ -476,18 +223,13 @@ namespace hpx { namespace util {
         // corresponding type in Types.
         template <typename U, typename... Us,
             typename Enable = typename std::enable_if<
-                detail::pack<U, Us...>::size == detail::pack<Ts...>::size &&
-                std::conditional<detail::pack<Us...>::size == 0,
-                    typename std::enable_if<
-                        !std::is_same<tuple,
-                            typename std::decay<U>::type>::value &&
-                            !detail::are_tuples_compatible_not_same<tuple,
-                                U&&>::value,
-                        detail::are_tuples_compatible<tuple, tuple<U>&&>>::type,
-                    detail::are_tuples_compatible<tuple,
-                        tuple<U, Us...>&&>>::type::value>::type>
-        explicit HPX_CONSTEXPR HPX_HOST_DEVICE tuple(U&& v, Us&&... vs)
-          : _impl(std::forward<U>(v), std::forward<Us>(vs)...)
+                !std::is_same<tuple, typename std::decay<U>::type>::value ||
+                util::pack<Us...>::size != 0>::type,
+            typename EnableCompatible = typename std::enable_if<detail::
+                    are_tuples_compatible<tuple, tuple<U, Us...>>::value>::type>
+        explicit constexpr HPX_HOST_DEVICE tuple(U&& v, Us&&... vs)
+          : _members(std::piecewise_construct, std::forward<U>(v),
+                std::forward<Us>(vs)...)
         {
         }
 
@@ -505,43 +247,85 @@ namespace hpx { namespace util {
         // tuple(const tuple& u) = default;
         // Initializes each element of *this with the corresponding element
         // of u.
-        HPX_CONSTEXPR HPX_HOST_DEVICE tuple(tuple const& other)
-          : _impl(other._impl)
+        constexpr HPX_HOST_DEVICE tuple(tuple const& other)
+          : _members(other._members)
         {
         }
 
         // tuple(tuple&& u) = default;
         // For all i, initializes the ith element of *this with
         // std::forward<Ti>(get<i>(u)).
-        HPX_CONSTEXPR HPX_HOST_DEVICE tuple(tuple&& other)
-          : _impl(std::move(other._impl))
+        constexpr HPX_HOST_DEVICE tuple(tuple&& other)
+          : _members(std::move(other._members))
         {
         }
 #endif
 
+    private:
+        template <std::size_t... Is, typename UTuple>
+        constexpr HPX_HOST_DEVICE tuple(util::index_pack<Is...>, UTuple&& other)
+          : _members(std::piecewise_construct,
+                util::get<Is>(std::forward<UTuple>(other))...)
+        {
+        }
+
+    public:
         // template <class... UTypes> constexpr tuple(const tuple<UTypes...>& u);
         // template <class... UTypes> constexpr tuple(tuple<UTypes...>&& u);
         // For all i, initializes the ith element of *this with
-        // get<i>(std::forward<U>(u).
+        // get<i>(std::forward<U>(u)).
         // This constructor shall not participate in overload resolution
         // unless each type in UTypes is implicitly convertible to its
         // corresponding type in Types
         template <typename UTuple,
-            typename Enable =
-                typename std::enable_if<detail::are_tuples_compatible_not_same<
-                    tuple, UTuple&&>::value>::type>
-        HPX_CONSTEXPR HPX_HOST_DEVICE tuple(UTuple&& other)
-          : _impl(std::forward<UTuple>(other))
+            typename Enable = typename std::enable_if<!std::is_same<tuple,
+                typename std::decay<UTuple>::type>::value>::type,
+            typename EnableCompatible = typename std::enable_if<
+                detail::are_tuples_compatible<tuple, UTuple>::value>::type>
+        constexpr HPX_HOST_DEVICE tuple(UTuple&& other)
+          : tuple(index_pack{}, std::forward<UTuple>(other))
         {
         }
 
         // 20.4.2.2, tuple assignment
+    private:
+        template <std::size_t... Is>
+        HPX_HOST_DEVICE void assign_(
+            util::index_pack<Is...>, tuple const& other)
+        {
+            int const _sequencer[] = {
+                ((_members.template get<Is>() =
+                         other._members.template get<Is>()),
+                    0)...};
+            (void) _sequencer;
+        }
+
+        template <std::size_t... Is>
+        HPX_HOST_DEVICE void assign_(util::index_pack<Is...>, tuple&& other)
+        {
+            int const _sequencer[] = {
+                ((_members.template get<Is>() =
+                         std::move(other._members).template get<Is>()),
+                    0)...};
+            (void) _sequencer;
+        }
+
+        template <std::size_t... Is, typename UTuple>
+        HPX_HOST_DEVICE void assign_(util::index_pack<Is...>, UTuple&& other)
+        {
+            int const _sequencer[] = {
+                ((_members.template get<Is>() =
+                         util::get<Is>(std::forward<UTuple>(other))),
+                    0)...};
+            (void) _sequencer;
+        }
 
+    public:
         // tuple& operator=(const tuple& u);
         // Assigns each element of u to the corresponding element of *this.
         HPX_HOST_DEVICE tuple& operator=(tuple const& other)
         {
-            _impl = other._impl;
+            assign_(index_pack{}, other);
             return *this;
         }
 
@@ -549,7 +333,7 @@ namespace hpx { namespace util {
         // For all i, assigns std::forward<Ti>(get<i>(u)) to get<i>(*this).
         HPX_HOST_DEVICE tuple& operator=(tuple&& other)
         {
-            _impl = std::move(other._impl);
+            assign_(index_pack{}, std::move(other));
             return *this;
         }
 
@@ -557,47 +341,82 @@ namespace hpx { namespace util {
         // template <class... UTypes> tuple& operator=(tuple<UTypes...>&& u);
         // For all i, assigns get<i>(std::forward<U>(u)) to get<i>(*this).
         template <typename UTuple>
-        HPX_HOST_DEVICE typename std::enable_if<
-            tuple_size<typename std::decay<UTuple>::type>::value ==
-                detail::pack<Ts...>::size,
-            tuple&>::type
-        operator=(UTuple&& other)
+        HPX_HOST_DEVICE tuple& operator=(UTuple&& other)
         {
-            _impl = std::forward<UTuple>(other);
+            assign_(index_pack{}, std::forward<UTuple>(other));
             return *this;
         }
 
         // 20.4.2.3, tuple swap
+    private:
+        template <std::size_t... Is>
+        HPX_HOST_DEVICE void swap_(util::index_pack<Is...>, tuple& other)
+        {
+            using std::swap;
+            int const _sequencer[] = {((swap(_members.template get<Is>(),
+                                           other._members.template get<Is>())),
+                0)...};
+            (void) _sequencer;
+        }
 
+    public:
         // void swap(tuple& rhs) noexcept(see below );
         // Calls swap for each element in *this and its corresponding element
         // in rhs.
         HPX_HOST_DEVICE void swap(tuple& other)
         {
-            _impl.swap(other._impl);
+            swap_(index_pack{}, other);
+        }
+
+        template <std::size_t I>
+        HPX_HOST_DEVICE typename util::at_index<I, Ts...>::type& get() noexcept
+        {
+            return _members.template get<I>();
+        }
+
+        template <std::size_t I>
+        HPX_HOST_DEVICE typename util::at_index<I, Ts...>::type const& get()
+            const noexcept
+        {
+            return _members.template get<I>();
         }
 
 #if defined(HPX_DATASTRUCTURES_HAVE_ADAPT_STD_TUPLE)
-        operator std::tuple<Ts...>() const&
+    private:
+        template <std::size_t... Is, typename UTuple>
+        std::tuple<Ts...> make_tuple_(util::index_pack<Is...>, UTuple&& t)
         {
-            return _impl;
+            return std::make_tuple(util::get<Is>(std::forward<UTuple>(t))...);
         }
 
+    public:
+        HPX_HOST_DEVICE
         operator std::tuple<Ts...>() &
         {
-            return _impl;
+            return make_tuple_(index_pack{}, *this);
         }
 
+        HPX_HOST_DEVICE
+        operator std::tuple<Ts...>() const&
+        {
+            return make_tuple_(index_pack{}, *this);
+        }
+
+        HPX_HOST_DEVICE
         operator std::tuple<Ts...>() &&
         {
-            return _impl;
+            return make_tuple_(index_pack{}, std::move(*this));
         }
 
+        HPX_HOST_DEVICE
         operator std::tuple<Ts...>() const&&
         {
-            return _impl;
+            return make_tuple_(index_pack{}, std::move(*this));
         }
 #endif
+
+    private:
+        util::member_pack_for<Ts...> _members;
     };
 
     // 20.4.2.5, tuple helper classes
@@ -636,12 +455,6 @@ namespace hpx { namespace util {
     {
     };
 
-    template <typename Type, std::size_t Size>
-    struct tuple_size<boost::array<Type, Size>>
-      : std::integral_constant<std::size_t, Size>
-    {
-    };
-
     template <typename Type, std::size_t Size>
     struct tuple_size<std::array<Type, Size>>
       : std::integral_constant<std::size_t, Size>
@@ -683,18 +496,18 @@ namespace hpx { namespace util {
     template <std::size_t I, typename... Ts>
     struct tuple_element<I, tuple<Ts...>>
     {
-        using type = typename detail::at_index<I, Ts...>::type;
+        using type = typename util::at_index<I, Ts...>::type;
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
             tuple<Ts...>& tuple) noexcept
         {
-            return tuple._impl.template get<I>();
+            return tuple.template get<I>();
         }
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
             tuple<Ts...> const& tuple) noexcept
         {
-            return tuple._impl.template get<I>();
+            return tuple.template get<I>();
         }
     };
 
@@ -703,13 +516,13 @@ namespace hpx { namespace util {
     {
         using type = T0;
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
             std::pair<T0, T1>& tuple) noexcept
         {
             return tuple.first;
         }
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
             std::pair<T0, T1> const& tuple) noexcept
         {
             return tuple.first;
@@ -721,49 +534,31 @@ namespace hpx { namespace util {
     {
         using type = T1;
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
             std::pair<T0, T1>& tuple) noexcept
         {
             return tuple.second;
         }
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
             std::pair<T0, T1> const& tuple) noexcept
         {
             return tuple.second;
         }
     };
 
-    template <std::size_t I, typename Type, std::size_t Size>
-    struct tuple_element<I, boost::array<Type, Size>>
-    {
-        using type = Type;
-
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
-            boost::array<Type, Size>& tuple) noexcept
-        {
-            return tuple[I];
-        }
-
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
-            boost::array<Type, Size> const& tuple) noexcept
-        {
-            return tuple[I];
-        }
-    };
-
     template <std::size_t I, typename Type, std::size_t Size>
     struct tuple_element<I, std::array<Type, Size>>
     {
         using type = Type;
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
             std::array<Type, Size>& tuple) noexcept
         {
             return tuple[I];
         }
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
             std::array<Type, Size> const& tuple) noexcept
         {
             return tuple[I];
@@ -776,25 +571,25 @@ namespace hpx { namespace util {
     {
         using type = typename std::tuple_element<I, std::tuple<Ts...>>::type;
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type& get(
             std::tuple<Ts...>& tuple) noexcept
         {
             return std::get<I>(tuple);
         }
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type const& get(
             std::tuple<Ts...> const& tuple) noexcept
         {
             return std::get<I>(tuple);
         }
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type&& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type&& get(
             std::tuple<Ts...>&& tuple) noexcept
         {
             return std::get<I>(std::move(tuple));
         }
 
-        static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE type const&& get(
+        static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE type const&& get(
             std::tuple<Ts...> const&& tuple) noexcept
         {
             return std::get<I>(std::move(tuple));
@@ -809,7 +604,7 @@ namespace hpx { namespace util {
         // constexpr typename tuple_element<I, tuple<Types...> >::type&
         // get(tuple<Types...>& t) noexcept;
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type&
             get(Tuple& t) noexcept
         {
@@ -820,7 +615,7 @@ namespace hpx { namespace util {
         // constexpr typename tuple_element<I, tuple<Types...> >::type const&
         // get(const tuple<Types...>& t) noexcept;
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type const&
             get(Tuple const& t) noexcept
         {
@@ -831,7 +626,7 @@ namespace hpx { namespace util {
         // constexpr typename tuple_element<I, tuple<Types...> >::type&&
         // get(tuple<Types...>&& t) noexcept;
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type&&
             get(Tuple&& t) noexcept
         {
@@ -843,7 +638,7 @@ namespace hpx { namespace util {
         // constexpr typename tuple_element<I, tuple<Types...> >::type const&&
         // get(const tuple<Types...>&& t) noexcept;
         template <std::size_t I, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
             typename tuple_element<I, Tuple>::type const&&
             get(Tuple const&& t) noexcept
         {
@@ -858,7 +653,7 @@ namespace hpx { namespace util {
     // template<class... Types>
     // constexpr tuple<VTypes...> make_tuple(Types&&... t);
     template <typename... Ts>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
         tuple<typename decay_unwrap<Ts>::type...>
         make_tuple(Ts&&... vs)
     {
@@ -896,20 +691,20 @@ namespace hpx { namespace util {
         struct tuple_cat_size_impl;
 
         template <std::size_t Size>
-        struct tuple_cat_size_impl<Size, detail::pack<>>
+        struct tuple_cat_size_impl<Size, util::pack<>>
           : std::integral_constant<std::size_t, Size>
         {
         };
 
         template <std::size_t Size, typename Head, typename... Tail>
-        struct tuple_cat_size_impl<Size, detail::pack<Head, Tail...>>
+        struct tuple_cat_size_impl<Size, util::pack<Head, Tail...>>
           : tuple_cat_size_impl<(Size + tuple_size<Head>::value),
-                detail::pack<Tail...>>
+                util::pack<Tail...>>
         {
         };
 
         template <typename... Tuples>
-        struct tuple_cat_size : tuple_cat_size_impl<0, detail::pack<Tuples...>>
+        struct tuple_cat_size : tuple_cat_size_impl<0, util::pack<Tuples...>>
         {
         };
 
@@ -918,12 +713,12 @@ namespace hpx { namespace util {
         struct tuple_cat_element;
 
         template <std::size_t I, typename Head, typename... Tail>
-        struct tuple_cat_element<I, detail::pack<Head, Tail...>,
+        struct tuple_cat_element<I, util::pack<Head, Tail...>,
             typename std::enable_if<(I < tuple_size<Head>::value)>::type>
           : tuple_element<I, Head>
         {
             template <typename THead, typename... TTail>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE auto get(
+            static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE auto get(
                 THead&& head, TTail&&... /*tail*/) noexcept
                 -> decltype(hpx::util::get<I>(std::forward<THead>(head)))
             {
@@ -932,20 +727,19 @@ namespace hpx { namespace util {
         };
 
         template <std::size_t I, typename Head, typename... Tail>
-        struct tuple_cat_element<I, detail::pack<Head, Tail...>,
+        struct tuple_cat_element<I, util::pack<Head, Tail...>,
             typename std::enable_if<(I >= tuple_size<Head>::value)>::type>
-          : tuple_cat_element<I - tuple_size<Head>::value,
-                detail::pack<Tail...>>
+          : tuple_cat_element<I - tuple_size<Head>::value, util::pack<Tail...>>
         {
-            using base_type = tuple_cat_element<I - tuple_size<Head>::value,
-                detail::pack<Tail...>>;
+            using _members = tuple_cat_element<I - tuple_size<Head>::value,
+                util::pack<Tail...>>;
 
             template <typename THead, typename... TTail>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE auto get(
+            static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE auto get(
                 THead&& /*head*/, TTail&&... tail) noexcept
-                -> decltype(base_type::get(std::forward<TTail>(tail)...))
+                -> decltype(_members::get(std::forward<TTail>(tail)...))
             {
-                return base_type::get(std::forward<TTail>(tail)...);
+                return _members::get(std::forward<TTail>(tail)...);
             }
         };
 
@@ -954,8 +748,7 @@ namespace hpx { namespace util {
         struct tuple_cat_result_impl;
 
         template <std::size_t... Is, typename... Tuples>
-        struct tuple_cat_result_impl<pack_c<std::size_t, Is...>,
-            pack<Tuples...>>
+        struct tuple_cat_result_impl<index_pack<Is...>, pack<Tuples...>>
         {
             using type =
                 tuple<typename tuple_cat_element<Is, pack<Tuples...>>::type...>;
@@ -966,8 +759,8 @@ namespace hpx { namespace util {
             typename tuple_cat_result_impl<Indices, Tuples>::type;
 
         template <std::size_t... Is, typename... Tuples, typename... Tuples_>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE auto tuple_cat_impl(
-            pack_c<std::size_t, Is...> is_pack, pack<Tuples...> tuple_pack,
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE auto tuple_cat_impl(
+            index_pack<Is...> is_pack, pack<Tuples...> tuple_pack,
             Tuples_&&... tuples)
             -> tuple_cat_result_of_t<decltype(is_pack), decltype(tuple_pack)>
         {
@@ -979,18 +772,17 @@ namespace hpx { namespace util {
     }    // namespace detail
 
     template <typename... Tuples>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE auto tuple_cat(
-        Tuples&&... tuples)
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE auto tuple_cat(Tuples&&... tuples)
         -> decltype(detail::tuple_cat_impl(
-            typename detail::make_index_pack<detail::tuple_cat_size<
+            typename util::make_index_pack<detail::tuple_cat_size<
                 typename std::decay<Tuples>::type...>::value>::type{},
-            detail::pack<typename std::decay<Tuples>::type...>{},
+            util::pack<typename std::decay<Tuples>::type...>{},
             std::forward<Tuples>(tuples)...))
     {
         return detail::tuple_cat_impl(
-            typename detail::make_index_pack<detail::tuple_cat_size<
+            typename util::make_index_pack<detail::tuple_cat_size<
                 typename std::decay<Tuples>::type...>::value>::type{},
-            detail::pack<typename std::decay<Tuples>::type...>{},
+            util::pack<typename std::decay<Tuples>::type...>{},
             std::forward<Tuples>(tuples)...);
     }
 
@@ -1007,7 +799,7 @@ namespace hpx { namespace util {
         struct tuple_equal_to
         {
             template <typename TTuple, typename UTuple>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
+            static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
                 TTuple const& t, UTuple const& u)
             {
                 return util::get<I>(t) == util::get<I>(u) &&
@@ -1019,7 +811,7 @@ namespace hpx { namespace util {
         struct tuple_equal_to<Size, Size>
         {
             template <typename TTuple, typename UTuple>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
+            static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
                 TTuple const& t, UTuple const& u)
             {
                 return true;
@@ -1028,7 +820,7 @@ namespace hpx { namespace util {
     }    // namespace detail
 
     template <typename... Ts, typename... Us>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
         typename std::enable_if<sizeof...(Ts) == sizeof...(Us), bool>::type
         operator==(tuple<Ts...> const& t, tuple<Us...> const& u)
     {
@@ -1039,7 +831,7 @@ namespace hpx { namespace util {
     // constexpr bool operator!=
     //     (const tuple<TTypes...>& t, const tuple<UTypes...>& u);
     template <typename... Ts, typename... Us>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
         typename std::enable_if<sizeof...(Ts) == sizeof...(Us), bool>::type
         operator!=(tuple<Ts...> const& t, tuple<Us...> const& u)
     {
@@ -1058,7 +850,7 @@ namespace hpx { namespace util {
         struct tuple_less_than
         {
             template <typename TTuple, typename UTuple>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
+            static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
                 TTuple const& t, UTuple const& u)
             {
                 return util::get<I>(t) < util::get<I>(u) ||
@@ -1071,7 +863,7 @@ namespace hpx { namespace util {
         struct tuple_less_than<Size, Size>
         {
             template <typename TTuple, typename UTuple>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
+            static constexpr HPX_HOST_DEVICE HPX_FORCEINLINE bool call(
                 TTuple const& t, UTuple const& u)
             {
                 return false;
@@ -1080,7 +872,7 @@ namespace hpx { namespace util {
     }    // namespace detail
 
     template <typename... Ts, typename... Us>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
         typename std::enable_if<sizeof...(Ts) == sizeof...(Us), bool>::type
         operator<(tuple<Ts...> const& t, tuple<Us...> const& u)
     {
@@ -1091,7 +883,7 @@ namespace hpx { namespace util {
     // constexpr bool operator>
     //     (const tuple<TTypes...>& t, const tuple<UTypes...>& u);
     template <typename... Ts, typename... Us>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
         typename std::enable_if<sizeof...(Ts) == sizeof...(Us), bool>::type
         operator>(tuple<Ts...> const& t, tuple<Us...> const& u)
     {
@@ -1102,7 +894,7 @@ namespace hpx { namespace util {
     // constexpr bool operator<=
     //     (const tuple<TTypes...>& t, const tuple<UTypes...>& u);
     template <typename... Ts, typename... Us>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
         typename std::enable_if<sizeof...(Ts) == sizeof...(Us), bool>::type
         operator<=(tuple<Ts...> const& t, tuple<Us...> const& u)
     {
@@ -1113,7 +905,7 @@ namespace hpx { namespace util {
     // constexpr bool operator>=
     //     (const tuple<TTypes...>& t, const tuple<UTypes...>& u);
     template <typename... Ts, typename... Us>
-    HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE
+    constexpr HPX_HOST_DEVICE HPX_FORCEINLINE
         typename std::enable_if<sizeof...(Ts) == sizeof...(Us), bool>::type
         operator>=(tuple<Ts...> const& t, tuple<Us...> const& u)
     {
diff --git a/libs/datastructures/include_compatibility/hpx/datastructures/detail/pack.hpp b/libs/datastructures/include_compatibility/hpx/datastructures/detail/pack.hpp
new file mode 100644
index 0000000000..64a8b7d27c
--- /dev/null
+++ b/libs/datastructures/include_compatibility/hpx/datastructures/detail/pack.hpp
@@ -0,0 +1,38 @@
+//  Copyright (c) 2019 Auriane Reverdell
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/datastructures/config/defines.hpp>
+#include <hpx/type_support/pack.hpp>
+
+#if defined(HPX_DATASTRUCTURES_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/datastructures/detail/pack.hpp is deprecated, \
+    please include hpx/type_support/pack.hpp instead")
+#else
+#warning "The header hpx/datastructures/detail/pack.hpp is deprecated, \
+    please include hpx/type_support/pack.hpp instead"
+#endif
+#endif
+
+namespace hpx { namespace util { namespace detail {
+
+    using hpx::util::pack;
+    using hpx::util::pack_c;
+
+    ///////////////////////////////////////////////////////////////////////////
+    using hpx::util::make_index_pack;
+
+    ///////////////////////////////////////////////////////////////////////////
+    using hpx::util::all_of;
+    using hpx::util::any_of;
+    using hpx::util::contains;
+    using hpx::util::none_of;
+
+    ///////////////////////////////////////////////////////////////////////////
+    using hpx::util::at_index;
+}}}    // namespace hpx::util::detail
diff --git a/libs/datastructures/include_compatibility/hpx/util/detail/pack.hpp b/libs/datastructures/include_compatibility/hpx/util/detail/pack.hpp
index d847516daf..3fb7325f24 100644
--- a/libs/datastructures/include_compatibility/hpx/util/detail/pack.hpp
+++ b/libs/datastructures/include_compatibility/hpx/util/detail/pack.hpp
@@ -6,14 +6,32 @@
 
 #include <hpx/config.hpp>
 #include <hpx/datastructures/config/defines.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #if defined(HPX_DATASTRUCTURES_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message("The header hpx/util/detail/pack.hpp is deprecated, \
-    please include hpx/datastructures/detail/pack.hpp instead")
+    please include hpx/type_support/pack.hpp instead")
 #else
 #warning "The header hpx/util/detail/pack.hpp is deprecated, \
-    please include hpx/datastructures/detail/pack.hpp instead"
+    please include hpx/type_support/pack.hpp instead"
 #endif
 #endif
+
+namespace hpx { namespace util { namespace detail {
+
+    using hpx::util::pack;
+    using hpx::util::pack_c;
+
+    ///////////////////////////////////////////////////////////////////////////
+    using hpx::util::make_index_pack;
+
+    ///////////////////////////////////////////////////////////////////////////
+    using hpx::util::all_of;
+    using hpx::util::any_of;
+    using hpx::util::contains;
+    using hpx::util::none_of;
+
+    ///////////////////////////////////////////////////////////////////////////
+    using hpx::util::at_index;
+}}}    // namespace hpx::util::detail
diff --git a/libs/datastructures/tests/unit/any.cpp b/libs/datastructures/tests/unit/any.cpp
index 34a3625de9..322d5dfbaa 100644
--- a/libs/datastructures/tests/unit/any.cpp
+++ b/libs/datastructures/tests/unit/any.cpp
@@ -30,7 +30,7 @@ int main()
 
         buffer << any1;
 
-        HPX_TEST_EQ(buffer.str(), "3040");
+        HPX_TEST(buffer.str() == "3040");
     }
 
     // non serializable version
@@ -40,11 +40,11 @@ int main()
             any_nonser any1_nonser(7), any2_nonser(7), any3_nonser(10),
                 any4_nonser(std::string("seven"));
 
-            HPX_TEST(any_cast<int>(any1_nonser) == 7);
-            HPX_TEST(any_cast<int>(any1_nonser) != 10);
-            HPX_TEST(any_cast<int>(any1_nonser) != 10.0f);
-            HPX_TEST(any_cast<int>(any1_nonser) == any_cast<int>(any1_nonser));
-            HPX_TEST(any_cast<int>(any1_nonser) == any_cast<int>(any2_nonser));
+            HPX_TEST_EQ(any_cast<int>(any1_nonser), 7);
+            HPX_TEST_NEQ(any_cast<int>(any1_nonser), 10);
+            HPX_TEST_NEQ(any_cast<int>(any1_nonser), 10.0f);
+            HPX_TEST_EQ(any_cast<int>(any1_nonser), any_cast<int>(any1_nonser));
+            HPX_TEST_EQ(any_cast<int>(any1_nonser), any_cast<int>(any2_nonser));
             HPX_TEST(any1_nonser.type() == any3_nonser.type());
             HPX_TEST(any1_nonser.type() != any4_nonser.type());
 
@@ -56,8 +56,8 @@ int main()
             any3_nonser = other_str;
             any4_nonser = 10.0f;
 
-            HPX_TEST(any_cast<std::string>(any1_nonser) == long_str);
-            HPX_TEST(any_cast<std::string>(any1_nonser) != other_str);
+            HPX_TEST_EQ(any_cast<std::string>(any1_nonser), long_str);
+            HPX_TEST_NEQ(any_cast<std::string>(any1_nonser), other_str);
             HPX_TEST(any1_nonser.type() == typeid(std::string));
             HPX_TEST(any_cast<std::string>(any1_nonser) ==
                 any_cast<std::string>(any1_nonser));
diff --git a/libs/datastructures/tests/unit/tuple.cpp b/libs/datastructures/tests/unit/tuple.cpp
index 9875bcfb53..87e91b408a 100644
--- a/libs/datastructures/tests/unit/tuple.cpp
+++ b/libs/datastructures/tests/unit/tuple.cpp
@@ -33,6 +33,7 @@
 // clang-format on
 
 #include <array>
+#include <cstddef>
 #include <functional>
 #include <memory>
 #include <string>
@@ -145,32 +146,32 @@ hpx::util::tuple<char (&)[10]> v2(cs);    // ok
 void construction_test()
 {
     hpx::util::tuple<int> t1;
-    HPX_TEST(hpx::util::get<0>(t1) == int());
+    HPX_TEST_EQ(hpx::util::get<0>(t1), int());
 
     hpx::util::tuple<float> t2(5.5f);
-    HPX_TEST(hpx::util::get<0>(t2) > 5.4f && hpx::util::get<0>(t2) < 5.6f);
+    HPX_TEST_RANGE(hpx::util::get<0>(t2), 5.4f, 5.6f);
 
     hpx::util::tuple<foo> t3(foo(12));
     HPX_TEST(hpx::util::get<0>(t3) == foo(12));
 
     hpx::util::tuple<double> t4(t2);
-    HPX_TEST(hpx::util::get<0>(t4) > 5.4 && hpx::util::get<0>(t4) < 5.6);
+    HPX_TEST_RANGE(hpx::util::get<0>(t4), 5.4f, 5.6f);
 
     hpx::util::tuple<int, float> t5;
-    HPX_TEST(hpx::util::get<0>(t5) == int());
-    HPX_TEST(hpx::util::get<1>(t5) == float());
+    HPX_TEST_EQ(hpx::util::get<0>(t5), int());
+    HPX_TEST_EQ(hpx::util::get<1>(t5), float());
 
     hpx::util::tuple<int, float> t6(12, 5.5f);
-    HPX_TEST(hpx::util::get<0>(t6) == 12);
-    HPX_TEST(hpx::util::get<1>(t6) > 5.4f && hpx::util::get<1>(t6) < 5.6f);
+    HPX_TEST_EQ(hpx::util::get<0>(t6), 12);
+    HPX_TEST_RANGE(hpx::util::get<1>(t6), 5.4f, 5.6f);
 
     hpx::util::tuple<int, float> t7(t6);
-    HPX_TEST(hpx::util::get<0>(t7) == 12);
-    HPX_TEST(hpx::util::get<1>(t7) > 5.4f && hpx::util::get<1>(t7) < 5.6f);
+    HPX_TEST_EQ(hpx::util::get<0>(t7), 12);
+    HPX_TEST_RANGE(hpx::util::get<1>(t7), 5.4f, 5.6f);
 
     hpx::util::tuple<long, double> t8(t6);
-    HPX_TEST(hpx::util::get<0>(t8) == 12);
-    HPX_TEST(hpx::util::get<1>(t8) > 5.4 && hpx::util::get<1>(t8) < 5.6);
+    HPX_TEST_EQ(hpx::util::get<0>(t8), 12);
+    HPX_TEST_RANGE(hpx::util::get<1>(t8), 5.4f, 5.6f);
 
     dummy(hpx::util::tuple<no_def_constructor, no_def_constructor,
         no_def_constructor>(std::string("Jaba"),    // ok, since the default
@@ -210,23 +211,23 @@ void element_access_test()
     HPX_TEST(i == 1 && i2 == 2);
 
     int j = hpx::util::get<0>(ct);
-    HPX_TEST(j == 1);
+    HPX_TEST_EQ(j, 1);
 
     HPX_TEST(hpx::util::get<0>(t) = 5);
 
     //hpx::util::get<0>(ct) = 5; // can't assign to const
 
     double e = hpx::util::get<1>(t);
-    HPX_TEST(e > 2.69 && e < 2.71);
+    HPX_TEST_RANGE(e, 2.69, 2.71);
 
     hpx::util::get<1>(t) = 3.14 + i;
-    HPX_TEST(hpx::util::get<1>(t) > 4.13 && hpx::util::get<1>(t) < 4.15);
+    HPX_TEST_RANGE(hpx::util::get<1>(t), 4.13, 4.15);
 
     //hpx::util::get<2>(t) = A(); // can't assign to const
     //dummy(hpx::util::get<4>(ct)); // illegal index
 
     ++hpx::util::get<0>(t);
-    HPX_TEST(hpx::util::get<0>(t) == 6);
+    HPX_TEST_EQ(hpx::util::get<0>(t), 6);
 
     HPX_TEST((std::is_const<hpx::util::tuple_element<0,
                   hpx::util::tuple<int, float>>::type>::value != true));
@@ -257,13 +258,13 @@ void copy_test()
     hpx::util::tuple<int, char> t1(4, 'a');
     hpx::util::tuple<int, char> t2(5, 'b');
     t2 = t1;
-    HPX_TEST(hpx::util::get<0>(t1) == hpx::util::get<0>(t2));
-    HPX_TEST(hpx::util::get<1>(t1) == hpx::util::get<1>(t2));
+    HPX_TEST_EQ(hpx::util::get<0>(t1), hpx::util::get<0>(t2));
+    HPX_TEST_EQ(hpx::util::get<1>(t1), hpx::util::get<1>(t2));
 
     hpx::util::tuple<long, std::string> t3(2, "a");
     t3 = t1;
-    HPX_TEST((double) hpx::util::get<0>(t1) == hpx::util::get<0>(t3));
-    HPX_TEST(hpx::util::get<1>(t1) == hpx::util::get<1>(t3)[0]);
+    HPX_TEST_EQ((double) hpx::util::get<0>(t1), hpx::util::get<0>(t3));
+    HPX_TEST_EQ(hpx::util::get<1>(t1), hpx::util::get<1>(t3)[0]);
 
     // testing copy and assignment with implicit conversions between elements
     // testing tie
@@ -277,9 +278,9 @@ void copy_test()
     double d;
     hpx::util::tie(i, c, d) = hpx::util::make_tuple(1, 'a', 5.5);
 
-    HPX_TEST(i == 1);
-    HPX_TEST(c == 'a');
-    HPX_TEST(d > 5.4 && d < 5.6);
+    HPX_TEST_EQ(i, 1);
+    HPX_TEST_EQ(c, 'a');
+    HPX_TEST_RANGE(d, 5.4, 5.6);
 }
 
 void mutate_test()
@@ -290,9 +291,9 @@ void mutate_test()
     hpx::util::get<2>(t1) = false;
     hpx::util::get<3>(t1) = foo(5);
 
-    HPX_TEST(hpx::util::get<0>(t1) == 6);
-    HPX_TEST(hpx::util::get<1>(t1) > 2.1f && hpx::util::get<1>(t1) < 2.3f);
-    HPX_TEST(hpx::util::get<2>(t1) == false);
+    HPX_TEST_EQ(hpx::util::get<0>(t1), 6);
+    HPX_TEST_RANGE(hpx::util::get<1>(t1), 2.1f, 2.3f);
+    HPX_TEST_EQ(hpx::util::get<2>(t1), false);
     HPX_TEST(hpx::util::get<3>(t1) == foo(5));
 }
 
@@ -303,13 +304,13 @@ void mutate_test()
 void make_tuple_test()
 {
     hpx::util::tuple<int, char> t1 = hpx::util::make_tuple(5, 'a');
-    HPX_TEST(hpx::util::get<0>(t1) == 5);
-    HPX_TEST(hpx::util::get<1>(t1) == 'a');
+    HPX_TEST_EQ(hpx::util::get<0>(t1), 5);
+    HPX_TEST_EQ(hpx::util::get<1>(t1), 'a');
 
     hpx::util::tuple<int, std::string> t2;
     t2 = hpx::util::make_tuple((short int) 2, std::string("Hi"));
-    HPX_TEST(hpx::util::get<0>(t2) == 2);
-    HPX_TEST(hpx::util::get<1>(t2) == "Hi");
+    HPX_TEST_EQ(hpx::util::get<0>(t2), 2);
+    HPX_TEST_EQ(hpx::util::get<1>(t2), "Hi");
 
     A a = A();
     B b;
@@ -352,14 +353,14 @@ void tie_test()
     foo c(5);
 
     hpx::util::tie(a, b, c) = hpx::util::make_tuple(2, 'a', foo(3));
-    HPX_TEST(a == 2);
-    HPX_TEST(b == 'a');
+    HPX_TEST_EQ(a, 2);
+    HPX_TEST_EQ(b, 'a');
     HPX_TEST(c == foo(3));
 
     hpx::util::tie(a, hpx::util::ignore, c) =
         hpx::util::make_tuple((short int) 5, false, foo(5));
-    HPX_TEST(a == 5);
-    HPX_TEST(b == 'a');
+    HPX_TEST_EQ(a, 5);
+    HPX_TEST_EQ(b, 'a');
     HPX_TEST(c == foo(5));
 
     // testing assignment from std::pair
@@ -387,7 +388,7 @@ void tuple_cat_test()
 
         auto expected = hpx::util::make_tuple(1, 2.f, 1, 2.f);
 
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // Cat multiple tuples
@@ -397,7 +398,7 @@ void tuple_cat_test()
 
         auto expected = hpx::util::make_tuple(1, 2.f, 1, 2.f, 1, 2.f);
 
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // Cat move only types
@@ -491,8 +492,8 @@ void ordering_test()
 void const_tuple_test()
 {
     const hpx::util::tuple<int, float> t1(5, 3.3f);
-    HPX_TEST(hpx::util::get<0>(t1) == 5);
-    HPX_TEST(hpx::util::get<1>(t1) == 3.3f);
+    HPX_TEST_EQ(hpx::util::get<0>(t1), 5);
+    HPX_TEST_EQ(hpx::util::get<1>(t1), 3.3f);
 }
 
 // ----------------------------------------------------------------------------
@@ -503,12 +504,12 @@ void tuple_length_test()
     typedef hpx::util::tuple<int, float, double> t1;
     typedef hpx::util::tuple<> t2;
 
-    HPX_TEST(hpx::util::tuple_size<t1>::value == 3);
-    HPX_TEST(hpx::util::tuple_size<t2>::value == 0);
+    HPX_TEST_EQ(hpx::util::tuple_size<t1>::value, std::size_t(3));
+    HPX_TEST_EQ(hpx::util::tuple_size<t2>::value, std::size_t(0));
 
     {
         using t3 = std::array<int, 4>;
-        HPX_TEST(hpx::util::tuple_size<t3>::value == 4);
+        HPX_TEST_EQ(hpx::util::tuple_size<t3>::value, std::size_t(4));
     }
 }
 
@@ -517,23 +518,25 @@ void tuple_length_test()
 // ----------------------------------------------------------------------------
 void tuple_swap_test()
 {
+    using std::swap;
+
     hpx::util::tuple<int, float, double> t1(1, 2.0f, 3.0), t2(4, 5.0f, 6.0);
-    boost::swap(t1, t2);
-    HPX_TEST(hpx::util::get<0>(t1) == 4);
-    HPX_TEST(hpx::util::get<1>(t1) == 5.0f);
-    HPX_TEST(hpx::util::get<2>(t1) == 6.0);
-    HPX_TEST(hpx::util::get<0>(t2) == 1);
-    HPX_TEST(hpx::util::get<1>(t2) == 2.0f);
-    HPX_TEST(hpx::util::get<2>(t2) == 3.0);
+    swap(t1, t2);
+    HPX_TEST_EQ(hpx::util::get<0>(t1), 4);
+    HPX_TEST_EQ(hpx::util::get<1>(t1), 5.0f);
+    HPX_TEST_EQ(hpx::util::get<2>(t1), 6.0);
+    HPX_TEST_EQ(hpx::util::get<0>(t2), 1);
+    HPX_TEST_EQ(hpx::util::get<1>(t2), 2.0f);
+    HPX_TEST_EQ(hpx::util::get<2>(t2), 3.0);
 
     int i = 1, j = 2;
 
     hpx::util::tuple<int&> t3(i), t4(j);
-    boost::swap(t3, t4);
-    HPX_TEST(hpx::util::get<0>(t3) == 2);
-    HPX_TEST(hpx::util::get<0>(t4) == 1);
-    HPX_TEST(i == 2);
-    HPX_TEST(j == 1);
+    swap(t3, t4);
+    HPX_TEST_EQ(hpx::util::get<0>(t3), 2);
+    HPX_TEST_EQ(hpx::util::get<0>(t4), 1);
+    HPX_TEST_EQ(i, 2);
+    HPX_TEST_EQ(j, 1);
 }
 
 void tuple_std_test()
@@ -542,29 +545,29 @@ void tuple_std_test()
     hpx::util::tuple<int, float, double> t1(1, 2.0f, 3.0);
     std::tuple<int, float, double> t2 = t1;
     hpx::util::tuple<int, float, double> t3 = t2;
-    HPX_TEST(std::get<0>(t1) == 1);
-    HPX_TEST(std::get<0>(t2) == 1);
-    HPX_TEST(std::get<0>(t3) == 1);
+    HPX_TEST_EQ(std::get<0>(t1), 1);
+    HPX_TEST_EQ(std::get<0>(t2), 1);
+    HPX_TEST_EQ(std::get<0>(t3), 1);
 
-    HPX_TEST(hpx::util::get<0>(t1) == 1);
-    HPX_TEST(hpx::util::get<0>(t2) == 1);
-    HPX_TEST(hpx::util::get<0>(t3) == 1);
+    HPX_TEST_EQ(hpx::util::get<0>(t1), 1);
+    HPX_TEST_EQ(hpx::util::get<0>(t2), 1);
+    HPX_TEST_EQ(hpx::util::get<0>(t3), 1);
 
-    HPX_TEST(std::get<1>(t1) == 2.0f);
-    HPX_TEST(std::get<1>(t2) == 2.0f);
-    HPX_TEST(std::get<1>(t3) == 2.0f);
+    HPX_TEST_EQ(std::get<1>(t1), 2.0f);
+    HPX_TEST_EQ(std::get<1>(t2), 2.0f);
+    HPX_TEST_EQ(std::get<1>(t3), 2.0f);
 
-    HPX_TEST(hpx::util::get<1>(t1) == 2.0f);
-    HPX_TEST(hpx::util::get<1>(t2) == 2.0f);
-    HPX_TEST(hpx::util::get<1>(t3) == 2.0f);
+    HPX_TEST_EQ(hpx::util::get<1>(t1), 2.0f);
+    HPX_TEST_EQ(hpx::util::get<1>(t2), 2.0f);
+    HPX_TEST_EQ(hpx::util::get<1>(t3), 2.0f);
 
-    HPX_TEST(std::get<2>(t1) == 3.0);
-    HPX_TEST(std::get<2>(t2) == 3.0);
-    HPX_TEST(std::get<2>(t3) == 3.0);
+    HPX_TEST_EQ(std::get<2>(t1), 3.0);
+    HPX_TEST_EQ(std::get<2>(t2), 3.0);
+    HPX_TEST_EQ(std::get<2>(t3), 3.0);
 
-    HPX_TEST(hpx::util::get<2>(t1) == 3.0);
-    HPX_TEST(hpx::util::get<2>(t2) == 3.0);
-    HPX_TEST(hpx::util::get<2>(t3) == 3.0);
+    HPX_TEST_EQ(hpx::util::get<2>(t1), 3.0);
+    HPX_TEST_EQ(hpx::util::get<2>(t2), 3.0);
+    HPX_TEST_EQ(hpx::util::get<2>(t3), 3.0);
 #endif
 }
 
diff --git a/libs/datastructures/tests/unit/unique_any.cpp b/libs/datastructures/tests/unit/unique_any.cpp
index 39b2d5aa9e..d01e89643f 100644
--- a/libs/datastructures/tests/unit/unique_any.cpp
+++ b/libs/datastructures/tests/unit/unique_any.cpp
@@ -40,11 +40,11 @@ int main()
             unique_any_nonser any1_nonser(7), any2_nonser(7), any3_nonser(10),
                 any4_nonser(std::string("seven"));
 
-            HPX_TEST(any_cast<int>(any1_nonser) == 7);
-            HPX_TEST(any_cast<int>(any1_nonser) != 10);
-            HPX_TEST(any_cast<int>(any1_nonser) != 10.0f);
-            HPX_TEST(any_cast<int>(any1_nonser) == any_cast<int>(any1_nonser));
-            HPX_TEST(any_cast<int>(any1_nonser) == any_cast<int>(any2_nonser));
+            HPX_TEST_EQ(any_cast<int>(any1_nonser), 7);
+            HPX_TEST_NEQ(any_cast<int>(any1_nonser), 10);
+            HPX_TEST_NEQ(any_cast<int>(any1_nonser), 10.0f);
+            HPX_TEST_EQ(any_cast<int>(any1_nonser), any_cast<int>(any1_nonser));
+            HPX_TEST_EQ(any_cast<int>(any1_nonser), any_cast<int>(any2_nonser));
             HPX_TEST(any1_nonser.type() == any3_nonser.type());
             HPX_TEST(any1_nonser.type() != any4_nonser.type());
 
@@ -56,8 +56,8 @@ int main()
             any3_nonser = other_str;
             any4_nonser = 10.0f;
 
-            HPX_TEST(any_cast<std::string>(any2_nonser) == long_str);
-            HPX_TEST(any_cast<std::string>(any2_nonser) != other_str);
+            HPX_TEST_EQ(any_cast<std::string>(any2_nonser), long_str);
+            HPX_TEST_NEQ(any_cast<std::string>(any2_nonser), other_str);
             HPX_TEST(any2_nonser.type() == typeid(std::string));
             HPX_TEST(any_cast<std::string>(any2_nonser) ==
                 any_cast<std::string>(any2_nonser));
diff --git a/libs/debugging/CMakeLists.txt b/libs/debugging/CMakeLists.txt
index 17a72469b6..774b227197 100644
--- a/libs/debugging/CMakeLists.txt
+++ b/libs/debugging/CMakeLists.txt
@@ -4,12 +4,12 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(debugging_headers
   hpx/debugging/demangle_helper.hpp
-  # do not add hpx/debugging/print.hpp as it includes threads
-  # instead users should add this manually on demand
+  hpx/debugging/print.hpp
+  hpx/debugging/attach_debugger.hpp
   )
 
 set(debugging_compat_headers
@@ -17,6 +17,7 @@ set(debugging_compat_headers
   )
 
 set(debugging_sources
+  attach_debugger.cpp
   )
 
 include(HPX_AddModule)
@@ -30,11 +31,5 @@ add_hpx_module(debugging
   COMPAT_HEADERS ${debugging_compat_headers}
   DEPENDENCIES
     hpx_config
-    hpx_errors
-    hpx_functional
-    hpx_coroutines
-    hpx_hardware
-    hpx_topology
-    hpx_program_options
   CMAKE_SUBDIRS examples tests
 )
diff --git a/libs/debugging/README.rst b/libs/debugging/README.rst
index 8b245bc473..f01decda04 100644
--- a/libs/debugging/README.rst
+++ b/libs/debugging/README.rst
@@ -13,4 +13,4 @@ debugging
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/debugging/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/debugging/docs/index.html>`__.
diff --git a/libs/debugging/include/hpx/debugging/attach_debugger.hpp b/libs/debugging/include/hpx/debugging/attach_debugger.hpp
new file mode 100644
index 0000000000..bb1a65d8f9
--- /dev/null
+++ b/libs/debugging/include/hpx/debugging/attach_debugger.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2007-2012 Hartmut Kaiser
+//  Copyright (c) 2017      Denis Blank
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_DEBUGGING_ATTACH_DEBUGGER_HPP
+#define HPX_DEBUGGING_ATTACH_DEBUGGER_HPP
+
+#include <hpx/config.hpp>
+#include <string>
+
+namespace hpx { namespace util {
+    /// Tries to break an attached debugger, if not supported a loop is
+    /// invoked which gives enough time to attach a debugger manually.
+    HPX_EXPORT void attach_debugger();
+}}    // namespace hpx::util
+
+#endif
diff --git a/libs/debugging/include/hpx/debugging/print.hpp b/libs/debugging/include/hpx/debugging/print.hpp
index 98df727505..d440d8801a 100644
--- a/libs/debugging/include/hpx/debugging/print.hpp
+++ b/libs/debugging/include/hpx/debugging/print.hpp
@@ -8,8 +8,6 @@
 #define HPX_DEBUGGING_PRINT_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
 
 #include <array>
 #include <bitset>
@@ -33,7 +31,7 @@
 
 // ------------------------------------------------------------
 // This file provides a simple to use printf style debugging
-// tool that can be used on a per file basis to enable ouput.
+// tool that can be used on a per file basis to enable output.
 // It is not intended to be exposed to users, but rather as
 // an aid for hpx development.
 // ------------------------------------------------------------
@@ -119,58 +117,81 @@ namespace hpx { namespace debug {
     // ------------------------------------------------------------------
     // format as zero padded hex
     // ------------------------------------------------------------------
-    template <int N = 4, typename T = int, typename Enable = void>
-    struct hex;
+    namespace detail {
 
-    template <int N, typename T>
-    struct hex<N, T, typename std::enable_if<!std::is_pointer<T>::value>::type>
-    {
-        hex(const T& v)
-          : data(v)
+        template <int N = 4, typename T = int, typename Enable = void>
+        struct hex;
+
+        template <int N, typename T>
+        struct hex<N, T,
+            typename std::enable_if<!std::is_pointer<T>::value>::type>
         {
-        }
-        const T& data;
-        friend std::ostream& operator<<(std::ostream& os, const hex<N, T>& d)
+            hex(const T& v)
+              : data(v)
+            {
+            }
+            const T& data;
+            friend std::ostream& operator<<(
+                std::ostream& os, const hex<N, T>& d)
+            {
+                os << std::right << "0x" << std::setfill('0') << std::setw(N)
+                   << std::noshowbase << std::hex << d.data;
+                return os;
+            }
+        };
+
+        template <int N, typename T>
+        struct hex<N, T,
+            typename std::enable_if<std::is_pointer<T>::value>::type>
         {
-            os << std::right << "0x" << std::setfill('0') << std::setw(N)
-               << std::noshowbase << std::hex << d.data;
-            return os;
-        }
-    };
+            hex(const T& v)
+              : data(v)
+            {
+            }
+            const T& data;
+            friend std::ostream& operator<<(
+                std::ostream& os, const hex<N, T>& d)
+            {
+                os << std::right << std::setw(N) << std::noshowbase << std::hex
+                   << d.data;
+                return os;
+            }
+        };
+    }    // namespace detail
 
-    template <int N, typename T>
-    struct hex<N, T, typename std::enable_if<std::is_pointer<T>::value>::type>
+    template <int N = 4, typename T>
+    detail::hex<N, T> hex(T const& v)
     {
-        hex(const T& v)
-          : data(v)
-        {
-        }
-        const T& data;
-        friend std::ostream& operator<<(std::ostream& os, const hex<N, T>& d)
-        {
-            os << std::right << std::setw(N) << std::noshowbase << std::hex
-               << d.data;
-            return os;
-        }
-    };
+        return detail::hex<N, T>(v);
+    }
 
     // ------------------------------------------------------------------
     // format as binary bits
     // ------------------------------------------------------------------
-    template <int N = 8, typename T = int>
-    struct bin
-    {
-        bin(const T& v)
-          : data(v)
-        {
-        }
-        const T& data;
-        friend std::ostream& operator<<(std::ostream& os, const bin<N, T>& d)
+    namespace detail {
+
+        template <int N = 8, typename T = int>
+        struct bin
         {
-            os << std::bitset<N>(d.data);
-            return os;
-        }
-    };
+            bin(const T& v)
+              : data(v)
+            {
+            }
+            const T& data;
+            friend std::ostream& operator<<(
+                std::ostream& os, const bin<N, T>& d)
+            {
+                os << std::bitset<N>(d.data);
+                return os;
+            }
+        };
+    }    // namespace detail
+
+    template <int N = 8, typename T>
+    detail::bin<N, T> bin(T const& v)
+    {
+        return detail::bin<N, T>(v);
+    }
 
     // ------------------------------------------------------------------
     // format as padded string
@@ -190,123 +211,8 @@ namespace hpx { namespace debug {
         }
     };
 
-    // ------------------------------------------------------------------
-    // safely dump thread pointer/description
-    // ------------------------------------------------------------------
-    template <typename T>
-    struct threadinfo
-    {
-    };
-
-    template <>
-    struct threadinfo<threads::thread_data*>
-    {
-        threadinfo(const threads::thread_data* v)
-          : data(v)
-        {
-        }
-        const threads::thread_data* data;
-        friend std::ostream& operator<<(std::ostream& os, const threadinfo& d)
-        {
-            os << ptr(d.data) << " \""
-               << ((d.data != nullptr) ? d.data->get_description() : "nullptr")
-               << "\"";
-            return os;
-        }
-    };
-
-    template <>
-    struct threadinfo<threads::thread_id_type*>
-    {
-        threadinfo(const threads::thread_id_type* v)
-          : data(v)
-        {
-        }
-        const threads::thread_id_type* data;
-        friend std::ostream& operator<<(std::ostream& os, const threadinfo& d)
-        {
-            if (d.data == nullptr)
-                os << "nullptr";
-            else
-                os << threadinfo<threads::thread_data*>(
-                    get_thread_id_data(*d.data));
-            return os;
-        }
-    };
-
-    template <>
-    struct threadinfo<hpx::threads::thread_init_data>
-    {
-        threadinfo(const hpx::threads::thread_init_data& v)
-          : data(v)
-        {
-        }
-        const hpx::threads::thread_init_data& data;
-        friend std::ostream& operator<<(std::ostream& os, const threadinfo& d)
-        {
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-            os << std::left << " \"" << d.data.description.get_description()
-               << "\"";
-#else
-            os << "??? " << /*hex<8,uintptr_t>*/ (uintptr_t(&d.data));
-#endif
-            return os;
-        }
-    };
-
 #ifdef HPX_HAVE_CXX17_FOLD_EXPRESSIONS
     namespace detail {
-        // ------------------------------------------------------------------
-        // helper class for printing thread ID, either std:: or hpx::
-        // ------------------------------------------------------------------
-        struct current_thread_print_helper
-        {
-        };
-
-        inline std::ostream& operator<<(
-            std::ostream& os, const current_thread_print_helper&)
-        {
-            if (hpx::threads::get_self_id() == hpx::threads::invalid_thread_id)
-            {
-                os << "-------------- ";
-            }
-            else
-            {
-                hpx::threads::thread_data* dummy =
-                    hpx::threads::get_self_id_data();
-                os << dummy << " ";
-            }
-            os << hex<12, std::thread::id>(std::this_thread::get_id())
-#ifdef DEBUGGING_PRINT_LINUX
-               << " cpu " << debug::dec<3, int>(sched_getcpu()) << " ";
-#else
-               << " cpu "
-               << "--- ";
-#endif
-            return os;
-        }
-
-        // ------------------------------------------------------------------
-        // helper class for printing time since start
-        // ------------------------------------------------------------------
-        struct current_time_print_helper
-        {
-        };
-
-        inline std::ostream& operator<<(
-            std::ostream& os, const current_time_print_helper&)
-        {
-            using namespace std::chrono;
-            static high_resolution_clock::time_point log_t_start =
-                high_resolution_clock::now();
-            //
-            auto now = high_resolution_clock::now();
-            auto nowt = duration_cast<microseconds>(now - log_t_start).count();
-            //
-            os << debug::dec<10>(nowt) << " ";
-            return os;
-        }
-
         template <typename TupleType, std::size_t... I>
         void tuple_print(
             std::ostream& os, const TupleType& tup, std::index_sequence<I...>)
@@ -321,17 +227,7 @@ namespace hpx { namespace debug {
         }
 
         template <typename... Args>
-        void display(const char* prefix, Args... args)
-        {
-            // using a temp stream object with a single copy to cout at the end
-            // prevents multiple threads from injecting overlapping text
-            std::stringstream tempstream;
-            tempstream << prefix << detail::current_time_print_helper()
-                       << detail::current_thread_print_helper();
-            ((tempstream << args << " "), ...);
-            tempstream << std::endl;
-            std::cout << tempstream.str();
-        }
+        void display(const char* prefix, Args... args);
 
         template <typename... Args>
         void debug(Args... args)
@@ -426,7 +322,7 @@ namespace hpx { namespace debug {
 
     struct disable_print
     {
-        HPX_CONSTEXPR disable_print(const char* p) {}
+        constexpr disable_print(const char* p) {}
 #else
     template <bool enable>
     struct enable_print;
@@ -435,55 +331,55 @@ namespace hpx { namespace debug {
     template <>
     struct enable_print<false>
     {
-        HPX_CONSTEXPR enable_print(const char* p) {}
+        constexpr enable_print(const char* p) {}
 #endif
 
-        HPX_CONSTEXPR bool is_enabled() const
+        constexpr bool is_enabled() const
         {
             return false;
         }
 
         template <typename... Args>
-        HPX_CXX14_CONSTEXPR void debug(Args... args) const
+        constexpr void debug(Args... args) const
         {
         }
 
         template <typename... Args>
-        HPX_CXX14_CONSTEXPR void warning(Args... args) const
+        constexpr void warning(Args... args) const
         {
         }
 
         template <typename... Args>
-        HPX_CXX14_CONSTEXPR void error(Args... args) const
+        constexpr void error(Args... args) const
         {
         }
 
         template <typename... Args>
-        HPX_CXX14_CONSTEXPR void timed(Args... args) const
+        constexpr void timed(Args... args) const
         {
         }
 
         template <typename T>
-        HPX_CXX14_CONSTEXPR void array(
+        constexpr void array(
             const std::string& name, const std::vector<T>& v) const
         {
         }
 
         template <typename T, std::size_t N>
-        HPX_CXX14_CONSTEXPR void array(
+        constexpr void array(
             const std::string& name, const std::array<T, N>& v) const
         {
         }
 
         template <typename Iter>
-        HPX_CXX14_CONSTEXPR void array(
+        constexpr void array(
             const std::string& name, Iter begin, Iter end) const
         {
         }
 
         // @todo, return void so that timers have zero footprint when disabled
         template <typename... Args>
-        HPX_CONSTEXPR int make_timer(double delay, const Args... args) const
+        constexpr int make_timer(double delay, const Args... args) const
         {
             return 0;
         }
@@ -494,7 +390,7 @@ namespace hpx { namespace debug {
     template <>
     struct enable_print<false> : public disable_print
     {
-        HPX_CONSTEXPR enable_print(const char* p)
+        constexpr enable_print(const char* p)
           : disable_print(p)
         {
         }
@@ -503,7 +399,7 @@ namespace hpx { namespace debug {
     template <>
     struct enable_print<true> : public disable_print
     {
-        HPX_CONSTEXPR enable_print(const char* p)
+        constexpr enable_print(const char* p)
           : disable_print(p)
         {
         }
@@ -518,28 +414,28 @@ namespace hpx { namespace debug {
         const char* prefix_;
 
     public:
-        HPX_CONSTEXPR enable_print(const char* p)
+        enable_print(const char* p)
           : prefix_(p)
         {
         }
 
-        HPX_CONSTEXPR bool is_enabled() const
+        constexpr bool is_enabled() const
         {
             return true;
         }
 
         template <typename... Args>
-        HPX_CXX14_CONSTEXPR void debug(Args... args)
+        constexpr void debug(Args... args)
         {
             detail::debug(prefix_, std::forward<Args>(args)...);
         }
         template <typename... Args>
-        HPX_CXX14_CONSTEXPR void warning(Args... args)
+        constexpr void warning(Args... args)
         {
             detail::warning(prefix_, std::forward<Args>(args)...);
         }
         template <typename... Args>
-        HPX_CXX14_CONSTEXPR void error(Args... args)
+        constexpr void error(Args... args)
         {
             detail::error(prefix_, std::forward<Args>(args)...);
         }
diff --git a/libs/debugging/src/attach_debugger.cpp b/libs/debugging/src/attach_debugger.cpp
new file mode 100644
index 0000000000..0f48e927ae
--- /dev/null
+++ b/libs/debugging/src/attach_debugger.cpp
@@ -0,0 +1,43 @@
+//  Copyright (c) 2007-2012 Hartmut Kaiser
+//  Copyright (c) 2017      Denis Blank
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/debugging/attach_debugger.hpp>
+
+#include <iostream>
+
+#if defined(HPX_HAVE_UNISTD_H)
+#include <unistd.h>
+#endif
+
+#if defined(HPX_WINDOWS)
+#include <Windows.h>
+#endif    // HPX_WINDOWS
+
+#if defined(_POSIX_VERSION)
+#include <boost/asio/ip/host_name.hpp>
+#endif
+
+namespace hpx { namespace util {
+    void attach_debugger()
+    {
+#if defined(_POSIX_VERSION)
+        volatile int i = 0;
+        std::cerr << "PID: " << getpid() << " on "
+                  << boost::asio::ip::host_name()
+                  << " ready for attaching debugger. Once attached set i = 1 "
+                     "and continue"
+                  << std::endl;
+        while (i == 0)
+        {
+            sleep(1);
+        }
+#elif defined(HPX_WINDOWS)
+        DebugBreak();
+#endif
+    }
+}}    // namespace hpx::util
diff --git a/libs/errors/CMakeLists.txt b/libs/errors/CMakeLists.txt
index c8cc3ba7fb..8d5762daa9 100644
--- a/libs/errors/CMakeLists.txt
+++ b/libs/errors/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -48,7 +48,6 @@ add_hpx_module(errors
   DEPENDENCIES
     hpx_assertion
     hpx_config
-    hpx_datastructures
     hpx_filesystem
     hpx_format
     hpx_logging
diff --git a/libs/errors/README.rst b/libs/errors/README.rst
index 966d057972..0e0cd81239 100644
--- a/libs/errors/README.rst
+++ b/libs/errors/README.rst
@@ -13,4 +13,4 @@ errors
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/errors/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/errors/docs/index.html>`__.
diff --git a/libs/errors/include/hpx/errors/exception_fwd.hpp b/libs/errors/include/hpx/errors/exception_fwd.hpp
index 9682c1c2af..d7ecd0a439 100644
--- a/libs/errors/include/hpx/errors/exception_fwd.hpp
+++ b/libs/errors/include/hpx/errors/exception_fwd.hpp
@@ -57,7 +57,13 @@ namespace hpx {
     /// \a get_errorcode() member function returns a reference to an
     /// \a hpx::error_code object with the behavior as specified above.
     ///
+#if defined(HPX_COMPUTE_DEVICE_CODE)
+    // We can't actually refer to this in device code. This is only to satisfy
+    // the compiler.
+    extern HPX_DEVICE error_code throws;
+#else
     HPX_EXCEPTION_EXPORT extern error_code throws;
+#endif
 }    // namespace hpx
 
 #include <hpx/errors/throw_exception.hpp>
diff --git a/libs/errors/include/hpx/errors/exception_info.hpp b/libs/errors/include/hpx/errors/exception_info.hpp
index 7af9a8c74e..4eb13383a9 100644
--- a/libs/errors/include/hpx/errors/exception_info.hpp
+++ b/libs/errors/include/hpx/errors/exception_info.hpp
@@ -9,15 +9,12 @@
 #define HPX_EXCEPTION_INFO_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
-#include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors/error_code.hpp>
 #include <hpx/errors/exception_info.hpp>
 
 #include <cstddef>
 #include <exception>
 #include <memory>
-#include <tuple>
 #include <type_traits>
 #include <typeinfo>
 #include <utility>
@@ -75,45 +72,35 @@ namespace hpx {
         };
 
         template <typename... Ts>
-        class exception_info_node : public exception_info_node_base
+        class exception_info_node
+          : public exception_info_node_base
+          , Ts...
         {
         public:
             template <typename... ErrorInfo>
             explicit exception_info_node(ErrorInfo&&... tagged_values)
-              : data(tagged_values._value...)
+              : Ts(tagged_values)...
             {
             }
 
-            template <std::size_t... Is>
-            void const* _lookup(util::detail::pack_c<std::size_t, Is...>,
-                std::type_info const& tag) const noexcept
+            void const* lookup(std::type_info const& tag) const
+                noexcept override
             {
                 using entry_type =
                     std::pair<std::type_info const&, void const*>;
                 entry_type const entries[] = {{typeid(typename Ts::tag),
-                    std::addressof(std::get<Is>(data))}...};
+                    std::addressof(static_cast<Ts const*>(this)->_value)}...};
 
                 for (auto const& entry : entries)
                 {
                     if (entry.first == tag)
                         return entry.second;
                 }
-                return nullptr;
-            }
-
-            void const* lookup(std::type_info const& tag) const
-                noexcept override
-            {
-                using indices_pack =
-                    typename util::detail::make_index_pack<sizeof...(Ts)>::type;
-                if (void const* value = _lookup(indices_pack(), tag))
-                    return value;
 
                 return next ? next->lookup(tag) : nullptr;
             }
 
             using exception_info_node_base::next;
-            std::tuple<typename Ts::type...> data;
         };
     }    // namespace detail
 
@@ -199,12 +186,7 @@ namespace hpx {
         E&& e, exception_info&& xi = exception_info())
     {
         using ED = typename std::decay<E>::type;
-        static_assert(
-#if defined(HPX_HAVE_CXX14_STD_IS_FINAL)
-            std::is_class<ED>::value && !std::is_final<ED>::value,
-#else
-            std::is_class<ED>::value,
-#endif
+        static_assert(std::is_class<ED>::value && !std::is_final<ED>::value,
             "E shall be a valid base class");
         static_assert(!std::is_base_of<exception_info, ED>::value,
             "E shall not derive from exception_info");
diff --git a/libs/errors/include/hpx/errors/throw_exception.hpp b/libs/errors/include/hpx/errors/throw_exception.hpp
index b3d38f6518..902be01218 100644
--- a/libs/errors/include/hpx/errors/throw_exception.hpp
+++ b/libs/errors/include/hpx/errors/throw_exception.hpp
@@ -11,13 +11,13 @@
 #define HPX_THROW_EXCEPTION_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/assertion/current_function.hpp>
 #include <hpx/errors/error.hpp>
 #include <hpx/errors/exception_fwd.hpp>
 #include <hpx/preprocessor/cat.hpp>
 #include <hpx/preprocessor/expand.hpp>
 #include <hpx/preprocessor/nargs.hpp>
 
-#include <boost/current_function.hpp>
 #include <boost/system/error_code.hpp>
 
 #include <exception>
@@ -107,20 +107,20 @@ namespace hpx {
 
 ///////////////////////////////////////////////////////////////////////////////
 #define HPX_THROW_IN_CURRENT_FUNC(errcode, msg)                                \
-    HPX_THROW_EXCEPTION(errcode, BOOST_CURRENT_FUNCTION, msg)                  \
+    HPX_THROW_EXCEPTION(errcode, HPX_ASSERTION_CURRENT_FUNCTION, msg)          \
     /**/
 
 #define HPX_RETHROW_IN_CURRENT_FUNC(errcode, msg)                              \
-    HPX_RETHROW_EXCEPTION(errcode, BOOST_CURRENT_FUNCTION, msg)                \
+    HPX_RETHROW_EXCEPTION(errcode, HPX_ASSERTION_CURRENT_FUNCTION, msg)        \
     /**/
 
 ///////////////////////////////////////////////////////////////////////////////
 #define HPX_THROWS_IN_CURRENT_FUNC_IF(ec, errcode, msg)                        \
-    HPX_THROWS_IF(ec, errcode, BOOST_CURRENT_FUNCTION, msg)                    \
+    HPX_THROWS_IF(ec, errcode, HPX_ASSERTION_CURRENT_FUNCTION, msg)            \
     /**/
 
 #define HPX_RETHROWS_IN_CURRENT_FUNC_IF(ec, errcode, msg)                      \
-    HPX_RETHROWS_IF(ec, errcode, BOOST_CURRENT_FUNCTION, msg)                  \
+    HPX_RETHROWS_IF(ec, errcode, HPX_ASSERTION_CURRENT_FUNCTION, msg)          \
     /**/
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/libs/execution/CMakeLists.txt b/libs/execution/CMakeLists.txt
index 4b14d24f09..57e8108652 100644
--- a/libs/execution/CMakeLists.txt
+++ b/libs/execution/CMakeLists.txt
@@ -4,11 +4,68 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
 set(execution_headers
+  hpx/execution/algorithms/detail/is_negative.hpp
+  hpx/execution/algorithms/detail/predicates.hpp
+  hpx/execution/datapar/execution_policy_fwd.hpp
+  hpx/execution/datapar/execution_policy.hpp
+  hpx/execution/exception_list.hpp
+  hpx/execution/execution.hpp
+  hpx/execution/execution_policy_fwd.hpp
+  hpx/execution/execution_policy.hpp
+  hpx/execution/executor_parameters.hpp
+  hpx/execution/executors/auto_chunk_size.hpp
+  hpx/execution/executors/default_executor.hpp
+  hpx/execution/executors/distribution_policy_executor.hpp
+  hpx/execution/executors/dynamic_chunk_size.hpp
+  hpx/execution/executors/execution_fwd.hpp
+  hpx/execution/executors/execution.hpp
+  hpx/execution/executors/execution_information_fwd.hpp
+  hpx/execution/executors/execution_information.hpp
+  hpx/execution/executors/execution_parameters_fwd.hpp
+  hpx/execution/executors/execution_parameters.hpp
+  hpx/execution/executors/fused_bulk_execute.hpp
+  hpx/execution/executors/guided_chunk_size.hpp
+  hpx/execution/executors.hpp
+  hpx/execution/executors/parallel_executor_aggregated.hpp
+  hpx/execution/executors/parallel_executor.hpp
+  hpx/execution/executors/persistent_auto_chunk_size.hpp
+  hpx/execution/executors/pool_executor.hpp
+  hpx/execution/executors/post_policy_dispatch.hpp
+  hpx/execution/executors/rebind_executor.hpp
+  hpx/execution/executors/sequenced_executor.hpp
+  hpx/execution/executors/service_executors.hpp
+  hpx/execution/executors/static_chunk_size.hpp
+  hpx/execution/executors/this_thread_executors.hpp
+  hpx/execution/executors/thread_execution.hpp
+  hpx/execution/executors/thread_execution_information.hpp
+  hpx/execution/executors/thread_pool_attached_executors.hpp
+  hpx/execution/executors/thread_pool_executors.hpp
+  hpx/execution/executors/thread_pool_os_executors.hpp
+  hpx/execution/executors/thread_timed_execution.hpp
+  hpx/execution/executors/timed_execution_fwd.hpp
+  hpx/execution/executors/timed_execution.hpp
+  hpx/execution/executors/timed_executors.hpp
+  hpx/execution/parallel/traits/detail/vc/vector_pack_alignment_size.hpp
+  hpx/execution/parallel/traits/detail/vc/vector_pack_count_bits.hpp
+  hpx/execution/parallel/traits/detail/vc/vector_pack_load_store.hpp
+  hpx/execution/parallel/traits/detail/vc/vector_pack_type.hpp
+  hpx/execution/parallel/traits/vector_pack_alignment_size.hpp
+  hpx/execution/parallel/traits/vector_pack_count_bits.hpp
+  hpx/execution/parallel/traits/vector_pack_load_store.hpp
+  hpx/execution/parallel/traits/vector_pack_type.hpp
+  hpx/execution/traits/executor_traits.hpp
+  hpx/execution/traits/is_execution_policy.hpp
+  hpx/execution/traits/is_executor.hpp
+  hpx/execution/traits/is_executor_parameters.hpp
+  hpx/execution/traits/is_timed_executor.hpp
+)
+
+set(execution_compat_headers
   hpx/parallel/algorithms/detail/is_negative.hpp
   hpx/parallel/algorithms/detail/predicates.hpp
   hpx/parallel/datapar/execution_policy_fwd.hpp
@@ -69,6 +126,8 @@ include(HPX_AddModule)
 add_hpx_module(execution
   FORCE_LINKING_GEN
   HEADERS ${execution_headers}
+  COMPATIBILITY_HEADERS ON    # Added in 1.5.0
+  COMPAT_HEADERS ${execution_compat_headers}
   DEPENDENCIES
     hpx_assertion
     hpx_allocator_support
diff --git a/libs/execution/README.rst b/libs/execution/README.rst
index 55980c9935..6b58974816 100644
--- a/libs/execution/README.rst
+++ b/libs/execution/README.rst
@@ -13,4 +13,4 @@ execution
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/execution/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/execution/docs/index.html>`__.
diff --git a/libs/execution/include/hpx/parallel/algorithms/detail/is_negative.hpp b/libs/execution/include/hpx/execution/algorithms/detail/is_negative.hpp
similarity index 100%
rename from libs/execution/include/hpx/parallel/algorithms/detail/is_negative.hpp
rename to libs/execution/include/hpx/execution/algorithms/detail/is_negative.hpp
diff --git a/libs/execution/include/hpx/parallel/algorithms/detail/predicates.hpp b/libs/execution/include/hpx/execution/algorithms/detail/predicates.hpp
similarity index 99%
rename from libs/execution/include/hpx/parallel/algorithms/detail/predicates.hpp
rename to libs/execution/include/hpx/execution/algorithms/detail/predicates.hpp
index 0515e723ae..3e3d9d4306 100644
--- a/libs/execution/include/hpx/parallel/algorithms/detail/predicates.hpp
+++ b/libs/execution/include/hpx/execution/algorithms/detail/predicates.hpp
@@ -12,7 +12,7 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 
-#include <hpx/parallel/algorithms/detail/is_negative.hpp>
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
 
 #include <algorithm>
 #include <cstddef>
diff --git a/libs/execution/include/hpx/parallel/datapar/execution_policy.hpp b/libs/execution/include/hpx/execution/datapar/execution_policy.hpp
similarity index 94%
rename from libs/execution/include/hpx/parallel/datapar/execution_policy.hpp
rename to libs/execution/include/hpx/execution/datapar/execution_policy.hpp
index c07cdb762f..40c68fd309 100644
--- a/libs/execution/include/hpx/parallel/datapar/execution_policy.hpp
+++ b/libs/execution/include/hpx/execution/datapar/execution_policy.hpp
@@ -10,15 +10,15 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_DATAPAR)
-#include <hpx/parallel/datapar/execution_policy_fwd.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
-#include <hpx/parallel/executors/rebind_executor.hpp>
-#include <hpx/parallel/executors/sequenced_executor.hpp>
+#include <hpx/execution/datapar/execution_policy_fwd.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
+#include <hpx/execution/executors/rebind_executor.hpp>
+#include <hpx/execution/executors/sequenced_executor.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/serialization/serialize.hpp>
-#include <hpx/traits/executor_traits.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 
 #include <type_traits>
@@ -59,7 +59,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR dataseq_task_policy() {}
+        constexpr dataseq_task_policy() {}
         /// \endcond
 
         /// Create a new dataseq_task_policy from itself
@@ -69,7 +69,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new sequenced_task_policy
         ///
-        HPX_CONSTEXPR dataseq_task_policy operator()(task_policy_tag tag) const
+        constexpr dataseq_task_policy operator()(task_policy_tag tag) const
         {
             return *this;
         }
@@ -138,7 +138,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -149,7 +149,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -209,7 +209,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new sequenced_task_policy
         ///
-        HPX_CONSTEXPR dataseq_task_policy_shim const& operator()(
+        constexpr dataseq_task_policy_shim const& operator()(
             task_policy_tag tag) const
         {
             return *this;
@@ -278,7 +278,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -289,16 +289,16 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR dataseq_task_policy_shim() {}
+        constexpr dataseq_task_policy_shim() {}
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR dataseq_task_policy_shim(
+        constexpr dataseq_task_policy_shim(
             Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
@@ -349,7 +349,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR dataseq_policy()
+        constexpr dataseq_policy()
           : exec_{}
           , params_{}
         {
@@ -363,7 +363,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new dataseq_task_policy
         ///
-        HPX_CONSTEXPR dataseq_task_policy operator()(task_policy_tag tag) const
+        constexpr dataseq_task_policy operator()(task_policy_tag tag) const
         {
             return dataseq_task_policy();
         }
@@ -433,7 +433,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -444,7 +444,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -500,7 +500,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new dataseq_task_policy_shim
         ///
-        HPX_CONSTEXPR dataseq_task_policy_shim<Executor, Parameters> operator()(
+        constexpr dataseq_task_policy_shim<Executor, Parameters> operator()(
             task_policy_tag tag) const
         {
             return dataseq_task_policy_shim<Executor, Parameters>(
@@ -570,7 +570,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -581,17 +581,16 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR dataseq_policy_shim() {}
+        constexpr dataseq_policy_shim() {}
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR dataseq_policy_shim(
-            Executor_&& exec, Parameters_&& params)
+        constexpr dataseq_policy_shim(Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
         {
@@ -645,7 +644,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR datapar_task_policy() {}
+        constexpr datapar_task_policy() {}
         /// \endcond
 
         /// Create a new datapar_task_policy from itself
@@ -655,7 +654,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new datapar_task_policy
         ///
-        HPX_CONSTEXPR datapar_task_policy operator()(task_policy_tag tag) const
+        constexpr datapar_task_policy operator()(task_policy_tag tag) const
         {
             return *this;
         }
@@ -723,7 +722,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -734,7 +733,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -781,7 +780,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR datapar_policy()
+        constexpr datapar_policy()
           : exec_{}
           , params_{}
         {
@@ -795,7 +794,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new datapar_task_policy
         ///
-        HPX_CONSTEXPR datapar_task_policy operator()(task_policy_tag tag) const
+        constexpr datapar_task_policy operator()(task_policy_tag tag) const
         {
             return datapar_task_policy();
         }
@@ -858,7 +857,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -869,7 +868,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -925,7 +924,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new datapar_task_policy_shim
         ///
-        HPX_CONSTEXPR datapar_task_policy_shim<Executor, Parameters> operator()(
+        constexpr datapar_task_policy_shim<Executor, Parameters> operator()(
             task_policy_tag tag) const
         {
             return datapar_task_policy_shim<Executor, Parameters>(
@@ -994,7 +993,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -1005,17 +1004,16 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR datapar_policy_shim() {}
+        constexpr datapar_policy_shim() {}
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR datapar_policy_shim(
-            Executor_&& exec, Parameters_&& params)
+        constexpr datapar_policy_shim(Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
         {
@@ -1073,8 +1071,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
         ///
         /// \returns The new sequenced_task_policy
         ///
-        HPX_CONSTEXPR datapar_task_policy_shim operator()(
-            task_policy_tag tag) const
+        constexpr datapar_task_policy_shim operator()(task_policy_tag tag) const
         {
             return *this;
         }
@@ -1142,7 +1139,7 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -1153,16 +1150,16 @@ namespace hpx { namespace parallel { namespace execution { inline namespace v1 {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR datapar_task_policy_shim() {}
+        constexpr datapar_task_policy_shim() {}
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR datapar_task_policy_shim(
+        constexpr datapar_task_policy_shim(
             Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
diff --git a/libs/execution/include/hpx/parallel/datapar/execution_policy_fwd.hpp b/libs/execution/include/hpx/execution/datapar/execution_policy_fwd.hpp
similarity index 100%
rename from libs/execution/include/hpx/parallel/datapar/execution_policy_fwd.hpp
rename to libs/execution/include/hpx/execution/datapar/execution_policy_fwd.hpp
diff --git a/libs/execution/include/hpx/parallel/exception_list.hpp b/libs/execution/include/hpx/execution/exception_list.hpp
similarity index 99%
rename from libs/execution/include/hpx/parallel/exception_list.hpp
rename to libs/execution/include/hpx/execution/exception_list.hpp
index b814873d72..45b8b70f11 100644
--- a/libs/execution/include/hpx/parallel/exception_list.hpp
+++ b/libs/execution/include/hpx/execution/exception_list.hpp
@@ -15,7 +15,7 @@
 #include <hpx/lcos/future.hpp>
 #include <hpx/type_support/decay.hpp>
 
-#include <hpx/parallel/execution_policy_fwd.hpp>
+#include <hpx/execution/execution_policy_fwd.hpp>
 
 #include <exception>
 #include <utility>
diff --git a/libs/execution/include/hpx/execution/execution.hpp b/libs/execution/include/hpx/execution/execution.hpp
new file mode 100644
index 0000000000..51a7d4eed6
--- /dev/null
+++ b/libs/execution/include/hpx/execution/execution.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2017 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#if !defined(HPX_PARALLEL_EXECUTION_DEC_25_2106_0102PM)
+#define HPX_PARALLEL_EXECUTION_DEC_25_2106_0102PM
+
+#include <hpx/execution/execution.hpp>
+#include <hpx/execution/executors.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
+#include <hpx/execution/executors/timed_execution.hpp>
+
+#endif
diff --git a/libs/execution/include/hpx/parallel/execution_policy.hpp b/libs/execution/include/hpx/execution/execution_policy.hpp
similarity index 94%
rename from libs/execution/include/hpx/parallel/execution_policy.hpp
rename to libs/execution/include/hpx/execution/execution_policy.hpp
index aca63b3e49..6002a9118b 100644
--- a/libs/execution/include/hpx/parallel/execution_policy.hpp
+++ b/libs/execution/include/hpx/execution/execution_policy.hpp
@@ -11,18 +11,18 @@
 #define HPX_PARALLEL_EXECUTION_POLICY_MAY_27_2014_0908PM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/datapar/execution_policy.hpp>
-#include <hpx/parallel/execution_policy_fwd.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
-#include <hpx/parallel/executors/rebind_executor.hpp>
-#include <hpx/parallel/executors/sequenced_executor.hpp>
+#include <hpx/execution/datapar/execution_policy.hpp>
+#include <hpx/execution/execution_policy_fwd.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
+#include <hpx/execution/executors/rebind_executor.hpp>
+#include <hpx/execution/executors/sequenced_executor.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/serialization/serialize.hpp>
-#include <hpx/traits/executor_traits.hpp>
-#include <hpx/traits/is_execution_policy.hpp>
-#include <hpx/traits/is_executor.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/type_support/decay.hpp>
 
@@ -33,7 +33,7 @@
 namespace hpx { namespace parallel { namespace execution {
     ///////////////////////////////////////////////////////////////////////////
     /// Default sequential execution policy object.
-    static task_policy_tag HPX_CONSTEXPR_OR_CONST task;
+    static constexpr task_policy_tag task;
 
     ///////////////////////////////////////////////////////////////////////////
     /// Extension: The class sequenced_task_policy is an execution
@@ -69,7 +69,7 @@ namespace hpx { namespace parallel { namespace execution {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR sequenced_task_policy() {}
+        constexpr sequenced_task_policy() {}
         /// \endcond
 
         /// Create a new sequenced_task_policy from itself
@@ -79,7 +79,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new sequenced_task_policy
         ///
-        HPX_CONSTEXPR sequenced_task_policy operator()(
+        constexpr sequenced_task_policy operator()(
             task_policy_tag /*tag*/) const
         {
             return *this;
@@ -152,7 +152,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -163,7 +163,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -223,7 +223,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new sequenced_task_policy
         ///
-        HPX_CONSTEXPR sequenced_task_policy_shim const& operator()(
+        constexpr sequenced_task_policy_shim const& operator()(
             task_policy_tag tag) const
         {
             return *this;
@@ -295,7 +295,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -306,7 +306,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
@@ -317,12 +317,12 @@ namespace hpx { namespace parallel { namespace execution {
                 std::is_constructible<Executor>::value &&
                     std::is_constructible<Parameters>::value,
                 Dependent>::type>
-        HPX_CONSTEXPR sequenced_task_policy_shim()
+        constexpr sequenced_task_policy_shim()
         {
         }
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR sequenced_task_policy_shim(
+        constexpr sequenced_task_policy_shim(
             Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
@@ -373,7 +373,7 @@ namespace hpx { namespace parallel { namespace execution {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR sequenced_policy()
+        constexpr sequenced_policy()
           : exec_{}
           , params_{}
         {
@@ -387,7 +387,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new sequenced_task_policy
         ///
-        HPX_CONSTEXPR sequenced_task_policy operator()(
+        constexpr sequenced_task_policy operator()(
             task_policy_tag /*tag*/) const
         {
             return sequenced_task_policy();
@@ -461,7 +461,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -472,7 +472,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -528,8 +528,8 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new sequenced_task_policy_shim
         ///
-        HPX_CONSTEXPR sequenced_task_policy_shim<Executor, Parameters>
-        operator()(task_policy_tag tag) const
+        constexpr sequenced_task_policy_shim<Executor, Parameters> operator()(
+            task_policy_tag tag) const
         {
             return sequenced_task_policy_shim<Executor, Parameters>(
                 exec_, params_);
@@ -601,7 +601,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -612,7 +612,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
@@ -623,13 +623,12 @@ namespace hpx { namespace parallel { namespace execution {
                 std::is_constructible<Executor>::value &&
                     std::is_constructible<Parameters>::value,
                 Dependent>::type>
-        HPX_CONSTEXPR sequenced_policy_shim()
+        constexpr sequenced_policy_shim()
         {
         }
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR sequenced_policy_shim(
-            Executor_&& exec, Parameters_&& params)
+        constexpr sequenced_policy_shim(Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
         {
@@ -683,7 +682,7 @@ namespace hpx { namespace parallel { namespace execution {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR parallel_task_policy() {}
+        constexpr parallel_task_policy() {}
         /// \endcond
 
         /// Create a new parallel_task_policy from itself
@@ -693,8 +692,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new parallel_task_policy
         ///
-        HPX_CONSTEXPR parallel_task_policy operator()(
-            task_policy_tag /*tag*/) const
+        constexpr parallel_task_policy operator()(task_policy_tag /*tag*/) const
         {
             return *this;
         }
@@ -765,7 +763,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -776,7 +774,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -831,7 +829,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new sequenced_task_policy
         ///
-        HPX_CONSTEXPR parallel_task_policy_shim operator()(
+        constexpr parallel_task_policy_shim operator()(
             task_policy_tag tag) const
         {
             return *this;
@@ -903,7 +901,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -914,7 +912,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
@@ -925,12 +923,12 @@ namespace hpx { namespace parallel { namespace execution {
                 std::is_constructible<Executor>::value &&
                     std::is_constructible<Parameters>::value,
                 Dependent>::type>
-        HPX_CONSTEXPR parallel_task_policy_shim()
+        constexpr parallel_task_policy_shim()
         {
         }
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR parallel_task_policy_shim(
+        constexpr parallel_task_policy_shim(
             Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
@@ -981,7 +979,7 @@ namespace hpx { namespace parallel { namespace execution {
         };
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR parallel_policy()
+        constexpr parallel_policy()
           : exec_{}
           , params_{}
         {
@@ -995,8 +993,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new parallel_policy
         ///
-        HPX_CONSTEXPR parallel_task_policy operator()(
-            task_policy_tag /*tag*/) const
+        constexpr parallel_task_policy operator()(task_policy_tag /*tag*/) const
         {
             return parallel_task_policy();
         }
@@ -1062,7 +1059,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -1073,7 +1070,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
@@ -1129,8 +1126,8 @@ namespace hpx { namespace parallel { namespace execution {
         ///
         /// \returns The new parallel_policy
         ///
-        HPX_CONSTEXPR parallel_task_policy_shim<Executor, Parameters>
-        operator()(task_policy_tag tag) const
+        constexpr parallel_task_policy_shim<Executor, Parameters> operator()(
+            task_policy_tag tag) const
         {
             return parallel_task_policy_shim<Executor, Parameters>(
                 exec_, params_);
@@ -1201,7 +1198,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR Executor const& executor() const
+        constexpr Executor const& executor() const
         {
             return exec_;
         }
@@ -1212,7 +1209,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR Parameters const& parameters() const
+        constexpr Parameters const& parameters() const
         {
             return params_;
         }
@@ -1223,13 +1220,12 @@ namespace hpx { namespace parallel { namespace execution {
                 std::is_constructible<Executor>::value &&
                     std::is_constructible<Parameters>::value,
                 Dependent>::type>
-        HPX_CONSTEXPR parallel_policy_shim()
+        constexpr parallel_policy_shim()
         {
         }
 
         template <typename Executor_, typename Parameters_>
-        HPX_CONSTEXPR parallel_policy_shim(
-            Executor_&& exec, Parameters_&& params)
+        constexpr parallel_policy_shim(Executor_&& exec, Parameters_&& params)
           : exec_(std::forward<Executor_>(exec))
           , params_(std::forward<Parameters_>(params))
         {
@@ -1269,7 +1265,7 @@ namespace hpx { namespace parallel { namespace execution {
         typedef parallel_execution_tag execution_category;
 
         /// \cond NOINTERNAL
-        HPX_CONSTEXPR parallel_unsequenced_policy()
+        constexpr parallel_unsequenced_policy()
           : exec_{}
           , params_{}
         {
@@ -1295,7 +1291,7 @@ namespace hpx { namespace parallel { namespace execution {
             return exec_;
         }
         /// Return the associated executor object.
-        HPX_CONSTEXPR executor_type const& executor() const
+        constexpr executor_type const& executor() const
         {
             return exec_;
         }
@@ -1306,7 +1302,7 @@ namespace hpx { namespace parallel { namespace execution {
             return params_;
         }
         /// Return the associated executor parameters object.
-        HPX_CONSTEXPR executor_parameters_type const& parameters() const
+        constexpr executor_parameters_type const& parameters() const
         {
             return params_;
         }
diff --git a/libs/execution/include/hpx/parallel/execution_policy_fwd.hpp b/libs/execution/include/hpx/execution/execution_policy_fwd.hpp
similarity index 95%
rename from libs/execution/include/hpx/parallel/execution_policy_fwd.hpp
rename to libs/execution/include/hpx/execution/execution_policy_fwd.hpp
index f80bd476fc..b22c046f74 100644
--- a/libs/execution/include/hpx/parallel/execution_policy_fwd.hpp
+++ b/libs/execution/include/hpx/execution/execution_policy_fwd.hpp
@@ -9,7 +9,7 @@
 
 #include <hpx/config.hpp>
 #if defined(HPX_HAVE_DATAPAR)
-#include <hpx/parallel/datapar/execution_policy_fwd.hpp>
+#include <hpx/execution/datapar/execution_policy_fwd.hpp>
 #endif
 
 namespace hpx { namespace parallel { namespace execution {
diff --git a/libs/execution/include/hpx/parallel/executor_parameters.hpp b/libs/execution/include/hpx/execution/executor_parameters.hpp
similarity index 57%
rename from libs/execution/include/hpx/parallel/executor_parameters.hpp
rename to libs/execution/include/hpx/execution/executor_parameters.hpp
index ada9810899..918bc76708 100644
--- a/libs/execution/include/hpx/parallel/executor_parameters.hpp
+++ b/libs/execution/include/hpx/execution/executor_parameters.hpp
@@ -9,10 +9,10 @@
 
 #include <hpx/config.hpp>
 
-#include <hpx/parallel/executors/auto_chunk_size.hpp>
-#include <hpx/parallel/executors/dynamic_chunk_size.hpp>
-#include <hpx/parallel/executors/guided_chunk_size.hpp>
-#include <hpx/parallel/executors/persistent_auto_chunk_size.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
+#include <hpx/execution/executors/auto_chunk_size.hpp>
+#include <hpx/execution/executors/dynamic_chunk_size.hpp>
+#include <hpx/execution/executors/guided_chunk_size.hpp>
+#include <hpx/execution/executors/persistent_auto_chunk_size.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
 
 #endif
diff --git a/libs/execution/include/hpx/execution/executors.hpp b/libs/execution/include/hpx/execution/executors.hpp
new file mode 100644
index 0000000000..531e9720fd
--- /dev/null
+++ b/libs/execution/include/hpx/execution/executors.hpp
@@ -0,0 +1,26 @@
+//  Copyright (c) 2007-2017 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#if !defined(HPX_PARALLEL_EXECUTORS_MAY_11_2015_0728PM)
+#define HPX_PARALLEL_EXECUTORS_MAY_11_2015_0728PM
+
+#include <hpx/config.hpp>
+
+#include <hpx/execution/executors/default_executor.hpp>
+#include <hpx/execution/executors/distribution_policy_executor.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
+#include <hpx/execution/executors/parallel_executor_aggregated.hpp>
+#include <hpx/execution/executors/pool_executor.hpp>
+#include <hpx/execution/executors/sequenced_executor.hpp>
+#include <hpx/execution/executors/service_executors.hpp>
+#include <hpx/execution/executors/this_thread_executors.hpp>
+#include <hpx/execution/executors/thread_pool_attached_executors.hpp>
+#include <hpx/execution/executors/thread_pool_executor.hpp>
+#include <hpx/execution/executors/thread_pool_executors.hpp>
+#include <hpx/execution/executors/thread_pool_os_executors.hpp>
+#include <hpx/execution/executors/timed_executors.hpp>
+
+#endif
diff --git a/libs/execution/include/hpx/parallel/executors/auto_chunk_size.hpp b/libs/execution/include/hpx/execution/executors/auto_chunk_size.hpp
similarity index 77%
rename from libs/execution/include/hpx/parallel/executors/auto_chunk_size.hpp
rename to libs/execution/include/hpx/execution/executors/auto_chunk_size.hpp
index f666f53754..9e01d4282a 100644
--- a/libs/execution/include/hpx/parallel/executors/auto_chunk_size.hpp
+++ b/libs/execution/include/hpx/execution/executors/auto_chunk_size.hpp
@@ -10,11 +10,11 @@
 #define HPX_PARALLEL_AUTO_CHUNK_SIZE_JUL_31_2015_0742PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/timing.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
 
-#include <hpx/parallel/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -39,8 +39,9 @@ namespace hpx { namespace parallel { namespace execution {
         ///       types will use 80 microseconds as the minimal time for which
         ///       any of the scheduled chunks should run.
         ///
-        HPX_CONSTEXPR auto_chunk_size()
-          : min_time_(80000)
+        constexpr auto_chunk_size(std::uint64_t num_iters_for_timing = 0)
+          : min_time_(200000)
+          , num_iters_for_timing_(num_iters_for_timing)
         {
         }
 
@@ -50,8 +51,10 @@ namespace hpx { namespace parallel { namespace execution {
         ///                     to decide how many loop iterations should be
         ///                     combined.
         ///
-        explicit auto_chunk_size(hpx::util::steady_duration const& rel_time)
+        explicit auto_chunk_size(hpx::util::steady_duration const& rel_time,
+            std::uint64_t num_iters_for_timing = 0)
           : min_time_(rel_time.value().count())
+          , num_iters_for_timing_(num_iters_for_timing)
         {
         }
 
@@ -61,12 +64,19 @@ namespace hpx { namespace parallel { namespace execution {
         std::size_t get_chunk_size(
             Executor&& exec, F&& f, std::size_t cores, std::size_t count)
         {
-            if (count > 100 * cores)
+            // by default use 1% of the iterations
+            if (num_iters_for_timing_ == 0)
+            {
+                num_iters_for_timing_ = count / 100;
+            }
+
+            // perform measurements only if necessary
+            if (num_iters_for_timing_ > 0)
             {
                 using hpx::util::high_resolution_clock;
                 std::uint64_t t = high_resolution_clock::now();
 
-                std::size_t test_chunk_size = f();
+                std::size_t test_chunk_size = f(num_iters_for_timing_);
                 if (test_chunk_size != 0)
                 {
                     t = (high_resolution_clock::now() - t) / test_chunk_size;
@@ -90,13 +100,19 @@ namespace hpx { namespace parallel { namespace execution {
         template <typename Archive>
         void serialize(Archive& ar, const unsigned int version)
         {
-            ar& min_time_;
+            // clang-format off
+            ar & min_time_ & num_iters_for_timing_;
+            // clang-format on
         }
         /// \endcond
 
     private:
         /// \cond NOINTERNAL
-        std::uint64_t min_time_;    // nanoseconds
+        // target time for on thread (nanoseconds)
+        std::uint64_t min_time_;
+
+        // number of iteration to use for timing
+        std::uint64_t num_iters_for_timing_;
         /// \endcond
     };
 }}}    // namespace hpx::parallel::execution
diff --git a/libs/execution/include/hpx/parallel/executors/default_executor.hpp b/libs/execution/include/hpx/execution/executors/default_executor.hpp
similarity index 76%
rename from libs/execution/include/hpx/parallel/executors/default_executor.hpp
rename to libs/execution/include/hpx/execution/executors/default_executor.hpp
index abd84c3255..6833c7f41b 100644
--- a/libs/execution/include/hpx/parallel/executors/default_executor.hpp
+++ b/libs/execution/include/hpx/execution/executors/default_executor.hpp
@@ -10,11 +10,11 @@
 #define HPX_PARALLEL_EXECUTORS_DEFAULT_EXECUTOR_AUG_24_2015_0624PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
 #include <hpx/runtime/threads/executors/default_executor.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
diff --git a/libs/execution/include/hpx/parallel/executors/distribution_policy_executor.hpp b/libs/execution/include/hpx/execution/executors/distribution_policy_executor.hpp
similarity index 99%
rename from libs/execution/include/hpx/parallel/executors/distribution_policy_executor.hpp
rename to libs/execution/include/hpx/execution/executors/distribution_policy_executor.hpp
index f034ded590..e155cb7d60 100644
--- a/libs/execution/include/hpx/parallel/executors/distribution_policy_executor.hpp
+++ b/libs/execution/include/hpx/execution/executors/distribution_policy_executor.hpp
@@ -11,13 +11,13 @@
 #define HPX_PARALLEL_EXECUTORS_DISTRIBUTION_POLICY_EXECUTOR_JUL_21_2015_0404PM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/functional/traits/is_action.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/components/server/invoke_function.hpp>
 #include <hpx/traits/is_distribution_policy.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <type_traits>
 #include <utility>
diff --git a/libs/execution/include/hpx/parallel/executors/dynamic_chunk_size.hpp b/libs/execution/include/hpx/execution/executors/dynamic_chunk_size.hpp
similarity index 93%
rename from libs/execution/include/hpx/parallel/executors/dynamic_chunk_size.hpp
rename to libs/execution/include/hpx/execution/executors/dynamic_chunk_size.hpp
index 1ce59fa977..0cb5647419 100644
--- a/libs/execution/include/hpx/parallel/executors/dynamic_chunk_size.hpp
+++ b/libs/execution/include/hpx/execution/executors/dynamic_chunk_size.hpp
@@ -10,8 +10,8 @@
 #define HPX_PARALLEL_DYNAMIC_CHUNK_SIZE_AUG_01_2015_0234PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/serialization/serialize.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -34,14 +34,14 @@ namespace hpx { namespace parallel { namespace execution {
         ///                     number of loop iterations to schedule together.
         ///                     The default chunk size is 1.
         ///
-        HPX_CONSTEXPR explicit dynamic_chunk_size(std::size_t chunk_size = 1)
+        constexpr explicit dynamic_chunk_size(std::size_t chunk_size = 1)
           : chunk_size_(chunk_size)
         {
         }
 
         /// \cond NOINTERNAL
         template <typename Executor, typename F>
-        HPX_CONSTEXPR std::size_t get_chunk_size(
+        constexpr std::size_t get_chunk_size(
             Executor&, F&&, std::size_t, std::size_t) const
         {
             return chunk_size_;
diff --git a/libs/execution/include/hpx/parallel/executors/execution.hpp b/libs/execution/include/hpx/execution/executors/execution.hpp
similarity index 98%
rename from libs/execution/include/hpx/parallel/executors/execution.hpp
rename to libs/execution/include/hpx/execution/executors/execution.hpp
index 006362986a..5e2eb06871 100644
--- a/libs/execution/include/hpx/parallel/executors/execution.hpp
+++ b/libs/execution/include/hpx/execution/executors/execution.hpp
@@ -12,28 +12,25 @@
 
 #include <hpx/config.hpp>
 // Necessary to avoid circular include
-#include <hpx/parallel/executors/execution_fwd.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
 
 #include <hpx/assertion.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/execution/executors/fused_bulk_execute.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/functional/bind_back.hpp>
+#include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/range.hpp>
-#if !defined(HPX_COMPUTE_DEVICE_CODE)
-#include <hpx/lcos/dataflow.hpp>
-#endif
-#include <hpx/functional/deferred_call.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/wait_all.hpp>
-#include <hpx/parallel/executors/fused_bulk_execute.hpp>
-#include <hpx/traits/executor_traits.hpp>
 #include <hpx/traits/future_access.hpp>
 #include <hpx/traits/future_then_result.hpp>
 #include <hpx/traits/future_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <cstddef>
@@ -1132,19 +1129,20 @@ namespace hpx { namespace parallel { namespace execution {
                     vector_result_type>::type result_future_type;
 
                 typedef typename hpx::traits::detail::shared_state_ptr<
-                    result_future_type>::type shared_state_type;
+                    vector_result_type>::type shared_state_type;
 
                 typedef typename std::decay<Future>::type future_type;
 
                 shared_state_type p =
-                    lcos::detail::make_continuation_exec<result_future_type>(
+                    lcos::detail::make_continuation_exec<vector_result_type>(
                         std::forward<Future>(predecessor),
                         std::forward<BulkExecutor>(exec),
-                        [HPX_CAPTURE_MOVE(func)](
+                        [func = std::move(func)](
                             future_type&& predecessor) mutable
-                        -> result_future_type {
-                            return hpx::dataflow(hpx::launch::sync,
-                                hpx::util::functional::unwrap{},
+                        -> vector_result_type {
+                            // use unwrap directly (instead of lazily) to avoid
+                            // having to pull in dataflow
+                            return hpx::util::unwrap(
                                 func(std::move(predecessor)));
                         });
 
diff --git a/libs/execution/include/hpx/parallel/executors/execution_fwd.hpp b/libs/execution/include/hpx/execution/executors/execution_fwd.hpp
similarity index 99%
rename from libs/execution/include/hpx/parallel/executors/execution_fwd.hpp
rename to libs/execution/include/hpx/execution/executors/execution_fwd.hpp
index bf535d5534..2d46da08da 100644
--- a/libs/execution/include/hpx/parallel/executors/execution_fwd.hpp
+++ b/libs/execution/include/hpx/execution/executors/execution_fwd.hpp
@@ -14,7 +14,7 @@
 #include <utility>
 
 #include <hpx/config.hpp>
-#include <hpx/traits/executor_traits.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
     ///////////////////////////////////////////////////////////////////////////
@@ -48,7 +48,7 @@ namespace hpx { namespace parallel { namespace execution {
     /// \cond NOINTERNAL
     struct task_policy_tag
     {
-        HPX_CONSTEXPR task_policy_tag() {}
+        constexpr task_policy_tag() {}
     };
     /// \endcond
 
diff --git a/libs/execution/include/hpx/parallel/executors/execution_information.hpp b/libs/execution/include/hpx/execution/executors/execution_information.hpp
similarity index 97%
rename from libs/execution/include/hpx/parallel/executors/execution_information.hpp
rename to libs/execution/include/hpx/execution/executors/execution_information.hpp
index f7d6e41812..1db4c48d33 100644
--- a/libs/execution/include/hpx/parallel/executors/execution_information.hpp
+++ b/libs/execution/include/hpx/execution/executors/execution_information.hpp
@@ -9,13 +9,13 @@
 #define HPX_PARALLEL_EXECUTORS_EXECUTION_INFORMATION_JAN_16_2017_0444PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/traits/executor_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_information_fwd.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_information_fwd.hpp>
 
 #include <cstddef>
 #include <type_traits>
diff --git a/libs/execution/include/hpx/parallel/executors/execution_information_fwd.hpp b/libs/execution/include/hpx/execution/executors/execution_information_fwd.hpp
similarity index 98%
rename from libs/execution/include/hpx/parallel/executors/execution_information_fwd.hpp
rename to libs/execution/include/hpx/execution/executors/execution_information_fwd.hpp
index 9080836334..eeff2cf9e8 100644
--- a/libs/execution/include/hpx/parallel/executors/execution_information_fwd.hpp
+++ b/libs/execution/include/hpx/execution/executors/execution_information_fwd.hpp
@@ -12,9 +12,9 @@
 #define HPX_PARALLEL_EXECUTORS_EXECUTION_INFORMATION_FWD_JAN_16_2017_0350PM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/execution_fwd.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/traits/executor_traits.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/topology.hpp>
 
 #include <cstddef>
 #include <type_traits>
diff --git a/libs/execution/include/hpx/parallel/executors/execution_parameters.hpp b/libs/execution/include/hpx/execution/executors/execution_parameters.hpp
similarity index 93%
rename from libs/execution/include/hpx/parallel/executors/execution_parameters.hpp
rename to libs/execution/include/hpx/execution/executors/execution_parameters.hpp
index caa54a9dab..0841e2b7bf 100644
--- a/libs/execution/include/hpx/parallel/executors/execution_parameters.hpp
+++ b/libs/execution/include/hpx/execution/executors/execution_parameters.hpp
@@ -5,29 +5,24 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #if !defined(HPX_PARALLEL_EXECUTORS_EXECUTION_PARAMETERS_AUG_21_2017_0750PM)
 #define HPX_PARALLEL_EXECUTORS_EXECUTION_PARAMETERS_AUG_21_2017_0750PM
 
 #include <hpx/config.hpp>
 #include <hpx/concepts/has_member_xxx.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/preprocessor/cat.hpp>
 #include <hpx/preprocessor/stringize.hpp>
 #include <hpx/serialization/base_object.hpp>
-#include <hpx/traits/is_executor.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/type_support/decay.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
+#include <hpx/type_support/pack.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_parameters_fwd.hpp>
-
-#include <boost/ref.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/execution_parameters_fwd.hpp>
 
 #include <cstddef>
 #include <functional>
@@ -432,14 +427,14 @@ namespace hpx { namespace parallel { namespace execution {
         template <>
         struct parameters_type_counter<>
         {
-            static HPX_CONSTEXPR_OR_CONST int value = 0;
+            static constexpr int value = 0;
         };
 
         /// Return the number of parameters which are true
         template <bool Flag1, bool... Flags>
         struct parameters_type_counter<Flag1, Flags...>
         {
-            static HPX_CONSTEXPR_OR_CONST int value =
+            static constexpr int value =
                 Flag1 + parameters_type_counter<Flags...>::value;
         };
 
@@ -620,26 +615,6 @@ namespace hpx { namespace parallel { namespace execution {
         };
 
         ///////////////////////////////////////////////////////////////////////
-        template <typename T>
-        struct unwrapper<::boost::reference_wrapper<T>>
-          : base_member_helper<boost::reference_wrapper<T>>
-          , maximal_number_of_chunks_call_helper<T, boost::reference_wrapper<T>>
-          , get_chunk_size_call_helper<T, boost::reference_wrapper<T>>
-          , mark_begin_execution_call_helper<T, boost::reference_wrapper<T>>
-          , mark_end_of_scheduling_call_helper<T, boost::reference_wrapper<T>>
-          , mark_end_execution_call_helper<T, boost::reference_wrapper<T>>
-          , processing_units_count_call_helper<T, boost::reference_wrapper<T>>
-          , reset_thread_distribution_call_helper<T,
-                boost::reference_wrapper<T>>
-        {
-            using wrapper_type = boost::reference_wrapper<T>;
-
-            unwrapper(wrapper_type wrapped_param)
-              : base_member_helper<wrapper_type>(wrapped_param)
-            {
-            }
-        };
-
         template <typename T>
         struct unwrapper<::std::reference_wrapper<T>>
           : base_member_helper<std::reference_wrapper<T>>
@@ -673,9 +648,8 @@ namespace hpx { namespace parallel { namespace execution {
         template <typename... Params>
         struct executor_parameters : public unwrapper<Params>...
         {
-            static_assert(
-                hpx::util::detail::all_of<hpx::traits::is_executor_parameters<
-                    typename std::decay<Params>::type>...>::value,
+            static_assert(hpx::util::all_of<hpx::traits::is_executor_parameters<
+                              typename std::decay<Params>::type>...>::value,
                 "All passed parameters must be a proper executor parameters "
                 "objects");
             static_assert(sizeof...(Params) >= 2,
@@ -693,8 +667,7 @@ namespace hpx { namespace parallel { namespace execution {
 
             template <typename Dependent = void,
                 typename Enable = typename std::enable_if<
-                    hpx::util::detail::all_of<
-                        std::is_constructible<Params>...>::value,
+                    hpx::util::all_of<std::is_constructible<Params>...>::value,
                     Dependent>::type>
             executor_parameters()
               : unwrapper<Params>()...
@@ -702,9 +675,9 @@ namespace hpx { namespace parallel { namespace execution {
             }
 
             template <typename... Params_,
-                typename Enable = typename std::enable_if<
-                    hpx::util::detail::pack<Params...>::size ==
-                    hpx::util::detail::pack<Params_...>::size>::type>
+                typename Enable =
+                    typename std::enable_if<hpx::util::pack<Params...>::size ==
+                        hpx::util::pack<Params_...>::size>::type>
             executor_parameters(Params_&&... params)
               : unwrapper<Params>(std::forward<Params_>(params))...
             {
diff --git a/libs/execution/include/hpx/parallel/executors/execution_parameters_fwd.hpp b/libs/execution/include/hpx/execution/executors/execution_parameters_fwd.hpp
similarity index 99%
rename from libs/execution/include/hpx/parallel/executors/execution_parameters_fwd.hpp
rename to libs/execution/include/hpx/execution/executors/execution_parameters_fwd.hpp
index 0d51cc5ec1..a3ce0034b3 100644
--- a/libs/execution/include/hpx/parallel/executors/execution_parameters_fwd.hpp
+++ b/libs/execution/include/hpx/execution/executors/execution_parameters_fwd.hpp
@@ -10,8 +10,8 @@
 #define HPX_PARALLEL_EXECUTORS_EXECUTION_PARAMETER_FWD_MAY_19_2017_0120PM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/execution_fwd.hpp>
-#include <hpx/traits/executor_traits.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
 #include <hpx/type_support/decay.hpp>
 
 #include <cstddef>
diff --git a/libs/execution/include/hpx/parallel/executors/fused_bulk_execute.hpp b/libs/execution/include/hpx/execution/executors/fused_bulk_execute.hpp
similarity index 92%
rename from libs/execution/include/hpx/parallel/executors/fused_bulk_execute.hpp
rename to libs/execution/include/hpx/execution/executors/fused_bulk_execute.hpp
index 9c2fef818d..b43a9ff0cb 100644
--- a/libs/execution/include/hpx/parallel/executors/fused_bulk_execute.hpp
+++ b/libs/execution/include/hpx/execution/executors/fused_bulk_execute.hpp
@@ -8,12 +8,12 @@
 #define HPX_PARALLEL_EXECUTORS_FUSED_BULK_EXECUTE_FEB_18_2019_0905AM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/iterator_support/traits/is_range.hpp>
-#include <hpx/parallel/executors/execution_fwd.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -62,8 +62,7 @@ namespace hpx { namespace parallel { namespace execution { namespace detail {
     template <typename Executor, typename F, typename Shape, typename Future,
         std::size_t... Is, typename... Ts>
     HPX_FORCEINLINE auto fused_bulk_sync_execute(Executor&& exec, F&& f,
-        Shape const& shape, Future&& predecessor,
-        hpx::util::detail::pack_c<std::size_t, Is...>,
+        Shape const& shape, Future&& predecessor, hpx::util::index_pack<Is...>,
         hpx::util::tuple<Ts...> const& args)
         -> decltype(execution::bulk_sync_execute(std::forward<Executor>(exec),
             std::forward<F>(f), shape, std::forward<Future>(predecessor),
@@ -93,8 +92,7 @@ namespace hpx { namespace parallel { namespace execution { namespace detail {
         {
             return fused_bulk_sync_execute(exec_, f_, shape_,
                 std::forward<Future>(predecessor),
-                typename hpx::util::detail::make_index_pack<sizeof...(
-                    Ts)>::type(),
+                typename hpx::util::make_index_pack<sizeof...(Ts)>::type(),
                 args_);
         }
     };
@@ -117,8 +115,7 @@ namespace hpx { namespace parallel { namespace execution { namespace detail {
     template <typename Executor, typename F, typename Shape, typename Future,
         std::size_t... Is, typename... Ts>
     HPX_FORCEINLINE auto fused_bulk_async_execute(Executor&& exec, F&& f,
-        Shape const& shape, Future&& predecessor,
-        hpx::util::detail::pack_c<std::size_t, Is...>,
+        Shape const& shape, Future&& predecessor, hpx::util::index_pack<Is...>,
         hpx::util::tuple<Ts...> const& args)
         -> decltype(execution::bulk_async_execute(std::forward<Executor>(exec),
             std::forward<F>(f), shape, std::forward<Future>(predecessor),
@@ -148,8 +145,7 @@ namespace hpx { namespace parallel { namespace execution { namespace detail {
         {
             return fused_bulk_async_execute(exec_, f_, shape_,
                 std::forward<Future>(predecessor),
-                typename hpx::util::detail::make_index_pack<sizeof...(
-                    Ts)>::type(),
+                typename hpx::util::make_index_pack<sizeof...(Ts)>::type(),
                 args_);
         }
     };
diff --git a/libs/execution/include/hpx/parallel/executors/guided_chunk_size.hpp b/libs/execution/include/hpx/execution/executors/guided_chunk_size.hpp
similarity index 94%
rename from libs/execution/include/hpx/parallel/executors/guided_chunk_size.hpp
rename to libs/execution/include/hpx/execution/executors/guided_chunk_size.hpp
index 34a75369e7..33e57bf1ca 100644
--- a/libs/execution/include/hpx/parallel/executors/guided_chunk_size.hpp
+++ b/libs/execution/include/hpx/execution/executors/guided_chunk_size.hpp
@@ -10,8 +10,8 @@
 #define HPX_PARALLEL_GUIDED_CHUNK_SIZE_AUG_01_2015_0238PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/serialization/serialize.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -41,7 +41,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///                     schedule together.
         ///                     The default minimal chunk size is 1.
         ///
-        HPX_CONSTEXPR explicit guided_chunk_size(std::size_t min_chunk_size = 1)
+        constexpr explicit guided_chunk_size(std::size_t min_chunk_size = 1)
           : min_chunk_size_(min_chunk_size)
         {
         }
@@ -60,7 +60,7 @@ namespace hpx { namespace parallel { namespace execution {
         //         }
 
         template <typename Executor, typename F>
-        HPX_CONSTEXPR std::size_t get_chunk_size(Executor&& exec, F&&,
+        constexpr std::size_t get_chunk_size(Executor&& exec, F&&,
             std::size_t cores, std::size_t num_tasks) const
         {
             return (std::max)(min_chunk_size_, (num_tasks + cores - 1) / cores);
diff --git a/libs/execution/include/hpx/parallel/executors/parallel_executor.hpp b/libs/execution/include/hpx/execution/executors/parallel_executor.hpp
similarity index 94%
rename from libs/execution/include/hpx/parallel/executors/parallel_executor.hpp
rename to libs/execution/include/hpx/execution/executors/parallel_executor.hpp
index a903779be5..acd0358063 100644
--- a/libs/execution/include/hpx/parallel/executors/parallel_executor.hpp
+++ b/libs/execution/include/hpx/execution/executors/parallel_executor.hpp
@@ -14,26 +14,25 @@
 #include <hpx/allocator_support/internal_allocator.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/async_launch_policy_dispatch.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/executors/fused_bulk_execute.hpp>
+#include <hpx/execution/executors/post_policy_dispatch.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/functional/bind_back.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/one_shot.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/executors/fused_bulk_execute.hpp>
-#include <hpx/parallel/executors/post_policy_dispatch.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/synchronization/latch.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/traits/future_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <algorithm>
@@ -47,7 +46,7 @@ namespace hpx { namespace parallel { namespace execution {
         template <typename Policy>
         struct get_default_policy
         {
-            static HPX_CONSTEXPR Policy call()
+            static constexpr Policy call()
             {
                 return Policy{};
             }
@@ -56,7 +55,7 @@ namespace hpx { namespace parallel { namespace execution {
         template <>
         struct get_default_policy<hpx::launch>
         {
-            static HPX_CONSTEXPR hpx::launch::async_policy call()
+            static constexpr hpx::launch::async_policy call()
             {
                 return hpx::launch::async_policy{};
             }
@@ -94,7 +93,7 @@ namespace hpx { namespace parallel { namespace execution {
         typedef static_chunk_size executor_parameters_type;
 
         /// Create a new parallel executor
-        HPX_CONSTEXPR explicit parallel_policy_executor(
+        constexpr explicit parallel_policy_executor(
             Policy l = detail::get_default_policy<Policy>::call(),
             std::size_t spread = 4, std::size_t tasks = std::size_t(-1))
           : policy_(l)
@@ -242,7 +241,7 @@ namespace hpx { namespace parallel { namespace execution {
                 lcos::detail::make_continuation_alloc<vector_result_type>(
                     hpx::util::internal_allocator<>{},
                     std::forward<Future>(predecessor), policy_,
-                    [HPX_CAPTURE_MOVE(func)](future_type&& predecessor) mutable
+                    [func = std::move(func)](future_type&& predecessor) mutable
                     -> vector_result_type {
                         // use unwrap directly (instead of lazily) to avoid
                         // having to pull in dataflow
diff --git a/libs/execution/include/hpx/parallel/executors/parallel_executor_aggregated.hpp b/libs/execution/include/hpx/execution/executors/parallel_executor_aggregated.hpp
similarity index 97%
rename from libs/execution/include/hpx/parallel/executors/parallel_executor_aggregated.hpp
rename to libs/execution/include/hpx/execution/executors/parallel_executor_aggregated.hpp
index 3ac12d8362..ec20299108 100644
--- a/libs/execution/include/hpx/parallel/executors/parallel_executor_aggregated.hpp
+++ b/libs/execution/include/hpx/execution/executors/parallel_executor_aggregated.hpp
@@ -13,19 +13,19 @@
 
 #include <hpx/config.hpp>
 #include <hpx/async_launch_policy_dispatch.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/executors/post_policy_dispatch.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/executors/post_policy_dispatch.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
 #include <hpx/runtime/get_worker_thread_num.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/synchronization/latch.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/traits/future_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -55,7 +55,7 @@ namespace hpx { namespace parallel { namespace execution {
         using executor_parameters_type = static_chunk_size;
 
         /// Create a new parallel executor
-        HPX_CONSTEXPR explicit parallel_policy_executor_aggregated(
+        constexpr explicit parallel_policy_executor_aggregated(
             std::size_t spread = 4, std::size_t tasks = std::size_t(-1))
           : num_spread_(spread)
           , num_tasks_(tasks)
@@ -251,7 +251,7 @@ namespace hpx { namespace parallel { namespace execution {
         using executor_parameters_type = static_chunk_size;
 
         /// Create a new parallel executor
-        HPX_CONSTEXPR explicit parallel_policy_executor_aggregated(
+        constexpr explicit parallel_policy_executor_aggregated(
             hpx::launch l = hpx::launch::async_policy{}, std::size_t spread = 4,
             std::size_t tasks = std::size_t(-1))
           : policy_(l)
diff --git a/libs/execution/include/hpx/parallel/executors/persistent_auto_chunk_size.hpp b/libs/execution/include/hpx/execution/executors/persistent_auto_chunk_size.hpp
similarity index 79%
rename from libs/execution/include/hpx/parallel/executors/persistent_auto_chunk_size.hpp
rename to libs/execution/include/hpx/execution/executors/persistent_auto_chunk_size.hpp
index be4c6b2f15..5abf9fa519 100644
--- a/libs/execution/include/hpx/parallel/executors/persistent_auto_chunk_size.hpp
+++ b/libs/execution/include/hpx/execution/executors/persistent_auto_chunk_size.hpp
@@ -10,9 +10,9 @@
 #define HPX_PARALLEL_PERSISTENT_AUTO_CHUNK_SIZE_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/timing.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -38,9 +38,11 @@ namespace hpx { namespace parallel { namespace execution {
         ///       and 80 microseconds as the minimal time for which
         ///       any of the scheduled chunks should run.
         ///
-        HPX_CONSTEXPR persistent_auto_chunk_size()
+        constexpr persistent_auto_chunk_size(
+            std::uint64_t num_iters_for_timing = 0)
           : chunk_size_time_(0)
-          , min_time_(80000)
+          , min_time_(200000)
+          , num_iters_for_timing_(num_iters_for_timing)
         {
         }
 
@@ -49,9 +51,11 @@ namespace hpx { namespace parallel { namespace execution {
         /// \param time_cs      The execution time for each chunk.
         ///
         explicit persistent_auto_chunk_size(
-            hpx::util::steady_duration const& time_cs)
+            hpx::util::steady_duration const& time_cs,
+            std::uint64_t num_iters_for_timing = 0)
           : chunk_size_time_(time_cs.value().count())
-          , min_time_(80000)
+          , min_time_(200000)
+          , num_iters_for_timing_(num_iters_for_timing)
         {
         }
 
@@ -63,9 +67,11 @@ namespace hpx { namespace parallel { namespace execution {
         /// \param time_cs       The execution time for each chunk.
         ///
         persistent_auto_chunk_size(hpx::util::steady_duration const& time_cs,
-            hpx::util::steady_duration const& rel_time)
+            hpx::util::steady_duration const& rel_time,
+            std::uint64_t num_iters_for_timing = 0)
           : chunk_size_time_(time_cs.value().count())
           , min_time_(rel_time.value().count())
+          , num_iters_for_timing_(num_iters_for_timing)
         {
         }
 
@@ -75,12 +81,19 @@ namespace hpx { namespace parallel { namespace execution {
         std::size_t get_chunk_size(
             Executor& exec, F&& f, std::size_t cores, std::size_t count)
         {
-            if (count > 100 * cores)
+            // by default use 1% of the iterations
+            if (num_iters_for_timing_ == 0)
+            {
+                num_iters_for_timing_ = count / 100;
+            }
+
+            // perform measurements only if necessary
+            if (num_iters_for_timing_ > 0)
             {
                 using hpx::util::high_resolution_clock;
                 std::uint64_t t = high_resolution_clock::now();
 
-                std::size_t test_chunk_size = f();
+                std::size_t test_chunk_size = f(num_iters_for_timing_);
                 if (test_chunk_size != 0)
                 {
                     if (chunk_size_time_ == 0)
@@ -114,7 +127,9 @@ namespace hpx { namespace parallel { namespace execution {
         template <typename Archive>
         void serialize(Archive& ar, const unsigned int version)
         {
-            ar& chunk_size_time_& min_time_;
+            // clang-format off
+            ar & chunk_size_time_ & min_time_ & num_iters_for_timing_;
+            // clang-format on
         }
         /// \endcond
 
@@ -122,6 +137,8 @@ namespace hpx { namespace parallel { namespace execution {
         /// \cond NOINTERNAL
         std::uint64_t chunk_size_time_;    // nanoseconds
         std::uint64_t min_time_;           // nanoseconds
+        // number of iteration to use for timing
+        std::uint64_t num_iters_for_timing_;
         /// \endcond
     };
 }}}    // namespace hpx::parallel::execution
diff --git a/libs/execution/include/hpx/parallel/executors/pool_executor.hpp b/libs/execution/include/hpx/execution/executors/pool_executor.hpp
similarity index 76%
rename from libs/execution/include/hpx/parallel/executors/pool_executor.hpp
rename to libs/execution/include/hpx/execution/executors/pool_executor.hpp
index de9d062c1f..9209088589 100644
--- a/libs/execution/include/hpx/parallel/executors/pool_executor.hpp
+++ b/libs/execution/include/hpx/execution/executors/pool_executor.hpp
@@ -10,11 +10,11 @@
 #define HPX_PARALLEL_EXECUTORS_POOL_EXECUTOR_FEB_17_2018_0327PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
diff --git a/libs/execution/include/hpx/parallel/executors/post_policy_dispatch.hpp b/libs/execution/include/hpx/execution/executors/post_policy_dispatch.hpp
similarity index 91%
rename from libs/execution/include/hpx/parallel/executors/post_policy_dispatch.hpp
rename to libs/execution/include/hpx/execution/executors/post_policy_dispatch.hpp
index 26ec88aec0..58539e0e06 100644
--- a/libs/execution/include/hpx/parallel/executors/post_policy_dispatch.hpp
+++ b/libs/execution/include/hpx/execution/executors/post_policy_dispatch.hpp
@@ -13,15 +13,15 @@
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/runtime/get_worker_thread_num.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
 #include <cstdint>
 #include <utility>
 
 namespace hpx { namespace parallel { namespace execution { namespace detail {
-    ///////////////////////////////////////////////////////////////////////
+
+    ////////////////////////////////////////////////////////////////////////////
     template <typename Policy>
     struct post_policy_dispatch
     {
@@ -57,13 +57,13 @@ namespace hpx { namespace parallel { namespace execution { namespace detail {
             threads::thread_pool_base* pool, threads::thread_schedule_hint hint,
             F&& f, Ts&&... ts)
         {
+            hint.mode = threads::thread_schedule_hint_mode_thread;
+            hint.hint = static_cast<std::int16_t>(get_worker_thread_num());
             threads::thread_id_type tid = threads::register_thread_nullary(pool,
                 hpx::util::deferred_call(
                     std::forward<F>(f), std::forward<Ts>(ts)...),
                 desc, threads::pending_do_not_schedule, true, policy.priority(),
-                threads::thread_schedule_hint(
-                    static_cast<std::int16_t>(get_worker_thread_num())),
-                threads::thread_stacksize_current);
+                hint, threads::thread_stacksize_current);
             threads::thread_id_type tid_self = threads::get_self_id();
 
             // make sure this thread is executed last
diff --git a/libs/execution/include/hpx/parallel/executors/rebind_executor.hpp b/libs/execution/include/hpx/execution/executors/rebind_executor.hpp
similarity index 95%
rename from libs/execution/include/hpx/parallel/executors/rebind_executor.hpp
rename to libs/execution/include/hpx/execution/executors/rebind_executor.hpp
index 368edbae01..e5d9317952 100644
--- a/libs/execution/include/hpx/parallel/executors/rebind_executor.hpp
+++ b/libs/execution/include/hpx/execution/executors/rebind_executor.hpp
@@ -8,8 +8,8 @@
 #define HPX_PARALLEL_REBIND_EXECUTOR_SEP_07_2016_0658AM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/execution_fwd.hpp>
-#include <hpx/traits/executor_traits.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/type_support/decay.hpp>
 
diff --git a/libs/execution/include/hpx/parallel/executors/sequenced_executor.hpp b/libs/execution/include/hpx/execution/executors/sequenced_executor.hpp
similarity index 98%
rename from libs/execution/include/hpx/parallel/executors/sequenced_executor.hpp
rename to libs/execution/include/hpx/execution/executors/sequenced_executor.hpp
index 5f6326128a..792599594f 100644
--- a/libs/execution/include/hpx/parallel/executors/sequenced_executor.hpp
+++ b/libs/execution/include/hpx/execution/executors/sequenced_executor.hpp
@@ -11,15 +11,15 @@
 
 #include <hpx/config.hpp>
 #include <hpx/async_launch_policy_dispatch.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
 #include <hpx/sync_launch_policy_dispatch.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/util/unwrap.hpp>
 
-#include <hpx/parallel/exception_list.hpp>
+#include <hpx/execution/exception_list.hpp>
 
 #include <cstddef>
 #include <iterator>
diff --git a/libs/execution/include/hpx/parallel/executors/service_executors.hpp b/libs/execution/include/hpx/execution/executors/service_executors.hpp
similarity index 94%
rename from libs/execution/include/hpx/parallel/executors/service_executors.hpp
rename to libs/execution/include/hpx/execution/executors/service_executors.hpp
index dc7a42a586..037ce1c7d7 100644
--- a/libs/execution/include/hpx/parallel/executors/service_executors.hpp
+++ b/libs/execution/include/hpx/execution/executors/service_executors.hpp
@@ -10,11 +10,11 @@
 #define HPX_PARALLEL_EXECUTORS_SERVICE_EXECUTORS_MAY_15_2015_0548PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
 #include <hpx/runtime/threads/executors/service_executors.hpp>
-#include <hpx/traits/executor_traits.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
     /// A \a service_executor exposes one of the predefined HPX thread pools
diff --git a/libs/execution/include/hpx/parallel/executors/static_chunk_size.hpp b/libs/execution/include/hpx/execution/executors/static_chunk_size.hpp
similarity index 93%
rename from libs/execution/include/hpx/parallel/executors/static_chunk_size.hpp
rename to libs/execution/include/hpx/execution/executors/static_chunk_size.hpp
index 2787a64998..b7a50ed550 100644
--- a/libs/execution/include/hpx/parallel/executors/static_chunk_size.hpp
+++ b/libs/execution/include/hpx/execution/executors/static_chunk_size.hpp
@@ -10,10 +10,10 @@
 #define HPX_PARALLEL_STATIC_CHUNK_SIZE_JUL_31_2015_0740PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
 #include <hpx/serialization/serialize.hpp>
-#include <hpx/traits/is_executor_parameters.hpp>
 
-#include <hpx/parallel/executors/execution_parameters_fwd.hpp>
+#include <hpx/execution/executors/execution_parameters_fwd.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -35,7 +35,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///       the number of available cores and the overall number of loop
         ///       iterations to schedule.
         ///
-        HPX_CONSTEXPR static_chunk_size()
+        constexpr static_chunk_size()
           : chunk_size_(0)
         {
         }
@@ -46,7 +46,7 @@ namespace hpx { namespace parallel { namespace execution {
         ///                     number of loop iterations to run on a single
         ///                     thread.
         ///
-        HPX_CONSTEXPR explicit static_chunk_size(std::size_t chunk_size)
+        constexpr explicit static_chunk_size(std::size_t chunk_size)
           : chunk_size_(chunk_size)
         {
         }
diff --git a/libs/execution/include/hpx/parallel/executors/this_thread_executors.hpp b/libs/execution/include/hpx/execution/executors/this_thread_executors.hpp
similarity index 80%
rename from libs/execution/include/hpx/parallel/executors/this_thread_executors.hpp
rename to libs/execution/include/hpx/execution/executors/this_thread_executors.hpp
index f076878d1e..145d1a2b2c 100644
--- a/libs/execution/include/hpx/parallel/executors/this_thread_executors.hpp
+++ b/libs/execution/include/hpx/execution/executors/this_thread_executors.hpp
@@ -8,11 +8,11 @@
 #define HPX_PARALLEL_EXECUTORS_THIS_THREAD_EXECUTORS_JUL_16_2015_0809PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
 #include <hpx/runtime/threads/executors/this_thread_executors.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
diff --git a/libs/execution/include/hpx/parallel/executors/thread_execution.hpp b/libs/execution/include/hpx/execution/executors/thread_execution.hpp
similarity index 96%
rename from libs/execution/include/hpx/parallel/executors/thread_execution.hpp
rename to libs/execution/include/hpx/execution/executors/thread_execution.hpp
index 0cdd256aad..0557b661bc 100644
--- a/libs/execution/include/hpx/parallel/executors/thread_execution.hpp
+++ b/libs/execution/include/hpx/execution/executors/thread_execution.hpp
@@ -14,21 +14,21 @@
 #if !defined(HPX_COMPUTE_DEVICE_CODE)
 #include <hpx/lcos/dataflow.hpp>
 #endif
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/fused_bulk_execute.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/functional/bind_back.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/lcos/local/futures_factory.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/fused_bulk_execute.hpp>
 #include <hpx/runtime/threads/executors/current_executor.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/traits/future_access.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <algorithm>
@@ -217,7 +217,8 @@ namespace hpx { namespace threads {
         shared_state_type p =
             lcos::detail::make_continuation_exec<result_future_type>(
                 std::forward<Future>(predecessor), std::forward<Executor>(exec),
-                [HPX_CAPTURE_MOVE(func), HPX_CAPTURE_MOVE(exec_current)](
+                [func = std::move(func),
+                    exec_current = std::move(exec_current)](
                     future_type&& predecessor) mutable -> result_future_type {
                     return hpx::dataflow(exec_current,
                         hpx::util::functional::unwrap{},
diff --git a/libs/execution/include/hpx/parallel/executors/thread_execution_information.hpp b/libs/execution/include/hpx/execution/executors/thread_execution_information.hpp
similarity index 94%
rename from libs/execution/include/hpx/parallel/executors/thread_execution_information.hpp
rename to libs/execution/include/hpx/execution/executors/thread_execution_information.hpp
index 0021c85dad..e6a2a38455 100644
--- a/libs/execution/include/hpx/parallel/executors/thread_execution_information.hpp
+++ b/libs/execution/include/hpx/execution/executors/thread_execution_information.hpp
@@ -10,12 +10,12 @@
 
 #include <hpx/config.hpp>
 #include <hpx/runtime/get_os_thread_count.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
 #include <hpx/topology/topology.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 
-#include <hpx/parallel/executors/execution_information.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
 
 #include <cstddef>
 #include <type_traits>
diff --git a/libs/execution/include/hpx/parallel/executors/thread_pool_attached_executors.hpp b/libs/execution/include/hpx/execution/executors/thread_pool_attached_executors.hpp
similarity index 85%
rename from libs/execution/include/hpx/parallel/executors/thread_pool_attached_executors.hpp
rename to libs/execution/include/hpx/execution/executors/thread_pool_attached_executors.hpp
index 08e977bebc..56e5c11bb9 100644
--- a/libs/execution/include/hpx/parallel/executors/thread_pool_attached_executors.hpp
+++ b/libs/execution/include/hpx/execution/executors/thread_pool_attached_executors.hpp
@@ -11,10 +11,10 @@
 #define HPX_PARALLEL_EXECUTORS_THREAD_POOL_ATTACHED_EXECUTORS_AUG_28_2015_0511PM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
 #include <hpx/runtime/threads/executors/thread_pool_attached_executors.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
diff --git a/libs/execution/include/hpx/parallel/executors/thread_pool_executor.hpp b/libs/execution/include/hpx/execution/executors/thread_pool_executor.hpp
similarity index 94%
rename from libs/execution/include/hpx/parallel/executors/thread_pool_executor.hpp
rename to libs/execution/include/hpx/execution/executors/thread_pool_executor.hpp
index 6cf1cbb1d1..4e27116532 100644
--- a/libs/execution/include/hpx/parallel/executors/thread_pool_executor.hpp
+++ b/libs/execution/include/hpx/execution/executors/thread_pool_executor.hpp
@@ -14,26 +14,25 @@
 #include <hpx/allocator_support/internal_allocator.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/async_launch_policy_dispatch.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+#include <hpx/execution/executors/fused_bulk_execute.hpp>
+#include <hpx/execution/executors/post_policy_dispatch.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/functional/bind_back.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/one_shot.hpp>
 #include <hpx/iterator_support/range.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/algorithms/detail/predicates.hpp>
-#include <hpx/parallel/executors/fused_bulk_execute.hpp>
-#include <hpx/parallel/executors/post_policy_dispatch.hpp>
-#include <hpx/parallel/executors/static_chunk_size.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/synchronization/latch.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/traits/future_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <algorithm>
@@ -225,7 +224,7 @@ namespace hpx { namespace parallel { namespace execution {
                 lcos::detail::make_continuation_alloc<vector_result_type>(
                     hpx::util::internal_allocator<>{},
                     std::forward<Future>(predecessor), hpx::launch::async,
-                    [HPX_CAPTURE_MOVE(func)](future_type&& predecessor) mutable
+                    [func = std::move(func)](future_type&& predecessor) mutable
                     -> vector_result_type {
                         // use unwrap directly (instead of lazily) to avoid
                         // having to pull in dataflow
diff --git a/libs/execution/include/hpx/parallel/executors/thread_pool_executors.hpp b/libs/execution/include/hpx/execution/executors/thread_pool_executors.hpp
similarity index 92%
rename from libs/execution/include/hpx/parallel/executors/thread_pool_executors.hpp
rename to libs/execution/include/hpx/execution/executors/thread_pool_executors.hpp
index 7f97687cd1..25320105a2 100644
--- a/libs/execution/include/hpx/parallel/executors/thread_pool_executors.hpp
+++ b/libs/execution/include/hpx/execution/executors/thread_pool_executors.hpp
@@ -10,11 +10,11 @@
 #define HPX_PARALLEL_EXECUTORS_THREAD_POOL_EXECUTORS_MAY_15_2015_0548PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
 #include <hpx/runtime/threads/executors/embedded_thread_pool_executors.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
diff --git a/libs/execution/include/hpx/parallel/executors/thread_pool_os_executors.hpp b/libs/execution/include/hpx/execution/executors/thread_pool_os_executors.hpp
similarity index 92%
rename from libs/execution/include/hpx/parallel/executors/thread_pool_os_executors.hpp
rename to libs/execution/include/hpx/execution/executors/thread_pool_os_executors.hpp
index 4d39eb288e..9a399cbe1f 100644
--- a/libs/execution/include/hpx/parallel/executors/thread_pool_os_executors.hpp
+++ b/libs/execution/include/hpx/execution/executors/thread_pool_os_executors.hpp
@@ -10,11 +10,11 @@
 #define HPX_PARALLEL_EXECUTORS_THREAD_POOL_OS_EXECUTORS_AUG_22_2015_0739PM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
 #include <hpx/runtime/threads/executors/thread_pool_os_executors.hpp>
 
 namespace hpx { namespace parallel { namespace execution {
diff --git a/libs/execution/include/hpx/parallel/executors/thread_timed_execution.hpp b/libs/execution/include/hpx/execution/executors/thread_timed_execution.hpp
similarity index 98%
rename from libs/execution/include/hpx/parallel/executors/thread_timed_execution.hpp
rename to libs/execution/include/hpx/execution/executors/thread_timed_execution.hpp
index caa17bddcc..253c217361 100644
--- a/libs/execution/include/hpx/parallel/executors/thread_timed_execution.hpp
+++ b/libs/execution/include/hpx/execution/executors/thread_timed_execution.hpp
@@ -14,7 +14,7 @@
 #include <hpx/timing/steady_clock.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 
-#include <hpx/parallel/executors/timed_execution.hpp>
+#include <hpx/execution/executors/timed_execution.hpp>
 
 #include <type_traits>
 #include <utility>
diff --git a/libs/execution/include/hpx/parallel/executors/timed_execution.hpp b/libs/execution/include/hpx/execution/executors/timed_execution.hpp
similarity index 95%
rename from libs/execution/include/hpx/parallel/executors/timed_execution.hpp
rename to libs/execution/include/hpx/execution/executors/timed_execution.hpp
index 4dd20b5cbe..ad6d2267ef 100644
--- a/libs/execution/include/hpx/parallel/executors/timed_execution.hpp
+++ b/libs/execution/include/hpx/execution/executors/timed_execution.hpp
@@ -9,16 +9,16 @@
 #define HPX_PARALLEL_EXECUTORS_TIMED_EXECUTION_JAN_07_2017_0735AM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/timed_execution_fwd.hpp>
+#include <hpx/execution/executors/timed_execution_fwd.hpp>
 
+#include <hpx/execution/traits/executor_traits.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/traits/executor_traits.hpp>
-#include <hpx/traits/is_executor.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
 
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/timed_executors.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/timed_executors.hpp>
 
 #include <type_traits>
 #include <utility>
diff --git a/libs/execution/include/hpx/parallel/executors/timed_execution_fwd.hpp b/libs/execution/include/hpx/execution/executors/timed_execution_fwd.hpp
similarity index 99%
rename from libs/execution/include/hpx/parallel/executors/timed_execution_fwd.hpp
rename to libs/execution/include/hpx/execution/executors/timed_execution_fwd.hpp
index b7528fa10a..f038bb2a56 100644
--- a/libs/execution/include/hpx/parallel/executors/timed_execution_fwd.hpp
+++ b/libs/execution/include/hpx/execution/executors/timed_execution_fwd.hpp
@@ -11,9 +11,9 @@
 #define HPX_PARALLEL_EXECUTORS_TIMED_EXECUTION_FWD_JAN_07_2017_0720AM
 
 #include <hpx/config.hpp>
-#include <hpx/parallel/executors/execution_fwd.hpp>
-#include <hpx/parallel/executors/timed_executors.hpp>
-#include <hpx/traits/executor_traits.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
+#include <hpx/execution/executors/timed_executors.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
 
 #include <type_traits>
 #include <utility>
diff --git a/libs/execution/include/hpx/parallel/executors/timed_executors.hpp b/libs/execution/include/hpx/execution/executors/timed_executors.hpp
similarity index 97%
rename from libs/execution/include/hpx/parallel/executors/timed_executors.hpp
rename to libs/execution/include/hpx/execution/executors/timed_executors.hpp
index 83e45c1b82..6390e1fa34 100644
--- a/libs/execution/include/hpx/parallel/executors/timed_executors.hpp
+++ b/libs/execution/include/hpx/execution/executors/timed_executors.hpp
@@ -10,19 +10,19 @@
 #define HPX_PARALLEL_TIMED_EXECUTORS_JAN_06_2017_0802AM
 
 #include <hpx/config.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/traits/executor_traits.hpp>
 #include <hpx/traits/is_launch_policy.hpp>
 #include <hpx/type_support/decay.hpp>
 #include <hpx/type_support/detail/wrap_int.hpp>
 
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
-#include <hpx/parallel/executors/sequenced_executor.hpp>
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
+#include <hpx/execution/executors/sequenced_executor.hpp>
 
 #include <chrono>
 #include <functional>
@@ -456,7 +456,7 @@ namespace hpx { namespace parallel { namespace execution {
     /// \endcond
 }}}    // namespace hpx::parallel::execution
 
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
-#include <hpx/parallel/executors/timed_execution.hpp>
+//#include <hpx/execution/executors/thread_timed_execution.hpp>
+//#include <hpx/execution/executors/timed_execution.hpp>
 
 #endif
diff --git a/libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp b/libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_alignment_size.hpp
similarity index 100%
rename from libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_alignment_size.hpp
diff --git a/libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp b/libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_count_bits.hpp
similarity index 100%
rename from libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_count_bits.hpp
diff --git a/libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp b/libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_load_store.hpp
similarity index 100%
rename from libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_load_store.hpp
diff --git a/libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_type.hpp b/libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_type.hpp
similarity index 100%
rename from libs/execution/include/hpx/parallel/traits/detail/vc/vector_pack_type.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/detail/vc/vector_pack_type.hpp
diff --git a/libs/execution/include/hpx/parallel/traits/vector_pack_alignment_size.hpp b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_alignment_size.hpp
similarity index 89%
rename from libs/execution/include/hpx/parallel/traits/vector_pack_alignment_size.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/vector_pack_alignment_size.hpp
index 06c418b5c3..9d5f45ead2 100644
--- a/libs/execution/include/hpx/parallel/traits/vector_pack_alignment_size.hpp
+++ b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_alignment_size.hpp
@@ -10,8 +10,8 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_DATAPAR)
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -44,7 +44,7 @@ namespace hpx { namespace parallel { namespace traits {
     template <typename... Vector>
     struct vector_pack_alignment<hpx::util::tuple<Vector...>,
         typename std::enable_if<
-            hpx::util::detail::all_of<is_vector_pack<Vector>...>::value>::type>
+            hpx::util::all_of<is_vector_pack<Vector>...>::value>::type>
     {
         typedef typename hpx::util::tuple_element<0,
             hpx::util::tuple<Vector...>>::type pack_type;
@@ -60,7 +60,7 @@ namespace hpx { namespace parallel { namespace traits {
     template <typename... Vector>
     struct vector_pack_size<hpx::util::tuple<Vector...>,
         typename std::enable_if<
-            hpx::util::detail::all_of<is_vector_pack<Vector>...>::value>::type>
+            hpx::util::all_of<is_vector_pack<Vector>...>::value>::type>
     {
         typedef typename hpx::util::tuple_element<0,
             hpx::util::tuple<Vector...>>::type pack_type;
@@ -70,7 +70,7 @@ namespace hpx { namespace parallel { namespace traits {
 }}}    // namespace hpx::parallel::traits
 
 #if !defined(__CUDACC__)
-#include <hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_alignment_size.hpp>
 #endif
 
 #endif
diff --git a/libs/execution/include/hpx/parallel/traits/vector_pack_count_bits.hpp b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_count_bits.hpp
similarity index 91%
rename from libs/execution/include/hpx/parallel/traits/vector_pack_count_bits.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/vector_pack_count_bits.hpp
index e9b3a56ff2..0078b41ca1 100644
--- a/libs/execution/include/hpx/parallel/traits/vector_pack_count_bits.hpp
+++ b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_count_bits.hpp
@@ -22,7 +22,7 @@ namespace hpx { namespace parallel { namespace traits {
 #if defined(HPX_HAVE_DATAPAR)
 
 #if !defined(__CUDACC__)
-#include <hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_count_bits.hpp>
 #endif
 
 #endif
diff --git a/libs/execution/include/hpx/parallel/traits/vector_pack_load_store.hpp b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_load_store.hpp
similarity index 93%
rename from libs/execution/include/hpx/parallel/traits/vector_pack_load_store.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/vector_pack_load_store.hpp
index 9f55e2e9a9..939e74bd23 100644
--- a/libs/execution/include/hpx/parallel/traits/vector_pack_load_store.hpp
+++ b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_load_store.hpp
@@ -26,7 +26,7 @@ namespace hpx { namespace parallel { namespace traits {
 }}}    // namespace hpx::parallel::traits
 
 #if !defined(__CUDACC__)
-#include <hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_load_store.hpp>
 #endif
 
 #endif
diff --git a/libs/execution/include/hpx/parallel/traits/vector_pack_type.hpp b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_type.hpp
similarity index 95%
rename from libs/execution/include/hpx/parallel/traits/vector_pack_type.hpp
rename to libs/execution/include/hpx/execution/parallel/traits/vector_pack_type.hpp
index 979c1d6682..b9b2471b6e 100644
--- a/libs/execution/include/hpx/parallel/traits/vector_pack_type.hpp
+++ b/libs/execution/include/hpx/execution/parallel/traits/vector_pack_type.hpp
@@ -38,7 +38,7 @@ namespace hpx { namespace parallel { namespace traits {
 }}}    // namespace hpx::parallel::traits
 
 #if !defined(__CUDACC__)
-#include <hpx/parallel/traits/detail/vc/vector_pack_type.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_type.hpp>
 #endif
 
 #endif
diff --git a/libs/execution/include/hpx/traits/executor_traits.hpp b/libs/execution/include/hpx/execution/traits/executor_traits.hpp
similarity index 100%
rename from libs/execution/include/hpx/traits/executor_traits.hpp
rename to libs/execution/include/hpx/execution/traits/executor_traits.hpp
diff --git a/libs/execution/include/hpx/traits/is_execution_policy.hpp b/libs/execution/include/hpx/execution/traits/is_execution_policy.hpp
similarity index 99%
rename from libs/execution/include/hpx/traits/is_execution_policy.hpp
rename to libs/execution/include/hpx/execution/traits/is_execution_policy.hpp
index 70181ae214..a9c7545c0a 100644
--- a/libs/execution/include/hpx/traits/is_execution_policy.hpp
+++ b/libs/execution/include/hpx/execution/traits/is_execution_policy.hpp
@@ -4,7 +4,7 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-/// \file hpx/traits/is_execution_policy.hpp
+/// \file hpx/execution/traits/is_execution_policy.hpp
 
 #if !defined(HPX_TRAITS_IS_EXECUTION_POLICY_SEP_07_2016_0805AM)
 #define HPX_TRAITS_IS_EXECUTION_POLICY_SEP_07_2016_0805AM
diff --git a/libs/execution/include/hpx/traits/is_executor.hpp b/libs/execution/include/hpx/execution/traits/is_executor.hpp
similarity index 98%
rename from libs/execution/include/hpx/traits/is_executor.hpp
rename to libs/execution/include/hpx/execution/traits/is_executor.hpp
index e2ff00aff3..07f51c7892 100644
--- a/libs/execution/include/hpx/traits/is_executor.hpp
+++ b/libs/execution/include/hpx/execution/traits/is_executor.hpp
@@ -8,7 +8,7 @@
 #define HPX_TRAITS_IS_EXECUTOR_DEC_23_0759PM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <type_traits>
 
@@ -177,7 +177,7 @@ namespace hpx { namespace traits {
     // trait testing for any of the above
     template <typename T, typename Enable = void>
     struct is_executor_any
-      : util::detail::any_of<is_one_way_executor<T>,
+      : util::any_of<is_one_way_executor<T>,
             is_never_blocking_one_way_executor<T>, is_bulk_one_way_executor<T>,
             is_two_way_executor<T>, is_bulk_two_way_executor<T>>
     {
diff --git a/libs/execution/include/hpx/traits/is_executor_parameters.hpp b/libs/execution/include/hpx/execution/traits/is_executor_parameters.hpp
similarity index 92%
rename from libs/execution/include/hpx/traits/is_executor_parameters.hpp
rename to libs/execution/include/hpx/execution/traits/is_executor_parameters.hpp
index 4b00f7942e..1cb06b316a 100644
--- a/libs/execution/include/hpx/traits/is_executor_parameters.hpp
+++ b/libs/execution/include/hpx/execution/traits/is_executor_parameters.hpp
@@ -5,9 +5,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #if !defined(HPX_TRAITS_IS_EXECUTOR_PARAMETERS_MAY_19_2017_0232PM)
 #define HPX_TRAITS_IS_EXECUTOR_PARAMETERS_MAY_19_2017_0232PM
 
@@ -17,8 +14,6 @@
 #include <functional>
 #include <type_traits>
 
-#include <boost/ref.hpp>
-
 namespace hpx { namespace traits {
     // new executor framework
     template <typename Parameters, typename Enable = void>
@@ -88,12 +83,6 @@ namespace hpx { namespace parallel { namespace execution {
           : hpx::traits::is_executor_parameters<T>
         {
         };
-
-        template <typename T>
-        struct is_executor_parameters<::boost::reference_wrapper<T>>
-          : hpx::traits::is_executor_parameters<T>
-        {
-        };
         /// \endcond
     }    // namespace detail
 
diff --git a/libs/execution/include/hpx/traits/is_timed_executor.hpp b/libs/execution/include/hpx/execution/traits/is_timed_executor.hpp
similarity index 97%
rename from libs/execution/include/hpx/traits/is_timed_executor.hpp
rename to libs/execution/include/hpx/execution/traits/is_timed_executor.hpp
index 2792a9322c..8ce220dbef 100644
--- a/libs/execution/include/hpx/traits/is_timed_executor.hpp
+++ b/libs/execution/include/hpx/execution/traits/is_timed_executor.hpp
@@ -8,7 +8,7 @@
 #define HPX_TRAITS_IS_TIMED_EXECUTOR_AUG_05_2015_0840AM
 
 #include <hpx/config.hpp>
-#include <hpx/traits/is_executor.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
 #include <hpx/type_support/decay.hpp>
 
 #include <type_traits>
diff --git a/libs/execution/include/hpx/parallel/execution.hpp b/libs/execution/include/hpx/parallel/execution.hpp
deleted file mode 100644
index 638f3dcfb5..0000000000
--- a/libs/execution/include/hpx/parallel/execution.hpp
+++ /dev/null
@@ -1,19 +0,0 @@
-//  Copyright (c) 2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#if !defined(HPX_PARALLEL_EXECUTION_DEC_25_2106_0102PM)
-#define HPX_PARALLEL_EXECUTION_DEC_25_2106_0102PM
-
-#include <hpx/parallel/executors.hpp>
-#include <hpx/parallel/executors/execution.hpp>
-#include <hpx/parallel/executors/execution_information.hpp>
-#include <hpx/parallel/executors/execution_parameters.hpp>
-#include <hpx/parallel/executors/thread_execution.hpp>
-#include <hpx/parallel/executors/thread_execution_information.hpp>
-#include <hpx/parallel/executors/thread_timed_execution.hpp>
-#include <hpx/parallel/executors/timed_execution.hpp>
-
-#endif
diff --git a/libs/execution/include/hpx/parallel/executors.hpp b/libs/execution/include/hpx/parallel/executors.hpp
deleted file mode 100644
index 678b2206f8..0000000000
--- a/libs/execution/include/hpx/parallel/executors.hpp
+++ /dev/null
@@ -1,26 +0,0 @@
-//  Copyright (c) 2007-2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#if !defined(HPX_PARALLEL_EXECUTORS_MAY_11_2015_0728PM)
-#define HPX_PARALLEL_EXECUTORS_MAY_11_2015_0728PM
-
-#include <hpx/config.hpp>
-
-#include <hpx/parallel/executors/default_executor.hpp>
-#include <hpx/parallel/executors/distribution_policy_executor.hpp>
-#include <hpx/parallel/executors/parallel_executor.hpp>
-#include <hpx/parallel/executors/parallel_executor_aggregated.hpp>
-#include <hpx/parallel/executors/pool_executor.hpp>
-#include <hpx/parallel/executors/sequenced_executor.hpp>
-#include <hpx/parallel/executors/service_executors.hpp>
-#include <hpx/parallel/executors/this_thread_executors.hpp>
-#include <hpx/parallel/executors/thread_pool_attached_executors.hpp>
-#include <hpx/parallel/executors/thread_pool_executor.hpp>
-#include <hpx/parallel/executors/thread_pool_executors.hpp>
-#include <hpx/parallel/executors/thread_pool_os_executors.hpp>
-#include <hpx/parallel/executors/timed_executors.hpp>
-
-#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/algorithms/detail/is_negative.hpp b/libs/execution/include_compatibility/hpx/parallel/algorithms/detail/is_negative.hpp
new file mode 100644
index 0000000000..939613362a
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/algorithms/detail/is_negative.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/algorithms/detail/is_negative.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/algorithms/detail/is_negative.hpp is deprecated, \
+    please include hpx/execution/algorithms/detail/is_negative.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/algorithms/detail/is_negative.hpp is deprecated, \
+    please include hpx/execution/algorithms/detail/is_negative.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/algorithms/detail/predicates.hpp b/libs/execution/include_compatibility/hpx/parallel/algorithms/detail/predicates.hpp
new file mode 100644
index 0000000000..c31b2b2cbd
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/algorithms/detail/predicates.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/algorithms/detail/predicates.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/algorithms/detail/predicates.hpp is deprecated, \
+    please include hpx/execution/algorithms/detail/predicates.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/algorithms/detail/predicates.hpp is deprecated, \
+    please include hpx/execution/algorithms/detail/predicates.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/datapar/execution_policy.hpp b/libs/execution/include_compatibility/hpx/parallel/datapar/execution_policy.hpp
new file mode 100644
index 0000000000..eb944230c5
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/datapar/execution_policy.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/datapar/execution_policy.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/datapar/execution_policy.hpp is deprecated, \
+    please include hpx/execution/datapar/execution_policy.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/datapar/execution_policy.hpp is deprecated, \
+    please include hpx/execution/datapar/execution_policy.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/datapar/execution_policy_fwd.hpp b/libs/execution/include_compatibility/hpx/parallel/datapar/execution_policy_fwd.hpp
new file mode 100644
index 0000000000..a4a8bd8742
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/datapar/execution_policy_fwd.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/datapar/execution_policy_fwd.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/datapar/execution_policy_fwd.hpp is deprecated, \
+    please include hpx/execution/datapar/execution_policy_fwd.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/datapar/execution_policy_fwd.hpp is deprecated, \
+    please include hpx/execution/datapar/execution_policy_fwd.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/exception_list.hpp b/libs/execution/include_compatibility/hpx/parallel/exception_list.hpp
new file mode 100644
index 0000000000..b58d7bd35f
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/exception_list.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/exception_list.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/parallel/exception_list.hpp is deprecated, \
+    please include hpx/execution/exception_list.hpp instead")
+#else
+#warning "The header hpx/parallel/exception_list.hpp is deprecated, \
+    please include hpx/execution/exception_list.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/execution.hpp b/libs/execution/include_compatibility/hpx/parallel/execution.hpp
new file mode 100644
index 0000000000..b4e6d10fe8
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/execution.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/execution.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/parallel/execution.hpp is deprecated, \
+    please include hpx/execution/execution.hpp instead")
+#else
+#warning "The header hpx/parallel/execution.hpp is deprecated, \
+    please include hpx/execution/execution.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/execution_policy.hpp b/libs/execution/include_compatibility/hpx/parallel/execution_policy.hpp
new file mode 100644
index 0000000000..263365e088
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/execution_policy.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/execution_policy.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/parallel/execution_policy.hpp is deprecated, \
+    please include hpx/execution/execution_policy.hpp instead")
+#else
+#warning "The header hpx/parallel/execution_policy.hpp is deprecated, \
+    please include hpx/execution/execution_policy.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/execution_policy_fwd.hpp b/libs/execution/include_compatibility/hpx/parallel/execution_policy_fwd.hpp
new file mode 100644
index 0000000000..a3729c7d0b
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/execution_policy_fwd.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/execution_policy_fwd.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/execution_policy_fwd.hpp is deprecated, \
+    please include hpx/execution/execution_policy_fwd.hpp instead")
+#else
+#warning "The header hpx/parallel/execution_policy_fwd.hpp is deprecated, \
+    please include hpx/execution/execution_policy_fwd.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executor_parameters.hpp b/libs/execution/include_compatibility/hpx/parallel/executor_parameters.hpp
new file mode 100644
index 0000000000..3f5484f988
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executor_parameters.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executor_parameters.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executor_parameters.hpp is deprecated, \
+    please include hpx/execution/executor_parameters.hpp instead")
+#else
+#warning "The header hpx/parallel/executor_parameters.hpp is deprecated, \
+    please include hpx/execution/executor_parameters.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors.hpp b/libs/execution/include_compatibility/hpx/parallel/executors.hpp
new file mode 100644
index 0000000000..952428cc57
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/parallel/executors.hpp is deprecated, \
+    please include hpx/execution/executors.hpp instead")
+#else
+#warning "The header hpx/parallel/executors.hpp is deprecated, \
+    please include hpx/execution/executors.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/auto_chunk_size.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/auto_chunk_size.hpp
new file mode 100644
index 0000000000..380928adf9
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/auto_chunk_size.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/auto_chunk_size.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/auto_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/auto_chunk_size.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/auto_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/auto_chunk_size.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/default_executor.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/default_executor.hpp
new file mode 100644
index 0000000000..7fe22aa955
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/default_executor.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/default_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/default_executor.hpp is deprecated, \
+    please include hpx/execution/executors/default_executor.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/default_executor.hpp is deprecated, \
+    please include hpx/execution/executors/default_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/distribution_policy_executor.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/distribution_policy_executor.hpp
new file mode 100644
index 0000000000..420cee7ed1
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/distribution_policy_executor.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/distribution_policy_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/distribution_policy_executor.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/distribution_policy_executor.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/distribution_policy_executor.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/distribution_policy_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/dynamic_chunk_size.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/dynamic_chunk_size.hpp
new file mode 100644
index 0000000000..439268ec9f
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/dynamic_chunk_size.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/dynamic_chunk_size.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/dynamic_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/dynamic_chunk_size.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/dynamic_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/dynamic_chunk_size.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/execution.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/execution.hpp
new file mode 100644
index 0000000000..1884f0dbb0
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/execution.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/execution.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/execution.hpp is deprecated, \
+    please include hpx/execution/executors/execution.hpp instead")
+#else
+#warning "The header hpx/parallel/executors/execution.hpp is deprecated, \
+    please include hpx/execution/executors/execution.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/execution_fwd.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/execution_fwd.hpp
new file mode 100644
index 0000000000..24e08402b9
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/execution_fwd.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/execution_fwd.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/execution_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/execution_fwd.hpp instead")
+#else
+#warning "The header hpx/parallel/executors/execution_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/execution_fwd.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/execution_information.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/execution_information.hpp
new file mode 100644
index 0000000000..a29ce8237e
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/execution_information.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/execution_information.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/execution_information.hpp is deprecated, \
+    please include hpx/execution/executors/execution_information.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/execution_information.hpp is deprecated, \
+    please include hpx/execution/executors/execution_information.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/execution_information_fwd.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/execution_information_fwd.hpp
new file mode 100644
index 0000000000..fb34a658e1
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/execution_information_fwd.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/execution_information_fwd.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/execution_information_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/execution_information_fwd.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/execution_information_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/execution_information_fwd.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/execution_parameters.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/execution_parameters.hpp
new file mode 100644
index 0000000000..add21afe21
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/execution_parameters.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/execution_parameters.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/execution_parameters.hpp is deprecated, \
+    please include hpx/execution/executors/execution_parameters.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/execution_parameters.hpp is deprecated, \
+    please include hpx/execution/executors/execution_parameters.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/execution_parameters_fwd.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/execution_parameters_fwd.hpp
new file mode 100644
index 0000000000..0094235ca4
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/execution_parameters_fwd.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/execution_parameters_fwd.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/execution_parameters_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/execution_parameters_fwd.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/execution_parameters_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/execution_parameters_fwd.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/fused_bulk_execute.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/fused_bulk_execute.hpp
new file mode 100644
index 0000000000..21a6aa2b7c
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/fused_bulk_execute.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/fused_bulk_execute.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/fused_bulk_execute.hpp is deprecated, \
+    please include hpx/execution/executors/fused_bulk_execute.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/fused_bulk_execute.hpp is deprecated, \
+    please include hpx/execution/executors/fused_bulk_execute.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/guided_chunk_size.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/guided_chunk_size.hpp
new file mode 100644
index 0000000000..f2ea76be65
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/guided_chunk_size.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/guided_chunk_size.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/guided_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/guided_chunk_size.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/guided_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/guided_chunk_size.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/parallel_executor.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/parallel_executor.hpp
new file mode 100644
index 0000000000..70fda79bb7
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/parallel_executor.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/parallel_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/parallel_executor.hpp is deprecated, \
+    please include hpx/execution/executors/parallel_executor.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/parallel_executor.hpp is deprecated, \
+    please include hpx/execution/executors/parallel_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/parallel_executor_aggregated.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/parallel_executor_aggregated.hpp
new file mode 100644
index 0000000000..895e40f1ca
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/parallel_executor_aggregated.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/parallel_executor_aggregated.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/parallel_executor_aggregated.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/parallel_executor_aggregated.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/parallel_executor_aggregated.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/parallel_executor_aggregated.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/persistent_auto_chunk_size.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/persistent_auto_chunk_size.hpp
new file mode 100644
index 0000000000..830ebebba2
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/persistent_auto_chunk_size.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/persistent_auto_chunk_size.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/persistent_auto_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/persistent_auto_chunk_size.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/persistent_auto_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/persistent_auto_chunk_size.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/pool_executor.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/pool_executor.hpp
new file mode 100644
index 0000000000..b806451e1c
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/pool_executor.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/pool_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/pool_executor.hpp is deprecated, \
+    please include hpx/execution/executors/pool_executor.hpp instead")
+#else
+#warning "The header hpx/parallel/executors/pool_executor.hpp is deprecated, \
+    please include hpx/execution/executors/pool_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/post_policy_dispatch.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/post_policy_dispatch.hpp
new file mode 100644
index 0000000000..76f05403cb
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/post_policy_dispatch.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/post_policy_dispatch.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/post_policy_dispatch.hpp is deprecated, \
+    please include hpx/execution/executors/post_policy_dispatch.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/post_policy_dispatch.hpp is deprecated, \
+    please include hpx/execution/executors/post_policy_dispatch.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/rebind_executor.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/rebind_executor.hpp
new file mode 100644
index 0000000000..c3d4646c0d
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/rebind_executor.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/rebind_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/rebind_executor.hpp is deprecated, \
+    please include hpx/execution/executors/rebind_executor.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/rebind_executor.hpp is deprecated, \
+    please include hpx/execution/executors/rebind_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/sequenced_executor.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/sequenced_executor.hpp
new file mode 100644
index 0000000000..ff882a14a5
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/sequenced_executor.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/sequenced_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/sequenced_executor.hpp is deprecated, \
+    please include hpx/execution/executors/sequenced_executor.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/sequenced_executor.hpp is deprecated, \
+    please include hpx/execution/executors/sequenced_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/service_executors.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/service_executors.hpp
new file mode 100644
index 0000000000..6106fbe58e
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/service_executors.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/service_executors.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/service_executors.hpp is deprecated, \
+    please include hpx/execution/executors/service_executors.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/service_executors.hpp is deprecated, \
+    please include hpx/execution/executors/service_executors.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/static_chunk_size.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/static_chunk_size.hpp
new file mode 100644
index 0000000000..07c8791129
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/static_chunk_size.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/static_chunk_size.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/static_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/static_chunk_size.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/static_chunk_size.hpp is deprecated, \
+    please include hpx/execution/executors/static_chunk_size.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/this_thread_executors.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/this_thread_executors.hpp
new file mode 100644
index 0000000000..61563cb5c1
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/this_thread_executors.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/this_thread_executors.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/this_thread_executors.hpp is deprecated, \
+    please include hpx/execution/executors/this_thread_executors.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/this_thread_executors.hpp is deprecated, \
+    please include hpx/execution/executors/this_thread_executors.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/thread_execution.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/thread_execution.hpp
new file mode 100644
index 0000000000..315cc2d801
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/thread_execution.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/thread_execution.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/thread_execution.hpp is deprecated, \
+    please include hpx/execution/executors/thread_execution.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/thread_execution.hpp is deprecated, \
+    please include hpx/execution/executors/thread_execution.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/thread_execution_information.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/thread_execution_information.hpp
new file mode 100644
index 0000000000..8f2cd5dac2
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/thread_execution_information.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/thread_execution_information.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/thread_execution_information.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/thread_execution_information.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/thread_execution_information.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/thread_execution_information.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_attached_executors.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_attached_executors.hpp
new file mode 100644
index 0000000000..9b2c009af6
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_attached_executors.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/thread_pool_attached_executors.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/thread_pool_attached_executors.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/thread_pool_attached_executors.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/thread_pool_attached_executors.hpp is \
+    deprecated, please include \
+    hpx/execution/executors/thread_pool_attached_executors.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_executor.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_executor.hpp
new file mode 100644
index 0000000000..adee99d7aa
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_executor.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/thread_pool_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/thread_pool_executor.hpp is deprecated, \
+    please include hpx/execution/executors/thread_pool_executor.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/thread_pool_executor.hpp is deprecated, \
+    please include hpx/execution/executors/thread_pool_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_executors.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_executors.hpp
new file mode 100644
index 0000000000..8b1d23b731
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_executors.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/thread_pool_executors.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/thread_pool_executors.hpp is deprecated, \
+    please include hpx/execution/executors/thread_pool_executors.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/thread_pool_executors.hpp is deprecated, \
+    please include hpx/execution/executors/thread_pool_executors.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_os_executors.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_os_executors.hpp
new file mode 100644
index 0000000000..483b0bf48a
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/thread_pool_os_executors.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/thread_pool_os_executors.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/thread_pool_os_executors.hpp is deprecated, \
+    please include hpx/execution/executors/thread_pool_os_executors.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/thread_pool_os_executors.hpp is deprecated, \
+    please include hpx/execution/executors/thread_pool_os_executors.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/thread_timed_execution.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/thread_timed_execution.hpp
new file mode 100644
index 0000000000..e66af3ad07
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/thread_timed_execution.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/thread_timed_execution.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/thread_timed_execution.hpp is deprecated, \
+    please include hpx/execution/executors/thread_timed_execution.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/thread_timed_execution.hpp is deprecated, \
+    please include hpx/execution/executors/thread_timed_execution.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/timed_execution.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/timed_execution.hpp
new file mode 100644
index 0000000000..1d5dc2679b
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/timed_execution.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/timed_execution.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/timed_execution.hpp is deprecated, \
+    please include hpx/execution/executors/timed_execution.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/timed_execution.hpp is deprecated, \
+    please include hpx/execution/executors/timed_execution.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/timed_execution_fwd.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/timed_execution_fwd.hpp
new file mode 100644
index 0000000000..bf975125a9
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/timed_execution_fwd.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/timed_execution_fwd.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/timed_execution_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/timed_execution_fwd.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/timed_execution_fwd.hpp is deprecated, \
+    please include hpx/execution/executors/timed_execution_fwd.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/executors/timed_executors.hpp b/libs/execution/include_compatibility/hpx/parallel/executors/timed_executors.hpp
new file mode 100644
index 0000000000..2ea48ad541
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/executors/timed_executors.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/executors/timed_executors.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/executors/timed_executors.hpp is deprecated, \
+    please include hpx/execution/executors/timed_executors.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/executors/timed_executors.hpp is deprecated, \
+    please include hpx/execution/executors/timed_executors.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp
new file mode 100644
index 0000000000..2f4e1ced15
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp
@@ -0,0 +1,25 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_alignment_size.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp \
+    is deprecated, please include \
+    hpx/execution/parallel/traits/detail/vc/vector_pack_alignment_size.hpp \
+    instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_alignment_size.hpp \
+    is deprecated, please include \
+    hpx/execution/parallel/traits/detail/vc/vector_pack_alignment_size.hpp \
+    instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp
new file mode 100644
index 0000000000..7d87a5d4f7
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_count_bits.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp is \
+    deprecated, please include \
+    hpx/execution/parallel/traits/detail/vc/vector_pack_count_bits.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_count_bits.hpp is \
+    deprecated, please include \
+    hpx/execution/parallel/traits/detail/vc/vector_pack_count_bits.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp
new file mode 100644
index 0000000000..6ade06bedb
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_load_store.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/detail/vc/vector_pack_load_store.hpp \
+    instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_load_store.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/detail/vc/vector_pack_load_store.hpp \
+    instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_type.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_type.hpp
new file mode 100644
index 0000000000..521789f550
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/detail/vc/vector_pack_type.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/detail/vc/vector_pack_type.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_type.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/detail/vc/vector_pack_type.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/traits/detail/vc/vector_pack_type.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/detail/vc/vector_pack_type.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_alignment_size.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_alignment_size.hpp
new file mode 100644
index 0000000000..d96a98fbfa
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_alignment_size.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_alignment_size.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/vector_pack_alignment_size.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_alignment_size.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/traits/vector_pack_alignment_size.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_alignment_size.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_count_bits.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_count_bits.hpp
new file mode 100644
index 0000000000..db79041866
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_count_bits.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_count_bits.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/vector_pack_count_bits.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_count_bits.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/traits/vector_pack_count_bits.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_count_bits.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_load_store.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_load_store.hpp
new file mode 100644
index 0000000000..2e2f59c567
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_load_store.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_load_store.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/vector_pack_load_store.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_load_store.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/parallel/traits/vector_pack_load_store.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_load_store.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_type.hpp b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_type.hpp
new file mode 100644
index 0000000000..0c183d92d7
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/parallel/traits/vector_pack_type.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/parallel/traits/vector_pack_type.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/parallel/traits/vector_pack_type.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_type.hpp instead")
+#else
+#warning "The header hpx/parallel/traits/vector_pack_type.hpp is deprecated, \
+    please include hpx/execution/parallel/traits/vector_pack_type.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/traits/executor_traits.hpp b/libs/execution/include_compatibility/hpx/traits/executor_traits.hpp
new file mode 100644
index 0000000000..e4295bf6b7
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/traits/executor_traits.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/traits/executor_traits.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/traits/executor_traits.hpp is deprecated, \
+    please include hpx/execution/traits/executor_traits.hpp instead")
+#else
+#warning "The header hpx/traits/executor_traits.hpp is deprecated, \
+    please include hpx/execution/traits/executor_traits.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/traits/is_execution_policy.hpp b/libs/execution/include_compatibility/hpx/traits/is_execution_policy.hpp
new file mode 100644
index 0000000000..09d08df440
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/traits/is_execution_policy.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/traits/is_execution_policy.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/traits/is_execution_policy.hpp is deprecated, \
+    please include hpx/execution/traits/is_execution_policy.hpp instead")
+#else
+#warning "The header hpx/traits/is_execution_policy.hpp is deprecated, \
+    please include hpx/execution/traits/is_execution_policy.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/traits/is_executor.hpp b/libs/execution/include_compatibility/hpx/traits/is_executor.hpp
new file mode 100644
index 0000000000..b22eadca10
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/traits/is_executor.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/traits/is_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/traits/is_executor.hpp is deprecated, \
+    please include hpx/execution/traits/is_executor.hpp instead")
+#else
+#warning "The header hpx/traits/is_executor.hpp is deprecated, \
+    please include hpx/execution/traits/is_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/traits/is_executor_parameters.hpp b/libs/execution/include_compatibility/hpx/traits/is_executor_parameters.hpp
new file mode 100644
index 0000000000..a0c46bb475
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/traits/is_executor_parameters.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/traits/is_executor_parameters.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/traits/is_executor_parameters.hpp is deprecated, \
+    please include hpx/execution/traits/is_executor_parameters.hpp instead")
+#else
+#warning "The header hpx/traits/is_executor_parameters.hpp is deprecated, \
+    please include hpx/execution/traits/is_executor_parameters.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/include_compatibility/hpx/traits/is_timed_executor.hpp b/libs/execution/include_compatibility/hpx/traits/is_timed_executor.hpp
new file mode 100644
index 0000000000..2195a88956
--- /dev/null
+++ b/libs/execution/include_compatibility/hpx/traits/is_timed_executor.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/execution/config/defines.hpp>
+#include <hpx/execution/traits/is_timed_executor.hpp>
+
+#if defined(HPX_EXECUTION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/traits/is_timed_executor.hpp is deprecated, \
+    please include hpx/execution/traits/is_timed_executor.hpp instead")
+#else
+#warning "The header hpx/traits/is_timed_executor.hpp is deprecated, \
+    please include hpx/execution/traits/is_timed_executor.hpp instead"
+#endif
+#endif
diff --git a/libs/execution/tests/regressions/annotated_minmax_2593.cpp b/libs/execution/tests/regressions/annotated_minmax_2593.cpp
index f0e29a7466..c60e7e3dcc 100644
--- a/libs/execution/tests/regressions/annotated_minmax_2593.cpp
+++ b/libs/execution/tests/regressions/annotated_minmax_2593.cpp
@@ -4,10 +4,10 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/execution/executor_parameters.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/parallel/algorithms/minmax.hpp>
-#include <hpx/parallel/executor_parameters.hpp>
 #include <hpx/testing.hpp>
 
 #include <vector>
diff --git a/libs/execution/tests/regressions/chunk_size_4118.cpp b/libs/execution/tests/regressions/chunk_size_4118.cpp
index 73c15a3827..7ff35cc9db 100644
--- a/libs/execution/tests/regressions/chunk_size_4118.cpp
+++ b/libs/execution/tests/regressions/chunk_size_4118.cpp
@@ -18,7 +18,7 @@ int main(int argc, char* argv[])
     std::vector<std::string> const cfg = {"hpx.os_threads=2"};
 
     // Initialize and run HPX
-    HPX_TEST(hpx::init(argc, argv, cfg) == 0);
+    HPX_TEST_EQ(hpx::init(argc, argv, cfg), 0);
 
     return hpx::util::report_errors();
 }
diff --git a/libs/execution/tests/unit/bulk_async.cpp b/libs/execution/tests/unit/bulk_async.cpp
index ab391bbbc5..5a38bb5137 100644
--- a/libs/execution/tests/unit/bulk_async.cpp
+++ b/libs/execution/tests/unit/bulk_async.cpp
@@ -21,7 +21,7 @@
 int bulk_test(
     hpx::thread::id tid, int value, bool is_par, int passed_through)    //-V813
 {
-    HPX_TEST(is_par == (tid != hpx::this_thread::get_id()));
+    HPX_TEST_EQ(is_par, (tid != hpx::this_thread::get_id()));
     HPX_TEST_EQ(passed_through, 42);
     return value;
 }
diff --git a/libs/execution/tests/unit/created_executor.cpp b/libs/execution/tests/unit/created_executor.cpp
index 4cb3146ace..a1205db081 100644
--- a/libs/execution/tests/unit/created_executor.cpp
+++ b/libs/execution/tests/unit/created_executor.cpp
@@ -69,7 +69,7 @@ namespace hpx { namespace parallel { namespace execution {
 
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -200,8 +200,8 @@ void sum_test()
     hpx::future<int> f_void_par = hpx::parallel::execution::async_execute(
         exec, &void_parallel_sum, std::begin(vec), std::end(vec), num_parts);
 
-    HPX_TEST(f_par.get() == sum);
-    HPX_TEST(f_void_par.get() == sum);
+    HPX_TEST_EQ(f_par.get(), sum);
+    HPX_TEST_EQ(f_void_par.get(), sum);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/libs/execution/tests/unit/executor_parameters.cpp b/libs/execution/tests/unit/executor_parameters.cpp
index ce0104305d..f49de27966 100644
--- a/libs/execution/tests/unit/executor_parameters.cpp
+++ b/libs/execution/tests/unit/executor_parameters.cpp
@@ -4,9 +4,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/parallel_executor_parameters.hpp>
@@ -24,8 +21,6 @@
 #include <utility>
 #include <vector>
 
-#include <boost/ref.hpp>
-
 #include "foreach_tests.hpp"
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -59,7 +54,6 @@ template <typename... Parameters>
 void parameters_test(Parameters&&... params)
 {
     parameters_test_impl(std::ref(params)...);
-    parameters_test_impl(boost::ref(params)...);
     parameters_test_impl(std::forward<Parameters>(params)...);
 }
 
diff --git a/libs/execution/tests/unit/foreach_tests.hpp b/libs/execution/tests/unit/foreach_tests.hpp
index 4c479df582..4c2688e926 100644
--- a/libs/execution/tests/unit/foreach_tests.hpp
+++ b/libs/execution/tests/unit/foreach_tests.hpp
@@ -278,7 +278,7 @@ void test_for_each_n_async(ExPolicy p, IteratorTag)
 
     hpx::future<iterator> f = hpx::parallel::for_each_n(
         p, iterator(std::begin(c)), c.size(), set_42());
-    HPX_TEST(f.get() == iterator(std::end(c)));
+    HPX_TEST_EQ(f.get(), iterator(std::end(c)));
 
     // verify values
     std::size_t count = 0;
diff --git a/libs/execution/tests/unit/minimal_async_executor.cpp b/libs/execution/tests/unit/minimal_async_executor.cpp
index 8dd4ffe865..c7043b4230 100644
--- a/libs/execution/tests/unit/minimal_async_executor.cpp
+++ b/libs/execution/tests/unit/minimal_async_executor.cpp
@@ -40,7 +40,7 @@ void apply_test(
 void async_bulk_test(
     int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -55,7 +55,7 @@ void test_apply(Executor& exec)
         exec, &apply_test, std::ref(l), std::ref(id), 42);
     l.count_down_and_wait();
 
-    HPX_TEST(id != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(id, hpx::this_thread::get_id());
 }
 
 template <typename Executor>
diff --git a/libs/execution/tests/unit/minimal_sync_executor.cpp b/libs/execution/tests/unit/minimal_sync_executor.cpp
index d61e078e13..26ca379452 100644
--- a/libs/execution/tests/unit/minimal_sync_executor.cpp
+++ b/libs/execution/tests/unit/minimal_sync_executor.cpp
@@ -44,7 +44,7 @@ hpx::thread::id sync_bulk_test(int value, hpx::thread::id tid,
 void sync_bulk_test_void(
     int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid == hpx::this_thread::get_id());
+    HPX_TEST_EQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -74,7 +74,7 @@ hpx::thread::id then_bulk_test(int value, hpx::shared_future<void> f,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid == hpx::this_thread::get_id());
+    HPX_TEST_EQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 
     return hpx::this_thread::get_id();
@@ -87,7 +87,7 @@ void then_bulk_test_void(int value, hpx::shared_future<void> f,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid == hpx::this_thread::get_id());
+    HPX_TEST_EQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -138,14 +138,14 @@ void test_bulk_sync(Executor& exec)
             exec, hpx::util::bind(&sync_bulk_test, _1, tid, _2), v, 42);
     for (auto const& id : ids)
     {
-        HPX_TEST(id == hpx::this_thread::get_id());
+        HPX_TEST_EQ(id, hpx::this_thread::get_id());
     }
 
     ids = hpx::parallel::execution::bulk_sync_execute(
         exec, &sync_bulk_test, v, tid, 42);
     for (auto const& id : ids)
     {
-        HPX_TEST(id == hpx::this_thread::get_id());
+        HPX_TEST_EQ(id, hpx::this_thread::get_id());
     }
 
     hpx::parallel::execution::bulk_sync_execute(
@@ -199,7 +199,7 @@ void test_bulk_then(Executor& exec)
 
     for (auto const& tid : tids)
     {
-        HPX_TEST(tid == hpx::this_thread::get_id());
+        HPX_TEST_EQ(tid, hpx::this_thread::get_id());
     }
 
     hpx::parallel::execution::bulk_then_execute(
diff --git a/libs/execution/tests/unit/minimal_timed_async_executor.cpp b/libs/execution/tests/unit/minimal_timed_async_executor.cpp
index f4f03b3670..3dc7231bc8 100644
--- a/libs/execution/tests/unit/minimal_timed_async_executor.cpp
+++ b/libs/execution/tests/unit/minimal_timed_async_executor.cpp
@@ -55,7 +55,7 @@ void test_timed_apply(Executor& exec)
 
         l.count_down_and_wait();
 
-        HPX_TEST(id != hpx::this_thread::get_id());
+        HPX_TEST_NEQ(id, hpx::this_thread::get_id());
     }
 
     {
@@ -70,7 +70,7 @@ void test_timed_apply(Executor& exec)
 
         l.count_down_and_wait();
 
-        HPX_TEST(id != hpx::this_thread::get_id());
+        HPX_TEST_NEQ(id, hpx::this_thread::get_id());
     }
 }
 
diff --git a/libs/execution/tests/unit/minimal_timed_sync_executor.cpp b/libs/execution/tests/unit/minimal_timed_sync_executor.cpp
index d11722fdc2..8996f5dd3b 100644
--- a/libs/execution/tests/unit/minimal_timed_sync_executor.cpp
+++ b/libs/execution/tests/unit/minimal_timed_sync_executor.cpp
@@ -55,7 +55,7 @@ void test_timed_apply(Executor& exec)
 
         l.count_down_and_wait();
 
-        HPX_TEST(id == hpx::this_thread::get_id());
+        HPX_TEST_EQ(id, hpx::this_thread::get_id());
     }
 
     {
@@ -70,7 +70,7 @@ void test_timed_apply(Executor& exec)
 
         l.count_down_and_wait();
 
-        HPX_TEST(id == hpx::this_thread::get_id());
+        HPX_TEST_EQ(id, hpx::this_thread::get_id());
     }
 }
 
diff --git a/libs/execution/tests/unit/parallel_executor.cpp b/libs/execution/tests/unit/parallel_executor.cpp
index a4707a7cca..6f0a88ccf2 100644
--- a/libs/execution/tests/unit/parallel_executor.cpp
+++ b/libs/execution/tests/unit/parallel_executor.cpp
@@ -67,7 +67,7 @@ void test_then()
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -119,7 +119,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/parallel_fork_executor.cpp b/libs/execution/tests/unit/parallel_fork_executor.cpp
index 73bd425364..58b9b8ef1a 100644
--- a/libs/execution/tests/unit/parallel_fork_executor.cpp
+++ b/libs/execution/tests/unit/parallel_fork_executor.cpp
@@ -67,7 +67,7 @@ void test_then()
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -118,7 +118,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/parallel_policy_executor.cpp b/libs/execution/tests/unit/parallel_policy_executor.cpp
index acf70949f0..22662976c1 100644
--- a/libs/execution/tests/unit/parallel_policy_executor.cpp
+++ b/libs/execution/tests/unit/parallel_policy_executor.cpp
@@ -32,7 +32,7 @@ void test_sync(bool sync)
     bool result = hpx::parallel::execution::sync_execute(exec, &test, 42) ==
         hpx::this_thread::get_id();
 
-    HPX_TEST(sync == result);
+    HPX_TEST_EQ(sync, result);
 }
 
 template <typename Policy>
@@ -45,7 +45,7 @@ void test_async(bool sync)
         hpx::parallel::execution::async_execute(exec, &test, 42).get() ==
         hpx::this_thread::get_id();
 
-    HPX_TEST(sync == result);
+    HPX_TEST_EQ(sync, result);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -71,19 +71,19 @@ void test_then(bool sync)
         hpx::parallel::execution::then_execute(exec, &test_f, f, 42).get() ==
         hpx::this_thread::get_id();
 
-    HPX_TEST(sync == result);
+    HPX_TEST_EQ(sync, result);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test_s(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid == hpx::this_thread::get_id());
+    HPX_TEST_EQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
 void bulk_test_a(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -141,7 +141,7 @@ void bulk_test_f_s(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid == hpx::this_thread::get_id());
+    HPX_TEST_EQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -152,7 +152,7 @@ void bulk_test_f_a(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/service_executors.cpp b/libs/execution/tests/unit/service_executors.cpp
index 47e23b98df..6d9f39f7ef 100644
--- a/libs/execution/tests/unit/service_executors.cpp
+++ b/libs/execution/tests/unit/service_executors.cpp
@@ -4,9 +4,9 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/execution/executors/service_executors.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/parallel/executors/service_executors.hpp>
 #include <hpx/testing.hpp>
 
 #include <algorithm>
@@ -61,7 +61,7 @@ void test_then(Executor& exec)
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, std::thread::id tid, int passed_through)
 {
-    HPX_TEST(tid != std::this_thread::get_id());
+    HPX_TEST_NEQ(tid, std::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -108,7 +108,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/shared_parallel_executor.cpp b/libs/execution/tests/unit/shared_parallel_executor.cpp
index c31bec398b..af250ea781 100644
--- a/libs/execution/tests/unit/shared_parallel_executor.cpp
+++ b/libs/execution/tests/unit/shared_parallel_executor.cpp
@@ -61,13 +61,13 @@ void test_async()
     hpx::shared_future<hpx::thread::id> fut =
         hpx::parallel::execution::async_execute(exec, &test, 42);
 
-    HPX_TEST(fut.get() != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(fut.get(), hpx::this_thread::get_id());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/standalone_thread_pool_executor.cpp b/libs/execution/tests/unit/standalone_thread_pool_executor.cpp
index 26d5cf4815..1f93f99e1a 100644
--- a/libs/execution/tests/unit/standalone_thread_pool_executor.cpp
+++ b/libs/execution/tests/unit/standalone_thread_pool_executor.cpp
@@ -11,13 +11,13 @@
 // runtime*. This test fails if thread pools, schedulers etc. assume that the
 // global runtime (configuration, thread manager, etc.) always exists.
 
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/include/apply.hpp>
 #include <hpx/include/async.hpp>
 #include <hpx/include/lcos.hpp>
 #include <hpx/include/parallel_executors.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
+#include <hpx/schedulers.hpp>
 #include <hpx/testing.hpp>
-#include <hpx/util/yield_while.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -75,7 +75,7 @@ void test_then(Executor& exec)
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -122,7 +122,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/standalone_thread_pool_os_executors.cpp b/libs/execution/tests/unit/standalone_thread_pool_os_executors.cpp
index 8f88baae8f..c82468ab61 100644
--- a/libs/execution/tests/unit/standalone_thread_pool_os_executors.cpp
+++ b/libs/execution/tests/unit/standalone_thread_pool_os_executors.cpp
@@ -11,12 +11,12 @@
 // pools, schedulers etc. assume that the global runtime (configuration, thread
 // manager, etc.) always exists.
 
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/include/apply.hpp>
 #include <hpx/include/async.hpp>
 #include <hpx/include/lcos.hpp>
 #include <hpx/include/parallel_executors.hpp>
 #include <hpx/testing.hpp>
-#include <hpx/util/yield_while.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -71,7 +71,7 @@ void test_then(Executor& exec)
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -118,7 +118,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/this_thread_executors.cpp b/libs/execution/tests/unit/this_thread_executors.cpp
index 5f4fca0d79..11584c176d 100644
--- a/libs/execution/tests/unit/this_thread_executors.cpp
+++ b/libs/execution/tests/unit/this_thread_executors.cpp
@@ -4,9 +4,9 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/execution/executors/this_thread_executors.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/parallel/executors/this_thread_executors.hpp>
 #include <hpx/testing.hpp>
 
 #include <algorithm>
@@ -61,7 +61,7 @@ void test_then(Executor& exec)
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -108,7 +108,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/thread_pool_attached_executors.cpp b/libs/execution/tests/unit/thread_pool_attached_executors.cpp
index bdd1efb09c..82f306b0ad 100644
--- a/libs/execution/tests/unit/thread_pool_attached_executors.cpp
+++ b/libs/execution/tests/unit/thread_pool_attached_executors.cpp
@@ -4,9 +4,9 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/execution/executors/thread_pool_attached_executors.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/parallel/executors/thread_pool_attached_executors.hpp>
 #include <hpx/testing.hpp>
 
 #include <algorithm>
@@ -62,7 +62,7 @@ void test_then(Executor& exec)
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -109,7 +109,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/thread_pool_executors.cpp b/libs/execution/tests/unit/thread_pool_executors.cpp
index 741521b551..5be9b82f91 100644
--- a/libs/execution/tests/unit/thread_pool_executors.cpp
+++ b/libs/execution/tests/unit/thread_pool_executors.cpp
@@ -4,9 +4,9 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/execution/executors/thread_pool_executors.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/parallel/executors/thread_pool_executors.hpp>
 #include <hpx/testing.hpp>
 
 #include <algorithm>
@@ -62,7 +62,7 @@ void test_then(Executor& exec)
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -109,7 +109,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/execution/tests/unit/thread_pool_os_executors.cpp b/libs/execution/tests/unit/thread_pool_os_executors.cpp
index f67d8d76f0..9abe8578f5 100644
--- a/libs/execution/tests/unit/thread_pool_os_executors.cpp
+++ b/libs/execution/tests/unit/thread_pool_os_executors.cpp
@@ -4,9 +4,9 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/execution/executors/thread_pool_os_executors.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/parallel/executors/thread_pool_os_executors.hpp>
 #include <hpx/testing.hpp>
 
 #include <algorithm>
@@ -62,7 +62,7 @@ void test_then(Executor& exec)
 ///////////////////////////////////////////////////////////////////////////////
 void bulk_test(int value, hpx::thread::id tid, int passed_through)    //-V813
 {
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
@@ -109,7 +109,7 @@ void bulk_test_f(int value, hpx::shared_future<void> f, hpx::thread::id tid,
 
     f.get();    // propagate exceptions
 
-    HPX_TEST(tid != hpx::this_thread::get_id());
+    HPX_TEST_NEQ(tid, hpx::this_thread::get_id());
     HPX_TEST_EQ(passed_through, 42);
 }
 
diff --git a/libs/filesystem/CMakeLists.txt b/libs/filesystem/CMakeLists.txt
index 36e7bfcc81..136ab88629 100644
--- a/libs/filesystem/CMakeLists.txt
+++ b/libs/filesystem/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(__boost_filesystem)
 if(HPX_FILESYSTEM_WITH_BOOST_FILESYSTEM_COMPATIBILITY)
diff --git a/libs/filesystem/README.rst b/libs/filesystem/README.rst
index 3f5645e468..5746d25bf0 100644
--- a/libs/filesystem/README.rst
+++ b/libs/filesystem/README.rst
@@ -13,4 +13,4 @@ filesystem
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/filesystem/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/filesystem/docs/index.html>`__.
diff --git a/libs/format/CMakeLists.txt b/libs/format/CMakeLists.txt
index 6f8bc6c526..f72affd93d 100644
--- a/libs/format/CMakeLists.txt
+++ b/libs/format/CMakeLists.txt
@@ -4,13 +4,16 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
 # Default location is $HPX_ROOT/libs/format/include
 set(format_headers
   hpx/format.hpp
+  hpx/util/bad_lexical_cast.hpp
+  hpx/util/from_string.hpp
+  hpx/util/to_string.hpp
 )
 
 # Default location is $HPX_ROOT/libs/format/include_compatibility
@@ -21,6 +24,7 @@ set(format_compat_headers
 # Default location is $HPX_ROOT/libs/format/src
 set(format_sources
   format.cpp
+  util/bad_lexical_cast.cpp
 )
 
 include(HPX_AddModule)
diff --git a/libs/format/README.rst b/libs/format/README.rst
index d118baa94e..d8a91a8869 100644
--- a/libs/format/README.rst
+++ b/libs/format/README.rst
@@ -12,4 +12,4 @@ format
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/format/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/format/docs/index.html>`__.
diff --git a/libs/format/include/hpx/format.hpp b/libs/format/include/hpx/format.hpp
index 0d14c2d9b0..01610a7ab1 100644
--- a/libs/format/include/hpx/format.hpp
+++ b/libs/format/include/hpx/format.hpp
@@ -14,6 +14,7 @@
 #include <cctype>
 #include <cstddef>
 #include <cstdio>
+#include <ctime>
 #include <ostream>
 #include <stdexcept>
 #include <string>
@@ -169,6 +170,36 @@ namespace hpx { namespace util {
             }
         };
 
+        template <>
+        struct formatter<std::tm, /*IsFundamental=*/false>
+        {
+            static void call(
+                std::ostream& os, boost::string_ref spec, void const* ptr)
+            {
+                std::tm const& value = *static_cast<std::tm const*>(ptr);
+
+                // conversion specifier
+                if (spec.empty())
+                    spec = "%c";    // standard date and time string
+
+                // copy spec to a null terminated buffer
+                std::string format(spec.to_string());
+
+                std::size_t length = 0;
+                std::vector<char> buffer(1);
+                buffer.resize(buffer.capacity());
+                do
+                {
+                    length = std::strftime(
+                        buffer.data(), buffer.size(), format.c_str(), &value);
+                    if (length == 0)
+                        buffer.resize(buffer.capacity() * 2);
+                } while (length == 0);
+
+                os.write(buffer.data(), length);
+            }
+        };
+
         template <typename T>
         void format_value(
             std::ostream& os, boost::string_ref spec, T const& value)
@@ -223,7 +254,7 @@ namespace hpx { namespace util {
         };
 
         ///////////////////////////////////////////////////////////////////////
-        // Use dedicated macro so it may be overriden
+        // Use dedicated macro so it may be overridden
 #if !defined(HPX_FORMAT_EXPORT)
 #define HPX_FORMAT_EXPORT HPX_EXPORT
 #endif
diff --git a/libs/format/include/hpx/util/bad_lexical_cast.hpp b/libs/format/include/hpx/util/bad_lexical_cast.hpp
new file mode 100644
index 0000000000..af3a73de44
--- /dev/null
+++ b/libs/format/include/hpx/util/bad_lexical_cast.hpp
@@ -0,0 +1,70 @@
+//  Copyright (c) 2019 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_UTIL_BAD_LEXICAL_CAST_HPP
+#define HPX_UTIL_BAD_LEXICAL_CAST_HPP
+
+#include <hpx/config.hpp>
+
+#include <typeinfo>
+
+#include <hpx/config/warnings_prefix.hpp>
+
+namespace hpx { namespace util {
+
+    class HPX_EXCEPTION_EXPORT bad_lexical_cast : public std::bad_cast
+    {
+    public:
+        bad_lexical_cast() noexcept
+          : source(&typeid(void))
+          , target(&typeid(void))
+        {
+        }
+
+        const char* what() const noexcept override;
+
+        virtual ~bad_lexical_cast() noexcept;
+
+        bad_lexical_cast(std::type_info const& source_type_arg,
+            std::type_info const& target_type_arg) noexcept
+          : source(&source_type_arg)
+          , target(&target_type_arg)
+        {
+        }
+
+        std::type_info const& source_type() const noexcept
+        {
+            return *source;
+        }
+
+        std::type_info const& target_type() const noexcept
+        {
+            return *target;
+        }
+
+    private:
+        std::type_info const* source;
+        std::type_info const* target;
+    };
+
+    namespace detail {
+
+        HPX_NORETURN HPX_EXPORT void throw_bad_lexical_cast(
+            std::type_info const& source_type,
+            std::type_info const& target_type);
+
+        template <typename Source, typename Target>
+        HPX_NORETURN inline Target throw_bad_lexical_cast()
+        {
+            detail::throw_bad_lexical_cast(typeid(Source), typeid(Target));
+        }
+    }    // namespace detail
+
+}}    // namespace hpx::util
+
+#include <hpx/config/warnings_suffix.hpp>
+
+#endif /*HPX_UTIL_BAD_LEXICAL_CAST_HPP*/
diff --git a/libs/format/include/hpx/util/from_string.hpp b/libs/format/include/hpx/util/from_string.hpp
new file mode 100644
index 0000000000..e02ab9e583
--- /dev/null
+++ b/libs/format/include/hpx/util/from_string.hpp
@@ -0,0 +1,141 @@
+//  Copyright (c) 2019 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_UTIL_FROM_STRING_HPP
+#define HPX_UTIL_FROM_STRING_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/util/bad_lexical_cast.hpp>
+
+#include <limits>
+#include <sstream>
+#include <stdexcept>
+#include <string>
+#include <type_traits>
+#include <utility>
+
+namespace hpx { namespace util {
+
+    namespace detail {
+        template <typename T, typename Enable = void>
+        struct from_string
+        {
+            static void call(std::string const& value, T& target)
+            {
+                std::istringstream stream(value);
+                stream.exceptions(std::ios_base::failbit);
+                stream >> target;
+            }
+        };
+
+        template <typename T, typename U>
+        T check_out_of_range(U const& value)
+        {
+            U const min = (std::numeric_limits<T>::min)();
+            U const max = (std::numeric_limits<T>::max)();
+            if (value < min || value > max)
+                throw std::out_of_range("from_string: out of range");
+            return static_cast<T>(value);
+        }
+
+        template <typename T>
+        struct from_string<T,
+            typename std::enable_if<std::is_integral<T>::value>::type>
+        {
+            static void call(std::string const& value, int& target)
+            {
+                target = std::stoi(value);
+            }
+            static void call(std::string const& value, long& target)
+            {
+                target = std::stol(value);
+            }
+            static void call(std::string const& value, long long& target)
+            {
+                target = std::stoll(value);
+            }
+
+            static void call(std::string const& value, unsigned int& target)
+            {
+                // there is no std::stoui
+                unsigned long target_long;
+                call(value, target_long);
+                target = check_out_of_range<T>(target_long);
+            }
+            static void call(std::string const& value, unsigned long& target)
+            {
+                target = std::stoul(value);
+            }
+            static void call(
+                std::string const& value, unsigned long long& target)
+            {
+                target = std::stoull(value);
+            }
+
+            template <typename U>
+            static void call(std::string const& value, U& target)
+            {
+                using promoted_t = decltype(+std::declval<U>());
+                static_assert(!std::is_same<promoted_t, U>::value, "");
+
+                promoted_t promoted;
+                call(value, promoted);
+                target = check_out_of_range<U>(promoted);
+            }
+        };
+
+        template <typename T>
+        struct from_string<T,
+            typename std::enable_if<std::is_floating_point<T>::value>::type>
+        {
+            static void call(std::string const& value, float& target)
+            {
+                target = std::stof(value);
+            }
+            static void call(std::string const& value, double& target)
+            {
+                target = std::stod(value);
+            }
+            static void call(std::string const& value, long double& target)
+            {
+                target = std::stold(value);
+            }
+        };
+    }    // namespace detail
+
+    template <typename T>
+    T from_string(std::string const& v)
+    {
+        T target;
+        try
+        {
+            detail::from_string<T>::call(v, target);
+        }
+        catch (...)
+        {
+            return detail::throw_bad_lexical_cast<std::string, T>();
+        }
+        return target;
+    }
+
+    template <typename T, typename U>
+    T from_string(std::string const& v, U&& default_value)
+    {
+        T target;
+        try
+        {
+            detail::from_string<T>::call(v, target);
+            return target;
+        }
+        catch (...)
+        {
+            return std::forward<U>(default_value);
+        }
+    }
+
+}}    // namespace hpx::util
+
+#endif /*HPX_UTIL_FROM_STRING_HPP*/
diff --git a/libs/format/include/hpx/util/to_string.hpp b/libs/format/include/hpx/util/to_string.hpp
new file mode 100644
index 0000000000..e962b932db
--- /dev/null
+++ b/libs/format/include/hpx/util/to_string.hpp
@@ -0,0 +1,56 @@
+//  Copyright (c) 2019 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_UTIL_TO_STRING_HPP
+#define HPX_UTIL_TO_STRING_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/format.hpp>
+#include <hpx/util/bad_lexical_cast.hpp>
+
+#include <string>
+#include <type_traits>
+
+namespace hpx { namespace util {
+
+    namespace detail {
+        template <typename T, typename Enable = void>
+        struct to_string
+        {
+            static std::string call(T const& value)
+            {
+                return util::format("{}", value);
+            }
+        };
+
+        template <typename T>
+        struct to_string<T,
+            typename std::enable_if<std::is_integral<T>::value ||
+                std::is_floating_point<T>::value>::type>
+        {
+            static std::string call(T const& value)
+            {
+                return std::to_string(value);
+            }
+        };
+    }    // namespace detail
+
+    template <typename T>
+    std::string to_string(T const& v)
+    {
+        try
+        {
+            return detail::to_string<T>::call(v);
+        }
+        catch (...)
+        {
+            return detail::throw_bad_lexical_cast<T, std::string>();
+        }
+    }
+
+}}    // namespace hpx::util
+
+#endif /*HPX_UTIL_TO_STRING_HPP*/
diff --git a/libs/format/src/util/bad_lexical_cast.cpp b/libs/format/src/util/bad_lexical_cast.cpp
new file mode 100644
index 0000000000..384a211ff4
--- /dev/null
+++ b/libs/format/src/util/bad_lexical_cast.cpp
@@ -0,0 +1,29 @@
+//  Copyright (c) 2019 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/util/bad_lexical_cast.hpp>
+
+#include <typeinfo>
+
+namespace hpx { namespace util {
+
+    const char* bad_lexical_cast::what() const noexcept
+    {
+        return "bad lexical cast: "
+               "source type value could not be interpreted as target";
+    }
+
+    bad_lexical_cast::~bad_lexical_cast() noexcept = default;
+
+    namespace detail {
+        void throw_bad_lexical_cast(std::type_info const& source_type,
+            std::type_info const& target_type)
+        {
+            throw bad_lexical_cast(source_type, target_type);
+        }
+    }    // namespace detail
+
+}}    // namespace hpx::util
diff --git a/libs/format/tests/unit/format.cpp b/libs/format/tests/unit/format.cpp
index 6eb86d7f56..cefb2ea0a1 100644
--- a/libs/format/tests/unit/format.cpp
+++ b/libs/format/tests/unit/format.cpp
@@ -8,6 +8,7 @@
 #include <hpx/format.hpp>
 #include <hpx/testing.hpp>
 
+#include <ctime>
 #include <string>
 
 int main(int argc, char* argv[])
@@ -42,6 +43,17 @@ int main(int argc, char* argv[])
         HPX_TEST_EQ((format("{} {}", true, false)), "1 0");
     }
 
+    {
+        std::time_t t = std::time(nullptr);
+        std::tm tm = *std::localtime(&t);
+        char buffer[64] = {};
+        std::strftime(buffer, 64, "%c", &tm);
+        HPX_TEST_EQ((format("{}", tm)), buffer);
+
+        std::strftime(buffer, 64, "%A %c", &tm);
+        HPX_TEST_EQ((format("{:%A %c}", tm)), buffer);
+    }
+
     {
         HPX_TEST_EQ((format("{{ {}", 1)), "{ 1");
         HPX_TEST_EQ((format("}} {}", 1)), "} 1");
diff --git a/libs/functional/CMakeLists.txt b/libs/functional/CMakeLists.txt
index 63361c4532..0578095bcb 100644
--- a/libs/functional/CMakeLists.txt
+++ b/libs/functional/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -31,6 +31,7 @@ set(functional_headers
   hpx/functional/protect.hpp
   hpx/functional/result_of.hpp
   hpx/functional/unique_function.hpp
+  hpx/functional/traits/get_action_name.hpp
   hpx/functional/traits/get_function_address.hpp
   hpx/functional/traits/get_function_annotation.hpp
   hpx/functional/traits/is_action.hpp
diff --git a/libs/functional/README.rst b/libs/functional/README.rst
index fb9b8aceb5..11c87efeb8 100644
--- a/libs/functional/README.rst
+++ b/libs/functional/README.rst
@@ -13,4 +13,4 @@ functional
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/functional/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/functional/docs/index.html>`__.
diff --git a/libs/functional/include/hpx/functional/bind.hpp b/libs/functional/include/hpx/functional/bind.hpp
index c8ba309664..d5dfd05a19 100644
--- a/libs/functional/include/hpx/functional/bind.hpp
+++ b/libs/functional/include/hpx/functional/bind.hpp
@@ -10,10 +10,8 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
-#include <hpx/datastructures/tuple.hpp>
+#include <hpx/datastructures/member_pack.hpp>
 #include <hpx/functional/invoke.hpp>
-#include <hpx/functional/invoke_fused.hpp>
 #include <hpx/functional/one_shot.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/functional/traits/get_function_address.hpp>
@@ -22,6 +20,7 @@
 #include <hpx/functional/traits/is_bind_expression.hpp>
 #include <hpx/functional/traits/is_placeholder.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -57,12 +56,13 @@ namespace hpx { namespace util {
         template <std::size_t I>
         struct bind_eval_placeholder
         {
-            template <typename T, typename Us>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE typename util::tuple_element<I,
-                typename std::remove_reference<Us>::type>::type&&
-            call(T&& /*t*/, Us&& unbound)
+            template <typename T, typename... Us>
+            static constexpr HPX_HOST_DEVICE decltype(auto) call(
+                T&& /*t*/, Us&&... vs)
             {
-                return util::get<I>(std::forward<Us>(unbound));
+                return util::member_pack_for<Us&&...>(
+                    std::piecewise_construct, std::forward<Us>(vs)...)
+                    .template get<I>();
             }
         };
 
@@ -70,9 +70,8 @@ namespace hpx { namespace util {
             typename Enable = void>
         struct bind_eval
         {
-            template <typename Us>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE T&& call(
-                T&& t, Us&& /*unbound*/)
+            template <typename... Us>
+            static constexpr HPX_HOST_DEVICE T&& call(T&& t, Us&&... /*vs*/)
             {
                 return std::forward<T>(t);
             }
@@ -92,123 +91,107 @@ namespace hpx { namespace util {
             typename std::enable_if<
                 traits::is_bind_expression<TD>::value>::type>
         {
-            template <typename Us>
-            static HPX_CONSTEXPR HPX_HOST_DEVICE
-                typename util::detail::invoke_fused_result<T, Us>::type
-                call(T&& t, Us&& unbound)
+            template <typename... Us>
+            static constexpr HPX_HOST_DEVICE
+                typename util::invoke_result<T, Us...>::type
+                call(T&& t, Us&&... vs)
             {
-                return util::invoke_fused(
-                    std::forward<T>(t), std::forward<Us>(unbound));
+                return HPX_INVOKE(std::forward<T>(t), std::forward<Us>(vs)...);
             }
         };
 
         ///////////////////////////////////////////////////////////////////////
-        template <typename F, typename Ts, typename Us>
+        template <typename F, typename Ts, typename... Us>
         struct invoke_bound_result;
 
-        template <typename F, typename... Ts, typename Us>
-        struct invoke_bound_result<F, util::tuple<Ts...>, Us>
+        template <typename F, typename... Ts, typename... Us>
+        struct invoke_bound_result<F, util::pack<Ts...>, Us...>
           : util::invoke_result<F,
                 decltype(bind_eval<Ts>::call(
-                    std::declval<Ts>(), std::declval<Us>()))...>
+                    std::declval<Ts>(), std::declval<Us>()...))...>
         {
         };
 
         ///////////////////////////////////////////////////////////////////////
-        template <typename F, typename Ts, typename Is>
-        struct bound_impl;
+        template <typename F, typename Is, typename... Ts>
+        class bound;
 
-        template <typename F, typename... Ts, std::size_t... Is>
-        struct bound_impl<F, util::tuple<Ts...>, pack_c<std::size_t, Is...>>
+        template <typename F, std::size_t... Is, typename... Ts>
+        class bound<F, index_pack<Is...>, Ts...>
         {
+        public:
+            bound() = default;    // needed for serialization
+
+            template <typename F_, typename... Ts_,
+                typename = typename std::enable_if<
+                    std::is_constructible<F, F_>::value>::type>
+            constexpr explicit bound(F_&& f, Ts_&&... vs)
+              : _f(std::forward<F_>(f))
+              , _args(std::piecewise_construct, std::forward<Ts_>(vs)...)
+            {
+            }
+
+#if !defined(__NVCC__) && !defined(__CUDACC__)
+            bound(bound const&) = default;
+            bound(bound&&) = default;
+#else
+            constexpr HPX_HOST_DEVICE bound(bound const& other)
+              : _f(other._f)
+              , _args(other._args)
+            {
+            }
+
+            constexpr HPX_HOST_DEVICE bound(bound&& other)
+              : _f(std::move(other._f))
+              , _args(std::move(other._args))
+            {
+            }
+#endif
+
+            bound& operator=(bound const&) = delete;
+
             template <typename... Us>
-            HPX_CXX14_CONSTEXPR HPX_HOST_DEVICE typename invoke_bound_result<F&,
-                util::tuple<Ts&...>, util::tuple<Us&&...>>::type
+            constexpr HPX_HOST_DEVICE typename invoke_bound_result<F&,
+                util::pack<Ts&...>, Us&&...>::type
             operator()(Us&&... vs) &
             {
                 return HPX_INVOKE(_f,
-                    detail::bind_eval<Ts&>::call(util::get<Is>(_args),
-                        util::forward_as_tuple(std::forward<Us>(vs)...))...);
+                    detail::bind_eval<Ts&>::call(
+                        _args.template get<Is>(), std::forward<Us>(vs)...)...);
             }
 
             template <typename... Us>
-            HPX_CONSTEXPR HPX_HOST_DEVICE typename invoke_bound_result<F const&,
-                util::tuple<Ts const&...>, util::tuple<Us&&...>>::type
+            constexpr HPX_HOST_DEVICE typename invoke_bound_result<F const&,
+                util::pack<Ts const&...>, Us&&...>::type
             operator()(Us&&... vs) const&
             {
                 return HPX_INVOKE(_f,
-                    detail::bind_eval<Ts const&>::call(util::get<Is>(_args),
-                        util::forward_as_tuple(std::forward<Us>(vs)...))...);
+                    detail::bind_eval<Ts const&>::call(
+                        _args.template get<Is>(), std::forward<Us>(vs)...)...);
             }
 
             template <typename... Us>
-            HPX_CXX14_CONSTEXPR HPX_HOST_DEVICE
-                typename invoke_bound_result<F&&, util::tuple<Ts&&...>,
-                    util::tuple<Us&&...>>::type
-                operator()(Us&&... vs) &&
+            constexpr HPX_HOST_DEVICE typename invoke_bound_result<F&&,
+                util::pack<Ts&&...>, Us&&...>::type
+            operator()(Us&&... vs) &&
             {
                 return HPX_INVOKE(std::move(_f),
-                    detail::bind_eval<Ts>::call(util::get<Is>(std::move(_args)),
-                        util::forward_as_tuple(std::forward<Us>(vs)...))...);
+                    detail::bind_eval<Ts>::call(
+                        std::move(_args).template get<Is>(),
+                        std::forward<Us>(vs)...)...);
             }
 
             template <typename... Us>
-            HPX_CONSTEXPR HPX_HOST_DEVICE
-                typename invoke_bound_result<F const&&,
-                    util::tuple<Ts const&&...>, util::tuple<Us&&...>>::type
-                operator()(Us&&... vs) const&&
+            constexpr HPX_HOST_DEVICE typename invoke_bound_result<F const&&,
+                util::pack<Ts const&&...>, Us&&...>::type
+            operator()(Us&&... vs) const&&
             {
                 return HPX_INVOKE(std::move(_f),
                     detail::bind_eval<Ts const>::call(
-                        util::get<Is>(std::move(_args)),
-                        util::forward_as_tuple(std::forward<Us>(vs)...))...);
-            }
-
-            F _f;
-            util::tuple<Ts...> _args;
-        };
-
-        template <typename F, typename... Ts>
-        class bound
-          : private bound_impl<F,
-                util::tuple<typename util::decay_unwrap<Ts>::type...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>
-        {
-            using base_type = detail::bound_impl<F,
-                util::tuple<typename util::decay_unwrap<Ts>::type...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>;
-
-        public:
-            bound() {}    // needed for serialization
-
-            template <typename F_, typename... Ts_,
-                typename = typename std::enable_if<
-                    std::is_constructible<F, F_>::value>::type>
-            HPX_CONSTEXPR explicit bound(F_&& f, Ts_&&... vs)
-              : base_type{std::forward<F_>(f),
-                    util::forward_as_tuple(std::forward<Ts_>(vs)...)}
-            {
-            }
-
-#if !defined(__NVCC__) && !defined(__CUDACC__)
-            bound(bound const&) = default;
-            bound(bound&&) = default;
-#else
-            HPX_HOST_DEVICE bound(bound const& other)
-              : base_type{other}
-            {
+                        std::move(_args).template get<Is>(),
+                        std::forward<Us>(vs)...)...);
             }
 
-            HPX_HOST_DEVICE bound(bound&& other)
-              : base_type{std::move(other)}
-            {
-            }
-#endif
-
-            bound& operator=(bound const&) = delete;
-
-            using base_type::operator();
-
             template <typename Archive>
             void serialize(Archive& ar, unsigned int const /*version*/)
             {
@@ -243,21 +226,23 @@ namespace hpx { namespace util {
 #endif
 
         private:
-            using base_type::_args;
-            using base_type::_f;
+            F _f;
+            util::member_pack_for<Ts...> _args;
         };
     }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
-    template <typename F, typename... Ts>
-    HPX_CONSTEXPR typename std::enable_if<
-        !traits::is_action<typename std::decay<F>::type>::value,
-        detail::bound<typename std::decay<F>::type,
-            typename std::decay<Ts>::type...>>::type
+    template <typename F, typename... Ts,
+        typename Enable = typename std::enable_if<
+            !traits::is_action<typename std::decay<F>::type>::value>::type>
+    constexpr detail::bound<typename std::decay<F>::type,
+        typename util::make_index_pack<sizeof...(Ts)>::type,
+        typename util::decay_unwrap<Ts>::type...>
     bind(F&& f, Ts&&... vs)
     {
         typedef detail::bound<typename std::decay<F>::type,
-            typename std::decay<Ts>::type...>
+            typename util::make_index_pack<sizeof...(Ts)>::type,
+            typename util::decay_unwrap<Ts>::type...>
             result_type;
 
         return result_type(std::forward<F>(f), std::forward<Ts>(vs)...);
diff --git a/libs/functional/include/hpx/functional/bind_back.hpp b/libs/functional/include/hpx/functional/bind_back.hpp
index 82cca07764..1c21ad8287 100644
--- a/libs/functional/include/hpx/functional/bind_back.hpp
+++ b/libs/functional/include/hpx/functional/bind_back.hpp
@@ -9,14 +9,14 @@
 #define HPX_UTIL_BIND_BACK_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
-#include <hpx/datastructures/tuple.hpp>
+#include <hpx/datastructures/member_pack.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/one_shot.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/functional/traits/get_function_address.hpp>
 #include <hpx/functional/traits/get_function_annotation.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -28,102 +28,87 @@ namespace hpx { namespace util {
         struct invoke_bound_back_result;
 
         template <typename F, typename... Ts, typename... Us>
-        struct invoke_bound_back_result<F, util::tuple<Ts...>, Us...>
+        struct invoke_bound_back_result<F, util::pack<Ts...>, Us...>
           : util::invoke_result<F, Us..., Ts...>
         {
         };
 
         ///////////////////////////////////////////////////////////////////////
-        template <typename F, typename Ts, typename Is>
-        struct bound_back_impl;
+        template <typename F, typename Is, typename... Ts>
+        class bound_back;
 
-        template <typename F, typename... Ts, std::size_t... Is>
-        struct bound_back_impl<F, util::tuple<Ts...>,
-            pack_c<std::size_t, Is...>>
+        template <typename F, std::size_t... Is, typename... Ts>
+        class bound_back<F, index_pack<Is...>, Ts...>
         {
+        public:
+            bound_back() = default;    // needed for serialization
+
+            template <typename F_, typename... Ts_,
+                typename = typename std::enable_if<
+                    std::is_constructible<F, F_>::value>::type>
+            constexpr explicit bound_back(F_&& f, Ts_&&... vs)
+              : _f(std::forward<F_>(f))
+              , _args(std::piecewise_construct, std::forward<Ts_>(vs)...)
+            {
+            }
+
+#if !defined(__NVCC__) && !defined(__CUDACC__)
+            bound_back(bound_back const&) = default;
+            bound_back(bound_back&&) = default;
+#else
+            constexpr HPX_HOST_DEVICE bound_back(bound_back const& other)
+              : _f(other._f)
+              , _args(other._args)
+            {
+            }
+
+            constexpr HPX_HOST_DEVICE bound_back(bound_back&& other)
+              : _f(std::move(other._f))
+              , _args(std::move(other._args))
+            {
+            }
+#endif
+
+            bound_back& operator=(bound_back const&) = delete;
+
             template <typename... Us>
-            HPX_CXX14_CONSTEXPR HPX_HOST_DEVICE
-                typename invoke_bound_back_result<F&, util::tuple<Ts&...>,
-                    Us&&...>::type
-                operator()(Us&&... vs) &
+            constexpr HPX_HOST_DEVICE typename invoke_bound_back_result<F&,
+                util::pack<Ts&...>, Us&&...>::type
+            operator()(Us&&... vs) &
             {
                 return HPX_INVOKE(
-                    _f, std::forward<Us>(vs)..., util::get<Is>(_args)...);
+                    _f, std::forward<Us>(vs)..., _args.template get<Is>()...);
             }
 
             template <typename... Us>
-            HPX_CONSTEXPR HPX_HOST_DEVICE
+            constexpr HPX_HOST_DEVICE
                 typename invoke_bound_back_result<F const&,
-                    util::tuple<Ts const&...>, Us&&...>::type
+                    util::pack<Ts const&...>, Us&&...>::type
                 operator()(Us&&... vs) const&
             {
                 return HPX_INVOKE(
-                    _f, std::forward<Us>(vs)..., util::get<Is>(_args)...);
+                    _f, std::forward<Us>(vs)..., _args.template get<Is>()...);
             }
 
             template <typename... Us>
-            HPX_CXX14_CONSTEXPR HPX_HOST_DEVICE
-                typename invoke_bound_back_result<F&&, util::tuple<Ts&&...>,
-                    Us&&...>::type
-                operator()(Us&&... vs) &&
+            constexpr HPX_HOST_DEVICE typename invoke_bound_back_result<F&&,
+                util::pack<Ts&&...>, Us&&...>::type
+            operator()(Us&&... vs) &&
             {
                 return HPX_INVOKE(std::move(_f), std::forward<Us>(vs)...,
-                    util::get<Is>(std::move(_args))...);
+                    std::move(_args).template get<Is>()...);
             }
 
             template <typename... Us>
-            HPX_CONSTEXPR HPX_HOST_DEVICE
+            constexpr HPX_HOST_DEVICE
                 typename invoke_bound_back_result<F const&&,
-                    util::tuple<Ts const&&...>, Us&&...>::type
+                    util::pack<Ts const&&...>, Us&&...>::type
                 operator()(Us&&... vs) const&&
             {
                 return HPX_INVOKE(std::move(_f), std::forward<Us>(vs)...,
-                    util::get<Is>(std::move(_args))...);
+                    std::move(_args).template get<Is>()...);
             }
 
-            F _f;
-            util::tuple<Ts...> _args;
-        };
-
-        template <typename F, typename... Ts>
-        class bound_back
-          : private bound_back_impl<F, util::tuple<Ts...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>
-        {
-            using base_type = detail::bound_back_impl<F, util::tuple<Ts...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>;
-
-        public:
-            bound_back() {}    // needed for serialization
-
-            template <typename F_, typename... Ts_,
-                typename = typename std::enable_if<
-                    std::is_constructible<F, F_>::value>::type>
-            HPX_CONSTEXPR explicit bound_back(F_&& f, Ts_&&... vs)
-              : base_type{std::forward<F_>(f),
-                    util::forward_as_tuple(std::forward<Ts_>(vs)...)}
-            {
-            }
-
-#if !defined(__NVCC__) && !defined(__CUDACC__)
-            bound_back(bound_back const&) = default;
-            bound_back(bound_back&&) = default;
-#else
-            HPX_CONSTEXPR HPX_HOST_DEVICE bound_back(bound_back const& other)
-              : base_type{other}
-            {
-            }
-
-            HPX_CONSTEXPR HPX_HOST_DEVICE bound_back(bound_back&& other)
-              : base_type{std::move(other)}
-            {
-            }
-#endif
-
-            bound_back& operator=(bound_back const&) = delete;
-
-            using base_type::operator();
-
             template <typename Archive>
             void serialize(Archive& ar, unsigned int const /*version*/)
             {
@@ -158,18 +143,20 @@ namespace hpx { namespace util {
 #endif
 
         private:
-            using base_type::_args;
-            using base_type::_f;
+            F _f;
+            util::member_pack_for<Ts...> _args;
         };
     }    // namespace detail
 
     template <typename F, typename... Ts>
-    HPX_CONSTEXPR detail::bound_back<typename std::decay<F>::type,
-        typename std::decay<Ts>::type...>
+    constexpr detail::bound_back<typename std::decay<F>::type,
+        typename util::make_index_pack<sizeof...(Ts)>::type,
+        typename util::decay_unwrap<Ts>::type...>
     bind_back(F&& f, Ts&&... vs)
     {
         typedef detail::bound_back<typename std::decay<F>::type,
-            typename std::decay<Ts>::type...>
+            typename util::make_index_pack<sizeof...(Ts)>::type,
+            typename util::decay_unwrap<Ts>::type...>
             result_type;
 
         return result_type(std::forward<F>(f), std::forward<Ts>(vs)...);
@@ -177,7 +164,7 @@ namespace hpx { namespace util {
 
     // nullary functions do not need to be bound again
     template <typename F>
-    HPX_CONSTEXPR typename std::decay<F>::type bind_back(F&& f)
+    constexpr typename std::decay<F>::type bind_back(F&& f)
     {
         return std::forward<F>(f);
     }
diff --git a/libs/functional/include/hpx/functional/bind_front.hpp b/libs/functional/include/hpx/functional/bind_front.hpp
index ff0a046571..c3f815952f 100644
--- a/libs/functional/include/hpx/functional/bind_front.hpp
+++ b/libs/functional/include/hpx/functional/bind_front.hpp
@@ -9,14 +9,14 @@
 #define HPX_UTIL_BIND_FRONT_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
-#include <hpx/datastructures/tuple.hpp>
+#include <hpx/datastructures/member_pack.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/one_shot.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/functional/traits/get_function_address.hpp>
 #include <hpx/functional/traits/get_function_annotation.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -28,104 +28,89 @@ namespace hpx { namespace util {
         struct invoke_bound_front_result;
 
         template <typename F, typename... Ts, typename... Us>
-        struct invoke_bound_front_result<F, util::tuple<Ts...>, Us...>
+        struct invoke_bound_front_result<F, util::pack<Ts...>, Us...>
           : util::invoke_result<F, Ts..., Us...>
         {
         };
 
         ///////////////////////////////////////////////////////////////////////
-        template <typename F, typename Ts, typename Is>
-        struct bound_front_impl;
+        template <typename F, typename Is, typename... Ts>
+        class bound_front;
 
-        template <typename F, typename... Ts, std::size_t... Is>
-        struct bound_front_impl<F, util::tuple<Ts...>,
-            pack_c<std::size_t, Is...>>
+        template <typename F, std::size_t... Is, typename... Ts>
+        class bound_front<F, index_pack<Is...>, Ts...>
         {
+        public:
+            bound_front() = default;    // needed for serialization
+
+            template <typename F_, typename... Ts_,
+                typename = typename std::enable_if<
+                    std::is_constructible<F, F_>::value>::type>
+            constexpr explicit bound_front(F_&& f, Ts_&&... vs)
+              : _f(std::forward<F_>(f))
+              , _args(std::piecewise_construct, std::forward<Ts_>(vs)...)
+            {
+            }
+
+#if !defined(__NVCC__) && !defined(__CUDACC__)
+            bound_front(bound_front const&) = default;
+            bound_front(bound_front&&) = default;
+#else
+            constexpr HPX_HOST_DEVICE bound_front(bound_front const& other)
+              : _f(other._f)
+              , _args(other._args)
+            {
+            }
+
+            constexpr HPX_HOST_DEVICE bound_front(bound_front&& other)
+              : _f(std::move(other._f))
+              , _args(std::move(other._args))
+            {
+            }
+#endif
+
+            bound_front& operator=(bound_front const&) = delete;
+
             template <typename... Us>
-            HPX_CXX14_CONSTEXPR HPX_HOST_DEVICE
-                typename invoke_bound_front_result<F&, util::tuple<Ts&...>,
-                    Us&&...>::type
-                operator()(Us&&... vs) &
+            constexpr HPX_HOST_DEVICE typename invoke_bound_front_result<F&,
+                util::pack<Ts&...>, Us&&...>::type
+            operator()(Us&&... vs) &
             {
                 return HPX_INVOKE(
-                    _f, util::get<Is>(_args)..., std::forward<Us>(vs)...);
+                    _f, _args.template get<Is>()..., std::forward<Us>(vs)...);
             }
 
             template <typename... Us>
-            HPX_CONSTEXPR HPX_HOST_DEVICE
+            constexpr HPX_HOST_DEVICE
                 typename invoke_bound_front_result<F const&,
-                    util::tuple<Ts const&...>, Us&&...>::type
+                    util::pack<Ts const&...>, Us&&...>::type
                 operator()(Us&&... vs) const&
             {
                 return HPX_INVOKE(
-                    _f, util::get<Is>(_args)..., std::forward<Us>(vs)...);
+                    _f, _args.template get<Is>()..., std::forward<Us>(vs)...);
             }
 
             template <typename... Us>
-            HPX_CXX14_CONSTEXPR HPX_HOST_DEVICE
-                typename invoke_bound_front_result<F&&, util::tuple<Ts&&...>,
-                    Us&&...>::type
-                operator()(Us&&... vs) &&
+            constexpr HPX_HOST_DEVICE typename invoke_bound_front_result<F&&,
+                util::pack<Ts&&...>, Us&&...>::type
+            operator()(Us&&... vs) &&
             {
                 return HPX_INVOKE(std::move(_f),
-                    util::get<Is>(std::move(_args))...,
+                    std::move(_args).template get<Is>()...,
                     std::forward<Us>(vs)...);
             }
 
             template <typename... Us>
-            HPX_CONSTEXPR HPX_HOST_DEVICE
+            constexpr HPX_HOST_DEVICE
                 typename invoke_bound_front_result<F const&&,
-                    util::tuple<Ts const&&...>, Us&&...>::type
+                    util::pack<Ts const&&...>, Us&&...>::type
                 operator()(Us&&... vs) const&&
             {
                 return HPX_INVOKE(std::move(_f),
-                    util::get<Is>(std::move(_args))...,
+                    std::move(_args).template get<Is>()...,
                     std::forward<Us>(vs)...);
             }
 
-            F _f;
-            util::tuple<Ts...> _args;
-        };
-
-        template <typename F, typename... Ts>
-        class bound_front
-          : private bound_front_impl<F, util::tuple<Ts...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>
-        {
-            using base_type = detail::bound_front_impl<F, util::tuple<Ts...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>;
-
-        public:
-            bound_front() {}    // needed for serialization
-
-            template <typename F_, typename... Ts_,
-                typename = typename std::enable_if<
-                    std::is_constructible<F, F_>::value>::type>
-            HPX_CONSTEXPR explicit bound_front(F_&& f, Ts_&&... vs)
-              : base_type{std::forward<F_>(f),
-                    util::forward_as_tuple(std::forward<Ts_>(vs)...)}
-            {
-            }
-
-#if !defined(__NVCC__) && !defined(__CUDACC__)
-            bound_front(bound_front const&) = default;
-            bound_front(bound_front&&) = default;
-#else
-            HPX_CONSTEXPR HPX_HOST_DEVICE bound_front(bound_front const& other)
-              : base_type{other}
-            {
-            }
-
-            HPX_CONSTEXPR HPX_HOST_DEVICE bound_front(bound_front&& other)
-              : base_type{std::move(other)}
-            {
-            }
-#endif
-
-            bound_front& operator=(bound_front const&) = delete;
-
-            using base_type::operator();
-
             template <typename Archive>
             void serialize(Archive& ar, unsigned int const /*version*/)
             {
@@ -160,18 +145,20 @@ namespace hpx { namespace util {
 #endif
 
         private:
-            using base_type::_args;
-            using base_type::_f;
+            F _f;
+            util::member_pack_for<Ts...> _args;
         };
     }    // namespace detail
 
     template <typename F, typename... Ts>
-    HPX_CONSTEXPR detail::bound_front<typename std::decay<F>::type,
-        typename std::decay<Ts>::type...>
+    constexpr detail::bound_front<typename std::decay<F>::type,
+        typename util::make_index_pack<sizeof...(Ts)>::type,
+        typename util::decay_unwrap<Ts>::type...>
     bind_front(F&& f, Ts&&... vs)
     {
         typedef detail::bound_front<typename std::decay<F>::type,
-            typename std::decay<Ts>::type...>
+            typename util::make_index_pack<sizeof...(Ts)>::type,
+            typename util::decay_unwrap<Ts>::type...>
             result_type;
 
         return result_type(std::forward<F>(f), std::forward<Ts>(vs)...);
@@ -179,7 +166,7 @@ namespace hpx { namespace util {
 
     // nullary functions do not need to be bound again
     template <typename F>
-    HPX_CONSTEXPR typename std::decay<F>::type bind_front(F&& f)
+    constexpr typename std::decay<F>::type bind_front(F&& f)
     {
         return std::forward<F>(f);
     }
diff --git a/libs/functional/include/hpx/functional/deferred_call.hpp b/libs/functional/include/hpx/functional/deferred_call.hpp
index abc69cb58d..a4fc889273 100644
--- a/libs/functional/include/hpx/functional/deferred_call.hpp
+++ b/libs/functional/include/hpx/functional/deferred_call.hpp
@@ -11,13 +11,14 @@
 #define HPX_UTIL_DEFERRED_CALL_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/tuple.hpp>
+#include <hpx/datastructures/member_pack.hpp>
 #include <hpx/functional/invoke_fused.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/functional/traits/get_function_address.hpp>
 #include <hpx/functional/traits/get_function_annotation.hpp>
 #include <hpx/functional/traits/is_callable.hpp>
 #include <hpx/type_support/decay.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -65,54 +66,30 @@ namespace hpx { namespace util {
         };
 
         ///////////////////////////////////////////////////////////////////////
-        template <typename F, typename Ts, typename Is>
-        struct deferred_impl;
-
-        template <typename F, typename... Ts, std::size_t... Is>
-        struct deferred_impl<F, util::tuple<Ts...>, pack_c<std::size_t, Is...>>
-        {
-            HPX_HOST_DEVICE HPX_FORCEINLINE
-                typename util::invoke_result<F, Ts...>::type
-                operator()()
-            {
-                return HPX_INVOKE(
-                    std::move(_f), util::get<Is>(std::move(_args))...);
-            }
-
-            F _f;
-            util::tuple<Ts...> _args;
-        };
-
-        template <typename F, typename... Ts>
+        template <typename F, typename Is, typename... Ts>
         class deferred;
 
-        template <typename F, typename... Ts>
-        class deferred
-          : private deferred_impl<F,
-                util::tuple<typename util::decay_unwrap<Ts>::type...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>
+        template <typename F, std::size_t... Is, typename... Ts>
+        class deferred<F, index_pack<Is...>, Ts...>
         {
-            using base_type = deferred_impl<F,
-                util::tuple<typename util::decay_unwrap<Ts>::type...>,
-                typename detail::make_index_pack<sizeof...(Ts)>::type>;
-
         public:
-            deferred() {}    // needed for serialization
+            deferred() = default;    // needed for serialization
 
             template <typename F_, typename... Ts_,
                 typename = typename std::enable_if<
                     std::is_constructible<F, F_>::value>::type>
-            explicit HPX_HOST_DEVICE deferred(F_&& f, Ts_&&... vs)
-              : base_type{std::forward<F_>(f),
-                    util::forward_as_tuple(std::forward<Ts_>(vs)...)}
+            explicit constexpr HPX_HOST_DEVICE deferred(F_&& f, Ts_&&... vs)
+              : _f(std::forward<F_>(f))
+              , _args(std::piecewise_construct, std::forward<Ts_>(vs)...)
             {
             }
 
 #if !defined(__NVCC__) && !defined(__CUDACC__)
             deferred(deferred&&) = default;
 #else
-            HPX_HOST_DEVICE deferred(deferred&& other)
-              : base_type{std::move(other)}
+            constexpr HPX_HOST_DEVICE deferred(deferred&& other)
+              : _f(std::move(other._f))
+              , _args(std::move(other._args))
             {
             }
 #endif
@@ -120,7 +97,13 @@ namespace hpx { namespace util {
             deferred(deferred const&) = delete;
             deferred& operator=(deferred const&) = delete;
 
-            using base_type::operator();
+            HPX_HOST_DEVICE HPX_FORCEINLINE
+                typename util::invoke_result<F, Ts...>::type
+                operator()()
+            {
+                return HPX_INVOKE(
+                    std::move(_f), std::move(_args).template get<Is>()...);
+            }
 
             template <typename Archive>
             void serialize(Archive& ar, unsigned int const /*version*/)
@@ -156,14 +139,15 @@ namespace hpx { namespace util {
 #endif
 
         private:
-            using base_type::_args;
-            using base_type::_f;
+            F _f;
+            util::member_pack_for<Ts...> _args;
         };
     }    // namespace detail
 
     template <typename F, typename... Ts>
     detail::deferred<typename std::decay<F>::type,
-        typename std::decay<Ts>::type...>
+        typename util::make_index_pack<sizeof...(Ts)>::type,
+        typename util::decay_unwrap<Ts>::type...>
     deferred_call(F&& f, Ts&&... vs)
     {
         static_assert(
@@ -171,7 +155,8 @@ namespace hpx { namespace util {
             "F shall be Callable with decay_t<Ts> arguments");
 
         typedef detail::deferred<typename std::decay<F>::type,
-            typename std::decay<Ts>::type...>
+            typename util::make_index_pack<sizeof...(Ts)>::type,
+            typename util::decay_unwrap<Ts>::type...>
             result_type;
 
         return result_type(std::forward<F>(f), std::forward<Ts>(vs)...);
diff --git a/libs/functional/include/hpx/functional/detail/basic_function.hpp b/libs/functional/include/hpx/functional/detail/basic_function.hpp
index a71859fab6..d468ef538e 100644
--- a/libs/functional/include/hpx/functional/detail/basic_function.hpp
+++ b/libs/functional/include/hpx/functional/detail/basic_function.hpp
@@ -35,7 +35,7 @@ namespace hpx { namespace util { namespace detail {
         using vtable = function_base_vtable;
 
     public:
-        HPX_CONSTEXPR explicit function_base(
+        constexpr explicit function_base(
             function_base_vtable const* empty_vptr) noexcept
           : vptr(empty_vptr)
           , object(nullptr)
@@ -81,13 +81,13 @@ namespace hpx { namespace util { namespace detail {
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename F>
-    HPX_CONSTEXPR bool is_empty_function(F* fp) noexcept
+    constexpr bool is_empty_function(F* fp) noexcept
     {
         return fp == nullptr;
     }
 
     template <typename T, typename C>
-    HPX_CONSTEXPR bool is_empty_function(T C::*mp) noexcept
+    constexpr bool is_empty_function(T C::*mp) noexcept
     {
         return mp == nullptr;
     }
@@ -97,13 +97,13 @@ namespace hpx { namespace util { namespace detail {
         return f->empty();
     }
 
-    inline HPX_CONSTEXPR bool is_empty_function_impl(...) noexcept
+    inline constexpr bool is_empty_function_impl(...) noexcept
     {
         return false;
     }
 
     template <typename F>
-    HPX_CONSTEXPR bool is_empty_function(F const& f) noexcept
+    constexpr bool is_empty_function(F const& f) noexcept
     {
         return detail::is_empty_function_impl(&f);
     }
@@ -120,7 +120,7 @@ namespace hpx { namespace util { namespace detail {
         using vtable = function_vtable<R(Ts...), Copyable>;
 
     public:
-        HPX_CONSTEXPR basic_function() noexcept
+        constexpr basic_function() noexcept
           : base_type(get_empty_vtable())
         {
         }
@@ -234,7 +234,7 @@ namespace hpx { namespace util { namespace detail {
         using base_type::get_function_annotation_itt;
 
     private:
-        static HPX_CONSTEXPR vtable const* get_empty_vtable() noexcept
+        static constexpr vtable const* get_empty_vtable() noexcept
         {
             return detail::get_empty_function_vtable<R(Ts...)>();
         }
diff --git a/libs/functional/include/hpx/functional/detail/empty_function.hpp b/libs/functional/include/hpx/functional/detail/empty_function.hpp
index 1c7c002df3..3a96f49448 100644
--- a/libs/functional/include/hpx/functional/detail/empty_function.hpp
+++ b/libs/functional/include/hpx/functional/detail/empty_function.hpp
@@ -35,9 +35,9 @@ namespace hpx { namespace util { namespace detail {
 // NOTE: nvcc (at least CUDA 9.2 and 10.1) fails with an internal compiler error
 // ("there was an error in verifying the lgenfe output!") with this enabled, so
 // we explicitly use the fallback.
-#if defined(HPX_HAVE_CXX11_CONSTEXPR) && !defined(HPX_HAVE_CUDA)
+#if !defined(HPX_HAVE_CUDA)
             template <typename Sig>
-            HPX_CONSTEXPR function_vtable<Sig, true> const*
+            constexpr function_vtable<Sig, true> const*
             get_empty_function_vtable() noexcept
             {
                 return &vtables<function_vtable<Sig, true>,
diff --git a/libs/functional/include/hpx/functional/detail/vtable/callable_vtable.hpp b/libs/functional/include/hpx/functional/detail/vtable/callable_vtable.hpp
index 9a4b38bc13..8c2b260249 100644
--- a/libs/functional/include/hpx/functional/detail/vtable/callable_vtable.hpp
+++ b/libs/functional/include/hpx/functional/detail/vtable/callable_vtable.hpp
@@ -54,7 +54,7 @@ namespace hpx { namespace util { namespace detail {
 #endif
 
         template <typename T>
-        HPX_CONSTEXPR callable_info_vtable(construct_vtable<T>) noexcept
+        constexpr callable_info_vtable(construct_vtable<T>) noexcept
 #if defined(HPX_HAVE_THREAD_DESCRIPTION)
           : get_function_address(
                 &callable_info_vtable::template _get_function_address<T>)
@@ -68,7 +68,7 @@ namespace hpx { namespace util { namespace detail {
         {
         }
 
-        HPX_CONSTEXPR callable_info_vtable(
+        constexpr callable_info_vtable(
             construct_vtable<empty_function>) noexcept
 #if defined(HPX_HAVE_THREAD_DESCRIPTION)
           : get_function_address(nullptr)
@@ -96,7 +96,7 @@ namespace hpx { namespace util { namespace detail {
         R (*invoke)(void*, Ts&&...);
 
         template <typename T>
-        HPX_CONSTEXPR callable_vtable(construct_vtable<T>) noexcept
+        constexpr callable_vtable(construct_vtable<T>) noexcept
           : invoke(&callable_vtable::template _invoke<T>)
         {
         }
@@ -106,7 +106,7 @@ namespace hpx { namespace util { namespace detail {
             return throw_bad_function_call<R>();
         }
 
-        HPX_CONSTEXPR callable_vtable(construct_vtable<empty_function>) noexcept
+        constexpr callable_vtable(construct_vtable<empty_function>) noexcept
           : invoke(&callable_vtable::_empty_invoke)
         {
         }
diff --git a/libs/functional/include/hpx/functional/detail/vtable/copyable_vtable.hpp b/libs/functional/include/hpx/functional/detail/vtable/copyable_vtable.hpp
index 7badb49c9d..b17de42f45 100644
--- a/libs/functional/include/hpx/functional/detail/vtable/copyable_vtable.hpp
+++ b/libs/functional/include/hpx/functional/detail/vtable/copyable_vtable.hpp
@@ -30,13 +30,13 @@ namespace hpx { namespace util { namespace detail {
         }
         void* (*copy)(void*, std::size_t, void const*, bool);
 
-        HPX_CONSTEXPR copyable_vtable(std::nullptr_t) noexcept
+        constexpr copyable_vtable(std::nullptr_t) noexcept
           : copy(nullptr)
         {
         }
 
         template <typename T>
-        HPX_CONSTEXPR copyable_vtable(construct_vtable<T>) noexcept
+        constexpr copyable_vtable(construct_vtable<T>) noexcept
           : copy(&copyable_vtable::template _copy<T>)
         {
         }
diff --git a/libs/functional/include/hpx/functional/detail/vtable/function_vtable.hpp b/libs/functional/include/hpx/functional/detail/vtable/function_vtable.hpp
index fac43bb3f0..1b8eb1ac7a 100644
--- a/libs/functional/include/hpx/functional/detail/vtable/function_vtable.hpp
+++ b/libs/functional/include/hpx/functional/detail/vtable/function_vtable.hpp
@@ -23,7 +23,7 @@ namespace hpx { namespace util { namespace detail {
       , callable_info_vtable
     {
         template <typename T>
-        HPX_CONSTEXPR function_base_vtable(
+        constexpr function_base_vtable(
             construct_vtable<T>, std::integral_constant<bool, true>) noexcept
           : vtable(construct_vtable<T>())
           , copyable_vtable(construct_vtable<T>())
@@ -32,7 +32,7 @@ namespace hpx { namespace util { namespace detail {
         }
 
         template <typename T>
-        HPX_CONSTEXPR function_base_vtable(
+        constexpr function_base_vtable(
             construct_vtable<T>, std::integral_constant<bool, false>) noexcept
           : vtable(construct_vtable<T>())
           , copyable_vtable(nullptr)
@@ -53,14 +53,14 @@ namespace hpx { namespace util { namespace detail {
         using copyable_tag = std::integral_constant<bool, false>;
 
         template <typename T>
-        HPX_CONSTEXPR function_vtable(construct_vtable<T>) noexcept
+        constexpr function_vtable(construct_vtable<T>) noexcept
           : function_base_vtable(construct_vtable<T>(), copyable_tag{})
           , callable_vtable<Sig>(construct_vtable<T>())
         {
         }
 
         template <typename T, typename CopyableTag>
-        HPX_CONSTEXPR function_vtable(construct_vtable<T>, CopyableTag) noexcept
+        constexpr function_vtable(construct_vtable<T>, CopyableTag) noexcept
           : function_base_vtable(construct_vtable<T>(), CopyableTag{})
           , callable_vtable<Sig>(construct_vtable<T>())
         {
@@ -73,7 +73,7 @@ namespace hpx { namespace util { namespace detail {
         using copyable_tag = std::integral_constant<bool, true>;
 
         template <typename T>
-        HPX_CONSTEXPR function_vtable(construct_vtable<T>) noexcept
+        constexpr function_vtable(construct_vtable<T>) noexcept
           : function_vtable<Sig, false>(construct_vtable<T>(), copyable_tag{})
         {
         }
diff --git a/libs/functional/include/hpx/functional/detail/vtable/vtable.hpp b/libs/functional/include/hpx/functional/detail/vtable/vtable.hpp
index babbe3ad39..75950e0eae 100644
--- a/libs/functional/include/hpx/functional/detail/vtable/vtable.hpp
+++ b/libs/functional/include/hpx/functional/detail/vtable/vtable.hpp
@@ -24,15 +24,14 @@ namespace hpx { namespace util { namespace detail {
     template <typename VTable, typename T>
     struct vtables
     {
-        static HPX_CONSTEXPR_OR_CONST VTable instance =
-            detail::construct_vtable<T>();
+        static constexpr VTable instance = detail::construct_vtable<T>();
     };
 
     template <typename VTable, typename T>
-    HPX_CONSTEXPR_OR_CONST VTable vtables<VTable, T>::instance;
+    constexpr VTable vtables<VTable, T>::instance;
 
     template <typename VTable, typename T>
-    HPX_CONSTEXPR VTable const* get_vtable() noexcept
+    constexpr VTable const* get_vtable() noexcept
     {
         static_assert(
             !std::is_reference<T>::value, "T shall have no ref-qualifiers");
@@ -88,7 +87,7 @@ namespace hpx { namespace util { namespace detail {
         void (*deallocate)(void*, std::size_t storage_size, bool);
 
         template <typename T>
-        HPX_CONSTEXPR vtable(construct_vtable<T>) noexcept
+        constexpr vtable(construct_vtable<T>) noexcept
           : deallocate(&vtable::template _deallocate<T>)
         {
         }
diff --git a/libs/functional/include/hpx/functional/function.hpp b/libs/functional/include/hpx/functional/function.hpp
index ae4a945c5b..84fcfaa208 100644
--- a/libs/functional/include/hpx/functional/function.hpp
+++ b/libs/functional/include/hpx/functional/function.hpp
@@ -34,7 +34,7 @@ namespace hpx { namespace util {
     public:
         typedef R result_type;
 
-        HPX_CONSTEXPR function(std::nullptr_t = nullptr) noexcept {}
+        constexpr function(std::nullptr_t = nullptr) noexcept {}
 
         function(function const&) = default;
         function(function&&) noexcept = default;
diff --git a/libs/functional/include/hpx/functional/function_ref.hpp b/libs/functional/include/hpx/functional/function_ref.hpp
index a2f71167dc..badc2c1067 100644
--- a/libs/functional/include/hpx/functional/function_ref.hpp
+++ b/libs/functional/include/hpx/functional/function_ref.hpp
@@ -36,7 +36,7 @@ namespace hpx { namespace util {
           , callable_info_vtable
         {
             template <typename T>
-            HPX_CONSTEXPR function_ref_vtable(construct_vtable<T>) noexcept
+            constexpr function_ref_vtable(construct_vtable<T>) noexcept
               : callable_vtable<Sig>(construct_vtable<T>())
               , callable_info_vtable(construct_vtable<T>())
             {
@@ -45,19 +45,19 @@ namespace hpx { namespace util {
 
         ///////////////////////////////////////////////////////////////////////
         template <typename F>
-        HPX_CONSTEXPR bool is_empty_function_ptr(F* fp) noexcept
+        constexpr bool is_empty_function_ptr(F* fp) noexcept
         {
             return fp == nullptr;
         }
 
         template <typename T, typename C>
-        HPX_CONSTEXPR bool is_empty_function_ptr(T C::*mp) noexcept
+        constexpr bool is_empty_function_ptr(T C::*mp) noexcept
         {
             return mp == nullptr;
         }
 
         template <typename F>
-        HPX_CONSTEXPR bool is_empty_function_ptr(F const& f) noexcept
+        constexpr bool is_empty_function_ptr(F const& f) noexcept
         {
             return false;
         }
@@ -96,6 +96,7 @@ namespace hpx { namespace util {
             return *this;
         }
 
+        // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
         function_ref& operator=(function_ref const& other) noexcept
         {
             vptr = other.vptr;
diff --git a/libs/functional/include/hpx/functional/invoke.hpp b/libs/functional/include/hpx/functional/invoke.hpp
index 0939860a94..9fa23882e2 100644
--- a/libs/functional/include/hpx/functional/invoke.hpp
+++ b/libs/functional/include/hpx/functional/invoke.hpp
@@ -4,9 +4,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #ifndef HPX_UTIL_INVOKE_HPP
 #define HPX_UTIL_INVOKE_HPP
 
@@ -14,8 +11,6 @@
 #include <hpx/functional/result_of.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
-#include <boost/ref.hpp>
-
 #include <functional>
 #include <type_traits>
 #include <utility>
@@ -28,14 +23,14 @@ namespace hpx { namespace util {
         {
             T C::*f;
 
-            HPX_CONSTEXPR HPX_HOST_DEVICE invoke_mem_obj(T C::*mem_obj) noexcept
+            constexpr HPX_HOST_DEVICE invoke_mem_obj(T C::*mem_obj) noexcept
               : f(mem_obj)
             {
             }
 
             // t0.*f
             template <typename T0>
-            HPX_CONSTEXPR HPX_HOST_DEVICE typename std::enable_if<
+            constexpr HPX_HOST_DEVICE typename std::enable_if<
                 std::is_base_of<C, typename std::decay<T0>::type>::value,
                 util::invoke_result<T C::*, T0>>::type::type
             operator()(T0&& v0) const noexcept
@@ -45,7 +40,7 @@ namespace hpx { namespace util {
 
             // (*t0).*f
             template <typename T0>
-            HPX_CONSTEXPR HPX_HOST_DEVICE typename std::enable_if<
+            constexpr HPX_HOST_DEVICE typename std::enable_if<
                 !std::is_base_of<C, typename std::decay<T0>::type>::value,
                 util::invoke_result<T C::*, T0>>::type::type
             operator()(T0&& v0) const noexcept(noexcept(*std::forward<T0>(v0)))
@@ -59,14 +54,14 @@ namespace hpx { namespace util {
         {
             T C::*f;
 
-            HPX_CONSTEXPR HPX_HOST_DEVICE invoke_mem_fun(T C::*mem_fun) noexcept
+            constexpr HPX_HOST_DEVICE invoke_mem_fun(T C::*mem_fun) noexcept
               : f(mem_fun)
             {
             }
 
             // (t0.*f)(t1, ..., tN)
             template <typename T0, typename... Ts>
-            HPX_CONSTEXPR HPX_HOST_DEVICE typename std::enable_if<
+            constexpr HPX_HOST_DEVICE typename std::enable_if<
                 std::is_base_of<C, typename std::decay<T0>::type>::value,
                 util::invoke_result<T C::*, T0, Ts...>>::type::type
             operator()(T0&& v0, Ts&&... vs) const
@@ -76,7 +71,7 @@ namespace hpx { namespace util {
 
             // ((*t0).*f)(t1, ..., tN)
             template <typename T0, typename... Ts>
-            HPX_CONSTEXPR HPX_HOST_DEVICE typename std::enable_if<
+            constexpr HPX_HOST_DEVICE typename std::enable_if<
                 !std::is_base_of<C, typename std::decay<T0>::type>::value,
                 util::invoke_result<T C::*, T0, Ts...>>::type::type
             operator()(T0&& v0, Ts&&... vs) const
@@ -106,13 +101,6 @@ namespace hpx { namespace util {
             using type = X&;
         };
 
-        // support boost::[c]ref, which is not callable as std::[c]ref
-        template <typename F, typename X>
-        struct dispatch_invoke<F, ::boost::reference_wrapper<X>>
-        {
-            using type = X&;
-        };
-
         template <typename F>
         using dispatch_invoke_t =
             typename ::hpx::util::detail::dispatch_invoke<F>::type;
@@ -142,7 +130,7 @@ namespace hpx { namespace util {
     ///
     /// \note This function is similar to `std::invoke` (C++17)
     template <typename F, typename... Ts>
-    HPX_CONSTEXPR HPX_HOST_DEVICE typename util::invoke_result<F, Ts...>::type
+    constexpr HPX_HOST_DEVICE typename util::invoke_result<F, Ts...>::type
     invoke(F&& f, Ts&&... vs)
     {
         return HPX_INVOKE(std::forward<F>(f), std::forward<Ts>(vs)...);
@@ -154,7 +142,7 @@ namespace hpx { namespace util {
     /// \tparam R The result type of the function when it's called
     ///           with the content of the given argument types vs.
     template <typename R, typename F, typename... Ts>
-    HPX_CONSTEXPR HPX_HOST_DEVICE R invoke_r(F&& f, Ts&&... vs)
+    constexpr HPX_HOST_DEVICE R invoke_r(F&& f, Ts&&... vs)
     {
         return HPX_INVOKE_R(R, std::forward<F>(f), std::forward<Ts>(vs)...);
     }
@@ -164,7 +152,7 @@ namespace hpx { namespace util {
         struct invoke
         {
             template <typename F, typename... Ts>
-            HPX_CONSTEXPR HPX_HOST_DEVICE
+            constexpr HPX_HOST_DEVICE
                 typename util::invoke_result<F, Ts...>::type
                 operator()(F&& f, Ts&&... vs) const
             {
@@ -176,7 +164,7 @@ namespace hpx { namespace util {
         struct invoke_r
         {
             template <typename F, typename... Ts>
-            HPX_CONSTEXPR HPX_HOST_DEVICE R operator()(F&& f, Ts&&... vs) const
+            constexpr HPX_HOST_DEVICE R operator()(F&& f, Ts&&... vs) const
             {
                 return HPX_INVOKE_R(
                     R, std::forward<F>(f), std::forward<Ts>(vs)...);
diff --git a/libs/functional/include/hpx/functional/invoke_fused.hpp b/libs/functional/include/hpx/functional/invoke_fused.hpp
index e7b81a9804..c9cd74b02c 100644
--- a/libs/functional/include/hpx/functional/invoke_fused.hpp
+++ b/libs/functional/include/hpx/functional/invoke_fused.hpp
@@ -10,10 +10,10 @@
 #define HPX_UTIL_INVOKE_FUSED_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/invoke.hpp>
 #include <hpx/functional/result_of.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/type_support/void_guard.hpp>
 
 #include <cstddef>
@@ -35,14 +35,14 @@ namespace hpx { namespace util {
         struct fused_result_of_impl;
 
         template <typename F, typename Tuple, std::size_t... Is>
-        struct fused_result_of_impl<F, Tuple&, pack_c<std::size_t, Is...>>
+        struct fused_result_of_impl<F, Tuple&, index_pack<Is...>>
           : util::result_of<F(
                 typename util::tuple_element<Is, Tuple>::type&...)>
         {
         };
 
         template <typename F, typename Tuple, std::size_t... Is>
-        struct fused_result_of_impl<F, Tuple&&, pack_c<std::size_t, Is...>>
+        struct fused_result_of_impl<F, Tuple&&, index_pack<Is...>>
           : util::result_of<F(
                 typename util::tuple_element<Is, Tuple>::type&&...)>
         {
@@ -67,9 +67,8 @@ namespace hpx { namespace util {
 
         ///////////////////////////////////////////////////////////////////////
         template <std::size_t... Is, typename F, typename Tuple>
-        HPX_CONSTEXPR HPX_HOST_DEVICE
-            typename invoke_fused_result<F, Tuple>::type
-            invoke_fused_impl(pack_c<std::size_t, Is...>, F&& f, Tuple&& t)
+        constexpr HPX_HOST_DEVICE typename invoke_fused_result<F, Tuple>::type
+        invoke_fused_impl(index_pack<Is...>, F&& f, Tuple&& t)
         {
             return HPX_INVOKE(
                 std::forward<F>(f), util::get<Is>(std::forward<Tuple>(t))...);
@@ -94,7 +93,7 @@ namespace hpx { namespace util {
     ///
     /// \note This function is similar to `std::apply` (C++17)
     template <typename F, typename Tuple>
-    HPX_CONSTEXPR HPX_HOST_DEVICE
+    constexpr HPX_HOST_DEVICE
         typename detail::invoke_fused_result<F, Tuple>::type
         invoke_fused(F&& f, Tuple&& t)
     {
@@ -108,7 +107,7 @@ namespace hpx { namespace util {
     /// \tparam R The result type of the function when it's called
     ///           with the content of the given sequenced type.
     template <typename R, typename F, typename Tuple>
-    HPX_CONSTEXPR HPX_HOST_DEVICE R invoke_fused_r(F&& f, Tuple&& t)
+    constexpr HPX_HOST_DEVICE R invoke_fused_r(F&& f, Tuple&& t)
     {
         using index_pack = typename detail::fused_index_pack<Tuple>::type;
         return util::void_guard<R>(),
@@ -122,7 +121,7 @@ namespace hpx { namespace util {
         struct invoke_fused
         {
             template <typename F, typename Tuple>
-            HPX_CONSTEXPR HPX_HOST_DEVICE
+            constexpr HPX_HOST_DEVICE
                 typename util::detail::invoke_fused_result<F, Tuple>::type
                 operator()(F&& f, Tuple&& t) const
             {
@@ -137,7 +136,7 @@ namespace hpx { namespace util {
         struct invoke_fused_r
         {
             template <typename F, typename Tuple>
-            HPX_CONSTEXPR HPX_HOST_DEVICE R operator()(F&& f, Tuple&& t) const
+            constexpr HPX_HOST_DEVICE R operator()(F&& f, Tuple&& t) const
             {
                 using index_pack =
                     typename util::detail::fused_index_pack<Tuple>::type;
diff --git a/libs/functional/include/hpx/functional/mem_fn.hpp b/libs/functional/include/hpx/functional/mem_fn.hpp
index 91b8c21e52..2a68cf6a04 100644
--- a/libs/functional/include/hpx/functional/mem_fn.hpp
+++ b/libs/functional/include/hpx/functional/mem_fn.hpp
@@ -19,20 +19,19 @@ namespace hpx { namespace util {
         template <typename MemberPointer>
         struct mem_fn
         {
-            HPX_CONSTEXPR explicit mem_fn(MemberPointer pm)
+            constexpr explicit mem_fn(MemberPointer pm)
               : _pm(pm)
             {
             }
 
-            HPX_CONSTEXPR mem_fn(mem_fn const& other)
+            constexpr mem_fn(mem_fn const& other)
               : _pm(other._pm)
             {
             }
 
             template <typename... Ts>
-            HPX_CONSTEXPR
-                typename util::invoke_result<MemberPointer, Ts...>::type
-                operator()(Ts&&... vs) const
+            constexpr typename util::invoke_result<MemberPointer, Ts...>::type
+            operator()(Ts&&... vs) const
             {
                 return util::invoke(_pm, std::forward<Ts>(vs)...);
             }
@@ -42,19 +41,19 @@ namespace hpx { namespace util {
     }    // namespace detail
 
     template <typename M, typename C>
-    HPX_CONSTEXPR detail::mem_fn<M C::*> mem_fn(M C::*pm)
+    constexpr detail::mem_fn<M C::*> mem_fn(M C::*pm)
     {
         return detail::mem_fn<M C::*>(pm);
     }
 
     template <typename R, typename C, typename... Ps>
-    HPX_CONSTEXPR detail::mem_fn<R (C::*)(Ps...)> mem_fn(R (C::*pm)(Ps...))
+    constexpr detail::mem_fn<R (C::*)(Ps...)> mem_fn(R (C::*pm)(Ps...))
     {
         return detail::mem_fn<R (C::*)(Ps...)>(pm);
     }
 
     template <typename R, typename C, typename... Ps>
-    HPX_CONSTEXPR detail::mem_fn<R (C::*)(Ps...) const> mem_fn(
+    constexpr detail::mem_fn<R (C::*)(Ps...) const> mem_fn(
         R (C::*pm)(Ps...) const)
     {
         return detail::mem_fn<R (C::*)(Ps...) const>(pm);
diff --git a/libs/functional/include/hpx/functional/one_shot.hpp b/libs/functional/include/hpx/functional/one_shot.hpp
index 3813465364..70c9db6921 100644
--- a/libs/functional/include/hpx/functional/one_shot.hpp
+++ b/libs/functional/include/hpx/functional/one_shot.hpp
@@ -28,7 +28,7 @@ namespace hpx { namespace util {
         public:
 #if !defined(HPX_DISABLE_ASSERTS)
             // default constructor is needed for serialization
-            HPX_CONSTEXPR one_shot_wrapper()
+            constexpr one_shot_wrapper()
               : _called(false)
             {
             }
@@ -36,13 +36,13 @@ namespace hpx { namespace util {
             template <typename F_,
                 typename = typename std::enable_if<
                     std::is_constructible<F, F_>::value>::type>
-            HPX_CONSTEXPR explicit one_shot_wrapper(F_&& f)
+            constexpr explicit one_shot_wrapper(F_&& f)
               : _f(std::forward<F_>(f))
               , _called(false)
             {
             }
 
-            HPX_CXX14_CONSTEXPR one_shot_wrapper(one_shot_wrapper&& other)
+            constexpr one_shot_wrapper(one_shot_wrapper&& other)
               : _f(std::move(other._f))
               , _called(other._called)
             {
@@ -57,17 +57,17 @@ namespace hpx { namespace util {
             }
 #else
             // default constructor is needed for serialization
-            HPX_CONSTEXPR one_shot_wrapper() {}
+            constexpr one_shot_wrapper() {}
 
             template <typename F_,
                 typename = typename std::enable_if<
                     std::is_constructible<F, F_>::value>::type>
-            HPX_CONSTEXPR explicit one_shot_wrapper(F_&& f)
+            constexpr explicit one_shot_wrapper(F_&& f)
               : _f(std::forward<F_>(f))
             {
             }
 
-            HPX_CONSTEXPR one_shot_wrapper(one_shot_wrapper&& other)
+            constexpr one_shot_wrapper(one_shot_wrapper&& other)
               : _f(std::move(other._f))
             {
             }
@@ -76,7 +76,7 @@ namespace hpx { namespace util {
 #endif
 
             template <typename... Ts>
-            HPX_CXX14_CONSTEXPR HPX_HOST_DEVICE
+            constexpr HPX_HOST_DEVICE
                 typename util::invoke_result<F, Ts...>::type
                 operator()(Ts&&... vs)
             {
@@ -126,8 +126,8 @@ namespace hpx { namespace util {
     }    // namespace detail
 
     template <typename F>
-    HPX_CONSTEXPR detail::one_shot_wrapper<typename std::decay<F>::type>
-    one_shot(F&& f)
+    constexpr detail::one_shot_wrapper<typename std::decay<F>::type> one_shot(
+        F&& f)
     {
         typedef detail::one_shot_wrapper<typename std::decay<F>::type>
             result_type;
diff --git a/libs/functional/include/hpx/functional/result_of.hpp b/libs/functional/include/hpx/functional/result_of.hpp
index 2ec705909c..e11f0e9326 100644
--- a/libs/functional/include/hpx/functional/result_of.hpp
+++ b/libs/functional/include/hpx/functional/result_of.hpp
@@ -4,16 +4,11 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #ifndef HPX_UTIL_RESULT_OF_HPP
 #define HPX_UTIL_RESULT_OF_HPP
 
 #include <hpx/config.hpp>
 
-#include <boost/ref.hpp>
-
 #include <type_traits>
 #include <utility>
 
@@ -21,52 +16,10 @@ namespace hpx { namespace util {
     namespace detail {
         ///////////////////////////////////////////////////////////////////////
         // f(t0, t1, ..., tN)
-#if HPX_HAS_CXX14_LIB_RESULT_OF_SFINAE
         template <typename T>
         struct result_of_function_object : std::result_of<T>
         {
         };
-#else
-        namespace result_of_function_object_impl {
-            struct fallback
-            {
-                template <typename T>
-                fallback(T const&)
-                {
-                }
-            };
-
-            template <typename... Ts>
-            fallback invoke(fallback, Ts&&...);
-
-            template <typename F, typename... Ts>
-            decltype(std::declval<F>()(std::declval<Ts>()...)) invoke(
-                F&&, Ts&&...);
-
-            template <typename T>
-            struct result_of_invoke;
-
-            template <typename F, typename... Ts>
-            struct result_of_invoke<F(Ts...)>
-            {
-                typedef decltype(result_of_function_object_impl::invoke(
-                    std::declval<F>(), std::declval<Ts>()...)) type;
-            };
-
-            template <typename T,
-                typename R = typename result_of_invoke<T>::type>
-            struct result_of_function_object
-            {
-                typedef R type;
-            };
-
-            template <typename T>
-            struct result_of_function_object<T, fallback>
-            {
-            };
-        }    // namespace result_of_function_object_impl
-        using result_of_function_object_impl::result_of_function_object;
-#endif
 
         ///////////////////////////////////////////////////////////////////////
         template <typename T>
@@ -171,13 +124,6 @@ namespace hpx { namespace util {
           : result_of_member_pointer<C, R (C::*(Ts...))(Ps...) const>
         {
         };
-
-        // support boost::[c]ref, which is not callable as std::[c]ref
-        template <typename X, typename F, typename... Ts>
-        struct result_of_impl<::boost::reference_wrapper<X>, F(Ts...)>
-          : result_of_impl<X, X&(Ts...)>
-        {
-        };
     }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
diff --git a/libs/functional/include/hpx/functional/traits/get_action_name.hpp b/libs/functional/include/hpx/functional/traits/get_action_name.hpp
new file mode 100644
index 0000000000..b01a369f8b
--- /dev/null
+++ b/libs/functional/include/hpx/functional/traits/get_action_name.hpp
@@ -0,0 +1,28 @@
+//  Copyright (c) 2007-2016 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Lelbach
+//  Copyright (c)      2011 Thomas Heller
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_FUNCTIONAL_TRAITS_GET_ACTION_NAME_HPP
+#define HPX_FUNCTIONAL_TRAITS_GET_ACTION_NAME_HPP
+
+#include <hpx/config.hpp>
+#if defined(HPX_HAVE_NETWORKING) &&                                            \
+    (HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX))
+#include <hpx/concurrency/itt_notify.hpp>
+#endif
+
+namespace hpx { namespace actions { namespace detail {
+    template <typename Action>
+    char const* get_action_name();
+
+#if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
+    template <typename Action>
+    util::itt::string_handle const& get_action_name_itt();
+#endif
+}}}    // namespace hpx::actions::detail
+
+#endif
diff --git a/libs/functional/include/hpx/functional/traits/is_bind_expression.hpp b/libs/functional/include/hpx/functional/traits/is_bind_expression.hpp
index d2c535d7c0..9b8fb4c97a 100644
--- a/libs/functional/include/hpx/functional/traits/is_bind_expression.hpp
+++ b/libs/functional/include/hpx/functional/traits/is_bind_expression.hpp
@@ -9,19 +9,11 @@
 
 #include <hpx/config.hpp>
 
-#ifdef HPX_HAVE_CXX11_STD_IS_BIND_EXPRESSION
 #include <functional>
-#endif
-#include <type_traits>
 
 namespace hpx { namespace traits {
     template <typename T>
-    struct is_bind_expression
-#ifdef HPX_HAVE_CXX11_STD_IS_BIND_EXPRESSION
-      : std::is_bind_expression<T>
-#else
-      : std::false_type
-#endif
+    struct is_bind_expression : std::is_bind_expression<T>
     {
     };
 
diff --git a/libs/functional/include/hpx/functional/traits/is_placeholder.hpp b/libs/functional/include/hpx/functional/traits/is_placeholder.hpp
index 9bb13206f4..5e8406bddc 100644
--- a/libs/functional/include/hpx/functional/traits/is_placeholder.hpp
+++ b/libs/functional/include/hpx/functional/traits/is_placeholder.hpp
@@ -13,22 +13,16 @@
 
 #include <boost/bind/arg.hpp>
 
-#ifdef HPX_HAVE_CXX11_STD_IS_PLACEHOLDER
 #include <functional>
-#endif
 #include <type_traits>
 
 namespace hpx { namespace traits {
     template <typename T>
     struct is_placeholder
-#ifdef HPX_HAVE_CXX11_STD_IS_PLACEHOLDER
       : std::integral_constant<int,
             std::is_placeholder<T>::value != 0 ?
                 std::is_placeholder<T>::value :
                 boost::is_placeholder<T>::value>
-#else
-      : boost::is_placeholder<T>
-#endif
     {
     };
 
diff --git a/libs/functional/include/hpx/functional/unique_function.hpp b/libs/functional/include/hpx/functional/unique_function.hpp
index 80647d2130..acadd8ed68 100644
--- a/libs/functional/include/hpx/functional/unique_function.hpp
+++ b/libs/functional/include/hpx/functional/unique_function.hpp
@@ -34,7 +34,7 @@ namespace hpx { namespace util {
     public:
         typedef R result_type;
 
-        HPX_CONSTEXPR unique_function(std::nullptr_t = nullptr) noexcept {}
+        constexpr unique_function(std::nullptr_t = nullptr) noexcept {}
 
         unique_function(unique_function&&) noexcept = default;
         unique_function& operator=(unique_function&&) noexcept = default;
diff --git a/libs/functional/tests/unit/function/contains_test.cpp b/libs/functional/tests/unit/function/contains_test.cpp
index cbe1dad910..48a51d4e52 100644
--- a/libs/functional/tests/unit/function/contains_test.cpp
+++ b/libs/functional/tests/unit/function/contains_test.cpp
@@ -59,7 +59,7 @@ static void target_test()
     hpx::util::function_nonser<int()> f;
 
     f = &forty_two;
-    HPX_TEST(*f.target<int (*)()>() == &forty_two);
+    HPX_TEST_EQ(*f.target<int (*)()>(), &forty_two);
     HPX_TEST(!f.target<Seventeen>());
 
     f = Seventeen();
diff --git a/libs/functional/tests/unit/function/function_args.cpp b/libs/functional/tests/unit/function/function_args.cpp
index 14d4e2798b..2eb1cbd75f 100644
--- a/libs/functional/tests/unit/function/function_args.cpp
+++ b/libs/functional/tests/unit/function/function_args.cpp
@@ -72,9 +72,9 @@ void test_by_value()
     f(c);
     f(std::move(c));
 
-    HPX_TEST(counter::default_constructions == 1);
-    HPX_TEST(counter::copy_constructions <= 1);
-    HPX_TEST(counter::move_constructions <= 3);
+    HPX_TEST_EQ(counter::default_constructions, 1);
+    HPX_TEST_LTE(counter::copy_constructions, 1);
+    HPX_TEST_LTE(counter::move_constructions, 3);
 
     counter::print();
 }
@@ -91,9 +91,9 @@ void test_by_lvalue_ref()
     f(c);
     //f(std::move(c)); // cannot bind rvalue to lvalue-ref (except MSVC)
 
-    HPX_TEST(counter::default_constructions == 1);
-    HPX_TEST(counter::copy_constructions == 0);
-    HPX_TEST(counter::move_constructions == 0);
+    HPX_TEST_EQ(counter::default_constructions, 1);
+    HPX_TEST_EQ(counter::copy_constructions, 0);
+    HPX_TEST_EQ(counter::move_constructions, 0);
 
     counter::print();
 }
@@ -110,9 +110,9 @@ void test_by_const_lvalue_ref()
     f(c);
     f(std::move(c));
 
-    HPX_TEST(counter::default_constructions == 1);
-    HPX_TEST(counter::copy_constructions == 0);
-    HPX_TEST(counter::move_constructions == 0);
+    HPX_TEST_EQ(counter::default_constructions, 1);
+    HPX_TEST_EQ(counter::copy_constructions, 0);
+    HPX_TEST_EQ(counter::move_constructions, 0);
 
     counter::print();
 }
@@ -129,9 +129,9 @@ void test_by_rvalue_ref()
     //f(c); // cannot bind lvalue to rvalue-ref
     f(std::move(c));
 
-    HPX_TEST(counter::default_constructions == 1);
-    HPX_TEST(counter::copy_constructions == 0);
-    HPX_TEST(counter::move_constructions == 0);
+    HPX_TEST_EQ(counter::default_constructions, 1);
+    HPX_TEST_EQ(counter::copy_constructions, 0);
+    HPX_TEST_EQ(counter::move_constructions, 0);
 
     counter::print();
 }
diff --git a/libs/functional/tests/unit/function/function_arith.cpp b/libs/functional/tests/unit/function/function_arith.cpp
index ccaf40ed8a..c597e600c2 100644
--- a/libs/functional/tests/unit/function/function_arith.cpp
+++ b/libs/functional/tests/unit/function/function_arith.cpp
@@ -14,33 +14,33 @@
 #include <hpx/functional/function.hpp>
 #include <hpx/testing.hpp>
 
-float mul_ints(int x, int y)
+double mul_ints(int x, int y)
 {
-    return ((float) x) * y;
+    return ((double) x) * y;
 }
 
 struct int_div
 {
-    float operator()(int x, int y) const
+    double operator()(int x, int y) const
     {
-        return ((float) x) / y;
+        return ((double) x) / y;
     };
 };
 
 int main()
 {
-    hpx::util::function_nonser<float(int x, int y)> f;
+    hpx::util::function_nonser<double(int x, int y)> f;
 
     f = int_div();
     HPX_TEST(f);
-    HPX_TEST_EQ(f(5, 3), 5.f / 3);
+    HPX_TEST_EQ(f(5, 3), 5. / 3);
 
     f = nullptr;
     HPX_TEST(!f);
 
     f = &mul_ints;
     HPX_TEST(f);
-    HPX_TEST_EQ(f(5, 3), 5.f * 3);
+    HPX_TEST_EQ(f(5, 3), 5. * 3);
 
     return hpx::util::report_errors();
 }
diff --git a/libs/functional/tests/unit/function/function_ref.cpp b/libs/functional/tests/unit/function/function_ref.cpp
index 0f535f287d..de4a2e05d2 100644
--- a/libs/functional/tests/unit/function/function_ref.cpp
+++ b/libs/functional/tests/unit/function/function_ref.cpp
@@ -119,7 +119,7 @@ static void test_zero_args()
     func_void_type v1 = five;
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation and self-assignment
     v1 = three;
@@ -135,7 +135,7 @@ static void test_zero_args()
 #endif
 
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a function
     v1 = five;
@@ -153,97 +153,97 @@ static void test_zero_args()
 #endif
 
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v1 = write_five;
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v1 = write_three;
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v1 = five;
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v1 = &write_three;
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     func_void_type v2(v1);
     v2 = three;
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v2 = (five);
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v2 = (write_five);
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v2 = write_three;
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Swapping
     v1 = five;
     std::swap(v1, v2);
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
     std::swap(v1, v2);
 
     // Invocation
     v2 = five;
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v2 = &write_three;
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v1 = three;
     v2 = v1;
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assign to a function from a function with a function
     v2 = write_five;
     v1 = v2;
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construct a function given another function containing a function
     func_void_type v3(v1);
@@ -251,37 +251,37 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v3 = three;
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v3 = five;
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v3 = &write_five;
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v3 = &write_three;
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v3 = five;
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construction of a function from a function containing a functor
     func_void_type v4(v3);
@@ -289,13 +289,13 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v4 = three;
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a function
     v4 = five;
@@ -303,25 +303,25 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v4 = &write_five;
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v4 = &write_three;
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v4 = five;
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construction of a function from a functor
     func_void_type v5(five);
@@ -329,13 +329,13 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v5 = three;
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a function
     v5 = five;
@@ -343,25 +343,25 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v5 = &write_five;
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v5 = &write_three;
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v5 = five;
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construction of a function from a function
     func_void_type v6(&write_five);
@@ -369,13 +369,13 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v6 = three;
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a function
     v6 = five;
@@ -383,25 +383,25 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v6 = &write_five;
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation
     v6 = &write_three;
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Invocation
     v6 = five;
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Const vs. non-const
     write_const_1_nonconst_2 one_or_two;
@@ -410,11 +410,11 @@ static void test_zero_args()
 
     global_int = 0;
     v7();
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
 
     global_int = 0;
     v8();
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
 
     // Test return values
     typedef hpx::util::function_ref<int()> func_int_type;
@@ -423,25 +423,25 @@ static void test_zero_args()
 
     func_int_type i0(gen_five);
 
-    HPX_TEST(i0() == 5);
+    HPX_TEST_EQ(i0(), 5);
     i0 = gen_three;
-    HPX_TEST(i0() == 3);
+    HPX_TEST_EQ(i0(), 3);
     i0 = &generate_five;
-    HPX_TEST(i0() == 5);
+    HPX_TEST_EQ(i0(), 5);
     i0 = &generate_three;
-    HPX_TEST(i0() == 3);
+    HPX_TEST_EQ(i0(), 3);
 
     // Test return values with compatible types
     typedef hpx::util::function_ref<long()> func_long_type;
     func_long_type i1(gen_five);
 
-    HPX_TEST(i1() == 5);
+    HPX_TEST_EQ(i1(), 5);
     i1 = gen_three;
-    HPX_TEST(i1() == 3);
+    HPX_TEST_EQ(i1(), 3);
     i1 = &generate_five;
-    HPX_TEST(i1() == 5);
+    HPX_TEST_EQ(i1(), 5);
     i1 = &generate_three;
-    HPX_TEST(i1() == 3);
+    HPX_TEST_EQ(i1(), 3);
 }
 
 static void test_one_arg()
@@ -449,30 +449,30 @@ static void test_one_arg()
     std::negate<int> neg;
 
     hpx::util::function_ref<int(int)> f1(neg);
-    HPX_TEST(f1(5) == -5);
+    HPX_TEST_EQ(f1(5), -5);
 
     hpx::util::function_ref<string(string)> id(&identity_str);
-    HPX_TEST(id("str") == "str");
+    HPX_TEST_EQ(id("str"), "str");
 
     hpx::util::function_ref<string(const char*)> id2(&identity_str);
-    HPX_TEST(id2("foo") == "foo");
+    HPX_TEST_EQ(id2("foo"), "foo");
 
     add_to_obj add_to(5);
     hpx::util::function_ref<int(int)> f2(add_to);
-    HPX_TEST(f2(3) == 8);
+    HPX_TEST_EQ(f2(3), 8);
 
     const hpx::util::function_ref<int(int)> cf2(add_to);
-    HPX_TEST(cf2(3) == 8);
+    HPX_TEST_EQ(cf2(3), 8);
 }
 
 static void test_two_args()
 {
     hpx::util::function_ref<string(const string&, const string&)> cat(
         &string_cat);
-    HPX_TEST(cat("str", "ing") == "string");
+    HPX_TEST_EQ(cat("str", "ing"), "string");
 
     hpx::util::function_ref<int(short, short)> sum(&sum_ints);
-    HPX_TEST(sum(2, 3) == 5);
+    HPX_TEST_EQ(sum(2, 3), 5);
 }
 
 struct add_with_throw_on_copy
@@ -501,7 +501,7 @@ static void test_ref()
     try
     {
         hpx::util::function_ref<int(int, int)> f(std::ref(atc));
-        HPX_TEST(f(1, 3) == 4);
+        HPX_TEST_EQ(f(1, 3), 4);
     }
     catch (std::runtime_error const& /*e*/)
     {
@@ -520,7 +520,7 @@ static void test_ptr_ref()
     global_int = 0;
     void_ptr = &write_three;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation and assignment
     void_ptr = &write_five;
@@ -528,19 +528,19 @@ static void test_ptr_ref()
     global_int = 0;
     void_ptr = &write_three;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Invocation of a function
     int (*int_ptr)() = &generate_five;
     func_int_type v2 = int_ptr;
     int_ptr = &generate_three;
-    HPX_TEST(v2() == 5);
+    HPX_TEST_EQ(v2(), 5);
 
     // Invocation and assignment
     int_ptr = &generate_five;
     v2 = int_ptr;
     int_ptr = &generate_three;
-    HPX_TEST(v2() == 5);
+    HPX_TEST_EQ(v2(), 5);
 }
 
 struct big_aggregating_structure
@@ -582,26 +582,26 @@ static void test_copy_semantics()
     f1_type f1 = obj;
     global_int = 0;
     f1();
-    HPX_TEST(global_int == 1);
+    HPX_TEST_EQ(global_int, 1);
 
     // Testing rvalue constructors
     f1_type f2(static_cast<f1_type&&>(f1));
-    HPX_TEST(global_int == 1);
+    HPX_TEST_EQ(global_int, 1);
     f2();
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
 
     f1_type f3(static_cast<f1_type&&>(f2));
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
     f3();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Testing, that no copies are made
     f1_type f4 = obj;
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
     f1_type f5 = obj;
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
     f4 = static_cast<f1_type&&>(f5);
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 }
 
 int main(int, char*[])
diff --git a/libs/functional/tests/unit/function/function_test.cpp b/libs/functional/tests/unit/function/function_test.cpp
index acb1e424ff..74a660d071 100644
--- a/libs/functional/tests/unit/function/function_test.cpp
+++ b/libs/functional/tests/unit/function/function_test.cpp
@@ -141,7 +141,7 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset() method
     v1.reset();
@@ -164,7 +164,7 @@ static void test_zero_args()
 #endif
 
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a non-empty function
     v1 = five;
@@ -182,7 +182,7 @@ static void test_zero_args()
 #endif
 
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // clear
     void (*fpv1)() = 0;    // NOLINT
@@ -200,7 +200,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v1 = write_three;
@@ -209,7 +209,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment
     v1 = five;
@@ -218,7 +218,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v1 = &write_three;
@@ -227,7 +227,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Construction from another function (that is empty)
     v1.reset();
@@ -241,7 +241,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a non-empty function
     v2 = (five);
@@ -249,7 +249,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     v2.reset();
     HPX_TEST(v2.empty());
@@ -261,7 +261,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v2 = write_three;
@@ -270,15 +270,15 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Swapping
     v1 = five;
     std::swap(v1, v2);
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
     std::swap(v1, v2);
     v1.reset();
 
@@ -289,7 +289,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v2 = &write_three;
@@ -298,7 +298,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a function from an empty function
     v2 = v1;
@@ -313,10 +313,10 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assign to a function from a function with a function
     v2 = write_five;
@@ -325,10 +325,10 @@ static void test_zero_args()
     HPX_TEST(!v2.empty());
     global_int = 0;
     v1();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
     global_int = 0;
     v2();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construct a function given another function containing a function
     func_void_type v3(v1);
@@ -336,7 +336,7 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset() method
     v3.reset();
@@ -349,7 +349,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a non-empty function
     v3 = five;
@@ -357,7 +357,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset()
     v3.reset();
@@ -370,7 +370,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v3 = &write_three;
@@ -379,7 +379,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment
     v3 = five;
@@ -388,7 +388,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v3();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construction of a function from a function containing a functor
     func_void_type v4(v3);
@@ -396,7 +396,7 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset() method
     v4.reset();
@@ -409,7 +409,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a non-empty function
     v4 = five;
@@ -417,7 +417,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset()
     v4.reset();
@@ -430,7 +430,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v4 = &write_three;
@@ -439,7 +439,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment
     v4 = five;
@@ -448,7 +448,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v4();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construction of a function from a functor
     func_void_type v5(five);
@@ -456,7 +456,7 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset() method
     v5.reset();
@@ -469,7 +469,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a non-empty function
     v5 = five;
@@ -477,7 +477,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset()
     v5.reset();
@@ -490,7 +490,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v5 = &write_three;
@@ -499,7 +499,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment
     v5 = five;
@@ -508,7 +508,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v5();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Construction of a function from a function
     func_void_type v6(&write_five);
@@ -516,7 +516,7 @@ static void test_zero_args()
     // Invocation of a function
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset() method
     v6.reset();
@@ -529,7 +529,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment to a non-empty function
     v6 = five;
@@ -537,7 +537,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // reset()
     v6.reset();
@@ -550,7 +550,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Assignment to a non-empty function from a free function
     v6 = &write_three;
@@ -559,7 +559,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Assignment
     v6 = five;
@@ -568,7 +568,7 @@ static void test_zero_args()
     // Invocation
     global_int = 0;
     v6();
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
 
     // Const vs. non-const
     write_const_1_nonconst_2 one_or_two;
@@ -577,11 +577,11 @@ static void test_zero_args()
 
     global_int = 0;
     v7();
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
 
     global_int = 0;
     v8();
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
 
     // Test construction from 0
     void (*fpv9)() = 0;    // NOLINT
@@ -599,13 +599,13 @@ static void test_zero_args()
 
     func_int_type i0(gen_five);
 
-    HPX_TEST(i0() == 5);
+    HPX_TEST_EQ(i0(), 5);
     i0 = gen_three;
-    HPX_TEST(i0() == 3);
+    HPX_TEST_EQ(i0(), 3);
     i0 = &generate_five;
-    HPX_TEST(i0() == 5);
+    HPX_TEST_EQ(i0(), 5);
     i0 = &generate_three;
-    HPX_TEST(i0() == 3);
+    HPX_TEST_EQ(i0(), 3);
     HPX_TEST(!i0.empty());
     i0.reset();
     HPX_TEST(!i0);
@@ -614,13 +614,13 @@ static void test_zero_args()
     typedef hpx::util::function_nonser<long()> func_long_type;
     func_long_type i1(gen_five);
 
-    HPX_TEST(i1() == 5);
+    HPX_TEST_EQ(i1(), 5);
     i1 = gen_three;
-    HPX_TEST(i1() == 3);
+    HPX_TEST_EQ(i1(), 3);
     i1 = &generate_five;
-    HPX_TEST(i1() == 5);
+    HPX_TEST_EQ(i1(), 5);
     i1 = &generate_three;
-    HPX_TEST(i1() == 3);
+    HPX_TEST_EQ(i1(), 3);
     HPX_TEST(!i1.empty());
     i1.reset();
     HPX_TEST(!i1);
@@ -631,30 +631,30 @@ static void test_one_arg()
     std::negate<int> neg;
 
     hpx::util::function_nonser<int(int)> f1(neg);
-    HPX_TEST(f1(5) == -5);
+    HPX_TEST_EQ(f1(5), -5);
 
     hpx::util::function_nonser<string(string)> id(&identity_str);
-    HPX_TEST(id("str") == "str");
+    HPX_TEST_EQ(id("str"), "str");
 
     hpx::util::function_nonser<string(const char*)> id2(&identity_str);
-    HPX_TEST(id2("foo") == "foo");
+    HPX_TEST_EQ(id2("foo"), "foo");
 
     add_to_obj add_to(5);
     hpx::util::function_nonser<int(int)> f2(add_to);
-    HPX_TEST(f2(3) == 8);
+    HPX_TEST_EQ(f2(3), 8);
 
     const hpx::util::function_nonser<int(int)> cf2(add_to);
-    HPX_TEST(cf2(3) == 8);
+    HPX_TEST_EQ(cf2(3), 8);
 }
 
 static void test_two_args()
 {
     hpx::util::function_nonser<string(const string&, const string&)> cat(
         &string_cat);
-    HPX_TEST(cat("str", "ing") == "string");
+    HPX_TEST_EQ(cat("str", "ing"), "string");
 
     hpx::util::function_nonser<int(short, short)> sum(&sum_ints);
-    HPX_TEST(sum(2, 3) == 5);
+    HPX_TEST_EQ(sum(2, 3), 5);
 }
 
 static void test_emptiness()
@@ -697,18 +697,18 @@ static void test_member_functions()
     X one(1);
     X five(5);
 
-    HPX_TEST(f1(&one) == 2);
-    HPX_TEST(f1(&five) == 10);
+    HPX_TEST_EQ(f1(&one), 2);
+    HPX_TEST_EQ(f1(&five), 10);
 
     hpx::util::function_nonser<int(X*)> f1_2;
     f1_2 = &X::twice;
 
-    HPX_TEST(f1_2(&one) == 2);
-    HPX_TEST(f1_2(&five) == 10);
+    HPX_TEST_EQ(f1_2(&one), 2);
+    HPX_TEST_EQ(f1_2(&five), 10);
 
     hpx::util::function_nonser<int(X&, int)> f2(&X::plus);
-    HPX_TEST(f2(one, 3) == 4);
-    HPX_TEST(f2(five, 4) == 9);
+    HPX_TEST_EQ(f2(one, 3), 4);
+    HPX_TEST_EQ(f2(five, 4), 9);
 }
 
 struct add_with_throw_on_copy
@@ -737,7 +737,7 @@ static void test_ref()
     try
     {
         hpx::util::function_nonser<int(int, int)> f(std::ref(atc));
-        HPX_TEST(f(1, 3) == 4);
+        HPX_TEST_EQ(f(1, 3), 4);
     }
     catch (std::runtime_error const& /*e*/)
     {
@@ -855,23 +855,23 @@ static void test_move_semantics()
     f1();
 
     HPX_TEST(!f1.empty());
-    HPX_TEST(global_int == 1);
+    HPX_TEST_EQ(global_int, 1);
 
     // Testing rvalue constructors
     f1_type f2(static_cast<f1_type&&>(f1));
     HPX_TEST(f1.empty());
     HPX_TEST(!f2.empty());
-    HPX_TEST(global_int == 1);
+    HPX_TEST_EQ(global_int, 1);
     f2();
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
 
     f1_type f3(static_cast<f1_type&&>(f2));
     HPX_TEST(f1.empty());
     HPX_TEST(f2.empty());
     HPX_TEST(!f3.empty());
-    HPX_TEST(global_int == 2);
+    HPX_TEST_EQ(global_int, 2);
     f3();
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
 
     // Testing move assignment
     f1_type f4;
@@ -881,23 +881,23 @@ static void test_move_semantics()
     HPX_TEST(f2.empty());
     HPX_TEST(f3.empty());
     HPX_TEST(!f4.empty());
-    HPX_TEST(global_int == 3);
+    HPX_TEST_EQ(global_int, 3);
     f4();
-    HPX_TEST(global_int == 4);
+    HPX_TEST_EQ(global_int, 4);
 
     // Testing self move assignment
     f4 = static_cast<f1_type&&>(f4);
     HPX_TEST(!f4.empty());
-    HPX_TEST(global_int == 4);
+    HPX_TEST_EQ(global_int, 4);
 
     // Testing, that no memory leaked when assigning to nonempty function
     f4 = obj;
     HPX_TEST(!f4.empty());
-    HPX_TEST(global_int == 4);
+    HPX_TEST_EQ(global_int, 4);
     f1_type f5 = obj;
-    HPX_TEST(global_int == 5);
+    HPX_TEST_EQ(global_int, 5);
     f4 = static_cast<f1_type&&>(f5);
-    HPX_TEST(global_int == 4);
+    HPX_TEST_EQ(global_int, 4);
 }
 
 int main(int, char*[])
diff --git a/libs/functional/tests/unit/function/nothrow_swap.cpp b/libs/functional/tests/unit/function/nothrow_swap.cpp
index ca7ae2eac5..48f5e6ddf6 100644
--- a/libs/functional/tests/unit/function/nothrow_swap.cpp
+++ b/libs/functional/tests/unit/function/nothrow_swap.cpp
@@ -33,6 +33,7 @@ struct MaybeThrowOnCopy
             throw tried_to_copy();
     }
 
+    // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
     MaybeThrowOnCopy& operator=(const MaybeThrowOnCopy& other)
     {
         if (throwOnCopy)
@@ -65,13 +66,13 @@ int main(int, char*[])
     MaybeThrowOnCopy::throwOnCopy = false;
     f = MaybeThrowOnCopy(1);
     g = MaybeThrowOnCopy(2);
-    HPX_TEST(f() == 1);
-    HPX_TEST(g() == 2);
+    HPX_TEST_EQ(f(), 1);
+    HPX_TEST_EQ(g(), 2);
 
     MaybeThrowOnCopy::throwOnCopy = true;
     f.swap(g);
-    HPX_TEST(f() == 2);
-    HPX_TEST(g() == 1);
+    HPX_TEST_EQ(f(), 2);
+    HPX_TEST_EQ(g(), 1);
 
     return hpx::util::report_errors();
 }
diff --git a/libs/functional/tests/unit/function/sum_avg.cpp b/libs/functional/tests/unit/function/sum_avg.cpp
index 3ac6642465..017974eee9 100644
--- a/libs/functional/tests/unit/function/sum_avg.cpp
+++ b/libs/functional/tests/unit/function/sum_avg.cpp
@@ -14,17 +14,17 @@
 #include <hpx/functional/function.hpp>
 #include <hpx/testing.hpp>
 
-void do_sum_avg(int values[], int n, int& sum, float& avg)
+void do_sum_avg(int values[], int n, int& sum, double& avg)
 {
     sum = 0;
     for (int i = 0; i < n; i++)
         sum += values[i];
-    avg = (float) sum / n;
+    avg = (double) sum / n;
 }
 
 int main()
 {
-    hpx::util::function_nonser<void(int values[], int n, int& sum, float& avg)>
+    hpx::util::function_nonser<void(int values[], int n, int& sum, double& avg)>
         sum_avg;
     sum_avg = &do_sum_avg;
 
diff --git a/libs/hardware/CMakeLists.txt b/libs/hardware/CMakeLists.txt
index ba93646167..54904f51ea 100644
--- a/libs/hardware/CMakeLists.txt
+++ b/libs/hardware/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/hardware/README.rst b/libs/hardware/README.rst
index a6ea20b7c2..55cd4d0366 100644
--- a/libs/hardware/README.rst
+++ b/libs/hardware/README.rst
@@ -12,4 +12,4 @@ hardware
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/hardware/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/hardware/docs/index.html>`__.
diff --git a/libs/hashing/CMakeLists.txt b/libs/hashing/CMakeLists.txt
index 4d2c7ebac1..232b486e38 100644
--- a/libs/hashing/CMakeLists.txt
+++ b/libs/hashing/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(hashing_headers
   hpx/hashing/fibhash.hpp
diff --git a/libs/hashing/README.rst b/libs/hashing/README.rst
index 4eb69fd073..76327641b4 100644
--- a/libs/hashing/README.rst
+++ b/libs/hashing/README.rst
@@ -12,4 +12,4 @@ hashing
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/hashing/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/hashing/docs/index.html>`__.
diff --git a/libs/hashing/include/hpx/hashing/fibhash.hpp b/libs/hashing/include/hpx/hashing/fibhash.hpp
index 4f92dd9954..2c68549397 100644
--- a/libs/hashing/include/hpx/hashing/fibhash.hpp
+++ b/libs/hashing/include/hpx/hashing/fibhash.hpp
@@ -43,7 +43,7 @@ namespace hpx { namespace util {
     // This function calculates the hash based on a multiplicative Fibonacci
     // scheme
     template <std::uint64_t N>
-    HPX_CONSTEXPR std::uint64_t fibhash(std::uint64_t i)
+    constexpr std::uint64_t fibhash(std::uint64_t i)
     {
         using helper = detail::hash_helper<N>;
         static_assert(N != 0, "This algorithm only works with N != 0");
diff --git a/libs/io_service/CMakeLists.txt b/libs/io_service/CMakeLists.txt
new file mode 100644
index 0000000000..08decc6291
--- /dev/null
+++ b/libs/io_service/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(io_service_headers
+  hpx/io_service/io_service_pool.hpp
+  hpx/io_service/io_service_thread_pool.hpp)
+
+set(io_service_compat_headers
+  hpx/runtime/threads/detail/io_service_thread_pool.hpp
+  hpx/util/io_service_pool.hpp)
+
+set(io_service_sources
+  io_service_pool.cpp
+  io_service_thread_pool.cpp)
+
+include(HPX_AddModule)
+add_hpx_module(io_service
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${io_service_sources}
+  HEADERS ${io_service_headers}
+  COMPAT_HEADERS ${io_service_compat_headers}
+  DEPENDENCIES
+    hpx_assertion
+    hpx_concurrency
+    hpx_config
+    hpx_errors
+    hpx_functional
+    hpx_logging
+    hpx_threading_base
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/io_service/README.rst b/libs/io_service/README.rst
new file mode 100644
index 0000000000..7d3085a4c4
--- /dev/null
+++ b/libs/io_service/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+==========
+io_service
+==========
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/io_service/docs/index.html>`__.
diff --git a/libs/io_service/docs/index.rst b/libs/io_service/docs/index.rst
new file mode 100644
index 0000000000..e77d91aa02
--- /dev/null
+++ b/libs/io_service/docs/index.rst
@@ -0,0 +1,18 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_io_service:
+
+==========
+io_service
+==========
+
+TODO: High-level description of the library.
+
+See the :ref:`API reference <libs_io_service_api>` of this module for more
+details.
+
diff --git a/libs/io_service/examples/CMakeLists.txt b/libs/io_service/examples/CMakeLists.txt
new file mode 100644
index 0000000000..c5f62cde72
--- /dev/null
+++ b/libs/io_service/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.io_service)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.io_service)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_IO_SERVICE_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.io_service)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.io_service)
+  endif()
+endif()
diff --git a/hpx/util/io_service_pool.hpp b/libs/io_service/include/hpx/io_service/io_service_pool.hpp
similarity index 68%
rename from hpx/util/io_service_pool.hpp
rename to libs/io_service/include/hpx/io_service/io_service_pool.hpp
index 9fbabf4ad7..7480430a63 100644
--- a/hpx/util/io_service_pool.hpp
+++ b/libs/io_service/include/hpx/io_service/io_service_pool.hpp
@@ -14,7 +14,7 @@
 #include <hpx/config/asio.hpp>
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/functional/function.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
 
 #include <boost/asio/io_service.hpp>
 /* The boost asio support includes termios.h.
@@ -33,8 +33,7 @@
 #include <hpx/config/warnings_prefix.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     /// A pool of io_service objects.
     class HPX_EXPORT io_service_pool
     {
@@ -92,17 +91,23 @@ namespace hpx { namespace util
         std::thread& get_os_thread_handle(std::size_t thread_num);
 
         /// \brief Get number of threads associated with this I/O service.
-        std::size_t size() const { return pool_size_; }
+        std::size_t size() const
+        {
+            return pool_size_;
+        }
 
         /// \brief Activate the thread \a index for this thread pool
         void thread_run(std::size_t index, barrier* startup = nullptr);
 
         /// \brief Return name of this pool
-        char const* get_name() const { return pool_name_; }
+        char const* get_name() const
+        {
+            return pool_name_;
+        }
 
     protected:
-        bool run_locked(std::size_t num_threads, bool join_threads,
-            barrier* startup);
+        bool run_locked(
+            std::size_t num_threads, bool join_threads, barrier* startup);
         void stop_locked();
         void join_locked();
         void clear_locked();
@@ -113,57 +118,58 @@ namespace hpx { namespace util
 
 // FIXME: Intel compilers don't like this
 #if defined(HPX_NATIVE_MIC)
-        typedef std::unique_ptr<boost::asio::io_service::work> work_type;
+            typedef std::unique_ptr<boost::asio::io_service::work> work_type;
 #else
-        using work_type = boost::asio::io_service::work;
+            using work_type = boost::asio::io_service::work;
 #endif
 
-        HPX_FORCEINLINE work_type initialize_work(boost::asio::io_service& io_service)
-        {
-            return work_type(
+            HPX_FORCEINLINE work_type initialize_work(
+                boost::asio::io_service& io_service)
+            {
+                return work_type(
 // FIXME: Intel compilers don't like this
 #if defined(HPX_NATIVE_MIC)
                     new boost::asio::io_service::work(io_service)
 #else
                     io_service
 #endif
-            );
-        }
+                );
+            }
 
-        std::mutex mtx_;
+            std::mutex mtx_;
 
-        /// The pool of io_services.
-        std::vector<io_service_ptr> io_services_;
-        std::vector<std::thread> threads_;
+            /// The pool of io_services.
+            std::vector<io_service_ptr> io_services_;
+            std::vector<std::thread> threads_;
 
-        /// The work that keeps the io_services running.
-        std::vector<work_type> work_;
+            /// The work that keeps the io_services running.
+            std::vector<work_type> work_;
 
-        /// The next io_service to use for a connection.
-        std::size_t next_io_service_;
+            /// The next io_service to use for a connection.
+            std::size_t next_io_service_;
 
-        /// set to true if stopped
-        bool stopped_;
+            /// set to true if stopped
+            bool stopped_;
 
-        /// initial number of OS threads to execute in this pool
-        std::size_t pool_size_;
+            /// initial number of OS threads to execute in this pool
+            std::size_t pool_size_;
 
-        /// call this for each thread start/stop
-        threads::policies::callback_notifier const& notifier_;
+            /// call this for each thread start/stop
+            threads::policies::callback_notifier const& notifier_;
 
-        char const* pool_name_;
-        char const* pool_name_postfix_;
+            char const* pool_name_;
+            char const* pool_name_postfix_;
 
-        /// Set to true if waiting for work to finish
-        bool waiting_;
+            /// Set to true if waiting for work to finish
+            bool waiting_;
 
-        // Barriers for waiting for work to finish on all worker threads
-        barrier wait_barrier_;
-        barrier continue_barrier_;
-    };
+            // Barriers for waiting for work to finish on all worker threads
+            barrier wait_barrier_;
+            barrier continue_barrier_;
+        };
 
-///////////////////////////////////////////////////////////////////////////////
-}}  // namespace hpx::util
+        ///////////////////////////////////////////////////////////////////////////////
+}}    // namespace hpx::util
 
 #include <hpx/config/warnings_suffix.hpp>
 
diff --git a/hpx/runtime/threads/detail/io_service_thread_pool.hpp b/libs/io_service/include/hpx/io_service/io_service_thread_pool.hpp
similarity index 81%
rename from hpx/runtime/threads/detail/io_service_thread_pool.hpp
rename to libs/io_service/include/hpx/io_service/io_service_thread_pool.hpp
index ebbebb1acb..03f47c3cbd 100644
--- a/hpx/runtime/threads/detail/io_service_thread_pool.hpp
+++ b/libs/io_service/include/hpx/io_service/io_service_thread_pool.hpp
@@ -8,23 +8,22 @@
 #define HPX_IO_SERVICE_THREAD_POOL_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/state.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
-#include <mutex>
 #include <cstddef>
 #include <cstdint>
 #include <exception>
 #include <iosfwd>
+#include <mutex>
 #include <utility>
 
 #include <hpx/config/warnings_prefix.hpp>
 
-namespace hpx { namespace threads { namespace detail
-{
+namespace hpx { namespace threads { namespace detail {
     ///////////////////////////////////////////////////////////////////////////
     class HPX_EXPORT io_service_thread_pool : public thread_pool_base
     {
@@ -61,7 +60,7 @@ namespace hpx { namespace threads { namespace detail
         bool run(std::unique_lock<std::mutex>& l, std::size_t pool_threads);
 
         ///////////////////////////////////////////////////////////////////////
-        void stop (std::unique_lock<std::mutex>& l, bool blocking = true);
+        void stop(std::unique_lock<std::mutex>& l, bool blocking = true);
 
         ///////////////////////////////////////////////////////////////////////
         void resume_direct(error_code& ec = throws);
@@ -69,11 +68,11 @@ namespace hpx { namespace threads { namespace detail
         void suspend_direct(error_code& ec = throws);
 
         ///////////////////////////////////////////////////////////////////////
-        void suspend_processing_unit_direct(std::size_t virt_core,
-            error_code& ec = throws);
+        void suspend_processing_unit_direct(
+            std::size_t virt_core, error_code& ec = throws);
 
-        void resume_processing_unit_direct(std::size_t virt_core,
-            error_code& ec = throws);
+        void resume_processing_unit_direct(
+            std::size_t virt_core, error_code& ec = throws);
 
         ///////////////////////////////////////////////////////////////////////
         std::thread& get_os_thread_handle(std::size_t global_thread_num);
@@ -91,8 +90,8 @@ namespace hpx { namespace threads { namespace detail
         void get_statistics(executor_statistics& stats, error_code& ec) const;
 
         // Provide the given processing unit to the scheduler.
-        void add_processing_unit(std::size_t virt_core, std::size_t thread_num,
-            error_code& ec);
+        void add_processing_unit(
+            std::size_t virt_core, std::size_t thread_num, error_code& ec);
 
         // Remove the given processing unit from the scheduler.
         void remove_processing_unit(std::size_t thread_num, error_code& ec);
@@ -100,7 +99,7 @@ namespace hpx { namespace threads { namespace detail
     private:
         util::io_service_pool threads_;
     };
-}}}
+}}}    // namespace hpx::threads::detail
 
 #include <hpx/config/warnings_suffix.hpp>
 
diff --git a/libs/io_service/include_compatibility/hpx/runtime/threads/detail/io_service_thread_pool.hpp b/libs/io_service/include_compatibility/hpx/runtime/threads/detail/io_service_thread_pool.hpp
new file mode 100644
index 0000000000..c8d6eec98d
--- /dev/null
+++ b/libs/io_service/include_compatibility/hpx/runtime/threads/detail/io_service_thread_pool.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/io_service/config/defines.hpp>
+#include <hpx/io_service/io_service_thread_pool.hpp>
+
+#if defined(HPX_IO_SERVICE_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/util/io_service_thread_pool.hpp is deprecated, \
+    please include hpx/io_service/io_service_thread_pool.hpp instead")
+#else
+#warning "The header hpx/util/io_service_thread_pool.hpp is deprecated, \
+    please include hpx/io_service/io_service_thread_pool.hpp instead"
+#endif
+#endif
diff --git a/libs/io_service/include_compatibility/hpx/util/io_service_pool.hpp b/libs/io_service/include_compatibility/hpx/util/io_service_pool.hpp
new file mode 100644
index 0000000000..9c384091da
--- /dev/null
+++ b/libs/io_service/include_compatibility/hpx/util/io_service_pool.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 Auriane Reverdell
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/io_service/config/defines.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
+
+#if defined(HPX_IO_SERVICE_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/io_service_pool.hpp is deprecated, \
+    please include hpx/io_service/io_service_pool.hpp instead")
+#else
+#warning "The header hpx/util/io_service_pool.hpp is deprecated, \
+    please include hpx/io_service/io_service_pool.hpp instead"
+#endif
+#endif
diff --git a/src/util/io_service_pool.cpp b/libs/io_service/src/io_service_pool.cpp
similarity index 90%
rename from src/util/io_service_pool.cpp
rename to libs/io_service/src/io_service_pool.cpp
index 5923825583..2364efd962 100644
--- a/src/util/io_service_pool.cpp
+++ b/libs/io_service/src/io_service_pool.cpp
@@ -9,11 +9,11 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/config/asio.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/concurrency/barrier.hpp>
-#include <hpx/config/asio.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 #include <hpx/logging.hpp>
 
 #include <boost/asio/io_service.hpp>
@@ -26,8 +26,7 @@
 #include <utility>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     io_service_pool::io_service_pool(std::size_t pool_size,
         threads::policies::callback_notifier const& notifier,
         char const* pool_name, char const* name_postfix)
@@ -97,7 +96,7 @@ namespace hpx { namespace util
         // use this thread for the given io service
         while (true)
         {
-            io_services_[index]->run();   // run io service
+            io_services_[index]->run();    // run io service
 
             if (waiting_)
             {
@@ -113,13 +112,13 @@ namespace hpx { namespace util
         notifier_.on_stop_thread(index, index, pool_name_, pool_name_postfix_);
     }
 
-    bool io_service_pool::run(std::size_t num_threads, bool join_threads,
-        util::barrier* startup)
+    bool io_service_pool::run(
+        std::size_t num_threads, bool join_threads, util::barrier* startup)
     {
         std::lock_guard<std::mutex> l(mtx_);
 
         // Create a pool of threads to run all of the io_services.
-        if (!threads_.empty())   // should be called only once
+        if (!threads_.empty())    // should be called only once
         {
             HPX_ASSERT(pool_size_ == io_services_.size());
             HPX_ASSERT(threads_.size() == io_services_.size());
@@ -144,7 +143,7 @@ namespace hpx { namespace util
         std::lock_guard<std::mutex> l(mtx_);
 
         // Create a pool of threads to run all of the io_services.
-        if (!threads_.empty())   // should be called only once
+        if (!threads_.empty())    // should be called only once
         {
             HPX_ASSERT(pool_size_ == io_services_.size());
             HPX_ASSERT(threads_.size() == io_services_.size());
@@ -164,8 +163,8 @@ namespace hpx { namespace util
         return run_locked(pool_size_, join_threads, startup);
     }
 
-    bool io_service_pool::run_locked(std::size_t num_threads, bool join_threads,
-        util::barrier* startup)
+    bool io_service_pool::run_locked(
+        std::size_t num_threads, bool join_threads, util::barrier* startup)
     {
         if (io_services_.empty())
         {
@@ -182,8 +181,7 @@ namespace hpx { namespace util
 
         for (std::size_t i = 0; i < num_threads; ++i)
         {
-            std::thread t(
-                &io_service_pool::thread_run, this, i, startup);
+            std::thread t(&io_service_pool::thread_run, this, i, startup);
             threads_.emplace_back(std::move(t));
         }
 
@@ -222,7 +220,8 @@ namespace hpx { namespace util
 
     void io_service_pool::stop_locked()
     {
-        if (!stopped_) {
+        if (!stopped_)
+        {
             // Explicitly inform all work to exit.
             work_.clear();
 
@@ -242,7 +241,8 @@ namespace hpx { namespace util
 
     void io_service_pool::wait_locked()
     {
-        if (!stopped_) {
+        if (!stopped_)
+        {
             // Clear work so that the run functions return when all work is done
             waiting_ = true;
             work_.clear();
@@ -268,7 +268,8 @@ namespace hpx { namespace util
 
     void io_service_pool::clear_locked()
     {
-        if (stopped_) {
+        if (stopped_)
+        {
             next_io_service_ = 0;
             threads_.clear();
             work_.clear();
@@ -287,18 +288,20 @@ namespace hpx { namespace util
         // use this function for single group io_service pools only
         std::lock_guard<std::mutex> l(mtx_);
 
-        if (index == -1) {
+        if (index == -1)
+        {
             if (++next_io_service_ == pool_size_)
                 next_io_service_ = 0;
 
             // Use a round-robin scheme to choose the next io_service to use.
             index = static_cast<int>(next_io_service_);
         }
-        else {
+        else
+        {
             next_io_service_ = static_cast<std::size_t>(index);
         }
 
-        return *io_services_[static_cast<std::size_t>(index)]; //-V108
+        return *io_services_[static_cast<std::size_t>(index)];    //-V108
     }
 
     std::thread& io_service_pool::get_os_thread_handle(std::size_t thread_num)
@@ -307,5 +310,4 @@ namespace hpx { namespace util
         return threads_[thread_num];
     }
 
-}}  // namespace hpx::util
-
+}}    // namespace hpx::util
diff --git a/src/runtime/threads/detail/io_service_thread_pool.cpp b/libs/io_service/src/io_service_thread_pool.cpp
similarity index 85%
rename from src/runtime/threads/detail/io_service_thread_pool.cpp
rename to libs/io_service/src/io_service_thread_pool.cpp
index bd8bccb5bc..9981271b0a 100644
--- a/src/runtime/threads/detail/io_service_thread_pool.cpp
+++ b/libs/io_service/src/io_service_thread_pool.cpp
@@ -5,19 +5,18 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/affinity/affinity_data.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/concurrency/barrier.hpp>
-#include <hpx/runtime/threads/detail/io_service_thread_pool.hpp>
-#include <hpx/affinity/affinity_data.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
+#include <hpx/io_service/io_service_thread_pool.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
 
 #include <cstddef>
 #include <exception>
 
-namespace hpx { namespace threads { namespace detail
-{
+namespace hpx { namespace threads { namespace detail {
     io_service_thread_pool::io_service_thread_pool(
         hpx::threads::thread_pool_init_parameters const& init)
       : thread_pool_base(init)
@@ -57,7 +56,8 @@ namespace hpx { namespace threads { namespace detail
         thread_state_ex_enum new_state_ex, thread_priority priority,
         error_code& ec)
     {
-        return threads::thread_state(threads::terminated, threads::wait_unknown);
+        return threads::thread_state(
+            threads::terminated, threads::wait_unknown);
     }
 
     threads::thread_id_type io_service_thread_pool::set_state(
@@ -74,8 +74,8 @@ namespace hpx { namespace threads { namespace detail
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    bool io_service_thread_pool::run(std::unique_lock<std::mutex>& l,
-        std::size_t num_threads)
+    bool io_service_thread_pool::run(
+        std::unique_lock<std::mutex>& l, std::size_t num_threads)
     {
         HPX_ASSERT(l.owns_lock());
         util::barrier startup(1);
@@ -89,14 +89,14 @@ namespace hpx { namespace threads { namespace detail
 
     void io_service_thread_pool::resume_direct(error_code& ec)
     {
-        HPX_ASSERT_MSG(false,
-            "Resuming io_service_thread_pool is not supported");
+        HPX_ASSERT_MSG(
+            false, "Resuming io_service_thread_pool is not supported");
     }
 
     void io_service_thread_pool::suspend_direct(error_code& ec)
     {
-        HPX_ASSERT_MSG(false,
-            "Suspending io_service_thread_pool is not supported");
+        HPX_ASSERT_MSG(
+            false, "Suspending io_service_thread_pool is not supported");
     }
 
     void io_service_thread_pool::suspend_processing_unit_direct(
@@ -147,4 +147,4 @@ namespace hpx { namespace threads { namespace detail
         std::size_t thread_num, error_code& ec)
     {
     }
-}}}
+}}}    // namespace hpx::threads::detail
diff --git a/libs/io_service/tests/CMakeLists.txt b/libs/io_service/tests/CMakeLists.txt
new file mode 100644
index 0000000000..941498ed15
--- /dev/null
+++ b/libs/io_service/tests/CMakeLists.txt
@@ -0,0 +1,42 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_IO_SERVICE_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_IO_SERVICE_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.io_service)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.io_service)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.io_service)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.io_service)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.io_service)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.io_service)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.io_service
+        HEADERS ${io_service_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        NOLIBS
+        DEPENDENCIES hpx_io_service)
+    endif()
+endif()
diff --git a/libs/io_service/tests/performance/CMakeLists.txt b/libs/io_service/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/io_service/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/io_service/tests/regressions/CMakeLists.txt b/libs/io_service/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/io_service/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/io_service/tests/unit/CMakeLists.txt b/libs/io_service/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/io_service/tests/unit/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/iterator_support/CMakeLists.txt b/libs/iterator_support/CMakeLists.txt
index 49c4518abe..09cabd8b86 100644
--- a/libs/iterator_support/CMakeLists.txt
+++ b/libs/iterator_support/CMakeLists.txt
@@ -4,11 +4,12 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(iterator_support_headers
   hpx/iterator_support/traits/is_iterator.hpp
   hpx/iterator_support/traits/is_range.hpp
+  hpx/iterator_support/counting_iterator.hpp
   hpx/iterator_support/iterator_adaptor.hpp
   hpx/iterator_support/iterator_facade.hpp
   hpx/iterator_support/iterator_range.hpp
diff --git a/libs/iterator_support/README.rst b/libs/iterator_support/README.rst
index 1e697607b2..a0e77a50d4 100644
--- a/libs/iterator_support/README.rst
+++ b/libs/iterator_support/README.rst
@@ -12,4 +12,4 @@ iterator_support
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/iterator_support/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/iterator_support/docs/index.html>`__.
diff --git a/libs/iterator_support/include/hpx/iterator_support/counting_iterator.hpp b/libs/iterator_support/include/hpx/iterator_support/counting_iterator.hpp
new file mode 100644
index 0000000000..0712350665
--- /dev/null
+++ b/libs/iterator_support/include/hpx/iterator_support/counting_iterator.hpp
@@ -0,0 +1,188 @@
+//  Copyright (c) 2020 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+//  This code is based on boost::iterators::counting_iterator
+//  Copyright David Abrahams 2003.
+
+#if !defined(HPX_ITERATOR_SUPPORT_COUNTING_ITERATOR_FEB_03_2020_1055AM)
+#define HPX_ITERATOR_SUPPORT_COUNTING_ITERATOR_FEB_03_2020_1055AM
+
+#include <hpx/config.hpp>
+#include <hpx/iterator_support/iterator_adaptor.hpp>
+#include <hpx/type_support.hpp>
+
+#include <cstddef>
+#include <iterator>
+#include <type_traits>
+
+namespace hpx { namespace util {
+
+    template <typename Incrementable, typename CategoryOrTraversal = void,
+        typename Difference = void, typename Enable = void>
+    class counting_iterator;
+
+    namespace detail {
+
+        template <typename Incrementable, typename CategoryOrTraversal,
+            typename Difference>
+        struct counting_iterator_base
+        {
+            // calculate category of the resulting iterator
+            template <typename Iterator>
+            struct iterator_category
+            {
+                using type =
+                    typename std::iterator_traits<Iterator>::iterator_category;
+            };
+
+            using base_traversal =
+                util::lazy_conditional<std::is_integral<Incrementable>::value,
+                    util::identity<std::random_access_iterator_tag>,
+                    iterator_category<Incrementable>>;
+
+            using traversal = typename util::lazy_conditional<
+                std::is_void<CategoryOrTraversal>::value, base_traversal,
+                util::identity<CategoryOrTraversal>>::type;
+
+            // calculate difference_type of the resulting iterator
+            template <typename Integer>
+            struct integer_difference_type
+            {
+                using type = typename std::conditional<
+                    (sizeof(Integer) >= sizeof(std::intmax_t)),
+
+                    std::conditional<(std::is_signed<Integer>::value), Integer,
+                        std::intmax_t>,
+
+                    std::conditional<(sizeof(Integer) < sizeof(std::ptrdiff_t)),
+                        std::ptrdiff_t, std::intmax_t>>::type::type;
+            };
+
+            template <typename Iterator>
+            struct iterator_difference_type
+            {
+                using type =
+                    typename std::iterator_traits<Iterator>::difference_type;
+            };
+
+            using base_difference =
+                util::lazy_conditional<std::is_integral<Incrementable>::value,
+                    integer_difference_type<Incrementable>,
+                    iterator_difference_type<Incrementable>>;
+
+            using difference =
+                typename util::lazy_conditional<std::is_void<Difference>::value,
+                    base_difference, util::identity<Difference>>::type;
+
+            using type = iterator_adaptor<counting_iterator<Incrementable,
+                                              CategoryOrTraversal, Difference>,
+                Incrementable, Incrementable, traversal, Incrementable const&,
+                difference>;
+        };
+    }    // namespace detail
+
+    ////////////////////////////////////////////////////////////////////////////
+    // specialization for Iterators (non-itengral types)
+    template <typename Incrementable, typename CategoryOrTraversal,
+        typename Difference, typename Enable>
+    class counting_iterator
+      : public detail::counting_iterator_base<Incrementable,
+            CategoryOrTraversal, Difference>::type
+    {
+    private:
+        using base_type = typename detail::counting_iterator_base<Incrementable,
+            CategoryOrTraversal, Difference>::type;
+
+        friend class iterator_core_access;
+
+    public:
+        counting_iterator() = default;
+        counting_iterator(counting_iterator const& rhs) = default;
+
+        explicit counting_iterator(Incrementable x)
+          : base_type(x)
+        {
+        }
+
+    private:
+        typename base_type::reference dereference() const
+        {
+            return this->base_reference();
+        }
+    };
+
+    template <typename Incrementable, typename CategoryOrTraversal,
+        typename Difference>
+    class counting_iterator<Incrementable, CategoryOrTraversal, Difference,
+        typename std::enable_if<std::is_integral<Incrementable>::value>::type>
+      : public detail::counting_iterator_base<Incrementable,
+            CategoryOrTraversal, Difference>::type
+    {
+    private:
+        using base_type = typename detail::counting_iterator_base<Incrementable,
+            CategoryOrTraversal, Difference>::type;
+
+        friend class iterator_core_access;
+
+    public:
+        counting_iterator() = default;
+        counting_iterator(counting_iterator const& rhs) = default;
+
+        explicit counting_iterator(Incrementable x)
+          : base_type(x)
+        {
+        }
+
+    private:
+        template <typename Iterator>
+        bool equal(Iterator const& rhs) const
+        {
+            return this->base() == rhs.base();
+        }
+
+        void increment()
+        {
+            ++this->base_reference();
+        }
+
+        void decrement()
+        {
+            --this->base_reference();
+        }
+
+        template <typename Distance>
+        void advance(Distance n)
+        {
+            this->base_reference() +=
+                static_cast<typename base_type::base_type>(n);
+        }
+
+        typename base_type::reference dereference() const
+        {
+            return this->base_reference();
+        }
+
+        template <typename OtherIncrementable>
+        typename base_type::difference_type distance_to(
+            counting_iterator<OtherIncrementable, CategoryOrTraversal,
+                Difference> const& y) const
+        {
+            using difference_type = typename base_type::difference_type;
+            return static_cast<difference_type>(y.base()) -
+                static_cast<difference_type>(this->base());
+        }
+    };
+
+    // Manufacture a counting iterator for an arbitrary incrementable type
+    template <typename Incrementable>
+    inline counting_iterator<Incrementable> make_counting_iterator(
+        Incrementable x)
+    {
+        return counting_iterator<Incrementable>(x);
+    }
+}}    // namespace hpx::util
+
+#endif
diff --git a/libs/iterator_support/include/hpx/iterator_support/iterator_facade.hpp b/libs/iterator_support/include/hpx/iterator_support/iterator_facade.hpp
index f5b8796784..23aa2b8003 100644
--- a/libs/iterator_support/include/hpx/iterator_support/iterator_facade.hpp
+++ b/libs/iterator_support/include/hpx/iterator_support/iterator_facade.hpp
@@ -158,6 +158,7 @@ namespace hpx { namespace util {
             }
         };
 
+        ////////////////////////////////////////////////////////////////////////
         // Implementation for bidirectional iterators
         template <typename Derived, typename T, typename Reference,
             typename Distance, typename Pointer>
@@ -199,7 +200,75 @@ namespace hpx { namespace util {
             }
         };
 
+        ////////////////////////////////////////////////////////////////////////
         // Implementation for random access iterators
+
+        // A proxy return type for operator[], needed to deal with
+        // iterators that may invalidate referents upon destruction.
+        // Consider the temporary iterator in *(a + n)
+        template <typename Iterator>
+        class operator_brackets_proxy
+        {
+            // Iterator is actually an iterator_facade, so we do not have to
+            // go through iterator_traits to access the traits.
+            using reference = typename Iterator::reference;
+            using value_type = typename Iterator::value_type;
+
+        public:
+            HPX_HOST_DEVICE explicit operator_brackets_proxy(
+                Iterator const& iter) noexcept
+              : iter_(iter)
+            {
+            }
+
+            HPX_HOST_DEVICE operator reference() const
+            {
+                return *iter_;
+            }
+
+            HPX_HOST_DEVICE operator_brackets_proxy& operator=(
+                value_type const& val)
+            {
+                *iter_ = val;
+                return *this;
+            }
+
+        private:
+            Iterator iter_;
+        };
+
+        // A meta-function that determines whether operator[] must return a
+        // proxy, or whether it can simply return a copy of the value_type.
+        template <typename ValueType>
+        struct use_operator_brackets_proxy
+          : std::integral_constant<bool,
+                !(std::is_copy_constructible<ValueType>::value &&
+                    std::is_const<ValueType>::value)>
+        {
+        };
+
+        template <typename Iterator, typename Value>
+        struct operator_brackets_result
+        {
+            using type = typename std::conditional<
+                use_operator_brackets_proxy<Value>::value,
+                operator_brackets_proxy<Iterator>, Value>::type;
+        };
+
+        template <typename Iterator>
+        HPX_HOST_DEVICE operator_brackets_proxy<Iterator>
+        make_operator_brackets_result(Iterator const& iter, std::true_type)
+        {
+            return operator_brackets_proxy<Iterator>(iter);
+        }
+
+        template <typename Iterator>
+        HPX_HOST_DEVICE typename Iterator::value_type
+        make_operator_brackets_result(Iterator const& iter, std::false_type)
+        {
+            return *iter;
+        }
+
         template <typename Derived, typename T, typename Reference,
             typename Distance, typename Pointer>
         class iterator_facade_base<Derived, T, std::random_access_iterator_tag,
@@ -225,9 +294,14 @@ namespace hpx { namespace util {
             {
             }
 
-            HPX_HOST_DEVICE reference operator[](difference_type n) const
+            HPX_HOST_DEVICE
+            typename operator_brackets_result<Derived, T>::type operator[](
+                difference_type n) const
             {
-                return *(this->derived() + n);
+                using use_proxy = use_operator_brackets_proxy<T>;
+
+                return make_operator_brackets_result<Derived>(
+                    this->derived() + n, use_proxy{});
             }
 
             HPX_HOST_DEVICE Derived& operator+=(difference_type n)
diff --git a/libs/iterator_support/include/hpx/iterator_support/range.hpp b/libs/iterator_support/include/hpx/iterator_support/range.hpp
index 269426fe7f..b15cb83a79 100644
--- a/libs/iterator_support/include/hpx/iterator_support/range.hpp
+++ b/libs/iterator_support/include/hpx/iterator_support/range.hpp
@@ -17,28 +17,28 @@ namespace hpx { namespace util {
     namespace detail {
         ///////////////////////////////////////////////////////////////////////
         template <typename T, std::size_t N>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE T* begin_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE T* begin_impl(
             T (&array)[N], long) noexcept
         {
             return &array[0];
         }
 
         template <typename T, std::size_t N>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE T* end_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE T* end_impl(
             T (&array)[N], long) noexcept
         {
             return &array[N];
         }
 
         template <typename T, std::size_t N>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE std::size_t size_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE std::size_t size_impl(
             T const (&array)[N], long) noexcept
         {
             return N;
         }
 
         template <typename T, std::size_t N>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE bool empty_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE bool empty_impl(
             T const (&array)[N], long) noexcept
         {
             return false;
@@ -46,14 +46,14 @@ namespace hpx { namespace util {
 
         ///////////////////////////////////////////////////////////////////////
         template <typename C, typename R = decltype(std::declval<C&>().begin())>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE R begin_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE R begin_impl(
             C& c, long) noexcept(noexcept(c.begin()))
         {
             return c.begin();
         }
 
         template <typename C, typename R = decltype(std::declval<C&>().end())>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE R end_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE R end_impl(
             C& c, long) noexcept(noexcept(c.begin()))
         {
             return c.end();
@@ -61,7 +61,7 @@ namespace hpx { namespace util {
 
         template <typename C,
             typename R = decltype(std::declval<C const&>().size())>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE R size_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE R size_impl(
             C const& c, long) noexcept(noexcept(c.size()))
         {
             return c.size();
@@ -69,7 +69,7 @@ namespace hpx { namespace util {
 
         template <typename C,
             typename R = decltype(std::declval<C const&>().empty())>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE R empty_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE R empty_impl(
             C const& c, long) noexcept(noexcept(c.empty()))
         {
             return c.empty();
@@ -89,7 +89,7 @@ namespace hpx { namespace util {
 
             template <typename C,
                 typename R = decltype(begin(std::declval<C&>()))>
-            HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE R begin_impl(
+            HPX_HOST_DEVICE constexpr HPX_FORCEINLINE R begin_impl(
                 C& c, int) noexcept(noexcept(begin(c)))
             {
                 return begin(c);
@@ -99,7 +99,7 @@ namespace hpx { namespace util {
 
             template <typename C,
                 typename R = decltype(end(std::declval<C&>()))>
-            HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE R end_impl(
+            HPX_HOST_DEVICE constexpr HPX_FORCEINLINE R end_impl(
                 C& c, int) noexcept(noexcept(end(c)))
             {
                 return end(c);
@@ -109,14 +109,14 @@ namespace hpx { namespace util {
         using range_impl::end_impl;
 
         template <typename C>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE std::size_t size_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE std::size_t size_impl(
             C const& c, int)
         {
             return std::distance(begin_impl(c, 0L), end_impl(c, 0L));
         }
 
         template <typename C>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE bool empty_impl(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE bool empty_impl(
             C const& c, int)
         {
             return begin_impl(c, 0L) == end_impl(c, 0L);
@@ -163,15 +163,15 @@ namespace hpx { namespace util {
     namespace range_adl {
         template <typename C,
             typename Iterator = typename detail::iterator<C>::type>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE Iterator begin(
-            C& c) noexcept(noexcept(detail::begin_impl(c, 0L)))
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE Iterator begin(C& c) noexcept(
+            noexcept(detail::begin_impl(c, 0L)))
         {
             return detail::begin_impl(c, 0L);
         }
 
         template <typename C,
             typename Iterator = typename detail::iterator<C const>::type>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE Iterator begin(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE Iterator begin(
             C const& c) noexcept(noexcept(detail::begin_impl(c, 0L)))
         {
             return detail::begin_impl(c, 0L);
@@ -179,15 +179,15 @@ namespace hpx { namespace util {
 
         template <typename C,
             typename Sentinel = typename detail::sentinel<C>::type>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE Sentinel end(
-            C& c) noexcept(noexcept(detail::end_impl(c, 0L)))
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE Sentinel end(C& c) noexcept(
+            noexcept(detail::end_impl(c, 0L)))
         {
             return detail::end_impl(c, 0L);
         }
 
         template <typename C,
             typename Sentinel = typename detail::sentinel<C const>::type>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE Sentinel end(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE Sentinel end(
             C const& c) noexcept(noexcept(detail::end_impl(c, 0L)))
         {
             return detail::end_impl(c, 0L);
@@ -196,7 +196,7 @@ namespace hpx { namespace util {
         template <typename C,
             typename Iterator = typename detail::iterator<C const>::type,
             typename Sentinel = typename detail::sentinel<C const>::type>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE std::size_t size(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE std::size_t size(
             C const& c) noexcept(noexcept(detail::size_impl(c, 0L)))
         {
             return detail::size_impl(c, 0L);
@@ -205,7 +205,7 @@ namespace hpx { namespace util {
         template <typename C,
             typename Iterator = typename detail::iterator<C const>::type,
             typename Sentinel = typename detail::sentinel<C const>::type>
-        HPX_HOST_DEVICE HPX_CONSTEXPR HPX_FORCEINLINE bool empty(
+        HPX_HOST_DEVICE constexpr HPX_FORCEINLINE bool empty(
             C const& c) noexcept(noexcept(detail::empty_impl(c, 0L)))
         {
             return detail::empty_impl(c, 0L);
diff --git a/libs/iterator_support/include/hpx/iterator_support/zip_iterator.hpp b/libs/iterator_support/include/hpx/iterator_support/zip_iterator.hpp
index 9c03d41217..483f375275 100644
--- a/libs/iterator_support/include/hpx/iterator_support/zip_iterator.hpp
+++ b/libs/iterator_support/include/hpx/iterator_support/zip_iterator.hpp
@@ -9,12 +9,12 @@
 #define HPX_ITERATOR_SUPPORT_ZIP_ITERATOR_MAY_29_2014_0852PM
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/functional/result_of.hpp>
 #include <hpx/iterator_support/iterator_facade.hpp>
 #include <hpx/iterator_support/traits/is_iterator.hpp>
 #include <hpx/serialization/serialization_fwd.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <iterator>
@@ -212,8 +212,7 @@ namespace hpx { namespace util {
             template <std::size_t... Is>
             HPX_HOST_DEVICE static
                 typename zip_iterator_reference<tuple<Ts...>>::type
-                call(detail::pack_c<std::size_t, Is...>,
-                    tuple<Ts...> const& iterators)
+                call(util::index_pack<Is...>, tuple<Ts...> const& iterators)
             {
                 return util::forward_as_tuple(*util::get<Is>(iterators)...);
             }
@@ -300,7 +299,7 @@ namespace hpx { namespace util {
             HPX_HOST_DEVICE typename base_type::reference dereference() const
             {
                 return dereference_iterator<IteratorTuple>::call(
-                    typename detail::make_index_pack<
+                    typename util::make_index_pack<
                         util::tuple_size<IteratorTuple>::value>::type(),
                     iterators_);
             }
@@ -329,8 +328,7 @@ namespace hpx { namespace util {
 
         private:
             template <typename F, std::size_t... Is>
-            HPX_HOST_DEVICE void apply(
-                F&& f, detail::pack_c<std::size_t, Is...>)
+            HPX_HOST_DEVICE void apply(F&& f, util::index_pack<Is...>)
             {
                 int const _sequencer[] = {
                     ((f(util::get<Is>(iterators_))), 0)...};
@@ -341,7 +339,7 @@ namespace hpx { namespace util {
             HPX_HOST_DEVICE void apply(F&& f)
             {
                 return apply(std::forward<F>(f),
-                    detail::make_index_pack<
+                    util::make_index_pack<
                         util::tuple_size<IteratorTuple>::value>());
             }
 
@@ -408,8 +406,7 @@ namespace hpx { namespace util {
 
         template <typename... Ts_>
         HPX_HOST_DEVICE typename std::enable_if<
-            detail::are_tuples_compatible_not_same<
-                typename zip_iterator::iterator_tuple_type,
+            std::is_assignable<typename zip_iterator::iterator_tuple_type&,
                 typename zip_iterator<Ts_...>::iterator_tuple_type&&>::value,
             zip_iterator&>::type
         operator=(zip_iterator<Ts_...> const& other)
@@ -419,8 +416,7 @@ namespace hpx { namespace util {
         }
         template <typename... Ts_>
         HPX_HOST_DEVICE typename std::enable_if<
-            detail::are_tuples_compatible_not_same<
-                typename zip_iterator::iterator_tuple_type,
+            std::is_assignable<typename zip_iterator::iterator_tuple_type&,
                 typename zip_iterator<Ts_...>::iterator_tuple_type&&>::value,
             zip_iterator&>::type
         operator=(zip_iterator<Ts_...>&& other)
@@ -482,8 +478,7 @@ namespace hpx { namespace util {
 
         template <typename... Ts_>
         HPX_HOST_DEVICE typename std::enable_if<
-            detail::are_tuples_compatible_not_same<
-                typename zip_iterator::iterator_tuple_type,
+            std::is_assignable<typename zip_iterator::iterator_tuple_type&,
                 typename zip_iterator<Ts_...>::iterator_tuple_type&&>::value,
             zip_iterator&>::type
         operator=(zip_iterator<Ts_...> const& other)
@@ -493,8 +488,7 @@ namespace hpx { namespace util {
         }
         template <typename... Ts_>
         HPX_HOST_DEVICE typename std::enable_if<
-            detail::are_tuples_compatible_not_same<
-                typename zip_iterator::iterator_tuple_type,
+            std::is_assignable<typename zip_iterator::iterator_tuple_type&,
                 typename zip_iterator<Ts_...>::iterator_tuple_type&&>::value,
             zip_iterator&>::type
         operator=(zip_iterator<Ts_...>&& other)
@@ -546,8 +540,8 @@ namespace hpx { namespace traits {
                 result_type;
 
             template <std::size_t... Is, typename... Ts_>
-            static result_type call(util::detail::pack_c<std::size_t, Is...>,
-                util::tuple<Ts_...> const& t)
+            static result_type call(
+                util::index_pack<Is...>, util::tuple<Ts_...> const& t)
             {
                 return util::make_tuple(
                     typename F::template apply<Ts>()(util::get<Is>(t))...);
@@ -556,7 +550,7 @@ namespace hpx { namespace traits {
             template <typename... Ts_>
             static result_type call(util::zip_iterator<Ts_...> const& iter)
             {
-                using hpx::util::detail::make_index_pack;
+                using hpx::util::make_index_pack;
                 return call(typename make_index_pack<sizeof...(Ts)>::type(),
                     iter.get_iterator_tuple());
             }
diff --git a/libs/iterator_support/tests/unit/CMakeLists.txt b/libs/iterator_support/tests/unit/CMakeLists.txt
index f145afbb24..e93afd32e5 100644
--- a/libs/iterator_support/tests/unit/CMakeLists.txt
+++ b/libs/iterator_support/tests/unit/CMakeLists.txt
@@ -5,6 +5,7 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 set(tests
+    counting_iterator
     is_iterator
     is_range
     iterator_adaptor
diff --git a/libs/iterator_support/tests/unit/counting_iterator.cpp b/libs/iterator_support/tests/unit/counting_iterator.cpp
new file mode 100644
index 0000000000..90dde2b4fb
--- /dev/null
+++ b/libs/iterator_support/tests/unit/counting_iterator.cpp
@@ -0,0 +1,362 @@
+//  Copyright (c) 2020 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+//  This code is based on boost::iterators::counting_iterator
+// (C) Copyright David Abrahams 2001.
+
+#include <hpx/hpx_init.hpp>
+#include <hpx/iterator_support.hpp>
+#include <hpx/program_options.hpp>
+#include <hpx/testing.hpp>
+
+#include <algorithm>
+#include <climits>
+#include <cstddef>
+#include <cstdlib>
+#include <iostream>
+#include <iterator>
+#include <list>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+#include "iterator_tests.hpp"
+
+template <typename T>
+struct signed_assert_nonnegative
+{
+    static void test(T x)
+    {
+        HPX_TEST(x >= 0);
+    }
+};
+
+template <typename T>
+struct unsigned_assert_nonnegative
+{
+    static void test(T x) {}
+};
+
+template <typename T>
+struct assert_nonnegative
+  : std::conditional<std::numeric_limits<T>::is_signed,
+        signed_assert_nonnegative<T>, unsigned_assert_nonnegative<T>>::type
+{
+};
+
+// Special tests for RandomAccess CountingIterators.
+template <typename CountingIterator, typename Value>
+void category_test(CountingIterator start, CountingIterator finish, Value,
+    std::random_access_iterator_tag)
+{
+    using difference_type =
+        typename std::iterator_traits<CountingIterator>::difference_type;
+
+    difference_type distance = std::distance(start, finish);
+
+    // Pick a random position internal to the range
+    difference_type offset = (unsigned) rand() % distance;
+
+    HPX_TEST(offset >= 0);
+
+    CountingIterator internal = start;
+    std::advance(internal, offset);
+
+    // Try some binary searches on the range to show that it's ordered
+    HPX_TEST(std::binary_search(start, finish, *internal));
+
+    std::pair<CountingIterator, CountingIterator> xy(
+        std::equal_range(start, finish, *internal));
+    CountingIterator x = xy.first, y = xy.second;
+
+    HPX_TEST(std::distance(x, y) == 1);
+
+// disable warning: unary minus operator applied to unsigned type, result still unsigned
+#if defined(HPX_MSVC)
+#pragma warning(push)
+#pragma warning(disable : 4146)
+#endif
+    // Show that values outside the range can't be found
+    HPX_TEST(!std::binary_search(start, std::prev(finish), *finish));
+#if defined(HPX_MSVC)
+#pragma warning(pop)
+#endif
+
+    // Do the generic random_access_iterator_test
+    using value_type = typename CountingIterator::value_type;
+
+    std::vector<value_type> v;
+    for (value_type z = *start; !(z == *finish); ++z)
+    {
+        v.push_back(z);
+    }
+
+    // Note that this test requires a that the first argument is
+    // dereferenceable /and/ a valid iterator prior to the first argument
+    tests::random_access_iterator_test(
+        start, static_cast<int>(v.size()), v.begin());
+}
+
+// Special tests for bidirectional CountingIterators
+template <typename CountingIterator, typename Value>
+void category_test(
+    CountingIterator start, Value v1, std::bidirectional_iterator_tag)
+{
+    Value v2 = v1;
+    ++v2;
+
+    // Note that this test requires a that the first argument is
+    // dereferenceable /and/ a valid iterator prior to the first argument
+    tests::bidirectional_iterator_test(start, v1, v2);
+}
+
+template <typename CountingIterator, typename Value>
+void category_test(CountingIterator start, CountingIterator finish, Value v1,
+    std::forward_iterator_tag)
+{
+    Value v2 = v1;
+    ++v2;
+    if (finish != start && finish != std::next(start))
+    {
+        tests::forward_readable_iterator_test(start, finish, v1, v2);
+    }
+}
+
+template <typename CountingIterator, typename Value>
+void test_aux(CountingIterator start, CountingIterator finish, Value v1)
+{
+    typedef typename CountingIterator::iterator_category category;
+
+    // If it's a RandomAccessIterator we can do a few delicate tests
+    category_test(start, finish, v1, category());
+
+    // Okay, brute force...
+    for (CountingIterator p = start; p != finish && std::next(p) != finish; ++p)
+    {
+        auto c = *p;
+        HPX_TEST(++c == *std::next(p));
+    }
+
+    // prove that a reference can be formed to these values
+    using value = typename CountingIterator::value_type;
+    value const* q = &*start;
+    (void) q;    // suppress unused variable warning
+}
+
+template <typename Incrementable>
+void test(Incrementable start, Incrementable finish)
+{
+#if defined(HPX_MSVC)
+#pragma warning(push)
+#pragma warning(disable : 4146)
+#endif
+    test_aux(hpx::util::make_counting_iterator(start),
+        hpx::util::make_counting_iterator(finish), start);
+#if defined(HPX_MSVC)
+#pragma warning(pop)
+#endif
+}
+
+template <typename Integer>
+void test_integer(Integer* = nullptr)    // default arg works around MSVC bug
+{
+    Integer start = Integer(0);
+    Integer finish = Integer(120);
+    test(start, finish);
+}
+
+template <typename Integer, typename Category, typename Difference>
+void test_integer3(Integer* = nullptr, Category* = nullptr,
+    Difference* = nullptr)    // default arg works around MSVC bug
+{
+    Integer start = Integer(0);
+    Integer finish = Integer(120);
+    using iterator =
+        hpx::util::counting_iterator<Integer, Category, Difference>;
+    test_aux(iterator(start), iterator(finish), start);
+}
+
+template <typename Container>
+void test_container(
+    Container* = nullptr)    // default arg works around MSVC bug
+{
+    Container c(1 + (unsigned) rand() % 1673);
+
+    typename Container::iterator const start = c.begin();
+
+    // back off by 1 to leave room for dereferenceable value at the end
+    typename Container::iterator finish = start;
+    std::advance(finish, c.size() - 1);
+
+    test(start, finish);
+
+    using const_iterator = typename Container::const_iterator;
+    test(const_iterator(start), const_iterator(finish));
+}
+
+class my_int1
+{
+public:
+    my_int1() = default;
+    explicit my_int1(int x)
+      : m_int(x)
+    {
+    }
+
+    my_int1& operator++()
+    {
+        ++m_int;
+        return *this;
+    }
+
+    bool operator==(my_int1 const& x) const
+    {
+        return m_int == x.m_int;
+    }
+
+private:
+    int m_int;
+};
+
+class my_int2
+{
+public:
+    using value_type = void;
+    using pointer = void;
+    using reference = void;
+    using difference_type = std::ptrdiff_t;
+    using iterator_category = std::bidirectional_iterator_tag;
+
+    my_int2() = default;
+    explicit my_int2(int x)
+      : m_int(x)
+    {
+    }
+
+    my_int2& operator++()
+    {
+        ++m_int;
+        return *this;
+    }
+    my_int2& operator--()
+    {
+        --m_int;
+        return *this;
+    }
+    bool operator==(my_int2 const& x) const
+    {
+        return m_int == x.m_int;
+    }
+
+private:
+    int m_int;
+};
+
+class my_int3
+{
+public:
+    using value_type = void;
+    using pointer = void;
+    using reference = void;
+    using difference_type = std::ptrdiff_t;
+    using iterator_category = std::random_access_iterator_tag;
+
+    my_int3() = default;
+    explicit my_int3(int x)
+      : m_int(x)
+    {
+    }
+    my_int3& operator++()
+    {
+        ++m_int;
+        return *this;
+    }
+    my_int3& operator+=(std::ptrdiff_t n)
+    {
+        m_int += static_cast<int>(n);
+        return *this;
+    }
+    std::ptrdiff_t operator-(my_int3 const& x) const
+    {
+        return m_int - x.m_int;
+    }
+    my_int3& operator--()
+    {
+        --m_int;
+        return *this;
+    }
+    bool operator==(my_int3 const& x) const
+    {
+        return m_int == x.m_int;
+    }
+    bool operator!=(my_int3 const& x) const
+    {
+        return m_int != x.m_int;
+    }
+    bool operator<(my_int3 const& x) const
+    {
+        return m_int < x.m_int;
+    }
+
+private:
+    int m_int;
+};
+
+int hpx_main(hpx::program_options::variables_map& vm)
+{
+    unsigned int seed = (unsigned int) std::time(nullptr);
+    if (vm.count("seed"))
+        seed = vm["seed"].as<unsigned int>();
+
+    std::cout << "using seed: " << seed << std::endl;
+    std::srand(seed);
+
+    // Test the built-in integer types.
+    test_integer<char>();
+    test_integer<unsigned char>();
+    test_integer<signed char>();
+    test_integer<wchar_t>();
+    test_integer<short>();
+    test_integer<unsigned short>();
+    test_integer<int>();
+    test_integer<unsigned int>();
+    test_integer<long>();
+    test_integer<unsigned long>();
+
+    // Test user-defined type.
+    test_integer3<my_int1, std::forward_iterator_tag, int>();
+    test_integer3<long, std::random_access_iterator_tag, int>();
+    test_integer<my_int2>();
+    test_integer<my_int3>();
+
+    // Some tests on container iterators, to prove we handle a few different categories
+    test_container<std::vector<int>>();
+    test_container<std::list<int>>();
+
+    // Also prove that we can handle raw pointers.
+    int array[2000];
+    test(hpx::util::make_counting_iterator(array),
+        hpx::util::make_counting_iterator(array + 2000 - 1));
+
+    return hpx::finalize();
+}
+
+int main(int argc, char* argv[])
+{
+    // add command line option which controls the random number generator seed
+    using namespace hpx::program_options;
+    options_description desc_commandline(
+        "Usage: " HPX_APPLICATION_STRING " [options]");
+
+    desc_commandline.add_options()("seed,s", value<unsigned int>(),
+        "the random number generator seed to use for this run");
+
+    // Initialize and run HPX
+    HPX_TEST_EQ_MSG(hpx::init(desc_commandline, argc, argv), 0,
+        "HPX main exited with non-zero status");
+
+    return hpx::util::report_errors();
+}
diff --git a/libs/iterator_support/tests/unit/is_iterator.cpp b/libs/iterator_support/tests/unit/is_iterator.cpp
index 406158539d..2a1e2be2c3 100644
--- a/libs/iterator_support/tests/unit/is_iterator.cpp
+++ b/libs/iterator_support/tests/unit/is_iterator.cpp
@@ -573,12 +573,12 @@ void bidirectional_concept()
     {
         using iterator = bidirectional_traversal_iterator;
         HPX_TEST_MSG((bidirectional_concept<iterator>::value),
-            "bidirectional traveral input iterator");
+            "bidirectional traversal input iterator");
     }
     {
         using iterator = random_access_traversal_iterator;
         HPX_TEST_MSG((bidirectional_concept<iterator>::value),
-            "random access traveral input iterator");
+            "random access traversal input iterator");
     }
 }
 
diff --git a/libs/iterator_support/tests/unit/iterator_adaptor.cpp b/libs/iterator_support/tests/unit/iterator_adaptor.cpp
index 1f70fdf59c..1c63405ae8 100644
--- a/libs/iterator_support/tests/unit/iterator_adaptor.cpp
+++ b/libs/iterator_support/tests/unit/iterator_adaptor.cpp
@@ -270,7 +270,7 @@ int main()
         int zero = 0;
         if (zero)    // don't do this, just make sure it compiles
         {
-            HPX_TEST((*i).x_ == i->foo());
+            HPX_TEST_EQ((*i).x_, i->foo());
         }
     }
 
@@ -282,7 +282,7 @@ int main()
         int zero = 0;
         if (zero)    // don't do this, just make sure it compiles
         {
-            HPX_TEST((*i).x_ == i->foo());
+            HPX_TEST_EQ((*i).x_, i->foo());
         }
     }
 
diff --git a/libs/iterator_support/tests/unit/iterator_facade.cpp b/libs/iterator_support/tests/unit/iterator_facade.cpp
index 1ee68900ff..90ee1e0440 100644
--- a/libs/iterator_support/tests/unit/iterator_facade.cpp
+++ b/libs/iterator_support/tests/unit/iterator_facade.cpp
@@ -171,14 +171,14 @@ int main()
     {
         int x = 0;
         iterator_with_proxy_reference i(x);
-        HPX_TEST(x == 0);
-        HPX_TEST(i.m_x == 0);
+        HPX_TEST_EQ(x, 0);
+        HPX_TEST_EQ(i.m_x, 0);
         ++(*i).m_x;
-        HPX_TEST(x == 1);
-        HPX_TEST(i.m_x == 1);
+        HPX_TEST_EQ(x, 1);
+        HPX_TEST_EQ(i.m_x, 1);
         ++i->m_x;
-        HPX_TEST(x == 2);
-        HPX_TEST(i.m_x == 2);
+        HPX_TEST_EQ(x, 2);
+        HPX_TEST_EQ(i.m_x, 2);
     }
 
     return hpx::util::report_errors();
diff --git a/libs/iterator_support/tests/unit/iterator_tests.hpp b/libs/iterator_support/tests/unit/iterator_tests.hpp
index df720584b5..b7242b7484 100644
--- a/libs/iterator_support/tests/unit/iterator_tests.hpp
+++ b/libs/iterator_support/tests/unit/iterator_tests.hpp
@@ -107,7 +107,7 @@ namespace tests {
         HPX_TEST(*i1 == v2);
         HPX_TEST(*i == v2);
 
-        // i is dereferencable, so it must be incrementable.
+        // i is dereferenceable, so it must be incrementable.
         ++i;
 
         // how to test for operator-> ?
@@ -304,11 +304,10 @@ namespace tests {
     void random_access_iterator_test(Iterator i, int N, TrueVals vals)
     {
         bidirectional_iterator_test(i, vals[0], vals[1]);
-        const Iterator j = i;
+        Iterator const j = i;
         int c;
 
-        typedef typename boost::detail::iterator_traits<Iterator>::value_type
-            value_type;
+        using value_type = typename std::iterator_traits<Iterator>::value_type;
 
         for (c = 0; c < N - 1; ++c)
         {
@@ -318,8 +317,8 @@ namespace tests {
             HPX_TEST(*i == *(j + c));
             HPX_TEST(*i == *(c + j));
             ++i;
-            HPX_TEST(i > j);
-            HPX_TEST(i >= j);
+            HPX_TEST(j < i);
+            HPX_TEST(j <= i);
             HPX_TEST(j <= i);
             HPX_TEST(j < i);
         }
@@ -332,8 +331,8 @@ namespace tests {
             HPX_TEST(*i == detail::implicit_cast<value_type>(j[N - 1 - c]));
             Iterator q = k - c;
             HPX_TEST(*i == *q);
-            HPX_TEST(i > j);
-            HPX_TEST(i >= j);
+            HPX_TEST(j < i);
+            HPX_TEST(j <= i);
             HPX_TEST(j <= i);
             HPX_TEST(j < i);
             --i;
@@ -358,8 +357,8 @@ namespace tests {
             HPX_TEST(*i == *(j + c));
             HPX_TEST(*i == *(c + j));
             ++i;
-            HPX_TEST(i > j);
-            HPX_TEST(i >= j);
+            HPX_TEST(j < i);
+            HPX_TEST(j <= i);
             HPX_TEST(j <= i);
             HPX_TEST(j < i);
         }
@@ -374,8 +373,8 @@ namespace tests {
             HPX_TEST(*i == x);
             Iterator q = k - c;
             HPX_TEST(*i == *q);
-            HPX_TEST(i > j);
-            HPX_TEST(i >= j);
+            HPX_TEST(j < i);
+            HPX_TEST(j <= i);
             HPX_TEST(j <= i);
             HPX_TEST(j < i);
             --i;
@@ -390,7 +389,7 @@ namespace tests {
         typedef typename std::iterator_traits<Iterator>::reference reference;
         HPX_TEST((std::is_same<const value_type&, reference>::value));
         const T& v2 = *i2;
-        HPX_TEST(v1 == v2);
+        HPX_TEST_EQ(v1, v2);
         //HPX_TEST(is_lvalue_iterator<Iterator>::value);
         //HPX_TEST(!is_non_const_lvalue_iterator<Iterator>::value);
     }
@@ -403,14 +402,14 @@ namespace tests {
         typedef typename std::iterator_traits<Iterator>::reference reference;
         HPX_TEST((std::is_same<value_type&, reference>::value));
         T& v3 = *i2;
-        HPX_TEST(v1 == v3);
+        HPX_TEST_EQ(v1, v3);
 
         // A non-const lvalue iterator is not necessarily writable, but we
         // are assuming the value_type is assignable here
         *i = v2;
 
         T& v4 = *i2;
-        HPX_TEST(v2 == v4);
+        HPX_TEST_EQ(v2, v4);
         //HPX_TEST(is_lvalue_iterator<Iterator>::value);
         //HPX_TEST(is_non_const_lvalue_iterator<Iterator>::value);
     }
diff --git a/libs/iterator_support/tests/unit/range.cpp b/libs/iterator_support/tests/unit/range.cpp
index 9639d4861d..50c0ffc4eb 100644
--- a/libs/iterator_support/tests/unit/range.cpp
+++ b/libs/iterator_support/tests/unit/range.cpp
@@ -14,12 +14,12 @@
 void array_range()
 {
     int r[3] = {0, 1, 2};
-    HPX_TEST_EQ(hpx::util::begin(r), &r[0]);
-    HPX_TEST_EQ(hpx::util::end(r), &r[3]);
+    HPX_TEST(hpx::util::begin(r) == &r[0]);
+    HPX_TEST(hpx::util::end(r) == &r[3]);
 
     int const cr[3] = {0, 1, 2};
-    HPX_TEST_EQ(hpx::util::begin(cr), &cr[0]);
-    HPX_TEST_EQ(hpx::util::end(cr), &cr[3]);
+    HPX_TEST(hpx::util::begin(cr) == &cr[0]);
+    HPX_TEST(hpx::util::end(cr) == &cr[3]);
     HPX_TEST_EQ(hpx::util::size(cr), 3u);
     HPX_TEST_EQ(hpx::util::empty(cr), false);
 }
@@ -53,12 +53,12 @@ struct member
 void member_range()
 {
     member r = member();
-    HPX_TEST_EQ(hpx::util::begin(r), &r.x);
-    HPX_TEST_EQ(hpx::util::end(r), &r.x + 1);
+    HPX_TEST(hpx::util::begin(r) == &r.x);
+    HPX_TEST(hpx::util::end(r) == &r.x + 1);
 
     member const cr = member();
-    HPX_TEST_EQ(hpx::util::begin(cr), &cr.x);
-    HPX_TEST_EQ(hpx::util::end(cr), &cr.x + 1);
+    HPX_TEST(hpx::util::begin(cr) == &cr.x);
+    HPX_TEST(hpx::util::end(cr) == &cr.x + 1);
     HPX_TEST_EQ(hpx::util::size(cr), 1u);
     HPX_TEST_EQ(hpx::util::empty(cr), false);
 }
@@ -94,12 +94,12 @@ namespace adl {
 void adl_range()
 {
     adl::free r = adl::free();
-    HPX_TEST_EQ(hpx::util::begin(r), &r.x);
-    HPX_TEST_EQ(hpx::util::end(r), &r.x + 1);
+    HPX_TEST(hpx::util::begin(r) == &r.x);
+    HPX_TEST(hpx::util::end(r) == &r.x + 1);
 
     adl::free const cr = adl::free();
-    HPX_TEST_EQ(hpx::util::begin(cr), &cr.x);
-    HPX_TEST_EQ(hpx::util::end(cr), &cr.x + 1);
+    HPX_TEST(hpx::util::begin(cr) == &cr.x);
+    HPX_TEST(hpx::util::end(cr) == &cr.x + 1);
     HPX_TEST_EQ(hpx::util::size(cr), 1u);
     HPX_TEST_EQ(hpx::util::empty(cr), false);
 }
diff --git a/libs/local_lcos/CMakeLists.txt b/libs/local_lcos/CMakeLists.txt
index 028ae628f2..65a7f6438b 100644
--- a/libs/local_lcos/CMakeLists.txt
+++ b/libs/local_lcos/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/local_lcos/README.rst b/libs/local_lcos/README.rst
index bc7aaa4220..33531b15da 100644
--- a/libs/local_lcos/README.rst
+++ b/libs/local_lcos/README.rst
@@ -13,4 +13,4 @@ local_lcos
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/local_lcos/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/local_lcos/docs/index.html>`__.
diff --git a/libs/local_lcos/include/hpx/local_lcos/packaged_task.hpp b/libs/local_lcos/include/hpx/local_lcos/packaged_task.hpp
index 560fe60f6a..f1631425b1 100644
--- a/libs/local_lcos/include/hpx/local_lcos/packaged_task.hpp
+++ b/libs/local_lcos/include/hpx/local_lcos/packaged_task.hpp
@@ -14,7 +14,7 @@
 #include <hpx/lcos/detail/future_data.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/local_lcos/promise.hpp>
-#include <hpx/util/annotated_function.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 
 #include <exception>
 #include <memory>
diff --git a/libs/local_lcos/include/hpx/local_lcos/promise.hpp b/libs/local_lcos/include/hpx/local_lcos/promise.hpp
index fd5d21f202..f3fef92d69 100644
--- a/libs/local_lcos/include/hpx/local_lcos/promise.hpp
+++ b/libs/local_lcos/include/hpx/local_lcos/promise.hpp
@@ -15,8 +15,6 @@
 #include <hpx/traits/future_access.hpp>
 #include <hpx/type_support/unused.hpp>
 
-#include <boost/utility/swap.hpp>
-
 #include <exception>
 #include <memory>
 #include <type_traits>
@@ -102,9 +100,9 @@ namespace hpx { namespace lcos { namespace local {
 
             void swap(promise_base& other) noexcept
             {
-                boost::swap(shared_state_, other.shared_state_);
-                boost::swap(future_retrieved_, other.future_retrieved_);
-                boost::swap(
+                std::swap(shared_state_, other.shared_state_);
+                std::swap(future_retrieved_, other.future_retrieved_);
+                std::swap(
                     shared_future_retrieved_, other.shared_future_retrieved_);
             }
 
diff --git a/libs/logging/CMakeLists.txt b/libs/logging/CMakeLists.txt
index 3a6aea3dde..bf2873bd7e 100644
--- a/libs/logging/CMakeLists.txt
+++ b/libs/logging/CMakeLists.txt
@@ -4,88 +4,55 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
 # Default location is $HPX_ROOT/libs/logging/include
 set(logging_headers
   hpx/logging.hpp
-  hpx/logging/format.hpp
-  hpx/logging/writer/format_write.hpp
-  hpx/logging/writer/named_write.hpp
-  hpx/logging/detail/time_format_holder.hpp
-  hpx/logging/detail/template.hpp
-  hpx/logging/detail/error.hpp
   hpx/logging/detail/macros.hpp
-  hpx/logging/detail/level.hpp
-  hpx/logging/detail/fwd.hpp
-  hpx/logging/detail/manipulator.hpp
   hpx/logging/detail/logger.hpp
-  hpx/logging/detail/format_write_detail.hpp
-  hpx/logging/detail/cache_before_init.hpp
-  hpx/logging/format_fwd.hpp
-  hpx/logging/logging.hpp
-  hpx/logging/format/formatter/named_spacer.hpp
-  hpx/logging/format/formatter/high_precision_time.hpp
-  hpx/logging/format/formatter/time_strf.hpp
-  hpx/logging/format/formatter/spacer.hpp
-  hpx/logging/format/formatter/time.hpp
-  hpx/logging/format/formatter/defaults.hpp
-  hpx/logging/format/formatter/convert_format.hpp
-  hpx/logging/format/formatter/thread_id.hpp
-  hpx/logging/format/array.hpp
+  hpx/logging/format/destinations.hpp
+  hpx/logging/format/formatters.hpp
   hpx/logging/format/named_write.hpp
-  hpx/logging/format/destination/named.hpp
-  hpx/logging/format/destination/defaults.hpp
-  hpx/logging/format/destination/convert_destination.hpp
-  hpx/logging/format/destination/file.hpp
-  hpx/logging/format/op_equal.hpp
-  hpx/logging/format/optimize.hpp
-  hpx/logging/format/named_write_fwd.hpp
+  hpx/logging/level.hpp
+  hpx/logging/logging.hpp
+  hpx/logging/manipulator.hpp
+  hpx/logging/message.hpp
 )
 
-
 # Default location is $HPX_ROOT/libs/logging/include_compatibility
 set(logging_compat_headers
   hpx/util/logging.hpp
-  hpx/util/logging/format.hpp
   hpx/util/logging/writer/format_write.hpp
   hpx/util/logging/writer/named_write.hpp
-  hpx/util/logging/detail/time_format_holder.hpp
-  hpx/util/logging/detail/template.hpp
-  hpx/util/logging/detail/error.hpp
   hpx/util/logging/detail/macros.hpp
   hpx/util/logging/detail/level.hpp
-  hpx/util/logging/detail/fwd.hpp
   hpx/util/logging/detail/manipulator.hpp
   hpx/util/logging/detail/logger.hpp
-  hpx/util/logging/detail/format_write_detail.hpp
-  hpx/util/logging/detail/cache_before_init.hpp
-  hpx/util/logging/format_fwd.hpp
   hpx/util/logging/logging.hpp
-  hpx/util/logging/format/formatter/named_spacer.hpp
   hpx/util/logging/format/formatter/high_precision_time.hpp
-  hpx/util/logging/format/formatter/time_strf.hpp
-  hpx/util/logging/format/formatter/spacer.hpp
-  hpx/util/logging/format/formatter/time.hpp
   hpx/util/logging/format/formatter/defaults.hpp
-  hpx/util/logging/format/formatter/convert_format.hpp
   hpx/util/logging/format/formatter/thread_id.hpp
-  hpx/util/logging/format/array.hpp
   hpx/util/logging/format/named_write.hpp
-  hpx/util/logging/format/destination/named.hpp
   hpx/util/logging/format/destination/defaults.hpp
-  hpx/util/logging/format/destination/convert_destination.hpp
   hpx/util/logging/format/destination/file.hpp
-  hpx/util/logging/format/op_equal.hpp
   hpx/util/logging/format/optimize.hpp
-  hpx/util/logging/format/named_write_fwd.hpp
 )
 
 # Default location is $HPX_ROOT/libs/logging/src
 set(logging_sources
+  level.cpp
   logging.cpp
+  manipulator.cpp
+  format/named_write.cpp
+  format/destination/defaults.cpp
+  format/destination/file.cpp
+  format/formatter/high_precision_time.cpp
+  format/formatter/defaults.cpp
+  format/formatter/thread_id.cpp
+  format/named_write.cpp
 )
 
 include(HPX_AddModule)
@@ -100,7 +67,9 @@ add_hpx_module(logging
   DEPENDENCIES
     hpx_assertion
     hpx_config
+    hpx_format
     hpx_filesystem
+    hpx_format
     hpx_timing
   CMAKE_SUBDIRS examples tests
 )
diff --git a/libs/logging/README.rst b/libs/logging/README.rst
index 363789f5d6..91e31aed3a 100644
--- a/libs/logging/README.rst
+++ b/libs/logging/README.rst
@@ -13,4 +13,4 @@ logging
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/logging/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/logging/docs/index.html>`__.
diff --git a/libs/logging/include/hpx/logging.hpp b/libs/logging/include/hpx/logging.hpp
index c257df43fc..a0acc5f24e 100644
--- a/libs/logging/include/hpx/logging.hpp
+++ b/libs/logging/include/hpx/logging.hpp
@@ -4,20 +4,19 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_UTIL_AGAS_LOGGING_APR_10_2008_1032AM)
-#define HPX_UTIL_AGAS_LOGGING_APR_10_2008_1032AM
+#ifndef HPX_LOGGING_HPP
+#define HPX_LOGGING_HPP
 
 #include <hpx/config.hpp>
 
-#include <string>
-#include <vector>
-
 #if defined(HPX_HAVE_LOGGING)
 
-#include <hpx/logging/format_fwd.hpp>
+#include <hpx/assertion/current_function.hpp>
+#include <hpx/format.hpp>
+#include <hpx/logging/level.hpp>
 #include <hpx/logging/logging.hpp>
 
-#include <boost/current_function.hpp>
+#include <string>
 
 ////////////////////////////////////////////////////////////////////////////////
 // specific logging
@@ -33,10 +32,8 @@
 ////////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace util {
     ////////////////////////////////////////////////////////////////////////////
-    HPX_API_EXPORT std::string levelname(int level);
-
     namespace detail {
-        HPX_API_EXPORT hpx::util::logging::level::type get_log_level(
+        HPX_API_EXPORT hpx::util::logging::level get_log_level(
             std::string const& env, bool allow_always = false);
     }
 
@@ -44,8 +41,8 @@ namespace hpx { namespace util {
     HPX_EXPORT HPX_DECLARE_LOG(agas)
 
 #define LAGAS_(lvl)                                                            \
-    HPX_LOG_USE_LOG(hpx::util::agas, ::hpx::util::logging::level::lvl)         \
-        << hpx::util::levelname(::hpx::util::logging::level::lvl) << " " /**/
+    HPX_LOG_FORMAT(hpx::util::agas, ::hpx::util::logging::level::lvl, "{} ",   \
+        ::hpx::util::logging::level::lvl) /**/
 
 #define LAGAS_ENABLED(lvl)                                                     \
     hpx::util::agas_logger()->is_enabled(::hpx::util::logging::level::lvl) /**/
@@ -54,8 +51,8 @@ namespace hpx { namespace util {
         HPX_EXPORT HPX_DECLARE_LOG(parcel)
 
 #define LPT_(lvl)                                                              \
-    HPX_LOG_USE_LOG(hpx::util::parcel, ::hpx::util::logging::level::lvl)       \
-        << hpx::util::levelname(::hpx::util::logging::level::lvl) << " " /**/
+    HPX_LOG_FORMAT(hpx::util::parcel, ::hpx::util::logging::level::lvl, "{} ", \
+        ::hpx::util::logging::level::lvl) /**/
 
 #define LPT_ENABLED(lvl)                                                       \
     hpx::util::parcel_logger()->is_enabled(                                    \
@@ -65,12 +62,11 @@ namespace hpx { namespace util {
         HPX_EXPORT HPX_DECLARE_LOG(timing)
 
 #define LTIM_(lvl)                                                             \
-    HPX_LOG_USE_LOG(hpx::util::timing, ::hpx::util::logging::level::lvl)       \
-        << hpx::util::levelname(::hpx::util::logging::level::lvl) << " " /**/
+    HPX_LOG_FORMAT(hpx::util::timing, ::hpx::util::logging::level::lvl, "{} ", \
+        ::hpx::util::logging::level::lvl) /**/
 #define LPROGRESS_                                                             \
-    HPX_LOG_USE_LOG(hpx::util::timing, ::hpx::util::logging::level::fatal)     \
-        << " " << __FILE__ << ":" << __LINE__ << " " << BOOST_CURRENT_FUNCTION \
-        << " " /**/
+    HPX_LOG_FORMAT(hpx::util::timing, ::hpx::util::logging::level::fatal,      \
+        " {}:{} {} ", __FILE__, __LINE__, HPX_ASSERT_CURRENT_FUNCTION) /**/
 
 #define LTIM_ENABLED(lvl)                                                      \
     hpx::util::timing_logger()->is_enabled(                                    \
@@ -80,9 +76,8 @@ namespace hpx { namespace util {
         HPX_EXPORT HPX_DECLARE_LOG(hpx)
 
 #define LHPX_(lvl, cat)                                                        \
-    HPX_LOG_USE_LOG(hpx::util::hpx, ::hpx::util::logging::level::lvl)          \
-        << hpx::util::levelname(::hpx::util::logging::level::lvl)              \
-        << (cat) /**/
+    HPX_LOG_FORMAT(hpx::util::hpx, ::hpx::util::logging::level::lvl, "{}{}",   \
+        ::hpx::util::logging::level::lvl, (cat)) /**/
 
 #define LHPX_ENABLED(lvl)                                                      \
     hpx::util::hpx_logger()->is_enabled(::hpx::util::logging::level::lvl) /**/
@@ -91,8 +86,8 @@ namespace hpx { namespace util {
         HPX_EXPORT HPX_DECLARE_LOG(app)
 
 #define LAPP_(lvl)                                                             \
-    HPX_LOG_USE_LOG(hpx::util::app, ::hpx::util::logging::level::lvl)          \
-        << hpx::util::levelname(::hpx::util::logging::level::lvl) << " " /**/
+    HPX_LOG_FORMAT(hpx::util::app, ::hpx::util::logging::level::lvl, "{} ",    \
+        ::hpx::util::logging::level::lvl) /**/
 
 #define LAPP_ENABLED(lvl)                                                      \
     hpx::util::app_logger()->is_enabled(::hpx::util::logging::level::lvl) /**/
@@ -102,9 +97,8 @@ namespace hpx { namespace util {
         HPX_EXPORT HPX_DECLARE_LOG(debuglog)
 
 #define LDEB_                                                                  \
-    HPX_LOG_USE_LOG(hpx::util::debuglog, ::hpx::util::logging::level::error)   \
-        << hpx::util::levelname(::hpx::util::logging::level::error)            \
-        << " " /**/
+    HPX_LOG_FORMAT(hpx::util::debuglog, ::hpx::util::logging::level::error,    \
+        "{} ", ::hpx::util::logging::level::error) /**/
 
 #define LDEB_ENABLED                                                           \
     hpx::util::debuglog_logger()->is_enabled(                                  \
@@ -116,9 +110,8 @@ namespace hpx { namespace util {
         HPX_EXPORT HPX_DECLARE_LOG(hpx_error)
 
 #define LFATAL_                                                                \
-    HPX_LOG_USE_LOG(hpx::util::hpx_error, ::hpx::util::logging::level::fatal)  \
-        << hpx::util::levelname(::hpx::util::logging::level::fatal)            \
-        << (" [ERR] ") /**/
+    HPX_LOG_FORMAT(hpx::util::hpx_error, ::hpx::util::logging::level::fatal,   \
+        "{} [ERR] ", ::hpx::util::logging::level::fatal) /**/
 
             HPX_EXPORT HPX_DECLARE_LOG(agas_console) HPX_EXPORT
         HPX_DECLARE_LOG(parcel_console) HPX_EXPORT
@@ -132,27 +125,27 @@ namespace hpx { namespace util {
 ///////////////////////////////////////////////////////////////////////////////
 #define LAGAS_CONSOLE_(lvl)                                                    \
     HPX_LOG_USE_LOG(hpx::util::agas_console,                                   \
-        static_cast<::hpx::util::logging::level::type>(lvl))                   \
+        static_cast<::hpx::util::logging::level>(lvl))                         \
     /**/
 
 #define LPT_CONSOLE_(lvl)                                                      \
     HPX_LOG_USE_LOG(hpx::util::parcel_console,                                 \
-        static_cast<::hpx::util::logging::level::type>(lvl))                   \
+        static_cast<::hpx::util::logging::level>(lvl))                         \
     /**/
 
 #define LTIM_CONSOLE_(lvl)                                                     \
     HPX_LOG_USE_LOG(hpx::util::timing_console,                                 \
-        static_cast<::hpx::util::logging::level::type>(lvl))                   \
+        static_cast<::hpx::util::logging::level>(lvl))                         \
     /**/
 
 #define LHPX_CONSOLE_(lvl)                                                     \
-    HPX_LOG_USE_LOG(hpx::util::hpx_console,                                    \
-        static_cast<::hpx::util::logging::level::type>(lvl))                   \
+    HPX_LOG_USE_LOG(                                                           \
+        hpx::util::hpx_console, static_cast<::hpx::util::logging::level>(lvl)) \
     /**/
 
 #define LAPP_CONSOLE_(lvl)                                                     \
-    HPX_LOG_USE_LOG(hpx::util::app_console,                                    \
-        static_cast<::hpx::util::logging::level::type>(lvl))                   \
+    HPX_LOG_USE_LOG(                                                           \
+        hpx::util::app_console, static_cast<::hpx::util::logging::level>(lvl)) \
     /**/
 
 #define LDEB_CONSOLE_                                                          \
@@ -183,15 +176,22 @@ namespace hpx { namespace util {
     namespace detail {
         struct dummy_log_impl
         {
-            constexpr dummy_log_impl() {}
+            constexpr dummy_log_impl() noexcept {}
+
+            template <typename T>
+            dummy_log_impl const& operator<<(T&&) const noexcept
+            {
+                return *this;
+            }
+
+            template <typename... Args>
+            dummy_log_impl const& format(char const*, Args const&...) const
+                noexcept
+            {
+                return *this;
+            }
         };
         constexpr dummy_log_impl dummy_log;
-
-        template <typename T>
-        dummy_log_impl const& operator<<(dummy_log_impl const& l, T&&)
-        {
-            return l;
-        }
     }    // namespace detail
 
     // clang-format off
@@ -246,4 +246,5 @@ bootstrap_logging const& operator<<(bootstrap_logging const& l, T&&)
 }
 
 #endif
-#endif
+
+#endif /*HPX_LOGGING_HPP*/
diff --git a/libs/logging/include/hpx/logging/detail/cache_before_init.hpp b/libs/logging/include/hpx/logging/detail/cache_before_init.hpp
deleted file mode 100644
index e9cad6d916..0000000000
--- a/libs/logging/include/hpx/logging/detail/cache_before_init.hpp
+++ /dev/null
@@ -1,78 +0,0 @@
-// cache_before_init.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_cache_before_init_HPP_DEFINED
-#define JT28092007_cache_before_init_HPP_DEFINED
-
-#include <hpx/config.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/format/optimize.hpp>
-#include <hpx/logging/writer/named_write.hpp>
-
-#include <utility>
-#include <vector>
-
-#include <hpx/config/warnings_prefix.hpp>
-
-namespace hpx { namespace util { namespace logging { namespace detail {
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Messages that were logged before initializing the log - Caching them
-
-    /**
-    The library will make sure your logger derives from this in case you want to
-    cache messages that are logged before logs are initialized.
-
-    Note:
-    - you should initialize your logs ASAP
-    - before logs are initialized
-    - cache can be turned off ONLY ONCE
-*/
-    struct HPX_EXPORT cache_before_init
-    {
-        HPX_NON_COPYABLE(cache_before_init);
-
-    private:
-        typedef std::vector<msg_type> message_array;
-
-    public:
-        cache_before_init()
-          : m_is_caching_off(false)
-        {
-        }
-
-        bool is_cache_turned_off() const noexcept
-        {
-            return m_is_caching_off;    // cache has been turned off
-        }
-
-        void turn_cache_off(writer::named_write const& writer_);
-
-        void add_msg(msg_type&& msg)
-        {
-            m_cache.push_back(std::move(msg));
-        }
-
-    private:
-        message_array m_cache;
-        bool m_is_caching_off;
-    };
-
-}}}}    // namespace hpx::util::logging::detail
-
-#include <hpx/config/warnings_suffix.hpp>
-
-#endif
diff --git a/libs/logging/include/hpx/logging/detail/error.hpp b/libs/logging/include/hpx/logging/detail/error.hpp
deleted file mode 100644
index 0871d8c400..0000000000
--- a/libs/logging/include/hpx/logging/detail/error.hpp
+++ /dev/null
@@ -1,26 +0,0 @@
-// error.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_error_HPP_DEFINED
-#define JT28092007_error_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-
-namespace hpx { namespace util { namespace logging {
-
-}}}    // namespace hpx::util::logging
-
-#endif
diff --git a/libs/logging/include/hpx/logging/detail/format_write_detail.hpp b/libs/logging/include/hpx/logging/detail/format_write_detail.hpp
deleted file mode 100644
index 43e027a0c1..0000000000
--- a/libs/logging/include/hpx/logging/detail/format_write_detail.hpp
+++ /dev/null
@@ -1,332 +0,0 @@
-// format_write_detail.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-// this is fixed!
-#ifndef JT28092007_format_write_detail_HPP_DEFINED
-#define JT28092007_format_write_detail_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-
-#include <memory>
-#include <type_traits>
-
-namespace hpx { namespace util { namespace logging {
-
-    namespace format_and_write {
-        struct simple;
-    }
-
-    /**
-@brief Classes that write the message, once it's been @ref gather "gathered".
-
-The most important class is writer::format_write
-
-*/
-    namespace writer {
-
-        /**
-@brief Allows custom formatting of the message before %logging it,
-and writing it to several destinations.
-
-Once the message has been "gathered", it's time to write it.
-The current class defines the following concepts:
-- formatter - allows formatting the message before writing it
-- destination - is a place where the message is to be written to (like, the console,
-a file, a socket, etc.)
-
-You can add several formatters and destinations. Note that each formatter class and
-each destination class is a @c %manipulator.
-Make sure you know what a manipulator is before using formatters and destinations.
-
-
-
-\n\n
-@section object_router The router object
-
-Once you've added the formatters and destinations,
-the @ref msg_route "router" comes into play. The @ref msg_route "router"
-specifies how formatters and destinations are called.
-By default, all formatters are called first, in the order they were added,
-and then all destinations are called, in the order they were added.
-You can easily access the router() instance.
-
-@code
-typedef logger< format_write > logger_type;
-HPX_DECLARE_LOG(g_l, logger_type)
-HPX_DECLARE_LOG_FILTER(g_log_filter, filter::no_ts )
-#define L_ HPX_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()->is_enabled() )
-
-// add formatters : [idx] [time] message [enter]
-g_l()->writer().add_formatter( formatter::idx() );
-g_l()->writer().add_formatter( formatter::time("$hh:$mm.$ss ") );
-g_l()->writer().add_formatter( formatter::append_newline() );
-
-// write to cout and file
-g_l()->writer().add_destination( destination::cout() );
-g_l()->writer().add_destination( destination::file("out.txt") );
-
-// usage
-int i = 1;
-L_ << "testing " << i << i+1 << i+2;
-@endcode
-
-In the above case, @c formatter::idx() is called, then @c formatter::time(),
-then @c formatter::append_newline(). Now, the destinations are called:
-@c destination::cout(), and then @c destination::file().
-
-
-
-\n\n
-@section apply_format_and_write_object The apply_format_and_write object
-
-Once the formatters and destinations are added, and you know the route, you have an
-extra object - the format_and_write - which
-contains the logic for calling the formatters and destinations.
-The format_and_write class knows how to call the formatters and destinations @em objects.
-Usually you'll be happy with the
-format_and_write::simple class - which simply calls @c operator() on the formatters,
-and @c operator() on the destinations.
-Otherwise, take a look at format_and_write namespace.
-
-An object of this type (apply_format_and_write) is created for each new logged message.
-
-
-\n\n
-@note This class is not thread-safe. If you want thread-safety,
-check out the other writer classes: on_dedicated_thread and ts_write
-
-
-
-\n\n
-@param format_base The base class for all formatter classes from your application.
-See manipulator.
-
-@param destination_base The base class for all destination classes from your application.
-See manipulator.
-
-@param apply_format_and_write [optional] The class that knows how to call
-the formatters and destinations. See @ref apply_format_and_write_object
-
-@param router_type [optional] The class that knows when to call the formatters,
-and when to call the destinations. See @ref object_router.
-
-
-
-\n\n
-@remarks Normally the router could own the formatters and destination objects.
-However, then, it would need to own the objects,
-which would mean needing to come up with a smart pointer strategy.
-This would complicate the router logic.
-Also, iterating over formatters/destinations would be slower,
-if we were to keep smart pointers within the router itself.
-
-
-
-@bug adding a spaced generic formatter and deleting the formatter - it won't happen
-
-*/
-        struct format_write
-        {
-            using formatter_base = formatter::base;
-            using destination_base = destination::base;
-            using router_type = msg_route::simple;
-            using formatter_array = array::ptr_holder<formatter_base>;
-            using destination_array = array::ptr_holder<destination_base>;
-
-            typedef typename formatter_base::ptr_type formatter_ptr;
-            typedef typename destination_base::ptr_type destination_ptr;
-
-            typedef ::hpx::util::logging::format_and_write::simple
-                apply_format_and_write_type;
-
-            format_write()
-              : m_router(m_formatters, m_destinations)
-            {
-            }
-
-        private:
-            // non-generic
-            template <class Formatter>
-            void add_formatter_impl(Formatter fmt, const std::false_type&)
-            {
-                formatter_ptr p = m_formatters.append(fmt);
-                m_router.append_formatter(p);
-            }
-
-            // non-generic
-            template <class Formatter>
-            void del_formatter_impl(Formatter fmt, const std::false_type&)
-            {
-                formatter_ptr p = m_formatters.get_ptr(fmt);
-                m_router.del_formatter(p);
-                m_formatters.del(fmt);
-            }
-
-            // non-generic
-            template <class Destination>
-            void add_destination_impl(Destination dest, const std::false_type&)
-            {
-                destination_ptr p = m_destinations.append(dest);
-                m_router.append_destination(p);
-            }
-
-            // non-generic
-            template <class Destination>
-            void del_destination_impl(Destination dest, const std::false_type&)
-            {
-                destination_ptr p = m_destinations.get_ptr(dest);
-                m_router.del_destination(p);
-                m_destinations.del(dest);
-            }
-
-            // generic manipulator
-            template <class Formatter>
-            void add_formatter_impl(Formatter fmt, const std::true_type&)
-            {
-                typedef hpx::util::logging::manipulator::detail ::
-                    generic_holder<Formatter, formatter_base>
-                        holder;
-                add_formatter_impl(holder(fmt), std::false_type());
-            }
-
-            // generic manipulator
-            template <class Formatter>
-            void del_formatter_impl(Formatter fmt, const std::true_type&)
-            {
-                typedef hpx::util::logging::manipulator::detail ::
-                    generic_holder<Formatter, formatter_base>
-                        holder;
-                del_formatter_impl(holder(fmt), std::false_type());
-            }
-
-            // generic manipulator
-            template <class Destination>
-            void add_destination_impl(Destination dest, const std::true_type&)
-            {
-                typedef hpx::util::logging::manipulator::detail ::
-                    generic_holder<Destination, destination_base>
-                        holder;
-                add_destination_impl(holder(dest), std::false_type());
-            }
-
-            // generic manipulator
-            template <class Destination>
-            void del_destination_impl(Destination dest, const std::true_type&)
-            {
-                typedef hpx::util::logging::manipulator::detail ::
-                    generic_holder<Destination, destination_base>
-                        holder;
-                del_destination_impl(holder(dest), std::false_type());
-            }
-
-        public:
-            /**
-        @brief Adds a formatter
-
-        @param fmt The formatter
-    */
-            template <class Formatter>
-            void add_formatter(Formatter fmt)
-            {
-                typedef hpx::util::logging::manipulator::is_generic is_generic;
-                add_formatter_impl<Formatter>(
-                    fmt, std::is_base_of<is_generic, Formatter>());
-            }
-
-            /**
-        @brief Adds a formatter. Also, the second argument is the @ref
-        hpx::util::logging::formatter::spacer_t "spacer" string
-
-        @param fmt The formatter
-        @param format_str The @ref hpx::util::logging::formatter::spacer_t
-        "spacer" string
-    */
-            template <class Formatter>
-            void add_formatter(Formatter fmt, const char* format_str)
-            {
-                add_formatter(spacer(fmt, format_str));
-            }
-
-            /**
-        @brief Deletes a formatter
-
-        @param fmt The formatter to delete
-    */
-            template <class Formatter>
-            void del_formatter(Formatter fmt)
-            {
-                typedef hpx::util::logging::manipulator::is_generic is_generic;
-                del_formatter_impl<Formatter>(
-                    fmt, std::is_base_of<is_generic, Formatter>());
-            }
-
-            /**
-        @brief Adds a destination
-    */
-            template <class Destination>
-            void add_destination(Destination dest)
-            {
-                typedef hpx::util::logging::manipulator::is_generic is_generic;
-                add_destination_impl<Destination>(
-                    dest, std::is_base_of<is_generic, Destination>());
-            }
-
-            /**
-        @brief Deletes a destination
-    */
-            template <class Destination>
-            void del_destination(Destination dest)
-            {
-                typedef hpx::util::logging::manipulator::is_generic is_generic;
-                del_destination_impl<Destination>(
-                    dest, std::is_base_of<is_generic, Destination>());
-            }
-
-            /**
-    returns the object that actually routes the message
-    */
-            router_type& router()
-            {
-                return m_router;
-            }
-
-            /**
-    returns the object that actually routes the message
-    */
-            const router_type& router() const
-            {
-                return m_router;
-            }
-
-            /**
-        does the actual write
-    */
-            void operator()(msg_type& msg) const
-            {
-                router().template write<apply_format_and_write_type>(msg);
-            }
-
-        private:
-            formatter_array m_formatters;
-            destination_array m_destinations;
-            router_type m_router;
-        };
-
-    }    // namespace writer
-
-}}}    // namespace hpx::util::logging
-
-#endif
diff --git a/libs/logging/include/hpx/logging/detail/fwd.hpp b/libs/logging/include/hpx/logging/detail/fwd.hpp
deleted file mode 100644
index bfe7954a5b..0000000000
--- a/libs/logging/include/hpx/logging/detail/fwd.hpp
+++ /dev/null
@@ -1,129 +0,0 @@
-// fwd.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_fwd_HPP_DEFINED
-#define JT28092007_fwd_HPP_DEFINED
-
-#include <hpx/config.hpp>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <time.h>
-
-#include <hpx/logging/detail/macros.hpp>
-
-// minimize inclusion of STL headers in our headers!!!
-#include <string>
-
-/*
-    Important: we define here only the things that are needed by ALL OF THE LIBRARY.
-    So be very careful when modifying this file
-    - we don't want any circular dependencies!
-
-    If unsure where to place something, place it logging.hpp!
-*/
-
-namespace hpx { namespace util { namespace logging {
-
-    namespace optimize {
-        struct cache_string_one_str;
-    }
-
-    typedef optimize::cache_string_one_str msg_type;
-
-    /**
-@page dealing_with_flags Dealing with flags.
-
-Some classes have extra settings. You can specify these settings in the
-class'es constructor.
-When setting a certain value, there's a very simple pattern:
-
-@code
-some_object obj(..., some_object_settings().setting1(value1).setting2(value2)....);
-@endcode
-
-Example:
-
-@code
-using namespace destination;
-file f("out.txt", file_settings.initial_overwrite(true).do_append(false) );
-@endcode
-
-*/
-
-    namespace detail {
-        template <class self_type, class type>
-        struct flag_with_self_type
-        {
-            flag_with_self_type(self_type* self, const type& val = type())
-              : m_val(val)
-              , m_self(self)
-            {
-            }
-            flag_with_self_type(flag_with_self_type const& other)
-              : m_val(other.m_val)
-              , m_self(other.m_self)
-            {
-            }
-
-            const type& operator()() const
-            {
-                return m_val;
-            }
-            self_type& operator()(const type& val)
-            {
-                m_val = val;
-                return *m_self;
-            }
-
-            flag_with_self_type& operator=(self_type const& other)
-            {
-                m_val = other.m_val;
-                return *this;
-            }
-            flag_with_self_type& operator=(flag_with_self_type const& other)
-            {
-                m_val = other.m_val;
-                m_self = other.m_self;
-                return *this;
-            }
-
-        private:
-            type m_val;
-            self_type* m_self;
-        };
-
-        /**
-        @brief Can hold a flag. See dealing_with_flags
-    */
-        template <class self_type>
-        struct flag
-        {
-            template <class val_type>
-            struct t : flag_with_self_type<self_type, val_type>
-            {
-                typedef flag_with_self_type<self_type, val_type> flag_base_type;
-                t(self_type* self, const val_type& val = val_type())
-                  : flag_base_type(self, val)
-                {
-                }
-            };
-        };
-    }    // namespace detail
-
-}}}    // namespace hpx::util::logging
-
-#endif
diff --git a/libs/logging/include/hpx/logging/detail/logger.hpp b/libs/logging/include/hpx/logging/detail/logger.hpp
index 7b178245f7..95d3e72ea6 100644
--- a/libs/logging/include/hpx/logging/detail/logger.hpp
+++ b/libs/logging/include/hpx/logging/detail/logger.hpp
@@ -14,19 +14,16 @@
 // See http://www.boost.org for updates, documentation, and revision history.
 // See http://www.torjo.com/log2/ for more details
 
-// IMPORTANT : the JT28092007_logger_HPP_DEFINED needs to remain constant
-// - don't change the macro name!
-#ifndef JT28092007_logger_HPP_DEFINED
-#define JT28092007_logger_HPP_DEFINED
-
-#include <hpx/logging/detail/cache_before_init.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/level.hpp>
+#ifndef HPX_LOGGING_DETAIL_LOGGER_HPP
+#define HPX_LOGGING_DETAIL_LOGGER_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/format.hpp>
 #include <hpx/logging/format/named_write.hpp>
+#include <hpx/logging/level.hpp>
 
-#include <sstream>
-#include <type_traits>
 #include <utility>
+#include <vector>
 
 namespace hpx { namespace util { namespace logging {
 
@@ -81,35 +78,35 @@ namespace hpx { namespace util { namespace logging {
     - check out the writer namespace
 
     */
-    struct logger
+    class logger
     {
-        typedef writer::named_write write_type;
+        HPX_NON_COPYABLE(logger);
 
-        struct gather_holder
+        struct gather_holder : message
         {    //-V690
             HPX_NON_COPYABLE(gather_holder);
 
-            gather_holder(logger const& p_this)
+            gather_holder(logger& p_this)
               : m_this(p_this)
             {
             }
 
             ~gather_holder()
             {
-                m_this.do_write(m_out.str());
-            }
-
-            std::ostringstream& out()
-            {
-                return m_out;
+                if (!empty())
+                    m_this.write(std::move(*this));
             }
 
         private:
-            logger const& m_this;
-            std::ostringstream m_out;
+            logger& m_this;
         };
 
-        logger(level::type default_level = level::enable_all)
+    public:
+        logger() noexcept
+          : m_level(level::enable_all)
+        {
+        }
+        explicit logger(level default_level) noexcept
           : m_level(default_level)
         {
         }
@@ -124,26 +121,26 @@ namespace hpx { namespace util { namespace logging {
         /**
             reads all data about a log message (gathers all the data about it)
         */
-        gather_holder gather() const
+        gather_holder gather()
         {
             return {*this};
         }
 
-        write_type& writer()
+        writer::named_write& writer() noexcept
         {
             return m_writer;
         }
-        const write_type& writer() const
+        writer::named_write const& writer() const noexcept
         {
             return m_writer;
         }
 
-        bool is_enabled(level::type level) const
+        bool is_enabled(level level) const noexcept
         {
             return level >= m_level;
         }
 
-        void set_enabled(level::type level)
+        void set_enabled(level level) noexcept
         {
             m_level = level;
         }
@@ -170,25 +167,23 @@ namespace hpx { namespace util { namespace logging {
         }
 
     public:
-        void turn_cache_off()
-        {
-            m_cache.turn_cache_off(m_writer);
-        }
+        HPX_EXPORT void turn_cache_off();
 
         // called after all data has been gathered
-        void do_write(msg_type msg) const
+        void write(message msg)
         {
-            if (m_cache.is_cache_turned_off())
+            if (m_is_caching_off)
                 m_writer(msg);
             else
-                m_cache.add_msg(std::move(msg));
+                m_cache.push_back(std::move(msg));
         }
 
     private:
-        mutable detail::cache_before_init m_cache;
-        write_type m_writer;
-        level::type m_level;
+        mutable std::vector<message> m_cache;
+        mutable bool m_is_caching_off;
+        writer::named_write m_writer;
+        level m_level;
     };
 }}}    // namespace hpx::util::logging
 
-#endif
+#endif /*HPX_LOGGING_DETAIL_LOGGER_HPP*/
diff --git a/libs/logging/include/hpx/logging/detail/macros.hpp b/libs/logging/include/hpx/logging/detail/macros.hpp
index dbf5de06cc..41a87e7061 100644
--- a/libs/logging/include/hpx/logging/detail/macros.hpp
+++ b/libs/logging/include/hpx/logging/detail/macros.hpp
@@ -21,7 +21,6 @@
 #ifndef JT28092007_macros_HPP_DEFINED
 #define JT28092007_macros_HPP_DEFINED
 
-#include <boost/current_function.hpp>
 #include <string>
 
 namespace hpx { namespace util { namespace logging {
@@ -152,7 +151,10 @@ HPX_DEFINE_LOG(g_l, logger_type)
     if (!(NAME##_logger()->is_enabled(LEVEL)))                                 \
         ;                                                                      \
     else                                                                       \
-        NAME##_logger()->gather().out()
+        NAME##_logger()->gather()
+
+#define HPX_LOG_FORMAT(NAME, LEVEL, FORMAT, ...)                               \
+    HPX_LOG_USE_LOG(NAME, LEVEL).format(FORMAT, __VA_ARGS__)
 
 }}}    // namespace hpx::util::logging
 
diff --git a/libs/logging/include/hpx/logging/detail/manipulator.hpp b/libs/logging/include/hpx/logging/detail/manipulator.hpp
deleted file mode 100644
index b8600501dd..0000000000
--- a/libs/logging/include/hpx/logging/detail/manipulator.hpp
+++ /dev/null
@@ -1,728 +0,0 @@
-// manipulator.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_manipulator_HPP_DEFINED
-#define JT28092007_manipulator_HPP_DEFINED
-
-#if defined(HPX_MSVC_WARNING_PRAGMA) && (HPX_MSVC >= 1020)
-#pragma warning(push)
-// 'class1' : inherits 'class2::member' via dominance
-#pragma warning(disable : 4250)
-#endif
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/format/optimize.hpp>
-
-#include <hpx/logging/format/op_equal.hpp>
-#include <memory>
-#include <string>
-
-namespace hpx { namespace util { namespace logging {
-
-    /**
-@brief Manipulators = Formatters and/or destinations.
-
-
-- @ref manipulator_common
-- @ref manipulator_base_class
-- @ref manipulator_default_base_class
-- @ref manipulator_generic
-- @ref manipulator_create
-- @ref manipulator_share_data
-- @ref manipulator_manipulate
-
-
-\n\n\n
-@section manipulator_common Common base class
-
-All formatters need to derive from a <b>common %base class</b>.
-Same goes for destinations.
-
-Remember:
-- formatter - allows formatting the message before writing it
-(like, prepending extra information - an index, the time, thread id, etc.)
-- destination - is a place where the message is to be written to
-(like, the console, a file, a socket, etc.)
-
-In your @ref hpx::util::logging::writer::format_write "format_write" object,
-you can have several formatters and destinations.
-Note that each formatter class and each destination class is a @c %manipulator.
-
-Each formatter and destination classes implement
-<tt>operator()(arg_type msg);</tt>, which
-processes the message:
-- for a formatter, this formats the msg
-  (like, prepends time to it, appends an enter, etc.)
-- for a destination, this writes the message to a destination (like,
-to console, a file, etc.)
-
-
-
-
-
-\n\n\n
-@section manipulator_base_class Specifying the base class
-
-You can use a typedef - one for the formatters, and one for the destinations:
-
-@code
-// ptr_type - optional ; usualy  you don't need to worry about this
-typedef formatter::base<  arg_type [,ptr_type] > formatter_base;
-typedef destination::base< arg_type [,ptr_type] > destination_base;
-@endcode
-
-
-The @c arg_type is the argument you receive in your <tt>operator()</tt>,
-to process the message. It can be as simple as this:
-
-@code
-// formatter - needs to modify the message
-typedef formatter::base< std::string&> formatter_base;
-
-// destination - needs to write the message - usually,
-it doesn't need to modify the message
-typedef destination::base<const std::string &> destination_base;
-@endcode
-
-Or, you can use a @ref customize_manipulator "custom string class", or,
-even an @ref customize_optimize "optimization string class".
-So, it's not uncommon to do something like this:
-
-@code
-typedef optimize::cache_string_one_str cache_string;
-
-// formatter - needs to modify the message - use an optimizer while formatting
-typedef formatter::base< cache_string&> formatter_base;
-
-// destination - needs to write the message - which has been converted to string
-typedef destination::base<const std::string &> destination_base;
-@endcode
-
-
-
-
-\n\n\n
-@section manipulator_default_base_class Default base classes
-
-As shown above, you can do your own typedefs. But there's an easier way,
-to specify the default base classes:
-use the default formatter %base class and the default destination %base class.
-
-They are: <tt>formatter::base<> </tt> and <tt>destination::base<> </tt>.
-
-The default destination %base class is computed based on your usage of the
-@ref HPX_LOG_DESTINATION_MSG macro:
-- if you haven't used it, it's <tt>const std::(w)string & </tt>
-- if you've used it, it's the type you specified there; see below
-
-@code
-HPX_LOG_DESTINATION_MSG( my_cool_string )
-@endcode
-
-In the above case
-@code
-destination::base<> = destination::base< const my_cool_string & >
-@endcode
-
-
-
-
-
-\n\n\n
-@section manipulator_generic Using manipulators that come with the library
-
-Now, you will define your @ref logger "logger(s)",
-to use the @ref hpx::util::logging::writer::format_write "format_write" class:
-
-@code
-HPX_DECLARE_LOG(g_l, logger_format_write );
-@endcode
-
-After this, you'll add formatter and/or destination classes to your logger(s):
-
-@code
-// add formatters : [idx] [time] message [enter]
-g_l()->writer().add_formatter( formatter::idx() );
-g_l()->writer().add_formatter( formatter::time() );
-g_l()->writer().add_formatter( formatter::append_newline() );
-
-// write to cout and file
-g_l()->writer().add_destination( destination::cout() );
-g_l()->writer().add_destination( destination::file("out.txt") );
-@endcode
-
-In the above case, if you were to write:
-
-@code
-#define L_ ... // defining the logger
-
-int i = 1;
-L_ << "this is so cool" << i++;
-@endcode
-
-a message similar to this would appear on both the console, and the file:
-
-@code
-[1] 12:57 this is so cool 1 <enter>
-@endcode
-
-
-You can use the formatter and/or destination classes that come with the library:
-- formatters: in the formatter namespace. Here are a few examples:
-  - formatter::idx - prepends an index
-  - formatter::append_newline - appends an enter after the message
-  - formatter::append_newline_if_needed - appends an enter after the message,
-  if not already there
-  - formatter::time - prepends the time
-  - formatter::thread_id - prepends the current thread id
-- destinations: in the destination namespace
-  - destination::cout - writes to console
-  - destination::stream - writes to a stream
-  - destination::file - writes to file
-  (using @c hpx::util::shmem::named_shared_object)
-
-Or, you can create your own formatter and/or destination class. See below:
-
-
-
-\n\n\n
-@section manipulator_create Creating your own formatter and/or destination class(es)
-
-To create your formatter class, you need to derive from
-@ref class_ "formatter::class_". You will need to implement
-<tt>operator()(arg_type)</tt> <br>
-(@c arg_type is the argument from your
-@ref manipulator_base_class "formatter base class")
-
-@code
-// milliseconds since start of the program
-struct ms_since_start : formatter::class_<ms_since_start> {
-    time_t m_start;
-    ms_since_start : m_start( time(0) ) {}
-
-    // param = std::string&
-    // (in other words, it's the arg_type from your formatter base class)
-    void operator()(param msg) const {
-        std::ostringstream out;
-        time_t now = time(0);
-        out << "[" << (now-start) << "] ";
-        msg = out.str() + msg;
-    }
-};
-@endcode
-
-To create your destination class, you need to derive from
-@ref class_ "destination::class_". You will need to implement
-<tt>operator()(arg_type)</tt> <br>
-(@c arg_type is the argument from your @ref manipulator_base_class
-"destination base class")
-
-@code
-struct to_hwnd
-: destination::class_<to_hwnd> {
-    HWND h;
-    to_hwnd(HWND h) : h(h) {}
-
-    bool operator==(const to_hwnd& other) { return h == other.h; }
-
-    // param = const std::string&
-    // (in other words, it's the arg_type from your destination base class)
-    void operator()(param msg) const {
-        ::SetWindowText(h, msg.c_str());
-    }
-};
-@endcode
-
-
-
-\n\n\n
-@section manipulator_share_data Sharing data for manipulator classes
-
-When you implement your own %manipulator (%formatter or %destination) class,
-you must make sure that
-it behaves like an STL function: <b>it needs to contain data as constant.</b>
-
-As long as data is constant, it's all ok - that is, no matter what functions get called,
-all the data in the formatter/destination
-must remain constant. We need constant functors - just like in STL - because internally,
-we copy formatters/destinations: that is, we keep
-several copies of a certain object - they all need to be syncronized.
-In case the objects' data is constant, that's no problem.
-
-In case the data needs to be changed - it needs to be shared.
-Several copies of the same instance must point to the same data.
-I've already provided a class you can derive from,
-when this is the case: the non_const_context class.
-
-@code
-struct my_file : destination::class_<my_file,destination_base,op_equal_has_context>,
-destination::non_const_context<std::ofstream> {
-    std::string m_filename;
-    bool operator==(const my_file & other) { return m_filename == other.m_filename; }
-
-    write_to_file(const std::string & filename)
-    : m_filename(filename), non_const_context_base(filename.c_str()) {}
-    void operator()(param msg) const {
-        context() << msg << std::endl ;
-    }
-};
-@endcode
-
-
-\n\n\n
-@section manipulator_manipulate Modifying a manipulator's state
-
-When it comes to keeping its state, a manipulator (formatter or destination) instance,
-has 2 possibilities:
--# either all its member data is constant - in which case you can't manipulate
-it (you can't modify it), OR
--# it has non const information, which can change, and thus, some can be manipulated
-
-In the former case, all the member functions the manipulator exposes
-are <tt>const</tt>ant.
-
-In the latter case,
-- your manipulator class can have member functions that can change its state
-(non-const member functions).
-- your manipulator class @b must use the non_const_context class to hold
-all its non-const state
-
-What this guarantees is @ref non_const_pointer_semantics "pointer-like semantics".
-
-Assume that you have your logger that uses formatters and destinations.
-You've added a manipulator to your logger,
-and at a later time, you want to modify it (the manipulator, that is).
-To achieve this, you'll create a copy, and modify that one (this will work
-because of the @ref non_const_pointer_semantics "pointer-like semantics"):
-
-Example 1: reusing the same %destination for 2 logs
-
-@code
-destination::file out("out.txt");
-g_l_dbg()->writer().add_destination(out);
-g_l_app()->writer().add_destination(out);
-@endcode
-
-\n
-Example 2: allow resetting/clearing a destination's stream
-
-@code
-// allow resetting a destination's stream
-destination::stream g_out(std::cout);
-g_l()->writer().add_destintination(g_out);
-
-// assuming this uses g_l(), this will output to std::cout
-L_ << "hello world";
-
-g_out.stream(&std::cerr);
-// assuming this uses g_l(), this will output to std::cerr
-L_ << "hello world 2";
-
-g_out.clear();
-// assuming this uses g_l(), this will not output anything
-L_ << "hello world 3";
-
-@endcode
-
-
-
-
-\n\n\n
-@section manipulator_use_it Using loggers in code
-
-Now that you've @ref manipulator_generic "added" formatters and/or destinations,
-you'll @ref defining_logger_macros "define the macros through which you'll do logging",
-and then do logging in your code:
-
-@code
-// macros through which you'll do logging
-#define LDBG_ HPX_LOG_USE_LOG_IF_LEVEL(g_l(), g_log_level(), debug )
-#define LERR_ HPX_LOG_USE_LOG_IF_LEVEL(g_l(), g_log_level(), error )
-#define LAPP_ HPX_LOG_USE_LOG_IF_LEVEL(g_l(), g_log_level(), info )
-
-// doing logging in code
-int i = 1;
-LDBG_ << "this is so cool " << i++;
-LERR_ << "first error " << i++;
-
-std::string hello = "hello", world = "world";
-LAPP_ << hello << ", " << world;
-
-g_log_level()->set_enabled(level::error);
-LDBG_ << "this will not be written anywhere";
-LAPP_ << "this won't be written anywhere either";
-LERR_ << "second error " << i++;
-
-g_log_level()->set_enabled(level::info);
-LAPP_ << "good to be back ;) " << i++;
-LERR_ << "third error " << i++;
-
-@endcode
-
-*/
-    namespace manipulator {
-
-        /**
-    @brief What to use as base class, for your manipulator classes
-
-    When using formatters and destinations, formatters must share a %base class,
-    and destinations must share a %base class - see manipulator namespace.
-
-    @note
-    Don't use directly. Use formatter::base<> or destination::base<> instead.
-*/
-        template <class raw_param_type, class param_type>
-        struct base : hpx::util::logging::op_equal::same_type_op_equal_base
-        {
-            typedef base<raw_param_type, param_type> self_type;
-
-            typedef self_type* ptr_type;
-
-            // used as msg_type in format_and_write classes
-            typedef raw_param_type raw_param;
-            typedef param_type param;
-
-            virtual void operator()(param val) const = 0;
-
-            /** @brief Override this if you want to allow configuration through scripting
-
-    That is, this allows configuration of your manipulator (formatter/destination)
-    at run-time.
-    */
-            virtual void configure(const std::string&) {}
-
-        protected:
-            // signify that we're only a base class - not to be used directly
-            base() {}
-            virtual ~base() {}
-        };
-
-        /**
-    @brief Use this when implementing your own formatter or destination class.
-    Don't use this directly. Use formatter::class_ or destination::class_
-*/
-        template <class type, class base_type>
-        struct class_
-          : base_type
-          , hpx::util::logging::op_equal::same_type_op_equal<type>
-        {
-            /** @brief Override this if you want to allow configuration through scripting
-
-    That is, this allows configuration of your manipulator
-    (formatter/destination) at run-time.
-    */
-            virtual void configure(const std::string&) {}
-
-            bool operator==(const class_&) const
-            {
-                return true;
-            }
-        };
-
-        /** @brief In case your manipulator (formatter or destination)
-needs to hold non-const context information, it can to derive from this.
-This automatically creates a shared pointer to the context information.
-
-Also, it provides the following operations:
-
-@c context(), which returns a <tt>context_type &</tt> reference
-
-Example:
-
-@code
-struct write_to_file : destination_base,
-destination::non_const_context<std::ofstream> {
-write_to_file(const char* filename) : non_const_context_base(filename) {}
-void operator()(param msg) const {
-    context() << msg ;
-}
-};
-@endcode
-
-@section non_const_pointer_semantics non_const_context - Pointer-like semantics
-
-Using non_const_context guarantees @em pointer-like semantics:
-if you copy-construct or copy-assign a value, both values will point to the same context:
-
-@code
-write_to_file a, b = a;
-a.file_name("t1.txt");
-// a == b  (a's state == b's state)
-
-write_to_file c, d;
-c.file_name("t2.txt");
-// c != d  (c's state != d's state)
-
-d = c;
-c.file_name("t3.txt");
-// c == d  (c's state == d's state)
-@endcode
-
-
-@remarks
-In case your manipulator has constant data, you don't need this
-*/
-        template <class context_type>
-        struct non_const_context
-        {    //-V690
-
-            // this can be used in the parent class, to forward data from its constructor
-            typedef non_const_context<context_type> non_const_context_base;
-
-        private:
-            typedef non_const_context<context_type> self_type;
-            typedef std::shared_ptr<context_type> ptr_type;
-
-        protected:
-            non_const_context(const non_const_context& other)
-              : m_context(other.m_context)
-            {
-            }
-
-            template <typename... ps>
-            non_const_context(const ps&... as)
-              : m_context(new context_type(as...))
-            {
-            }
-
-            context_type& context() const
-            {
-                return *(m_context.get());
-            }
-
-        private:
-            mutable ptr_type m_context;
-        };
-
-        /**
-@brief Represents a generic manipulator (formatter or destination)
-
-A generic manipulator is one that does not derive from any formatter_base
-or destination_base class (@ref manipulator_base_class).
-
-Libraries, such as this one, can provide generic manipulators,
-and they can't rely on
-any @ref manipulator_base_class "base class" - since it's you,
-the user, who can choose which is the base class.
-
-A generic manipulator has no way of knowing the type of the
-@em msg you pass on operator().
-Thus, usually generic manipulators have a templated operator=,
-and do the best to convert what's in, to what they need.
-
-Example:
-@code
-struct cout {
-    void operator()(const msg_type & msg) const {
-        do_convert_destination::write(msg, std::cout);
-    }
-};
-@endcode
-
-As long as exists a conversion function from your @c msg_type to what
-the manipulator needs, it all works.
-Thus, no matter what your %formatter @ref manipulator_base_class "base class" or
-%destination @ref manipulator_base_class "base class"
-is, the code will still work. You can add your %formatter/ %destination classes,
-and the generic %formatter/ %destination classes
-
-@code
-typedef ... formatter_base;
-logger< format_write > g_l();
-
-struct my_cool_formatter : formatter_base { ... };
-
-// adding formatter class from the Logging lib
-g_l().add_formatter( formatter::thread_id() );
-
-// adding formatter class defined by you
-g_l().add_formatter( my_cool_formatter() );
-@endcode
-
-@sa hpx::util::logging::destination::convert, hpx::util::logging::formatter::convert
-*/
-        struct is_generic
-        {
-            virtual ~is_generic() {}
-
-            /** @brief Override this if you want to allow configuration through scripting
-
-    That is, this allows configuration of your manipulator
-    (formatter/destination) at run-time.
-    */
-            virtual void configure(const std::string&) {}
-        };
-
-        namespace detail {
-
-            // holds the generic manipulator, and forwards to it
-            template <class generic_type, class manipulator_base>
-            struct generic_holder
-              : class_<generic_holder<generic_type, manipulator_base>,
-                    manipulator_base>
-            {
-                typedef typename manipulator_base::param param;
-
-                generic_type m_val;
-                generic_holder(const generic_type& val)
-                  : m_val(val)
-                {
-                }
-
-                bool operator==(const generic_holder& other) const
-                {
-                    return m_val == other.m_val;
-                }
-
-                virtual void operator()(param val) const
-                {
-                    m_val.operator()(val);
-                }
-
-                virtual void configure(const std::string& str)
-                {
-                    m_val.configure(str);
-                }
-            };
-        }    // namespace detail
-
-    }    // namespace manipulator
-
-    /**
-@brief Formatter is a manipulator.
-It allows you to format the message before writing it to the destination(s)
-
-Examples of formatters are : @ref formatter::time_t "prepend the time",
-@ref formatter::high_precision_time_t "prepend high-precision time",
-@ref formatter::idx_t "prepend the index of the message", etc.
-
-
-See:
-- @ref manipulator "The manipulator namespace"
-- @ref manipulator_manipulate "Modifying a formatter's state"
-- @ref manipulator::non_const_context "formatter::non_const_context"
-
-*/
-    namespace formatter {
-        namespace detail {
-            struct format_base_finder
-            {
-                typedef ::hpx::util::logging::optimize::cache_string_one_str
-                    arg_type;
-                typedef hpx::util::logging::manipulator::base<arg_type,
-                    arg_type&>
-                    type;
-            };
-        }    // namespace detail
-
-        /**
-    @brief What to use as base class, for your formatter classes
-
-    When using formatters and destinations, formatters must share a %base class,
-    and destinations must share a %base class - see manipulator namespace.
-    */
-        struct base : detail::format_base_finder::type
-        {
-        };
-
-        /**
-        @brief Use this when implementing your own formatter class
-
-        @param type Your own class name
-
-        @param base_type (optional) The formatter base class.
-        Unless you've specified your own formatter class,
-        you'll be happy with the default
-    */
-        template <class type, class base_type = base>
-        struct class_ : hpx::util::logging::manipulator::class_<type, base_type>
-        {
-        };
-
-        using hpx::util::logging::manipulator::non_const_context;
-
-        /**
-        @sa hpx::util::logging::manipulator::is_generic
-    */
-        typedef hpx::util::logging::manipulator::is_generic is_generic;
-
-    }    // namespace formatter
-
-    /**
-@brief Destination is a manipulator. It contains a place where the message,
-after being formatted, is to be written to.
-
-Some viable destinations are : @ref destination::cout "the console",
-@ref destination::file "a file", a socket, etc.
-
-See:
-- @ref manipulator "The manipulator namespace"
-- @ref manipulator_manipulate "Modifying a destination's state"
-- @ref manipulator::non_const_context "formatter::non_const_context"
-
-
-*/
-    namespace destination {
-        namespace detail {
-            struct destination_base_finder
-            {
-                typedef std::string arg_type;
-                typedef hpx::util::logging::manipulator::base<arg_type,
-                    const arg_type&>
-                    type;
-            };
-        }    // namespace detail
-
-        /**
-    @brief What to use as base class, for your destination classes
-
-    When using formatters and destinations, formatters must share a %base class,
-    and destinations must share a %base class - see manipulator namespace.
-    */
-        struct base : detail::destination_base_finder::type
-        {
-        };
-
-        using hpx::util::logging::manipulator::non_const_context;
-
-        /**
-        @brief Use this when implementing your own destination class
-
-        @param type Your own class name
-
-        @param base_type (optional)
-        The destination base class. Unless you've specified your own destination class,
-        you'll be happy with the default
-    */
-        template <class type, class base_type = base>
-        struct class_ : hpx::util::logging::manipulator::class_<type, base_type>
-        {
-        };
-
-        /**
-        @sa hpx::util::logging::manipulator::is_generic
-    */
-        typedef hpx::util::logging::manipulator::is_generic is_generic;
-
-    }    // namespace destination
-
-}}}    // namespace hpx::util::logging
-
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(pop)
-#endif
-
-#endif
diff --git a/libs/logging/include/hpx/logging/detail/time_format_holder.hpp b/libs/logging/include/hpx/logging/detail/time_format_holder.hpp
deleted file mode 100644
index 03afdf944b..0000000000
--- a/libs/logging/include/hpx/logging/detail/time_format_holder.hpp
+++ /dev/null
@@ -1,217 +0,0 @@
-// time_format_holder.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_time_format_holder_HPP_DEFINED
-#define JT28092007_time_format_holder_HPP_DEFINED
-
-#include <hpx/assertion.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-
-#include <algorithm>
-#include <cstddef>
-#include <cstdio>
-#include <sstream>
-#include <string>
-#include <vector>
-
-namespace hpx { namespace util { namespace logging { namespace detail {
-
-    /**
-    This only holds the time format, and allows writing a certain time
-*/
-    struct time_format_holder
-    {
-    private:
-        struct index_info
-        {
-            typedef std::size_t uint;
-
-            index_info(uint src_idx_, int* format_idx_, int advance_size_ = 2,
-                int size_ = 2)
-              : src_idx(src_idx_)
-              , format_idx(format_idx_)
-              , advance_size(advance_size_)
-              , size(size_)
-            {
-            }
-            uint src_idx;
-            int* format_idx;
-            int advance_size;
-            int size;
-
-            static bool by_index(
-                const index_info& first, const index_info& second)
-            {
-                return first.src_idx < second.src_idx;
-            }
-        };
-
-    public:
-        bool operator==(const time_format_holder& other) const
-        {
-            return m_format == other.m_format;
-        }
-
-        /**
-        constructs a time format holder object
-    */
-        time_format_holder(const std::string& format)
-          : m_day(-1)
-          , m_month(-1)
-          , m_yy(-1)
-          , m_yyyy(-1)
-          , m_hour(-1)
-          , m_min(-1)
-          , m_sec(-1)
-          , m_millisec(-1)
-          , m_microsec(-1)
-          , m_nanosec(-1)
-        {
-            set_format(format);
-        }
-
-        void set_format(const std::string& format)
-        {
-            // format too big
-            HPX_ASSERT(format.size() < 64);
-            m_format.clear();
-
-            m_day = -1;
-            m_month = -1;
-            m_yy = -1;
-            m_yyyy = -1;
-            m_hour = -1;
-            m_min = -1;
-            m_sec = -1;
-            m_millisec = -1;
-            m_microsec = -1;
-            m_nanosec = -1;
-
-            typedef std::size_t uint;
-            uint day_idx = format.find("$dd");
-            uint month_idx = format.find("$MM");
-            uint yy_idx = format.find("$yy");
-            uint yyyy_idx = format.find("$yyyy");
-            uint hour_idx = format.find("$hh");
-            uint min_idx = format.find("$mm");
-            uint sec_idx = format.find("$ss");
-            uint millisec_idx = format.find("$mili");
-            uint microsec_idx = format.find("$micro");
-            uint nanosec_idx = format.find("$nano");
-
-            typedef std::vector<index_info> array;
-            array indexes;
-            if (day_idx != std::string::npos)
-                indexes.emplace_back(day_idx, &m_day);
-            if (month_idx != std::string::npos)
-                indexes.emplace_back(month_idx, &m_month);
-
-            if (yy_idx != std::string::npos || yyyy_idx != std::string::npos)
-            {
-                if (yyyy_idx != std::string::npos)
-                    indexes.emplace_back(yyyy_idx, &m_yyyy, 4);    //-V112
-                else
-                    indexes.emplace_back(yy_idx, &m_yy);
-            }
-
-            if (hour_idx != std::string::npos)
-                indexes.emplace_back(hour_idx, &m_hour);
-            if (min_idx != std::string::npos)
-                indexes.emplace_back(min_idx, &m_min);
-            if (sec_idx != std::string::npos)
-                indexes.emplace_back(sec_idx, &m_sec);
-            if (millisec_idx != std::string::npos)
-                indexes.emplace_back(
-                    millisec_idx, &m_millisec, 4, 3);    // -V112
-            if (microsec_idx != std::string::npos)
-                indexes.emplace_back(microsec_idx, &m_microsec, 5, 6);
-            if (nanosec_idx != std::string::npos)
-                indexes.emplace_back(nanosec_idx, &m_nanosec, 4, 9);    //-V112
-
-            std::sort(indexes.begin(), indexes.end(), index_info::by_index);
-
-            // create the format string, that we can actually pass to sprintf
-            uint prev_idx = 0;
-            int idx = 0;
-            for (array::iterator begin = indexes.begin(), end = indexes.end();
-                 begin != end; ++begin)
-            {
-                m_format += format.substr(prev_idx, begin->src_idx - prev_idx);
-                *begin->format_idx = idx;
-                std::ostringstream cur_sprintf_format;
-                cur_sprintf_format << "%0" << begin->size << "d";
-                m_format += cur_sprintf_format.str();
-                prev_idx = static_cast<hpx::util::logging::detail ::
-                        time_format_holder::index_info::uint>(begin->src_idx +
-                    static_cast<hpx::util::logging::detail::
-                            time_format_holder ::index_info::uint>(
-                        begin->advance_size) +
-                    1ul);
-                ++idx;
-            }
-
-            m_format += format.substr(prev_idx);
-        }
-
-        void write_time(char buffer[], int day, int month, int year, int hour,
-            int min, int sec, int millisec, int microsec, int nanosec) const
-        {
-            int vals[11];
-            vals[m_day + 1] = day;
-            vals[m_month + 1] = month;
-            vals[m_yy + 1] = year % 100;
-            vals[m_yyyy + 1] = year;
-            vals[m_hour + 1] = hour;
-            vals[m_min + 1] = min;
-            vals[m_sec + 1] = sec;
-            vals[m_millisec + 1] = millisec;
-            vals[m_microsec + 1] = microsec;
-            vals[m_nanosec + 1] = nanosec;
-
-            // ignore value at index 0
-            // - it's there so that I don't have to test for an index being -1
-            sprintf(buffer, m_format.c_str(), vals[1], vals[2], vals[3],
-                vals[4], vals[5], vals[6], vals[7], vals[8], vals[9], vals[10]);
-        }
-
-        void write_time(char buffer[], int day, int month, int year, int hour,
-            int min, int sec) const
-        {
-            int vals[8];
-            vals[m_day + 1] = day;
-            vals[m_month + 1] = month;
-            vals[m_yy + 1] = year % 100;
-            vals[m_yyyy + 1] = year;
-            vals[m_hour + 1] = hour;
-            vals[m_min + 1] = min;
-            vals[m_sec + 1] = sec;
-
-            // ignore value at index 0
-            // - it's there so that I don't have to test for an index being -1
-            sprintf(buffer, m_format.c_str(), vals[1], vals[2], vals[3],
-                vals[4], vals[5], vals[6], vals[7]);
-        }
-
-    private:
-        // the indexes of each escape sequence within the format string
-        int m_day, m_month, m_yy, m_yyyy, m_hour, m_min, m_sec, m_millisec,
-            m_microsec, m_nanosec;
-        std::string m_format;
-    };
-
-}}}}    // namespace hpx::util::logging::detail
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format.hpp b/libs/logging/include/hpx/logging/format.hpp
deleted file mode 100644
index 0fe0f2cfed..0000000000
--- a/libs/logging/include/hpx/logging/format.hpp
+++ /dev/null
@@ -1,286 +0,0 @@
-// format.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-// this is fixed!
-#ifndef JT28092007_format_HPP_DEFINED
-#define JT28092007_format_HPP_DEFINED
-
-#include <hpx/assertion.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
-#include <hpx/logging/format/array.hpp>
-#include <hpx/logging/format/op_equal.hpp>
-#include <hpx/logging/format_fwd.hpp>
-
-#include <algorithm>
-#include <memory>
-#include <set>
-#include <string>
-#include <type_traits>
-#include <vector>
-
-namespace hpx { namespace util { namespace logging {
-
-    /**
-@file hpx/logging/format.hpp
-
-Include this file when you're using @ref manipulator "formatters and destinations",
-and you want to define the logger classes, in a source file
-(using HPX_DEFINE_LOG)
-
-*/
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Format and write
-    //
-
-    /**
-        @brief The @c %format_and_write classes know how to call
-        the formatter and destination @c objects.
-
-        Usually you'll be happy with the
-        format_and_write::simple class - which simply calls @c
-        operator() on the formatters , and @c operator() on the destinations.
-
-        Note that usually the formatter and destination class just have an @c operator(),
-        which when called, formats the message
-        or writes it to a destination. In case your formatters/destinations are
-        more complex than that (for instance, more than
-        a member function needs to be called),
-        you'll have to implement your own %format_and_write class.
-    */
-    namespace format_and_write {
-
-        /**
-        @brief Formats the message, and writes it to destinations
-        - calls @c operator() on the formatters , and @c operator() on the destinations.
-        Ignores @c clear_format() commands.
-
-        @param msg_type The message to pass to the formatter. This is the
-        type that is passed to the formatter objects and to the destination objects.
-        Thus, it needs to be convertible to the argument to be sent to the
-        formatter objects and to the argument to be sent to the destination objects.
-        Usually, it's the argument you pass on to your destination classes.
-
-        If you derive from @c destination::base, this type can be
-        @c destination::base::raw_param (see below).
-
-        Example:
-
-        @code
-        typedef destination::base<const std::string &> dest_base;
-        // in this case : msg_type = std::string = dest_base::raw_param
-        struct write_to_cout : dest_base {
-            void operator()(param msg) const {
-                std::cout << msg ;
-            }
-        };
-
-
-        typedef destination::base<const std::string &> dest_base;
-        // in this case : msg_type = cache_string = dest_base::raw_param
-        struct write_to_file : dest_base, ... {
-            void operator()(param msg) const {
-                context() << msg ;
-            }
-        };
-
-        @endcode
-    */
-        struct simple
-        {
-            simple(msg_type& msg)
-              : m_msg(msg)
-            {
-            }
-
-            template <class formatter_ptr>
-            void format(const formatter_ptr& fmt)
-            {
-                (*fmt)(m_msg);
-            }
-            template <class destination_ptr>
-            void write(const destination_ptr& dest)
-            {
-                (*dest)(m_msg);
-            }
-            void clear_format() {}
-
-        protected:
-            msg_type& m_msg;
-        };
-
-    }    // namespace format_and_write
-
-    ///////////////////////////////////////////////////////////////////////////
-    // Message routing
-    //
-
-    /**
-    @brief Specifies the route : how formatting and writing to destinations take place.
-
-    Classes in this namespace specify when formatters and destinations are to be called.
-
-    @sa msg_route::simple
-
-    */
-    namespace msg_route {
-
-        /**
-        @brief Recomended base class for message routers that
-        need access to the underlying formatter and/or destination array.
-    */
-        template <class formatter_array, class destination_array>
-        struct formatter_and_destination_array_holder
-        {
-        protected:
-            formatter_and_destination_array_holder(
-                const formatter_array& formats_,
-                const destination_array& destinations_)
-              : m_formats(formats_)
-              , m_destinations(destinations_)
-            {
-            }
-
-            const formatter_array& formats() const
-            {
-                return m_formats;
-            }
-            const destination_array& destinations() const
-            {
-                return m_destinations;
-            }
-
-        private:
-            const formatter_array& m_formats;
-            const destination_array& m_destinations;
-        };
-
-        /**
-@brief Represents a simple router - first calls all formatters
-- in the order they were added, then all destinations - in the order they were added
-
-Example:
-
-@code
-typedef logger< format_write > logger_type;
-HPX_DEFINE_LOG_FILTER(g_log_filter, filter::no_ts )
-HPX_DEFINE_LOG(g_l, logger_type)
-#define L_ HPX_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()->is_enabled() )
-
-// add formatters : [idx] [time] message [enter]
-g_l()->writer().add_formatter( write_idx() );
-g_l()->writer().add_formatter( write_time() );
-g_l()->writer().add_formatter( append_newline() );
-
-// write to cout and file
-g_l()->writer().add_destination( write_to_cout() );
-g_l()->writer().add_destination( write_to_file("out.txt") );
-
-// usage
-int i = 1;
-L_ << "testing " << i << i+1 << i+2;
-@endcode
-
-In the above case:
-- First, the formatters are called: @c write_idx() is called, then @c write_time(),
-then @c append_newline().
-- Then, the destinations are called: @c write_to_cout(), and then @c write_to_file().
-
-
-
-@param format_base The base class for all formatter classes from your application.
-See manipulator.
-
-@param destination_base The base class for all destination classes from your application.
-See manipulator.
-
-    */
-        struct simple
-        {
-            typedef typename formatter::base::ptr_type formatter_ptr;
-            typedef typename destination::base::ptr_type destination_ptr;
-
-            typedef std::vector<formatter_ptr> f_array;
-            typedef std::vector<destination_ptr> d_array;
-            struct write_info
-            {
-                f_array formats;
-                d_array destinations;
-            };
-
-            template <class formatter_array, class destination_array>
-            simple(const formatter_array&, const destination_array&)
-            {
-            }
-
-            void append_formatter(formatter_ptr fmt)
-            {
-                m_to_write.formats.push_back(fmt);
-            }
-            void del_formatter(formatter_ptr fmt)
-            {
-                typename f_array::iterator del = std::remove(
-                    m_to_write.formats.begin(), m_to_write.formats.end(), fmt);
-                m_to_write.formats.erase(del, m_to_write.formats.end());
-            }
-
-            void append_destination(destination_ptr dest)
-            {
-                m_to_write.destinations.push_back(dest);
-            }
-
-            void del_destination(destination_ptr dest)
-            {
-                typename d_array::iterator del =
-                    std::remove(m_to_write.destinations.begin(),
-                        m_to_write.destinations.end(), dest);
-                m_to_write.destinations.erase(
-                    del, m_to_write.destinations.end());
-            }
-
-            template <class format_and_write>
-            void write(msg_type& msg) const
-            {
-                format_and_write m(msg);
-
-                for (typename f_array::const_iterator
-                         b_f = m_to_write.formats.begin(),
-                         e_f = m_to_write.formats.end();
-                     b_f != e_f; ++b_f)
-                    m.format(*b_f);
-
-                for (typename d_array::const_iterator
-                         b_d = m_to_write.destinations.begin(),
-                         e_d = m_to_write.destinations.end();
-                     b_d != e_d; ++b_d)
-                    m.write(*b_d);
-            }
-
-        private:
-            write_info m_to_write;
-        };
-
-    }    // namespace msg_route
-}}}      // namespace hpx::util::logging
-
-#include <hpx/logging/detail/format_write_detail.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
-
-#include <hpx/logging/format/destination/defaults.hpp>
-#include <hpx/logging/format/formatter/defaults.hpp>
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/array.hpp b/libs/logging/include/hpx/logging/format/array.hpp
deleted file mode 100644
index 508a713dba..0000000000
--- a/libs/logging/include/hpx/logging/format/array.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-// array_holder.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_array_holder_HPP_DEFINED
-#define JT28092007_array_holder_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <memory>
-#include <vector>
-
-namespace hpx { namespace util { namespace logging {
-
-    ///////////////////////////////////////////////////////////////////////////
-    // array holder class
-    namespace array {
-
-        /**
-        Holds an array of manipulators (formatters or destinations). It owns them,
-        holding them internally as smart pointers
-        Each function call is locked.
-
-        The base_type must implement operator==
-
-        When you call get_ptr() or del(), the type you provide, must implement
-        operator==(const type& , const base_type&)
-    */
-        template <class base_type>
-        class ptr_holder
-        {
-        public:
-            typedef base_type value_type;
-            typedef std::unique_ptr<value_type> ptr_type;
-            typedef std::vector<ptr_type> array_type;
-
-            template <class derived>
-            base_type* append(derived val)
-            {
-                // FIXME try/catch
-                derived* copy = new derived(val);
-                m_array.push_back(ptr_type(copy));
-                return copy;
-            }
-
-            template <class derived>
-            base_type* get_ptr(derived val) const
-            {
-                for (typename array_type::const_iterator b = m_array.begin(),
-                                                         e = m_array.end();
-                     b != e; ++b)
-                    if (val == (*(b->get())))
-                        return b->get();
-
-                // not found
-                return 0;
-            }
-
-            template <class derived>
-            void del(derived val)
-            {
-                base_type* p = get_ptr(val);
-                del(p);
-            }
-
-            void del(base_type* p)
-            {
-                for (typename array_type::iterator b = m_array.begin(),
-                                                   e = m_array.end();
-                     b != e; ++b)
-                    if (b->get() == p)
-                    {
-                        m_array.erase(b);
-                        return;
-                    }
-            }
-
-        private:
-            array_type m_array;
-        };
-
-    }    // namespace array
-
-}}}    // namespace hpx::util::logging
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/destination/convert_destination.hpp b/libs/logging/include/hpx/logging/format/destination/convert_destination.hpp
deleted file mode 100644
index f5c15da352..0000000000
--- a/libs/logging/include/hpx/logging/format/destination/convert_destination.hpp
+++ /dev/null
@@ -1,71 +0,0 @@
-// convert_destination.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_convert_destination_HPP_DEFINED
-#define JT28092007_convert_destination_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <ostream>
-#include <string>
-
-namespace hpx { namespace util { namespace logging { namespace destination {
-
-    template <class t>
-    struct into
-    {
-    };
-
-    /**
-@brief Allows writing messages to destinations
-
-It has 2 function overloads:
-- write(message, output) - writes the given message, to the given output
-- do_convert(message, into<other_type>() );
-
-FIXME
-*/
-    namespace convert {
-        template <class obj>
-        inline void write(const obj& m, std::ostream& out)
-        {
-            out << m;
-        }
-
-        inline void write(const char* m, std::ostream& out)
-        {
-            out << m;
-        }
-
-        inline const char* do_convert(const char* c, const into<const char*>&)
-        {
-            return c;
-        }
-        inline const char* do_convert(
-            const std::string& s, const into<const char*>&)
-        {
-            return s.c_str();
-        }
-
-        inline const std::string& do_convert(
-            const std::string& s, const into<std::string>&)
-        {
-            return s;
-        }
-    }    // namespace convert
-
-}}}}    // namespace hpx::util::logging::destination
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/destination/defaults.hpp b/libs/logging/include/hpx/logging/format/destination/defaults.hpp
deleted file mode 100644
index 13ab056843..0000000000
--- a/libs/logging/include/hpx/logging/format/destination/defaults.hpp
+++ /dev/null
@@ -1,138 +0,0 @@
-// destination_defaults.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_destination_defaults_HPP_DEFINED
-#define JT28092007_destination_defaults_HPP_DEFINED
-
-#include <hpx/config.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
-#include <hpx/logging/format/destination/convert_destination.hpp>
-#include <hpx/logging/format/destination/file.hpp>
-#include <iostream>
-
-namespace hpx { namespace util { namespace logging { namespace destination {
-
-    /**
-    @brief Writes the string to console
-*/
-    struct cout : is_generic
-    {
-        void operator()(const msg_type& msg) const
-        {
-            convert::write(msg, std::cout);
-        }
-
-        bool operator==(const cout&) const
-        {
-            return true;
-        }
-    };
-
-    /**
-    @brief Writes the string to cerr
-*/
-    struct cerr : is_generic
-    {
-        void operator()(const msg_type& msg) const
-        {
-            convert::write(msg, std::cerr);
-        }
-
-        bool operator==(const cerr&) const
-        {
-            return true;
-        }
-    };
-
-    /**
-    @brief writes to stream.
-
-    @note:
-    The stream must outlive this object! Or, clear() the stream,
-    before the stream is deleted.
-*/
-    struct stream
-      : is_generic
-      , non_const_context<std::ostream*>
-    {
-        typedef std::ostream stream_type;
-        typedef non_const_context<stream_type*> non_const_context_base;
-
-        stream(stream_type* s)
-          : non_const_context_base(s)
-        {
-        }
-        stream(stream_type& s)
-          : non_const_context_base(&s)
-        {
-        }
-
-        void operator()(const msg_type& msg) const
-        {
-            if (non_const_context_base::context())
-                convert::write(msg, *non_const_context_base::context());
-        }
-
-        bool operator==(const stream& other) const
-        {
-            return non_const_context_base::context() !=
-                other.non_const_context_base::context();
-        }
-
-        /**
-        @brief resets the stream. Further output will be written to this stream
-    */
-        void set_stream(stream_type* p)
-        {
-            non_const_context_base::context() = p;
-        }
-
-        /**
-        @brief clears the stream. Further output will be ignored
-    */
-        void clear()
-        {
-            set_stream(nullptr);
-        }
-    };
-
-    /**
-    @brief Writes the string to output debug window
-
-    For non-Windows systems, this is the console.
-*/
-    struct dbg_window : is_generic
-    {
-        void operator()(const msg_type& msg) const
-        {
-#ifdef HPX_WINDOWS
-            ::OutputDebugStringA(convert::do_convert(msg, into<const char*>()));
-#else
-            // non windows - dump to console
-            std::cout << msg;
-#endif
-        }
-
-        bool operator==(const dbg_window&) const
-        {
-            return true;
-        }
-    };
-
-}}}}    // namespace hpx::util::logging::destination
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/destination/file.hpp b/libs/logging/include/hpx/logging/format/destination/file.hpp
deleted file mode 100644
index 31c19fe7e4..0000000000
--- a/libs/logging/include/hpx/logging/format/destination/file.hpp
+++ /dev/null
@@ -1,166 +0,0 @@
-// destination_file.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_destination_file_HPP_DEFINED
-#define JT28092007_destination_file_HPP_DEFINED
-
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(push)
-#pragma warning(disable : 4355)
-#endif
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
-#include <hpx/logging/format/destination/convert_destination.hpp>
-
-#include <boost/config.hpp>
-#include <boost/smart_ptr/detail/spinlock.hpp>
-
-#include <fstream>
-#include <memory>
-#include <mutex>
-#include <string>
-
-namespace hpx { namespace util { namespace logging { namespace destination {
-
-    /**
-    @brief settings for when constructing a file class. To see how it's used,
-    see @ref dealing_with_flags.
-*/
-    struct file_settings
-    {
-        typedef ::hpx::util::logging::detail::flag<file_settings> flag;
-
-        file_settings()
-          : flush_each_time(this, true)
-          , initial_overwrite(this, false)
-          , do_append(this, true)
-          , extra_flags(this, std::ios_base::out)
-        {
-        }
-
-        /// if true (default), flushes after each write
-        flag::t<bool> flush_each_time;
-        // if true it initially overwrites the file; default = false
-        flag::t<bool> initial_overwrite;
-        // if true (default), opens the file for appending
-        flag::t<bool> do_append;
-
-        /// just in case you have some extra flags to pass, when opening the file
-        flag::t<std::ios_base::openmode> extra_flags;
-    };
-
-    namespace detail {
-        inline std::ios_base::openmode open_flags(file_settings fs)
-        {
-            std::ios_base::openmode flags = std::ios_base::out;
-            flags |= fs.extra_flags();
-            if (fs.do_append() && !fs.initial_overwrite())
-                flags |= std::ios_base::app;
-            if (fs.initial_overwrite())
-                flags |= std::ios_base::trunc;
-            return flags;
-        }
-
-        struct file_info
-        {
-            file_info(const std::string& name_, file_settings const& settings_)
-              : name(name_)
-              ,
-              //               out( new std::ofstream
-              //                   ( name_.c_str(), open_flags(settings_) )),
-              settings(settings_)
-            {
-            }
-
-            void open()
-            {
-                out.reset(
-                    new std::ofstream(name.c_str(), open_flags(settings)));
-            }
-
-            void close()
-            {
-                out.reset();
-            }
-
-            std::string name;
-            std::shared_ptr<std::ofstream> out;
-            file_settings settings;
-        };
-    }    // namespace detail
-
-    /**
-    @brief Writes the string to a file
-*/
-    struct file
-      : is_generic
-      , non_const_context<detail::file_info>
-    {
-        typedef non_const_context<detail::file_info> non_const_context_base;
-        typedef boost::detail::spinlock mutex_type;
-
-        /**
-        @brief constructs the file destination
-
-        @param file_name name of the file
-        @param set [optional] file settings - see file_settings class,
-        and @ref dealing_with_flags
-    */
-        file(const std::string& file_name, file_settings set = file_settings())
-          : non_const_context_base(file_name, set)
-        {
-        }
-
-        void operator()(const msg_type& msg) const
-        {
-            std::lock_guard<mutex_type> l(mtx_);
-
-            if (!non_const_context_base::context().out)
-                non_const_context_base::context()
-                    .open();    // make sure file is opened
-            convert::write(msg, *(non_const_context_base::context().out));
-            if (non_const_context_base::context().settings.flush_each_time())
-                non_const_context_base::context().out->flush();
-        }
-
-        bool operator==(const file& other) const
-        {
-            return non_const_context_base::context().name ==
-                other.context().name;
-        }
-
-        /** configure through script
-        right now, you can only specify the file name
-    */
-        void configure(const std::string& str)
-        {
-            // configure - the file name, for now
-            non_const_context_base::context().close();
-            non_const_context_base::context().name.assign(
-                str.begin(), str.end());
-        }
-
-        static mutex_type mtx_;
-    };
-
-}}}}    // namespace hpx::util::logging::destination
-
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(pop)
-#endif
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/destination/named.hpp b/libs/logging/include/hpx/logging/format/destination/named.hpp
deleted file mode 100644
index a03d93b65c..0000000000
--- a/libs/logging/include/hpx/logging/format/destination/named.hpp
+++ /dev/null
@@ -1,247 +0,0 @@
-// destination_named.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_destination_named_HPP_DEFINED
-#define JT28092007_destination_named_HPP_DEFINED
-
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(push)
-#pragma warning(disable : 4355)
-#endif
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
-#include <hpx/logging/format/array.hpp>    // array
-#include <hpx/logging/format/destination/convert_destination.hpp>
-
-#include <map>
-#include <memory>
-#include <sstream>
-#include <string>
-#include <type_traits>
-#include <vector>
-
-namespace hpx { namespace util { namespace logging { namespace destination {
-
-    namespace detail {
-        struct named_context
-        {
-            typedef base destination_base_type;
-            typedef ::hpx::util::logging::array::ptr_holder<
-                destination_base_type>
-                array;
-
-            struct write_info
-            {
-                array destinations;
-                typedef std::map<std::string, destination_base_type*> coll;
-                coll name_to_destination;
-                std::string format_string;
-
-                typedef std::vector<destination_base_type*> step_array;
-                step_array write_steps;
-            };
-            write_info m_info;
-
-            template <class destination_type>
-            void add(const std::string& name, destination_type dest)
-            {
-                // care about if generic or not
-                typedef hpx::util::logging::manipulator::is_generic is_generic;
-                add_impl<destination_type>(name, dest,
-                    std::is_base_of<is_generic, destination_type>());
-                compute_write_steps();
-            }
-
-            void del(const std::string& name)
-            {
-                {
-                    destination_base_type* p = m_info.name_to_destination[name];
-                    m_info.name_to_destination.erase(name);
-                    m_info.destinations.del(p);
-                }
-                compute_write_steps();
-            }
-
-            void configure(
-                const std::string& name, const std::string& configure_str)
-            {
-                destination_base_type* p = m_info.name_to_destination[name];
-                if (p)
-                    p->configure(configure_str);
-            }
-
-            void format_string(const std::string& str)
-            {
-                {
-                    m_info.format_string = str;
-                }
-                compute_write_steps();
-            }
-
-            void write(const msg_type& msg) const
-            {
-                for (typename write_info::step_array::const_iterator
-                         b = m_info.write_steps.begin(),
-                         e = m_info.write_steps.end();
-                     b != e; ++b)
-                    (**b)(msg);
-            }
-
-        private:
-            // non-generic
-            template <class destination_type>
-            void add_impl(const std::string& name, destination_type dest,
-                const std::false_type&)
-            {
-                destination_base_type* p = m_info.destinations.append(dest);
-                m_info.name_to_destination[name] = p;
-            }
-            // generic manipulator
-            template <class destination_type>
-            void add_impl(const std::string& name, destination_type dest,
-                const std::true_type&)
-            {
-                typedef hpx::util::logging::manipulator::detail ::
-                    generic_holder<destination_type, destination_base_type>
-                        holder;
-                add_impl(name, holder(dest), std::false_type());
-            }
-
-            // recomputes the write steps - note taht this takes place after
-            // each operation for instance, the user might have first set the
-            // string and later added the formatters
-            void HPX_EXPORT compute_write_steps();
-        };
-
-    }    // namespace detail
-
-    /**
-@brief Allows you to contain multiple destinations,
-give each such destination a name.
-Then, at run-time, you can specify a format string which will specify which
-destinations to be called, and on what order.
-
-This allows you:
-- to hold multiple destinations
-- each destination is given a name, when being added.
-The name <b>must not</b> contain spaces and must not start with '+'/'-' signs
-- you have a %format string, which contains what destinations to be called,
-and on which order
-
-The %format string contains destination names, separated by space.
-
-When a message is written to this destination,
-I parse the format string. When a name is encountered, if there's a destination
-corresponding to this name, I will call it.
-
-Example:
-
-@code
-g_l()->writer().add_destination(
-    destination::named("cout out debug")
-        .add( "cout", destination::cout())
-        .add( "debug", destination::dbg_window() )
-        .add( "out", destination::file("out.txt"))
-     );
-@endcode
-
-In the above code, we'll write to 3 destinations, in the following order:
-- first, to the console
-- second, to the out.txt file
-- third, to the debug window
-
-
-
-@section If you deal with config files
-
-As an extra feature:
-- if a name starts with '-' is ignored
-- if a name starts with '+', is included.
-
-This is useful if you want to set this format string in a config file.
-The good thing is that this way you can easily turn on/off
-certain destinations, while seing all the available destinations as well.
-
-Example: \n <tt>+out_file -debug_window +console</tt> \n
-In the above example, I know that the available destinations are @c out_file,
-@c debug_window and @c console, but I'm not writing to @c debug_window.
-
-
-@code
-#include <hpx/logging/format/destination/named.hpp>
-@endcode
-*/
-    struct named
-      : is_generic
-      , non_const_context<detail::named_context>
-    {
-        typedef non_const_context<detail::named_context> non_const_context_base;
-
-        /**
-        @brief constructs the named destination
-
-        @param named_name name of the named
-        @param set [optional] named settings - see named_settings class,
-        and @ref dealing_with_flags
-    */
-        named(const std::string& format_string = std::string())
-        {
-            non_const_context_base::context().format_string(format_string);
-        }
-        void operator()(const msg_type& msg) const
-        {    //-V659
-            non_const_context_base::context().write(msg);
-        }
-
-        named& string(const std::string& str)
-        {
-            non_const_context_base::context().format_string(str);
-            return *this;
-        }
-
-        template <class destination>
-        named& add(const std::string& name, destination dest)
-        {
-            non_const_context_base::context().add(name, dest);
-            return *this;
-        }
-
-        void del(const std::string& name)
-        {
-            non_const_context_base::context().del(name);
-        }
-
-        void configure_inner(
-            const std::string& name, const std::string& configure_str)
-        {
-            non_const_context_base::context().configure(name, configure_str);
-        }
-
-        bool operator==(const named& other) const
-        {
-            return &(non_const_context_base::context()) ==
-                &(other.non_const_context_base::context());
-        }
-    };
-
-}}}}    // namespace hpx::util::logging::destination
-
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(pop)
-#endif
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/destinations.hpp b/libs/logging/include/hpx/logging/format/destinations.hpp
new file mode 100644
index 0000000000..7476fff026
--- /dev/null
+++ b/libs/logging/include/hpx/logging/format/destinations.hpp
@@ -0,0 +1,166 @@
+// destination_defaults.hpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#ifndef HPX_LOGGING_FORMAT_DESTINATIONS_HPP
+#define HPX_LOGGING_FORMAT_DESTINATIONS_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/logging/manipulator.hpp>
+
+#include <ios>
+#include <iosfwd>
+#include <memory>
+#include <ostream>
+#include <string>
+
+namespace hpx { namespace util { namespace logging { namespace destination {
+
+    /**
+    @brief Writes the string to console
+*/
+    struct cout : manipulator
+    {
+        HPX_EXPORT static std::unique_ptr<cout> make();
+
+        HPX_EXPORT ~cout();
+
+    protected:
+        cout() = default;
+    };
+
+    /**
+    @brief Writes the string to cerr
+*/
+    struct cerr : manipulator
+    {
+        HPX_EXPORT static std::unique_ptr<cerr> make();
+
+        HPX_EXPORT ~cerr();
+
+    protected:
+        cerr() = default;
+    };
+
+    /**
+    @brief writes to stream.
+
+    @note:
+    The stream must outlive this object! Or, clear() the stream,
+    before the stream is deleted.
+*/
+    struct stream : manipulator
+    {
+        HPX_EXPORT static std::unique_ptr<stream> make(
+            std::ostream* stream_ptr);
+
+        HPX_EXPORT ~stream();
+
+        /**
+        @brief resets the stream. Further output will be written to this stream
+    */
+        void set_stream(std::ostream* stream_ptr)
+        {
+            ptr = stream_ptr;
+        }
+
+        /**
+        @brief clears the stream. Further output will be ignored
+    */
+        void clear()
+        {
+            ptr = nullptr;
+        }
+
+    protected:
+        explicit stream(std::ostream* stream_ptr)
+          : ptr(stream_ptr)
+        {
+        }
+
+    protected:
+        std::ostream* ptr;
+    };
+
+    /**
+    @brief Writes the string to output debug window
+
+    For non-Windows systems, this is the console.
+*/
+    struct dbg_window : manipulator
+    {
+        HPX_EXPORT static std::unique_ptr<dbg_window> make();
+
+        HPX_EXPORT ~dbg_window();
+
+    protected:
+        dbg_window() = default;
+    };
+
+    /**
+    @brief Writes the string to a file
+*/
+    struct file : manipulator
+    {
+        /**
+    @brief settings for when constructing a file class. To see how it's used,
+    see @ref dealing_with_flags.
+*/
+        struct file_settings
+        {
+            file_settings()
+              : flush_each_time(true)
+              , initial_overwrite(false)
+              , do_append(true)
+              , extra_flags(std::ios_base::out)
+            {
+            }
+
+            /// if true (default), flushes after each write
+            bool flush_each_time : 1;
+            // if true it initially overwrites the file; default = false
+            bool initial_overwrite : 1;
+            // if true (default), opens the file for appending
+            bool do_append : 1;
+            /// just in case you have some extra flags to pass, when opening the file
+            std::ios_base::openmode extra_flags;
+        };
+
+        /**
+        @brief constructs the file destination
+
+        @param file_name name of the file
+        @param set [optional] file settings - see file_settings class,
+        and @ref dealing_with_flags
+    */
+        HPX_EXPORT static std::unique_ptr<file> make(
+            std::string const& file_name, file_settings set = {});
+
+        HPX_EXPORT ~file();
+
+    protected:
+        file(std::string const& file_name, file_settings set)
+          : name(file_name)
+          , settings(set)
+        {
+        }
+
+        std::string name;
+        file_settings settings;
+    };
+
+}}}}    // namespace hpx::util::logging::destination
+
+#endif /*HPX_LOGGING_FORMAT_DESTINATIONS_HPP*/
diff --git a/libs/logging/include/hpx/logging/format/formatter/convert_format.hpp b/libs/logging/include/hpx/logging/format/formatter/convert_format.hpp
deleted file mode 100644
index 53533125bc..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/convert_format.hpp
+++ /dev/null
@@ -1,159 +0,0 @@
-// convert_format.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_convert_format_HPP_DEFINED
-#define JT28092007_convert_format_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/format/optimize.hpp>
-#include <string>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    /**
-    @brief Allows format convertions
-    - In case you're using a formatter that does not match your string type
-
-    In case you want to use a formatter developed by someone else
-    (for instance, a formatter provided by this lib),
-    perhaps you're using another type of string to hold the message
-    - thus, you need to provide a conversion function
-
-    Example:
-    FIXME
-
-    --> convert_format::prepend
-
-    explain that you can extend the following - since they're namespaces!!!
-    so that you can "inject" your own write function
-    in the convert_format::prepend/orwhatever namespace, and
-    then it'll be automatically used!
-*/
-    namespace convert {
-        /**
-    Example : write_time
-    */
-        namespace prepend {
-
-            inline void write(const char* src, std::string& dest)
-            {
-                const char* end = src;
-                for (; *end; ++end)
-                {
-                }
-                dest.insert(dest.begin(), src, end);
-            }
-            inline void write(const std::string& src, std::string& dest)
-            {
-                dest.insert(dest.begin(), src.begin(), src.end());
-            }
-            inline void write(const std::string& src,
-                hpx::util::logging::optimize::cache_string_one_str& dest)
-            {
-                dest.prepend_string(src);
-            }
-
-            inline void write(const char* src,
-                hpx::util::logging::optimize::cache_string_one_str& dest)
-            {
-                dest.prepend_string(src);
-            }
-        }    // namespace prepend
-
-        /**
-    */
-        namespace append {
-            inline void write(const std::string& src, std::string& dest)
-            {
-                dest += src;
-            }
-            inline void write(const std::string& src,
-                hpx::util::logging::optimize::cache_string_one_str& dest)
-            {
-                dest.append_string(src);
-            }
-
-            inline void write(const char* src, std::string& dest)
-            {
-                dest += src;
-            }
-            inline void write(const char* src,
-                hpx::util::logging::optimize::cache_string_one_str& dest)
-            {
-                dest.append_string(src);
-            }
-
-        }    // namespace append
-    }        // namespace convert
-
-    struct do_convert_format
-    {
-        struct prepend
-        {
-            template <class string>
-            static const std::string& get_underlying_string(const string& str)
-            {
-                return str;
-            }
-
-            template <class string>
-            static void write(const char* src, string& dest)
-            {
-                convert::prepend::write(src, dest);
-            }
-
-            template <class src_type, class string>
-            static void write(const src_type& src, string& dest)
-            {
-                convert::prepend::write(src, dest);
-            }
-            template <class src_type, class string>
-            static void write(src_type& src, string& dest)
-            {
-                convert::prepend::write(src, dest);
-            }
-        };
-
-        struct append
-        {
-            template <class string>
-            static const std::string& get_underlying_string(const string& str)
-            {
-                return str;
-            }
-
-            template <class string>
-            static void write(const char* src, string& dest)
-            {
-                convert::append::write(src, dest);
-            }
-
-            template <class src_type, class string>
-            static void write(const src_type& src, string& dest)
-            {
-                convert::append::write(src, dest);
-            }
-            template <class src_type, class string>
-            static void write(src_type& src, string& dest)
-            {
-                convert::append::write(src, dest);
-            }
-        };
-    };
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatter/defaults.hpp b/libs/logging/include/hpx/logging/format/formatter/defaults.hpp
deleted file mode 100644
index 96f2562ddc..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/defaults.hpp
+++ /dev/null
@@ -1,161 +0,0 @@
-// formatter_defaults.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_formatter_defaults_HPP_DEFINED
-#define JT28092007_formatter_defaults_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
-#include <hpx/logging/format/formatter/convert_format.hpp>
-#include <hpx/logging/format/formatter/spacer.hpp>
-#include <hpx/logging/format/formatter/thread_id.hpp>
-#include <hpx/logging/format/formatter/time.hpp>
-#include <hpx/logging/format/formatter/time_strf.hpp>
-#include <cstdint>
-#include <iomanip>
-#include <ios>
-#include <sstream>
-#include <stdio.h>
-#include <time.h>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    /**
-@brief prefixes each message with an index.
-
-Example:
-@code
-L_ << "my message";
-L_ << "my 2nd message";
-@endcode
-
-This will output something similar to:
-
-@code
-[1] my message
-[2] my 2nd message
-@endcode
-
-
-@param convert [optional] In case there needs to be a conversion between
-std::(w)string and the string that holds your logged message. See convert_format.
-For instance, you might use @ref hpx::util::logging::optimize::cache_string_one_str
-"a cached_string class" (see @ref hpx::util::logging::optimize "optimize namespace").
-*/
-    template <class convert = do_convert_format::prepend>
-    struct idx_t
-      : is_generic
-      , formatter::non_const_context<std::uint64_t>
-    {
-        typedef formatter::non_const_context<std::uint64_t>
-            non_const_context_base;
-        typedef convert convert_type;
-
-        idx_t()
-          : non_const_context_base(0ull)
-        {
-        }
-        void operator()(msg_type& str) const
-        {
-            std::ostringstream idx;
-            idx << std::hex << std::setw(sizeof(std::uint64_t) * 2)
-                << std::setfill('0') << ++context();
-
-            convert::write(idx.str(), str);
-        }
-
-        bool operator==(const idx_t&) const
-        {
-            return true;
-        }
-    };
-
-    /**
-@brief Appends a new line
-
-@param convert [optional] In case there needs to be a conversion between
-std::(w)string and the string that holds your logged message. See convert_format.
-For instance, you might use @ref hpx::util::logging::optimize::cache_string_one_str
-"a cached_string class" (see @ref hpx::util::logging::optimize "optimize namespace").
-*/
-    template <class convert = do_convert_format::append>
-    struct append_newline_t : is_generic
-    {
-        typedef convert convert_type;
-
-        void operator()(msg_type& str) const
-        {
-            convert::write("\n", str);
-        }
-
-        bool operator==(const append_newline_t&) const
-        {
-            return true;
-        }
-    };
-
-    /**
-@brief Appends a new line, if not already there
-
-@param convert [optional] In case there needs to be a conversion between
-std::(w)string and the string that holds your logged message. See convert_format.
-For instance, you might use @ref hpx::util::logging::optimize::cache_string_one_str
-"a cached_string class" (see @ref hpx::util::logging::optimize "optimize namespace").
-*/
-    template <class convert = do_convert_format::append>
-    struct append_newline_if_needed_t : is_generic
-    {
-        typedef convert convert_type;
-
-        void operator()(msg_type& str) const
-        {
-            bool is_needed = true;
-            if (!convert::get_underlying_string(str).empty())
-                if (*(convert::get_underlying_string(str).rbegin()) == '\n')
-                    is_needed = false;
-
-            if (is_needed)
-                convert::write("\n", str);
-        }
-
-        bool operator==(const append_newline_if_needed_t&) const
-        {
-            return true;
-        }
-    };
-
-    /** @brief idx_t with default values. See idx_t
-
-@copydoc idx_t
-*/
-    typedef idx_t<> idx;
-
-    /** @brief append_newline_t with default values. See append_newline_t
-
-@copydoc append_newline_t
-*/
-    typedef append_newline_t<> append_newline;
-
-    /** @brief append_newline_if_needed_t with default values. See
-     * append_newline_if_needed_t
-
-@copydoc append_newline_if_needed_t
-*/
-    typedef append_newline_if_needed_t<> append_newline_if_needed;
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatter/high_precision_time.hpp b/libs/logging/include/hpx/logging/format/formatter/high_precision_time.hpp
deleted file mode 100644
index ae4439957a..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/high_precision_time.hpp
+++ /dev/null
@@ -1,165 +0,0 @@
-// high_precision_time.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_high_precision_time_HPP_DEFINED
-#define JT28092007_high_precision_time_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-
-#include <hpx/logging/detail/manipulator.hpp>    // is_generic
-#include <hpx/logging/detail/time_format_holder.hpp>
-#include <hpx/logging/format/formatter/convert_format.hpp>
-
-#include <chrono>
-#include <cstdint>
-#include <ctime>
-#include <string>
-
-#if !(defined(__linux) || defined(linux) || defined(__linux__) ||              \
-    defined(__FreeBSD__) || defined(__APPLE__) || defined(HPX_MSVC))
-#include <boost/smart_ptr/detail/spinlock.hpp>
-#include <mutex>
-#endif
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    /**
-@brief Prefixes the message with a high-precision time (.
-You pass the format string at construction.
-
-@code
-#include <hpx/logging/format/formatter/high_precision_time.hpp>
-@endcode
-
-Internally, it uses hpx::util::date_time::microsec_time_clock.
-So, our precision matches this class.
-
-The format can contain escape sequences:
-$dd - day, 2 digits
-$MM - month, 2 digits
-$yy - year, 2 digits
-$yyyy - year, 4 digits
-$hh - hour, 2 digits
-$mm - minute, 2 digits
-$ss - second, 2 digits
-$mili - milliseconds
-$micro - microseconds (if the high precision clock allows; otherwise, it pads zeros)
-$nano - nanoseconds (if the high precision clock allows; otherwise, it pads zeros)
-
-
-Example:
-
-@code
-high_precision_time("$mm:$ss:$micro");
-@endcode
-
-@param convert [optional] In case there needs to be a conversion between
-std::(w)string and the string that holds your logged message. See convert_format.
-For instance, you might use @ref hpx::util::logging::optimize::cache_string_one_str
-"a cached_string class" (see @ref hpx::util::logging::optimize "optimize namespace").
-*/
-    template <class convert = do_convert_format::prepend>
-    struct high_precision_time_t
-      : is_generic
-      , non_const_context<hpx::util::logging::detail::time_format_holder>
-    {
-        typedef convert convert_type;
-        typedef non_const_context<
-            hpx::util::logging::detail::time_format_holder>
-            non_const_context_base;
-
-        /**
-        constructs a high_precision_time object
-    */
-        high_precision_time_t(const std::string& format)
-          : non_const_context_base(format)
-        {
-        }
-
-        void write_high_precision_time(msg_type& msg,
-            std::chrono::time_point<std::chrono::system_clock> val) const
-        {
-            std::time_t tt = std::chrono::system_clock::to_time_t(val);
-
-#if defined(__linux) || defined(linux) || defined(__linux__) ||                \
-    defined(__FreeBSD__) || defined(__APPLE__)
-            std::tm local_tm;
-            localtime_r(&tt, &local_tm);
-#elif defined(HPX_MSVC)
-            std::tm local_tm;
-            localtime_s(&local_tm, &tt);
-#else
-            // fall back to non-thread-safe version on other platforms
-            std::tm local_tm;
-            {
-                static boost::detail::spinlock mutex =
-                    BOOST_DETAIL_SPINLOCK_INIT;
-                std::unique_lock<boost::detail::spinlock> ul(mutex);
-                local_tm = *std::localtime(&tt);
-            }
-#endif
-
-            std::chrono::nanoseconds nanosecs =
-                std::chrono::duration_cast<std::chrono::nanoseconds>(
-                    val.time_since_epoch());
-            std::chrono::microseconds microsecs =
-                std::chrono::duration_cast<std::chrono::microseconds>(
-                    val.time_since_epoch());
-            std::chrono::milliseconds millisecs =
-                std::chrono::duration_cast<std::chrono::milliseconds>(
-                    val.time_since_epoch());
-
-            char buffer[64];
-
-            non_const_context_base::context().write_time(buffer,
-                local_tm.tm_mday, local_tm.tm_mon + 1, local_tm.tm_year + 1900,
-                local_tm.tm_hour, local_tm.tm_min, local_tm.tm_sec,
-                millisecs.count() % 1000, microsecs.count() % 1000,
-                nanosecs.count() % 1000);
-
-            convert::write(buffer, msg);
-        }
-
-        void operator()(msg_type& msg) const
-        {
-            write_high_precision_time(msg, std::chrono::system_clock::now());
-        }
-
-        bool operator==(const high_precision_time_t& other) const
-        {
-            return non_const_context_base::context() ==
-                other.non_const_context_base::context();
-        }
-
-        /** @brief configure through script
-
-        the string = the time format
-    */
-        void configure(const std::string& str)
-        {
-            non_const_context_base::context().set_format(str);
-        }
-    };
-
-    /** @brief high_precision_time_t with default values. See high_precision_time_t
-
-@copydoc high_precision_time_t
-*/
-    typedef high_precision_time_t<> high_precision_time;
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatter/named_spacer.hpp b/libs/logging/include/hpx/logging/format/formatter/named_spacer.hpp
deleted file mode 100644
index db805f5e28..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/named_spacer.hpp
+++ /dev/null
@@ -1,308 +0,0 @@
-// named_spacer.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_named_spacer_HPP_DEFINED
-#define JT28092007_named_spacer_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
-#include <hpx/logging/format/array.hpp>                       // array
-#include <hpx/logging/format/formatter/convert_format.hpp>    // do_convert_format
-
-#include <cstddef>
-#include <map>
-#include <memory>
-#include <string>
-#include <type_traits>
-#include <vector>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    namespace detail {
-
-        inline std::string unescape(std::string escaped)
-        {
-            typedef std::size_t size_type;
-            size_type idx_start = 0;
-            while (true)
-            {
-                size_type found = escaped.find("%%", idx_start);
-                if (found != std::string::npos)
-                {
-                    escaped.erase(
-                        escaped.begin() + static_cast<std::ptrdiff_t>(found));
-                    ++idx_start;
-                }
-                else
-                    break;
-            }
-            return escaped;
-        }
-
-        struct base_named_spacer_context
-        {
-            typedef base format_base_type;
-            typedef ::hpx::util::logging::array::ptr_holder<format_base_type>
-                array;
-
-            struct write_step
-            {
-                write_step(const std::string& prefix_, format_base_type* fmt_)
-                  : prefix(prefix_)
-                  , fmt(fmt_)
-                {
-                }
-                std::string prefix;
-                // could be null - in case formatter not found by name, or it's
-                // the last step
-                format_base_type* fmt;
-            };
-
-            struct write_info
-            {
-                array formatters;
-                typedef std::map<std::string, format_base_type*> coll;
-                coll name_to_formatter;
-
-                std::string format_string;
-
-                // how we write
-                typedef std::vector<write_step> write_step_array;
-                write_step_array write_steps;
-            };
-            write_info m_info;
-
-            template <class formatter, class converter>
-            void add(const std::string& name, formatter fmt)
-            {
-                // care about if generic or not
-                typedef hpx::util::logging::manipulator::is_generic is_generic;
-                add_impl<converter, formatter>(
-                    name, fmt, std::is_base_of<is_generic, formatter>());
-                compute_write_steps();
-            }
-
-            void del(const std::string& name)
-            {
-                {
-                    format_base_type* p = m_info.name_to_formatter[name];
-                    m_info.name_to_formatter.erase(name);
-                    m_info.formatters.del(p);
-                }
-                compute_write_steps();
-            }
-
-            void configure(
-                const std::string& name, const std::string& configure_str)
-            {
-                format_base_type* p = m_info.name_to_formatter[name];
-                if (p)
-                    p->configure(configure_str);
-            }
-
-            void format_string(const std::string& str)
-            {
-                {
-                    m_info.format_string = str;
-                }
-                compute_write_steps();
-            }
-
-        protected:
-            template <class converter>
-            void write_with_convert(msg_type& msg,
-                ::hpx::util::logging::formatter::do_convert_format::prepend*)
-                const
-            {
-                // prepend
-                typedef typename write_info::write_step_array array_;
-                for (typename array_::const_reverse_iterator
-                         b = m_info.write_steps.rbegin(),
-                         e = m_info.write_steps.rend();
-                     b != e; ++b)
-                {
-                    if (b->fmt)
-                        (*(b->fmt))(msg);
-                    converter::write(b->prefix, msg);
-                }
-            }
-            template <class converter>
-            void write_with_convert(msg_type& msg, ...) const
-            {
-                // append
-                typedef typename write_info::write_step_array array_;
-                for (typename array_::const_iterator
-                         b = m_info.write_steps.begin(),
-                         e = m_info.write_steps.end();
-                     b != e; ++b)
-                {
-                    converter::write(b->prefix, msg);
-                    if (b->fmt)
-                        (*(b->fmt))(msg);
-                }
-            }
-
-            // recomputes the write steps - note taht this takes place after
-            // each operation for instance, the user might have first set the
-            // string and later added the formatters
-            void HPX_EXPORT compute_write_steps();
-
-        private:
-            // non-generic
-            template <class convert, class formatter>
-            void add_impl(
-                const std::string& name, formatter fmt, const std::false_type&)
-            {
-                format_base_type* p = m_info.formatters.append(fmt);
-                m_info.name_to_formatter[name] = p;
-            }
-            // generic manipulator
-            template <class convert, class formatter>
-            void add_impl(
-                const std::string& name, formatter fmt, const std::true_type&)
-            {
-                typedef hpx::util::logging::manipulator::detail::generic_holder<
-                    formatter, format_base_type>
-                    holder;
-
-                typedef typename formatter::convert_type formatter_convert_type;
-                // they must share the same type of conversion - otherwise when
-                // trying to prepend we could end up appending or vice versa
-                static_assert(
-                    (std::is_same<formatter_convert_type, convert>::value),
-                    "std::is_same<formatter_convert_type, "
-                    "convert_type>::value");
-
-                add_impl<convert>(name, holder(fmt), std::false_type());
-            }
-        };
-
-        template <class convert>
-        struct named_spacer_context : base_named_spacer_context
-        {
-            typedef convert convert_type;
-
-            template <class formatter>
-            void add(const std::string& name, formatter fmt)
-            {
-                base_named_spacer_context::add<formatter, convert>(name, fmt);
-            }
-
-            void write(msg_type& msg) const
-            {
-                base_named_spacer_context::write_with_convert<convert>(
-                    msg, nullptr);
-            }
-        };
-    }    // namespace detail
-
-    /**
-@brief Allows you to contain multiple formatters,
-and specify a %spacer between them. You have a %spacer string, and within it,
-you can escape your contained formatters.
-
-@code
-#include <hpx/logging/format/formatter/named_spacer.hpp>
-@endcode
-
-This allows you:
-- to hold multiple formatters
-- each formatter is given a name, when being added
-- you have a %spacer string, which contains what is to be prepended or
-appended to the string (by default, prepended)
-- a formatter is escaped with @c '\%' chars, like this @c "%name%"
-- if you want to write the @c '\%', just double it,
-like this: <tt>"this %% gets written"</tt>
-
-Example:
-
-@code
-#define L_ HPX_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()->is_enabled() )
-
-g_l()->writer().add_formatter( formatter::named_spacer("[%index%] %time% (T%thread%) ")
-        .add( "index", formatter::idx())
-        .add( "thread", formatter::thread_id())
-        .add( "time", formatter::time("$mm")) );
-@endcode
-
-Assuming you'd use the above in code
-@code
-int i = 1;
-L_ << "this is so cool " << i++;
-L_ << "this is so cool again " << i++;
-@endcode
-
-You could have an output like this:
-
-@code
-[1] 53 (T3536) this is so cool 1
-[2] 54 (T3536) this is so cool again 2
-@endcode
-
-*/
-    template <class convert>
-    struct named_spacer_t
-      : is_generic
-      , non_const_context<detail::named_spacer_context<convert>>
-    {
-        typedef non_const_context<detail::named_spacer_context<convert>>
-            context_base;
-
-        named_spacer_t(const std::string& str = std::string())
-        {
-            if (!str.empty())
-                context_base::context().format_string(str);
-        }
-
-        named_spacer_t& string(const std::string& str)
-        {
-            context_base::context().format_string(str);
-            return *this;
-        }
-
-        template <class formatter>
-        named_spacer_t& add(const std::string& name, formatter fmt)
-        {
-            context_base::context().add(name, fmt);
-            return *this;
-        }
-
-        void del(const std::string& name)
-        {
-            context_base::context().del(name);
-        }
-
-        void configure_inner(
-            const std::string& name, const std::string& configure_str)
-        {
-            context_base::context().configure(name, configure_str);
-        }
-
-        void operator()(msg_type& msg) const
-        {
-            context_base::context().write(msg);
-        }
-
-        bool operator==(const named_spacer_t& other) const
-        {
-            return &(context_base::context()) ==
-                &(other.context_base::context());
-        }
-    };
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatter/spacer.hpp b/libs/logging/include/hpx/logging/format/formatter/spacer.hpp
deleted file mode 100644
index f959d68cdd..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/spacer.hpp
+++ /dev/null
@@ -1,227 +0,0 @@
-// spacer.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_spacer_HPP_DEFINED
-#define JT28092007_spacer_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>    // is_generic
-#include <hpx/logging/format/formatter/convert_format.hpp>
-
-#include <cstddef>
-#include <string>
-#include <type_traits>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    namespace detail {
-
-        template <class original_formatter>
-        inline void spacer_write_with_convert(
-            optimize::cache_string_one_str& msg, const original_formatter& fmt,
-            const std::string& prefix, const std::string& suffix,
-            const do_convert_format::prepend*)
-        {
-            // prepend
-            do_convert_format::prepend::write(suffix, msg);
-            fmt(msg);
-            do_convert_format::prepend::write(prefix, msg);
-        }
-        template <class original_formatter>
-        inline void spacer_write_with_convert(
-            optimize::cache_string_one_str& msg, const original_formatter& fmt,
-            const std::string& prefix, const std::string& suffix,
-            const do_convert_format::append*)
-        {
-            // append
-            do_convert_format::append::write(prefix, msg);
-            fmt(msg);
-            do_convert_format::append::write(suffix, msg);
-        }
-        template <class original_formatter, class convert>
-        inline void spacer_write_with_convert(
-            optimize::cache_string_one_str& msg, const original_formatter& fmt,
-            const std::string& prefix, const std::string& suffix,
-            const convert*)
-        {
-            // custom conversion - prefix before suffix
-            convert::write(prefix, msg);
-            fmt(msg);
-            convert::write(suffix, msg);
-        }
-
-        // note: pass original_formatter here
-        // - so that original_formatter::operator() gets called,
-        // not the spacer_t's operator()
-        template <class original_formatter, class convert>
-        inline void spacer_write(optimize::cache_string_one_str& msg,
-            const original_formatter& fmt, const std::string& prefix,
-            const std::string& suffix)
-        {
-            spacer_write_with_convert(msg, fmt, prefix, suffix, 0);
-        }
-    }    // namespace detail
-
-    /** @brief Prepends some info, and appends some info to an existing formatter
-
-The syntax is simple: construct a spacer by passing the original formatter,
-and the text to space (prepend and append).
-Use:
-- @c % to mean the original formatter text
-- anything before @c "%" is prepended before
-- anything after @c "%" is appended after
-
-Examples:
-
-@code
-// prefix "[" before index, and append "] " after it.
-formatter::spacer( formatter::idx(), "[%] ");
-
-// prefix "{T" before thread_id, and append "} " after it
-formatter::spacer( formatter::thread_id(), "{T%} ");
-@endcode
-
-When adding a spacer formatter, you'll do something similar to:
-
-@code
-g_l()->writer().add_formatter( formatter::spacer( formatter::idx(), "[%] ") );
-@endcode
-
-However, to make this even simpler, I allow an ever easier syntax:
-
-@code
-// equivalent to the above
-g_l()->writer().add_formatter( formatter::idx(), "[%] " );
-@endcode
-
-
-*/
-    template <class convert, class original_formatter,
-        bool is_generic_formatter>
-    struct spacer_t : original_formatter
-    {
-        // "fixed" formatter - it has a msg_type typedef
-        typedef typename original_formatter::param param;
-        typedef original_formatter spacer_base;
-
-        spacer_t(const original_formatter& fmt, const char* format_str)
-          : spacer_base(fmt)
-        {
-            parse_format(format_str);
-        }
-
-        void operator()(param msg) const
-        {
-            detail::spacer_write<spacer_base, convert>(
-                msg, *this, m_prefix, m_suffix);
-        }
-
-    private:
-        void parse_format(const std::string& format_str)
-        {
-            typedef std::size_t size_type;
-            size_type msg_idx = format_str.find('%');
-            if (msg_idx != std::string::npos)
-            {
-                m_prefix = format_str.substr(0, msg_idx);
-                m_suffix = format_str.substr(msg_idx + 1);
-            }
-            else
-                // no suffix
-                m_prefix = format_str;
-        }
-
-    private:
-        std::string m_prefix, m_suffix;
-    };
-
-    // specialize for generic formatters
-    template <class convert, class original_formatter>
-    struct spacer_t<convert, original_formatter, true> : original_formatter
-    {
-        // generic formatter
-        typedef original_formatter spacer_base;
-
-        spacer_t(const original_formatter& fmt, const char* format_str)
-          : spacer_base(fmt)
-        {
-            parse_format(format_str);
-        }
-
-        void operator()(msg_type& msg) const
-        {
-            detail::spacer_write<spacer_base, convert>(
-                msg, *this, m_prefix, m_suffix);
-        }
-
-    private:
-        void parse_format(const std::string& format_str)
-        {
-            typedef std::size_t size_type;
-            size_type msg_idx = format_str.find('%');
-            if (msg_idx != std::string::npos)
-            {
-                m_prefix = format_str.substr(0, msg_idx);
-                m_suffix = format_str.substr(msg_idx + 1);
-            }
-            else
-                // no suffix
-                m_prefix = format_str;
-        }
-
-    private:
-        std::string m_prefix, m_suffix;
-    };
-
-    namespace detail {
-        template <class original_formatter, int>
-        struct find_spacer_generic
-        {
-            // generic
-            typedef typename original_formatter::convert_type convert;
-            typedef spacer_t<convert, original_formatter, true> type;
-        };
-        template <class original_formatter>
-        struct find_spacer_generic<original_formatter, 0>
-        {
-            // not generic
-            typedef do_convert_format::prepend convert;
-            typedef spacer_t<convert, original_formatter, false> type;
-        };
-
-        template <class original_formatter>
-        struct find_spacer
-          : find_spacer_generic<original_formatter,
-                std::is_base_of<is_generic, original_formatter>::value>
-        {
-        };
-    }    // namespace detail
-
-    /**
-    @copydoc spacer_t
-*/
-    template <class original_formatter>
-    typename detail::find_spacer<original_formatter>::type spacer(
-        const original_formatter& fmt, const char* format_str)
-    {
-        typedef
-            typename detail::find_spacer<original_formatter>::type spacer_type;
-        return spacer_type(fmt, format_str);
-    }
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatter/thread_id.hpp b/libs/logging/include/hpx/logging/format/formatter/thread_id.hpp
deleted file mode 100644
index 18370e9a09..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/thread_id.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-// formatter_thread_id.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_formatter_thread_id_HPP_DEFINED
-#define JT28092007_formatter_thread_id_HPP_DEFINED
-
-#include <hpx/config.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>    // is_generic
-#include <hpx/logging/format/formatter/convert_format.hpp>
-#include <sstream>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    /**
-@brief Writes the thread_id to the log
-
-@param convert [optional] In case there needs to be a conversion between
-std::(w)string and the string that holds your logged message. See convert_format.
-For instance, you might use @ref hpx::util::logging::optimize::cache_string_one_str
-"a cached_string class" (see @ref hpx::util::logging::optimize "optimize namespace").
-*/
-    template <class convert = do_convert_format::prepend>
-    struct thread_id_t : is_generic
-    {
-        typedef convert convert_type;
-
-        void operator()(msg_type& msg) const
-        {
-            std::ostringstream out;
-            out
-#if defined(HPX_WINDOWS)
-                << ::GetCurrentThreadId()
-#else
-                << pthread_self()
-#endif
-                ;
-
-            convert::write(out.str(), msg);
-        }
-
-        bool operator==(const thread_id_t&) const
-        {
-            return true;
-        }
-    };
-
-    /** @brief thread_id_t with default values. See thread_id_t
-
-@copydoc thread_id_t
-*/
-    typedef thread_id_t<> thread_id;
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatter/time.hpp b/libs/logging/include/hpx/logging/format/formatter/time.hpp
deleted file mode 100644
index c1d9ece6b7..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/time.hpp
+++ /dev/null
@@ -1,113 +0,0 @@
-// formatter_time.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_formatter_time_HPP_DEFINED
-#define JT28092007_formatter_time_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>    // is_generic
-#include <hpx/logging/detail/time_format_holder.hpp>
-#include <hpx/logging/format/formatter/convert_format.hpp>
-
-#include <string>
-#include <time.h>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    /**
-@brief Prefixes the message with the time. You pass the format string at construction.
-
-It's friendlier than write_time_strf (which uses strftime).
-
-The format can contain escape sequences:
-$dd - day, 2 digits
-$MM - month, 2 digits
-$yy - year, 2 digits
-$yyyy - year, 4 digits
-$hh - hour, 2 digits
-$mm - minute, 2 digits
-$ss - second, 2 digits
-
-Example: time("Today is $dd/$MM/$yyyy");
-
-Note: for a high precision clock, try high_precision_time (uses hpx::util::date_time)
-
-@param convert [optional] In case there needs to be a conversion between
-std::(w)string and the string that holds your logged message. See convert_format.
-For instance, you might use @ref hpx::util::logging::optimize::cache_string_one_str
-"a cached_string class" (see @ref hpx::util::logging::optimize "optimize namespace").
-*/
-    template <class convert = do_convert_format::prepend>
-    struct time_t
-      : is_generic
-      , non_const_context<hpx::util::logging::detail::time_format_holder>
-    {
-        typedef convert convert_type;
-        typedef non_const_context<
-            hpx::util::logging::detail::time_format_holder>
-            non_const_context_base;
-
-        /**
-        constructs a time object
-    */
-        time_t(const std::string& format)
-          : non_const_context_base(format)
-        {
-        }
-
-        void write_time(msg_type& msg, ::time_t val) const
-        {
-            char buffer[64];
-
-            tm details = *localtime(&val);
-            non_const_context_base::context().write_time(buffer,
-                details.tm_mday, details.tm_mon + 1, details.tm_year + 1900,
-                details.tm_hour, details.tm_min, details.tm_sec);
-
-            convert::write(buffer, msg);
-        }
-
-        void operator()(msg_type& msg) const
-        {
-            ::time_t val = ::time(nullptr);
-            write_time(msg, val);
-        }
-
-        bool operator==(const time_t& other) const
-        {
-            return non_const_context_base::context() ==
-                other.non_const_context_base::context();
-        }
-
-        /** @brief configure through script
-
-        the string = the time format
-    */
-        void configure(const std::string& str)
-        {
-            non_const_context_base::context().set_format(str);
-        }
-    };
-
-    /** @brief time_t with default values. See time_t
-
-@copydoc time_t
-*/
-    typedef time_t<> time;
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatter/time_strf.hpp b/libs/logging/include/hpx/logging/format/formatter/time_strf.hpp
deleted file mode 100644
index f49bcce52d..0000000000
--- a/libs/logging/include/hpx/logging/format/formatter/time_strf.hpp
+++ /dev/null
@@ -1,85 +0,0 @@
-// formatter_time.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_formatter_time_strf_HPP_DEFINED
-#define JT28092007_formatter_time_strf_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/manipulator.hpp>    // is_generic
-#include <hpx/logging/format/formatter/convert_format.hpp>
-#include <stdio.h>
-#include <string>
-#include <time.h>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-
-    /**
-@brief Prefixes the message with the time, by using strftime function.
-You pass the format string at construction.
-
-@param msg_type The type that holds your logged message.
-
-@param convert [optional] In case there needs to be a conversion between
-std::(w)string and the string that holds your logged message. See convert_format.
-For instance, you might use @ref hpx::util::logging::optimize::cache_string_one_str
-"a cached_string class" (see @ref hpx::util::logging::optimize "optimize namespace").
-*/
-    template <class convert = do_convert_format::prepend>
-    struct time_strf_t : is_generic
-    {
-        typedef convert convert_type;
-
-        /**
-        constructs a time_strf object
-
-        @param format the time format , strftime-like
-        @param localtime if true, use localtime, otherwise global time
-    */
-        time_strf_t(const std::string& format, bool localtime)
-          : m_format(format)
-          , m_localtime(localtime)
-        {
-        }
-
-        void operator()(msg_type& msg) const
-        {
-            char buffer[64];
-            ::time_t t = ::time(nullptr);
-            ::tm t_details = m_localtime ? *localtime(&t) : *gmtime(&t);
-            if (0 !=
-                strftime(buffer, sizeof(buffer), m_format.c_str(), &t_details))
-                convert::write(buffer, msg);
-        }
-
-        bool operator==(const time_strf_t& other) const
-        {
-            return m_format == other.m_format;
-        }
-
-    private:
-        std::string m_format;
-        bool m_localtime;
-    };
-
-    /** @brief time_strf_t with default values. See time_strf_t
-
-@copydoc time_strf_t
-*/
-    typedef time_strf_t<> time_strf;
-
-}}}}    // namespace hpx::util::logging::formatter
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/formatters.hpp b/libs/logging/include/hpx/logging/format/formatters.hpp
new file mode 100644
index 0000000000..0fb87e870f
--- /dev/null
+++ b/libs/logging/include/hpx/logging/format/formatters.hpp
@@ -0,0 +1,119 @@
+// formatters.hpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#ifndef HPX_LOGGING_FORMAT_FORMATTERS_HPP
+#define HPX_LOGGING_FORMAT_FORMATTERS_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/logging/manipulator.hpp>
+
+#include <memory>
+#include <string>
+
+namespace hpx { namespace util { namespace logging { namespace formatter {
+
+    /**
+@brief prefixes each message with an index.
+
+Example:
+@code
+L_ << "my message";
+L_ << "my 2nd message";
+@endcode
+
+This will output something similar to:
+
+@code
+[1] my message
+[2] my 2nd message
+@endcode
+*/
+    struct idx : manipulator
+    {
+        HPX_EXPORT static std::unique_ptr<idx> make();
+
+        HPX_EXPORT ~idx();
+
+    protected:
+        idx() = default;
+    };
+
+    /**
+@brief Prefixes the message with a high-precision time (.
+You pass the format string at construction.
+
+@code
+#include <hpx/logging/format/formatter/high_precision_time.hpp>
+@endcode
+
+Internally, it uses hpx::util::date_time::microsec_time_clock.
+So, our precision matches this class.
+
+The format can contain escape sequences:
+$dd - day, 2 digits
+$MM - month, 2 digits
+$yy - year, 2 digits
+$yyyy - year, 4 digits
+$hh - hour, 2 digits
+$mm - minute, 2 digits
+$ss - second, 2 digits
+$mili - milliseconds
+$micro - microseconds (if the high precision clock allows; otherwise, it pads zeros)
+$nano - nanoseconds (if the high precision clock allows; otherwise, it pads zeros)
+
+
+Example:
+
+@code
+high_precision_time("$mm:$ss:$micro");
+@endcode
+
+@param convert [optional] In case there needs to be a conversion between
+std::(w)string and the string that holds your logged message. See convert_format.
+*/
+    struct high_precision_time : manipulator
+    {
+        HPX_EXPORT static std::unique_ptr<high_precision_time> make(
+            std::string const& format);
+
+        HPX_EXPORT ~high_precision_time();
+
+    protected:
+        explicit high_precision_time(std::string const& format)
+        {
+            configure(format);
+        }
+    };
+
+    /**
+@brief Writes the thread_id to the log
+
+@param convert [optional] In case there needs to be a conversion between
+std::(w)string and the string that holds your logged message. See convert_format.
+*/
+    struct thread_id : manipulator
+    {
+        HPX_EXPORT static std::unique_ptr<thread_id> make();
+
+        HPX_EXPORT ~thread_id();
+
+    protected:
+        thread_id() = default;
+    };
+
+}}}}    // namespace hpx::util::logging::formatter
+
+#endif /*HPX_LOGGING_FORMAT_FORMATTERS_HPP*/
diff --git a/libs/logging/include/hpx/logging/format/named_write.hpp b/libs/logging/include/hpx/logging/format/named_write.hpp
index 0b7cff5f01..11da6da012 100644
--- a/libs/logging/include/hpx/logging/format/named_write.hpp
+++ b/libs/logging/include/hpx/logging/format/named_write.hpp
@@ -14,9 +14,446 @@
 // See http://www.boost.org for updates, documentation, and revision history.
 // See http://www.torjo.com/log2/ for more details
 
-#ifndef JT28092007_format_named_writer_HPP_DEFINED
-#define JT28092007_format_named_writer_HPP_DEFINED
+#ifndef HPX_LOGGING_FORMAT_NAMED_WRITER_HPP
+#define HPX_LOGGING_FORMAT_NAMED_WRITER_HPP
 
-#include <hpx/logging/writer/named_write.hpp>
+#include <hpx/config.hpp>
+#include <hpx/logging/format/destinations.hpp>
+#include <hpx/logging/format/formatters.hpp>
 
+#include <cstddef>
+#include <memory>
+#include <sstream>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace hpx { namespace util { namespace logging { namespace detail {
+
+    template <typename T>
+    struct named
+    {
+        std::string name;
+        T value;
+    };
+
+    template <typename C, typename S>
+    typename C::iterator find_named(C& c, S const& name)
+    {
+        for (auto iter = c.begin(), end = c.end(); iter != end; ++iter)
+        {
+            if (iter->name == name)
+                return iter;
+        }
+        return c.end();
+    }
+
+    /**
+@brief Allows you to contain multiple formatters,
+and specify a %spacer between them. You have a %spacer string, and within it,
+you can escape your contained formatters.
+
+@code
+#include <hpx/logging/format/formatter/named.hpp>
+@endcode
+
+This allows you:
+- to hold multiple formatters
+- each formatter is given a name, when being added
+- you have a %spacer string, which contains what is to be prepended or
+appended to the string (by default, prepended)
+- a formatter is escaped with @c '\%' chars, like this @c "%name%"
+- if you want to write the @c '\%', just double it,
+like this: <tt>"this %% gets written"</tt>
+
+Example:
+
+@code
+#define L_ HPX_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()->is_enabled() )
+
+g_l()->writer().add_formatter( formatter::named("[%index%] %time% (T%thread%) ")
+        .add( "index", formatter::idx())
+        .add( "thread", formatter::thread_id())
+        .add( "time", formatter::time("$mm")) );
+@endcode
+
+Assuming you'd use the above in code
+@code
+int i = 1;
+L_ << "this is so cool " << i++;
+L_ << "this is so cool again " << i++;
+@endcode
+
+You could have an output like this:
+
+@code
+[1] 53 (T3536) this is so cool 1
+[2] 54 (T3536) this is so cool again 2
+@endcode
+
+*/
+    struct named_formatters
+    {
+        HPX_NON_COPYABLE(named_formatters);
+
+        using ptr_type = std::unique_ptr<formatter::manipulator>;
+
+        named_formatters() = default;
+
+        named_formatters& string(std::string const& str)
+        {
+            format_string = str;
+            compute_write_steps();
+            return *this;
+        }
+
+        void add(std::string const& name, ptr_type p)
+        {
+            auto iter = find_named(formatters, name);
+            if (iter != formatters.end())
+                iter->value = std::move(p);
+            else
+                formatters.push_back(named<ptr_type>{name, std::move(p)});
+            compute_write_steps();
+        }
+
+        void configure(
+            std::string const& name, std::string const& configure_str)
+        {
+            auto iter = find_named(formatters, name);
+            if (iter != formatters.end())
+                iter->value->configure(configure_str);
+        }
+
+        void operator()(std::stringstream& out, message const& msg) const
+        {
+            for (auto const& step : write_steps)
+            {
+                out << step.prefix;
+                if (step.fmt)
+                {
+                    if (step.fmt == (formatter::manipulator*) -1)
+                        out << msg;
+                    else
+                        (*step.fmt)(out);
+                }
+            }
+        }
+
+    private:
+        // recomputes the write steps - note taht this takes place after
+        // each operation for instance, the user might have first set the
+        // string and later added the formatters
+        void compute_write_steps();
+
+    private:
+        struct write_step
+        {
+            write_step(std::string const& prefix_, formatter::manipulator* fmt_)
+              : prefix(prefix_)
+              , fmt(fmt_)
+            {
+            }
+            std::string prefix;
+            // could be null - in case formatter not found by name, or it's
+            // the last step
+            formatter::manipulator* fmt;
+        };
+
+        std::vector<named<ptr_type>> formatters;
+        std::vector<write_step> write_steps;
+        std::string format_string;
+    };
+
+    /**
+@brief Allows you to contain multiple destinations,
+give each such destination a name.
+Then, at run-time, you can specify a format string which will specify which
+destinations to be called, and on what order.
+
+This allows you:
+- to hold multiple destinations
+- each destination is given a name, when being added.
+The name <b>must not</b> contain spaces and must not start with '+'/'-' signs
+- you have a %format string, which contains what destinations to be called,
+and on which order
+
+The %format string contains destination names, separated by space.
+
+When a message is written to this destination,
+I parse the format string. When a name is encountered, if there's a destination
+corresponding to this name, I will call it.
+
+Example:
+
+@code
+g_l()->writer().add_destination(
+    destination::named_destinations("cout out debug")
+        .add( "cout", destination::cout())
+        .add( "debug", destination::dbg_window() )
+        .add( "out", destination::file("out.txt"))
+     );
+@endcode
+
+In the above code, we'll write to 3 destinations, in the following order:
+- first, to the console
+- second, to the out.txt file
+- third, to the debug window
+
+
+
+@section If you deal with config files
+
+As an extra feature:
+- if a name starts with '-' is ignored
+- if a name starts with '+', is included.
+
+This is useful if you want to set this format string in a config file.
+The good thing is that this way you can easily turn on/off
+certain destinations, while seing all the available destinations as well.
+
+Example: \n <tt>+out_file -debug_window +console</tt> \n
+In the above example, I know that the available destinations are @c out_file,
+@c debug_window and @c console, but I'm not writing to @c debug_window.
+
+*/
+    struct named_destinations
+    {
+        HPX_NON_COPYABLE(named_destinations);
+
+        using ptr_type = std::unique_ptr<destination::manipulator>;
+
+        named_destinations() = default;
+
+        named_destinations& string(std::string const& str)
+        {
+            format_string = str;
+            compute_write_steps();
+            return *this;
+        }
+
+        void add(std::string const& name, ptr_type p)
+        {
+            auto iter = find_named(destinations, name);
+            if (iter != destinations.end())
+                iter->value = std::move(p);
+            else
+                destinations.push_back(named<ptr_type>{name, std::move(p)});
+            compute_write_steps();
+        }
+
+        void configure(
+            std::string const& name, std::string const& configure_str)
+        {
+            auto iter = find_named(destinations, name);
+            if (iter != destinations.end())
+                iter->value->configure(configure_str);
+        }
+
+        void operator()(const message& msg) const
+        {
+            for (auto const& step : write_steps)
+                (*step)(msg);
+        }
+
+    private:
+        // recomputes the write steps - note taht this takes place after
+        // each operation for instance, the user might have first set the
+        // string and later added the formatters
+        void compute_write_steps();
+
+    private:
+        std::vector<named<ptr_type>> destinations;
+        std::vector<destination::manipulator*> write_steps;
+        std::string format_string;
+    };
+
+}}}}    // namespace hpx::util::logging::detail
+
+namespace hpx { namespace util { namespace logging { namespace writer {
+
+    /**
+@brief Composed of a named formatter and a named destinations.
+Thus, you can specify the formatting and destinations as strings
+
+@code
+#include <hpx/logging/format/named_write.hpp>
+@endcode
+
+
+Contains a very easy interface for using @ref manipulator "formatters and destinations":
+- at construction, specify 2 params: the %formatter string and the destinations string
+
+Setting the @ref manipulator "formatters and destinations" to
+write to is extremely simple:
+
+@code
+// Set the formatters (first param) and destinatins (second step) in one step
+g_l()->writer().write("%time%($hh:$mm.$ss.$mili) [%idx%] |\n",
+"cout file(out.txt) debug");
+
+// set the formatter(s)
+g_l()->writer().format("%time%($hh:$mm.$ss.$mili) [%idx%] |\n");
+
+// set the destination(s)
+g_l()->writer().destination("cout file(out.txt) debug");
+@endcode
+
+
+@section format_string_syntax The syntax of the format string
+
+- The format string specifies how the message is to be logged
+- Every formatter is escaped using <tt>%</tt><em>fmt</em><tt>%</tt>
+  - Available formatters:
+    - <tt>"%idx%"</tt> - writes the index of the message (formatter::idx)
+    - <tt>"%time%"</tt> - writes the time (formatter::high_precision_time)
+    - <tt>"%thread_id%"</tt> - writes the thread id (formatter::thread_id)
+    - if you want to write @c "%", double it, like this: @c "%%"
+- @c "|" is used to specify the original message. What is before it,
+is prepended to the message, what is after, is appended to the message
+- If a formatter is configurable, append @em (params) to it
+  - For now, only @c "%time%" is configurable. For instance,
+  @c "%time%($hh:$mm.$ss.$mili)" writes time like @c "21:14.24.674"
+
+Example:
+@code
+"%time%($hh:$mm.$ss.$mili) [%idx%] |\n"
+@endcode
+
+The output can look like:
+
+@code
+21:03.17.243 [1] this is so cool
+21:03.17.243 [2] first error
+21:03.17.243 [3] hello, world
+@endcode
+
+
+@section dest_string_syntax The syntax of the destinations string
+
+- The syntax of the destination string specifies where the message is to be logged
+  - Every destination is specified by name
+  - Separate destinations by space (' ')
+- Available destinations
+  - <tt>"cout"</tt> - writes to std::cout (destination::cout)
+  - <tt>"cerr"</tt> - writes to std::cerr (destination::cerr)
+  - <tt>"debug"</tt> - writes to the debug window: OutputDebugString in Windows,
+  console on Linux (destination::dbg_window)
+  - <tt>"file"</tt> - writes to a file (destination::file)
+- If a destination is configurable, append @em (params) to it
+  - Right now, @c "file" is configurable
+    - Append <tt>(</tt><em>filename</em><tt>)</tt> to them to specify the file name.
+    Example: @c "file(out.txt)" will write to the out.txt file
+
+Examples:
+- <tt>"file(out.txt) cout"</tt> - will write to a file called out.txt and to cout
+- <tt>"cout debug"</tt> - will write to cout and debug window (see above)
+
+@note
+If you want to output to 2 files, don't use "file(one.txt) file(two.txt)".
+This will just configure "file" twice, ending up with writing only to "two.txt" file.
+
+@param format_write_ the underlying format writer
+
+
+*/
+    struct named_write
+    {
+        HPX_EXPORT named_write();
+
+        /** @brief sets the format string: what should be before,
+    and what after the original message, separated by "|"
+
+    Example: \n
+    "[%idx%] |\n" - this writes "[%idx%] " before the message,
+    and "\n" after the message
+
+    If "|" is not present, the whole message is prepended to the message
+    */
+        void format(std::string const& format_str)
+        {
+            m_format_str = format_str;
+            configure_formatter(format_str);
+        };
+
+        /** @brief sets the destinations string - where should logged messages
+         * be outputted
+    */
+        void destination(std::string const& destination_str)
+        {
+            m_destination_str = destination_str;
+            configure_destination(destination_str);
+        }
+
+        /** @brief Specifies the formats and destinations in one step
+    */
+        void write(
+            std::string const& format_str, std::string const& destination_str)
+        {
+            format(format_str);
+            destination(destination_str);
+        }
+
+        void operator()(message const& msg) const
+        {
+            std::stringstream out;
+            m_format(out, msg);
+
+#if !defined(HPX_COMPUTE_HOST_CODE)
+            message formatted(std::move(out));
+            m_destination(formatted);
 #endif
+        }
+
+        /** @brief Replaces a formatter from the named formatter.
+
+    You can use this, for instance, when you want to share
+    a formatter between multiple named writers.
+    */
+        template <typename Formatter>
+        void set_formatter(std::string const& name, Formatter fmt)
+        {
+            m_format.add(
+                name, detail::named_formatters::ptr_type(new Formatter(fmt)));
+        }
+
+        template <typename Formatter, typename... Args>
+        void set_formatter(std::string const& name, Args&&... args)
+        {
+            m_format.add(name, Formatter::make(std::forward<Args>(args)...));
+        }
+
+        /** @brief Replaces a destination from the named destination.
+
+    You can use this, for instance, when you want to share a
+    destination between multiple named writers.
+    */
+        template <typename Destination>
+        void set_destination(std::string const& name, Destination dest)
+        {
+            m_destination.add(name,
+                detail::named_destinations::ptr_type(new Destination(dest)));
+        }
+
+        template <typename Destination, typename... Args>
+        void set_destination(std::string const& name, Args&&... args)
+        {
+            m_destination.add(
+                name, Destination::make(std::forward<Args>(args)...));
+        }
+
+    private:
+        HPX_EXPORT void configure_formatter(std::string const& format);
+        HPX_EXPORT void configure_destination(std::string const& format);
+
+    private:
+        detail::named_formatters m_format;
+        detail::named_destinations m_destination;
+
+        std::string m_format_str;
+        std::string m_destination_str;
+    };
+
+}}}}    // namespace hpx::util::logging::writer
+
+#endif /*HPX_LOGGING_FORMAT_NAMED_WRITER_HPP*/
diff --git a/libs/logging/include/hpx/logging/format/named_write_fwd.hpp b/libs/logging/include/hpx/logging/format/named_write_fwd.hpp
deleted file mode 100644
index 242006c3dd..0000000000
--- a/libs/logging/include/hpx/logging/format/named_write_fwd.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// named_write_fwd.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_format_named_writer_fwd_HPP_DEFINED
-#define JT28092007_format_named_writer_fwd_HPP_DEFINED
-
-#include <hpx/logging/format_fwd.hpp>
-#include <hpx/logging/writer/named_write.hpp>
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/op_equal.hpp b/libs/logging/include/hpx/logging/format/op_equal.hpp
deleted file mode 100644
index 217c8584bd..0000000000
--- a/libs/logging/include/hpx/logging/format/op_equal.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-// op_equal.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_op_equal_HPP_DEFINED
-#define JT28092007_op_equal_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
-#include <typeinfo>
-#include <vector>
-
-namespace hpx { namespace util { namespace logging {
-
-    /**
-    @brief Implements operator== for manipulators
-
-*/
-    namespace op_equal {
-
-        struct same_type_op_equal_top
-        {
-            virtual bool equals(const same_type_op_equal_top&) const = 0;
-
-        protected:
-            same_type_op_equal_top() {}
-            virtual ~same_type_op_equal_top() {}
-            same_type_op_equal_top(const same_type_op_equal_top&) {}
-        };
-        inline bool operator==(
-            const same_type_op_equal_top& a, const same_type_op_equal_top& b)
-        {
-            return a.equals(b);
-        }
-
-        /**
-        @brief Base class when you want to implement operator==
-        that will compare based on type and member operator==
-
-        @sa same_type_op_equal
-    */
-        struct same_type_op_equal_base : virtual same_type_op_equal_top
-        {
-        };
-
-        /**
-        @brief Implements operator==, which compares two objects.
-        If they have the same type, it will compare them using the type's member
-        operator==.
-
-        The only constraint is that operator== must be a *member* function
-    */
-        template <class type>
-        struct same_type_op_equal : same_type_op_equal_base
-        {
-            virtual bool equals(const same_type_op_equal_top& other) const
-            {
-                if (typeid(*this) != typeid(other))
-                    return false;
-                const type& real_other = dynamic_cast<const type&>(other);
-
-                // this forces 'type' to implement operator==
-                return (dynamic_cast<const type&>(*this))
-                    .
-                    operator==(real_other);
-            }
-        };
-
-    }    // namespace op_equal
-}}}      // namespace hpx::util::logging
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format/optimize.hpp b/libs/logging/include/hpx/logging/format/optimize.hpp
deleted file mode 100644
index aa2bffed12..0000000000
--- a/libs/logging/include/hpx/logging/format/optimize.hpp
+++ /dev/null
@@ -1,336 +0,0 @@
-// optimize.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_optimize_HPP_DEFINED
-#define JT28092007_optimize_HPP_DEFINED
-
-#include <hpx/config.hpp>
-#include <hpx/assertion.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-
-#include <cstddef>
-#include <cstring>
-#include <cwchar>
-#include <map>
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-namespace hpx { namespace util { namespace logging {
-
-    /**
-    @brief Gathering the message: contains optimizers for formatting and/or destinations:
-    for example, caching techniques
-*/
-    namespace optimize {
-
-        /**
-        @brief Optimizes the formatting for prepending and/or appending strings to
-        the original message
-
-        It keeps all the modified message in one string.
-        Useful if some formatter needs to access the whole
-        string at once.
-
-        reserve_prepend() - the size that is reserved for prepending
-        (similar to string::reserve function)
-        reserve_append() - the size that is reserved for appending
-        (similar to string::reserve function)
-
-        Note : as strings are prepended, reserve_prepend() shrinks.
-        Same goes for append.
-    */
-        struct cache_string_one_str
-        {
-            typedef cache_string_one_str self_type;
-
-            /**
-        @param reserve_prepend - how many chars to have space to prepend by default
-        @param reserve_append - how many chars to have space to append by default
-        @param grow_size - in case we add a string and there's no room for it,
-                           with how much should we grow? We'll
-                           grow this much in addition to the added string
-                           - in the needed direction
-         */
-            cache_string_one_str(std::size_t reserve_prepend_,
-                std::size_t reserve_append_, std::size_t grow_size_ = 10)
-              : m_reserve_prepend(reserve_prepend_)
-              , m_reserve_append(reserve_append_)
-              , m_grow_size(grow_size_)
-              , m_full_msg_computed(false)
-            {
-            }
-
-            /**
-        @param msg - the message that is originally cached
-        @param reserve_prepend - how many chars to have space to prepend by default
-        @param reserve_append - how many chars to have space to append by default
-        @param grow_size - in case we add a string and there's no room for it,
-                           with how much should we grow? We'll
-                           grow this much in addition to the added string
-                           - in the needed direction
-         */
-            cache_string_one_str(const std::string& msg,
-                std::size_t reserve_prepend_ = 10,
-                std::size_t reserve_append_ = 10, std::size_t grow_size_ = 10)
-              : m_reserve_prepend(reserve_prepend_)
-              , m_reserve_append(reserve_append_)
-              , m_grow_size(grow_size_)
-              , m_full_msg_computed(false)
-            {
-                set_string(msg);
-            }
-
-            cache_string_one_str(cache_string_one_str&& other)
-              : m_reserve_prepend(other.m_reserve_prepend)
-              , m_reserve_append(other.m_reserve_prepend)
-              , m_grow_size(other.m_grow_size)
-              , m_str(std::move(other.m_str))
-              , m_full_msg_computed(other.m_full_msg_computed)
-              , m_full_msg(std::move(other.m_full_msg))
-            {
-                other.m_reserve_prepend = 10;
-                other.m_reserve_append = 10;
-                other.m_grow_size = 10;
-                other.m_full_msg_computed = false;
-            }
-
-            cache_string_one_str()
-              : m_reserve_prepend(10)
-              , m_reserve_append(10)
-              , m_grow_size(10)
-              , m_full_msg_computed(false)
-            {
-            }
-
-            void set_string(const std::string& str)
-            {
-                m_str.resize(str.size() + m_reserve_prepend + m_reserve_append);
-                std::copy(str.begin(), str.end(),
-                    m_str.begin() +
-                        static_cast<std::ptrdiff_t>(m_reserve_prepend));
-                m_full_msg_computed = false;
-            }
-
-            std::size_t reserve_prepend() const
-            {
-                return m_reserve_prepend;
-            }
-            std::size_t reserve_append() const
-            {
-                return m_reserve_append;
-            }
-            std::size_t grow_size() const
-            {
-                return m_grow_size;
-            }
-
-            void reserve_prepend(std::size_t new_size)
-            {
-                resize_string(new_size, m_reserve_append);
-            }
-
-            void reserve_append(std::size_t new_size)
-            {
-                resize_string(m_reserve_prepend, new_size);
-            }
-
-            void grow_size(std::size_t new_size)
-            {
-                m_grow_size = new_size;
-            }
-
-        private:
-            static std::size_t str_len(const char* str)
-            {
-                return strlen(str);
-            }
-            static std::size_t str_len(const wchar_t* str)
-            {
-                return wcslen(str);
-            }
-
-        public:
-            void prepend_string(const char* str)
-            {
-                std::size_t len = str_len(str);
-                if (m_reserve_prepend < len)
-                {
-                    std::size_t new_reserve_prepend = len + m_grow_size;
-                    resize_string(new_reserve_prepend, m_reserve_append);
-                }
-
-                HPX_ASSERT(m_reserve_prepend >= len);
-
-                std::ptrdiff_t start_idx =
-                    static_cast<std::ptrdiff_t>(m_reserve_prepend - len);
-                m_reserve_prepend -= len;
-
-                std::copy(str, str + len, m_str.begin() + start_idx);
-                m_full_msg_computed = false;
-            }
-            void append_string(const char* str)
-            {
-                std::size_t len = str_len(str);
-                if (m_reserve_append < len)
-                {
-                    std::size_t new_reserve_append = len + m_grow_size;
-                    resize_string(m_reserve_prepend, new_reserve_append);
-                }
-
-                HPX_ASSERT(m_reserve_append >= len);
-
-                std::ptrdiff_t start_idx = static_cast<std::ptrdiff_t>(
-                    m_str.size() - m_reserve_append);
-
-                std::copy(str, str + len, m_str.begin() + start_idx);
-                m_reserve_append -= len;
-                m_full_msg_computed = false;
-            }
-
-            /**
-            @brief pre-pends a string (inserts it at the beginning)
-        */
-            void prepend_string(const std::string& str)
-            {
-                if (m_reserve_prepend < str.size())
-                {
-                    std::size_t new_reserve_prepend = str.size() + m_grow_size;
-                    resize_string(new_reserve_prepend, m_reserve_append);
-                }
-
-                HPX_ASSERT(m_reserve_prepend >= str.size());
-
-                std::ptrdiff_t start_idx =
-                    static_cast<std::ptrdiff_t>(m_reserve_prepend - str.size());
-                m_reserve_prepend -= str.size();
-
-                std::copy(str.begin(), str.end(), m_str.begin() + start_idx);
-                m_full_msg_computed = false;
-            }
-
-            /**
-            @brief appends a string (inserts it at the end)
-        */
-            void append_string(const std::string& str)
-            {
-                if (m_reserve_append < str.size())
-                {
-                    std::size_t new_reserve_append = str.size() + m_grow_size;
-                    resize_string(m_reserve_prepend, new_reserve_append);
-                }
-
-                HPX_ASSERT(m_reserve_append >= str.size());
-
-                std::ptrdiff_t start_idx = static_cast<std::ptrdiff_t>(
-                    m_str.size() - m_reserve_append);
-
-                std::copy(str.begin(), str.end(), m_str.begin() + start_idx);
-                m_reserve_append -= str.size();
-                m_full_msg_computed = false;
-            }
-
-            /**
-            writes the current cached contents to a stream
-        */
-            template <class stream_type>
-            void to_stream(stream_type& stream) const
-            {
-                stream.write(m_str.begin() + m_reserve_prepend,
-                    m_str.size() - m_reserve_prepend - m_reserve_append);
-            }
-
-            /**
-            returns the full string
-        */
-            const std::string& full_string() const
-            {
-                if (!m_full_msg_computed)
-                {
-                    m_full_msg_computed = true;
-                    m_full_msg = m_str.substr(m_reserve_prepend,
-                        m_str.size() - m_reserve_prepend - m_reserve_append);
-                }
-                return m_full_msg;
-            }
-
-            operator const std::string&() const
-            {
-                return full_string();
-            }
-
-        private:
-            void resize_string(
-                std::size_t reserve_prepend_, std::size_t reserve_append_)
-            {
-                if (is_string_set())
-                {
-                    std::size_t to_add = reserve_prepend_ + reserve_append_ -
-                        m_reserve_prepend - m_reserve_append;
-                    std::size_t new_size = m_str.size() + to_add;
-
-                    // I'm creating a new string instead of resizing the existing one
-                    // this is because the new string could be of lower size
-                    std::string new_str(reserve_prepend_, 0);
-                    std::size_t used_size =
-                        m_str.size() - m_reserve_prepend - m_reserve_append;
-                    new_str.insert(new_str.end(),
-                        m_str.begin() +
-                            static_cast<std::ptrdiff_t>(m_reserve_prepend),
-                        m_str.begin() +
-                            static_cast<std::ptrdiff_t>(
-                                m_reserve_prepend + used_size));
-
-                    HPX_ASSERT(new_size ==
-                        reserve_prepend_ + used_size + reserve_append_);
-
-                    new_str.resize(new_size, 0);
-                    std::swap(new_str, m_str);
-                }
-
-                m_reserve_prepend = reserve_prepend_;
-                m_reserve_append = reserve_append_;
-            }
-
-            // if true, string was already set
-            bool is_string_set() const
-            {
-                return !m_str.empty();
-            }
-
-        private:
-            std::size_t m_reserve_prepend;
-            std::size_t m_reserve_append;
-            std::size_t m_grow_size;
-            std::string m_str;
-
-            // caching
-            mutable bool m_full_msg_computed;
-            mutable std::string m_full_msg;
-        };
-
-        template <class stream>
-        inline stream& operator<<(stream& out, const cache_string_one_str& val)
-        {
-            out << val.full_string();
-            return out;
-        }
-
-    }    // namespace optimize
-}}}      // namespace hpx::util::logging
-
-#endif
diff --git a/libs/logging/include/hpx/logging/format_fwd.hpp b/libs/logging/include/hpx/logging/format_fwd.hpp
deleted file mode 100644
index 1cd51979bc..0000000000
--- a/libs/logging/include/hpx/logging/format_fwd.hpp
+++ /dev/null
@@ -1,29 +0,0 @@
-// format_fwd.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-// this needs to be fixed!
-#ifndef JT28092007_format_fwd_HPP_DEFINED
-#define JT28092007_format_fwd_HPP_DEFINED
-
-#include <hpx/config.hpp>
-
-namespace hpx { namespace util { namespace logging { namespace writer {
-    struct named_write;
-}}}}    // namespace hpx::util::logging::writer
-
-#include <hpx/logging/format.hpp>
-
-#endif
diff --git a/libs/logging/include/hpx/logging/detail/level.hpp b/libs/logging/include/hpx/logging/level.hpp
similarity index 67%
rename from libs/logging/include/hpx/logging/detail/level.hpp
rename to libs/logging/include/hpx/logging/level.hpp
index dabdc96fdb..ca6ac8d82a 100644
--- a/libs/logging/include/hpx/logging/detail/level.hpp
+++ b/libs/logging/include/hpx/logging/level.hpp
@@ -14,10 +14,12 @@
 // See http://www.boost.org for updates, documentation, and revision history.
 // See http://www.torjo.com/log2/ for more details
 
-#ifndef JT28092007_level_HPP_DEFINED
-#define JT28092007_level_HPP_DEFINED
+#ifndef HPX_LOGGING_LEVEL_HPP
+#define HPX_LOGGING_LEVEL_HPP
 
-#include <hpx/logging/detail/fwd.hpp>
+#include <hpx/config.hpp>
+
+#include <boost/utility/string_ref.hpp>
 
 namespace hpx { namespace util { namespace logging {
 
@@ -42,23 +44,22 @@ namespace hpx { namespace util { namespace logging {
     error, fatal will be logged.
 
 */
-    namespace level {
-        /** the higher the level, the more critical the error */
-        typedef unsigned int type;
+    enum class level : unsigned int
+    {
+        disable_all = static_cast<unsigned int>(-1),
+        enable_all = 0,
+        debug = 1000,
+        info = 2000,
+        warning = 3000,
+        error = 4000,
+        fatal = 5000,
+        always = 6000
+    };
 
-        enum : type
-        {
-            disable_all = (type) -1,
-            enable_all = 0,
-            debug = 1000,
-            info = 2000,
-            warning = 3000,
-            error = 4000,
-            fatal = 5000,
-            always = 6000
-        };
-    }    // namespace level
+    ////////////////////////////////////////////////////////////////////////////
+    HPX_EXPORT void format_value(
+        std::ostream& os, boost::string_ref spec, level value);
 
 }}}    // namespace hpx::util::logging
 
-#endif
+#endif /*HPX_LOGGING_LEVEL_HPP*/
diff --git a/libs/logging/include/hpx/logging/logging.hpp b/libs/logging/include/hpx/logging/logging.hpp
index a06947adca..e5e8d17d26 100644
--- a/libs/logging/include/hpx/logging/logging.hpp
+++ b/libs/logging/include/hpx/logging/logging.hpp
@@ -17,10 +17,9 @@
 #ifndef JT28092007_logging_HPP_DEFINED
 #define JT28092007_logging_HPP_DEFINED
 
-#include <hpx/logging/detail/fwd.hpp>
-#include <hpx/logging/detail/level.hpp>
 #include <hpx/logging/detail/logger.hpp>
 #include <hpx/logging/detail/macros.hpp>
+#include <hpx/logging/level.hpp>
 
 namespace hpx { namespace util { namespace logging {
 
@@ -33,7 +32,7 @@ If you want to use @ref manipulator "formatters and destinations",
 then you can include this one instead:
 
 @code
-#include <hpx/logging/format_fwd.hpp>
+#include <hpx/logging/format.hpp>
 @endcode
 
 */
diff --git a/libs/logging/include/hpx/logging/manipulator.hpp b/libs/logging/include/hpx/logging/manipulator.hpp
new file mode 100644
index 0000000000..8040bc049c
--- /dev/null
+++ b/libs/logging/include/hpx/logging/manipulator.hpp
@@ -0,0 +1,95 @@
+// manipulator.hpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#ifndef HPX_LOGGING_MANIPULATOR_HPP
+#define HPX_LOGGING_MANIPULATOR_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/format.hpp>
+#include <hpx/logging/message.hpp>
+
+#include <boost/utility/string_ref.hpp>
+
+#include <iosfwd>
+#include <string>
+
+namespace hpx { namespace util { namespace logging {
+
+    /// @brief Formatter is a manipulator.
+    /// It allows you to format the message before writing it to the destination(s)
+    ///
+    /// Examples of formatters are : @ref formatter::time_t "prepend the time",
+    /// @ref formatter::high_precision_time_t "prepend high-precision time",
+    /// @ref formatter::idx_t "prepend the index of the message", etc.
+
+    namespace formatter {
+
+        /// @brief What to use as base class, for your formatter classes
+        struct manipulator
+        {
+            virtual void operator()(std::ostream& to) const = 0;
+
+            friend void format_value(std::ostream& os,
+                boost::string_ref /*spec*/, manipulator const& value)
+            {
+                value(os);
+            }
+
+            /// @brief Override this if you want to allow configuration through
+            /// scripting.
+            ///
+            /// That is, this allows configuration of your manipulator at run-time.
+            virtual void configure(std::string const&) {}
+
+            HPX_EXPORT virtual ~manipulator();
+
+        protected:
+            // signify that we're only a base class - not to be used directly
+            manipulator() = default;
+        };
+
+    }    // namespace formatter
+
+    /// @brief Destination is a manipulator. It contains a place where the message,
+    /// after being formatted, is to be written to.
+    ///
+    /// Some viable destinations are : @ref destination::cout "the console",
+    /// @ref destination::file "a file", a socket, etc.
+    namespace destination {
+
+        /// @brief What to use as base class, for your destination classes
+        struct manipulator
+        {
+            virtual void operator()(message const& val) = 0;
+
+            /// @brief Override this if you want to allow configuration through
+            /// scripting.
+            ///
+            /// That is, this allows configuration of your manipulator at run-time.
+            virtual void configure(std::string const&) {}
+
+            HPX_EXPORT virtual ~manipulator();
+
+        protected:
+            // signify that we're only a base class - not to be used directly
+            manipulator() = default;
+        };
+
+    }    // namespace destination
+
+}}}    // namespace hpx::util::logging
+
+#endif /*HPX_LOGGING_MANIPULATOR_HPP*/
diff --git a/libs/logging/include/hpx/logging/message.hpp b/libs/logging/include/hpx/logging/message.hpp
new file mode 100644
index 0000000000..c15d7d7048
--- /dev/null
+++ b/libs/logging/include/hpx/logging/message.hpp
@@ -0,0 +1,130 @@
+// message.hpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#ifndef HPX_LOGGING_MESSAGE_HPP
+#define HPX_LOGGING_MESSAGE_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/format.hpp>
+
+#include <boost/utility/string_ref.hpp>
+
+#include <cstddef>
+#include <sstream>
+#include <string>
+#include <utility>
+
+namespace hpx { namespace util { namespace logging {
+
+    /**
+        @brief Optimizes the formatting for prepending and/or appending strings to
+        the original message
+
+        It keeps all the modified message in one string.
+        Useful if some formatter needs to access the whole
+        string at once.
+
+        reserve() - the size that is reserved for prepending
+        (similar to string::reserve function)
+
+        Note : as strings are prepended, reserve() shrinks.
+    */
+    class message
+    {
+    public:
+        message()
+          : m_full_msg_computed(false)
+        {
+        }
+
+        /**
+        @param msg - the message that is originally cached
+         */
+        explicit message(std::stringstream msg)
+          :
+#if !defined(HPX_COMPUTE_HOST_CODE)
+          m_str(std::move(msg))
+          ,
+#endif
+          m_full_msg_computed(false)
+        {
+        }
+
+        message(message&& other) noexcept
+          :
+#if !defined(HPX_COMPUTE_HOST_CODE)
+          m_str(std::move(other.m_str))
+          ,
+#endif
+          m_full_msg_computed(other.m_full_msg_computed)
+#if !defined(HPX_COMPUTE_HOST_CODE)
+          , m_full_msg(std::move(other.m_full_msg))
+#endif
+        {
+            other.m_full_msg_computed = false;
+        }
+
+        template <typename T>
+        message& operator<<(T&& v)
+        {
+            m_str << std::forward<T>(v);
+            m_full_msg_computed = false;
+            return *this;
+        }
+
+        template <typename... Args>
+        message& format(
+            boost::string_ref format_str, Args const&... args) noexcept
+        {
+            util::format_to(m_str, format_str, args...);
+            m_full_msg_computed = false;
+            return *this;
+        }
+
+        /**
+            returns the full string
+        */
+        std::string const& full_string() const
+        {
+            if (!m_full_msg_computed)
+            {
+                m_full_msg_computed = true;
+                m_full_msg = m_str.str();
+            }
+            return m_full_msg;
+        }
+
+        bool empty() const
+        {
+            return full_string().empty();
+        }
+
+        friend std::ostream& operator<<(std::ostream& os, message const& value)
+        {
+            return os << value.m_str.rdbuf();
+        }
+
+    private:
+        std::stringstream m_str;
+
+        // caching
+        mutable bool m_full_msg_computed;
+        mutable std::string m_full_msg;
+    };
+
+}}}    // namespace hpx::util::logging
+
+#endif /*HPX_LOGGING_MESSAGE_HPP*/
diff --git a/libs/logging/include/hpx/logging/writer/format_write.hpp b/libs/logging/include/hpx/logging/writer/format_write.hpp
deleted file mode 100644
index e9b9806070..0000000000
--- a/libs/logging/include/hpx/logging/writer/format_write.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-// format_write.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-// this is fixed!
-#ifndef JT28092007_format_write_HPP_DEFINED
-#define JT28092007_format_write_HPP_DEFINED
-
-#include <hpx/logging/format.hpp>
-
-#endif
diff --git a/libs/logging/include/hpx/logging/writer/named_write.hpp b/libs/logging/include/hpx/logging/writer/named_write.hpp
deleted file mode 100644
index 736a47c8e8..0000000000
--- a/libs/logging/include/hpx/logging/writer/named_write.hpp
+++ /dev/null
@@ -1,436 +0,0 @@
-// named_write.hpp
-
-// Boost Logging library
-//
-// Author: John Torjo, www.torjo.com
-//
-// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
-//
-//  SPDX-License-Identifier: BSL-1.0
-// Distributed under the Boost Software License, Version 1.0.
-//    (See accompanying file LICENSE_1_0.txt or copy at
-//          http://www.boost.org/LICENSE_1_0.txt)
-//
-// See http://www.boost.org for updates, documentation, and revision history.
-// See http://www.torjo.com/log2/ for more details
-
-#ifndef JT28092007_named_writer_HPP_DEFINED
-#define JT28092007_named_writer_HPP_DEFINED
-
-#include <hpx/assertion.hpp>
-#include <hpx/logging/format.hpp>
-#include <cstddef>
-#include <string>
-
-// all destinations
-#include <hpx/logging/format/destination/file.hpp>
-#include <hpx/logging/format/destination/named.hpp>
-
-// all formats
-#include <hpx/logging/format/formatter/high_precision_time.hpp>
-#include <hpx/logging/format/formatter/named_spacer.hpp>
-#include <hpx/logging/format/formatter/thread_id.hpp>
-
-namespace hpx { namespace util { namespace logging { namespace detail {
-    typedef formatter::high_precision_time formatter_time_type;
-    typedef formatter::high_precision_time_t<
-        formatter::do_convert_format::append>
-        formatter_time_type_append;
-}}}}    // namespace hpx::util::logging::detail
-
-namespace hpx { namespace util { namespace logging { namespace writer {
-
-    /**
-@brief Composed of a named formatter and a named destinations.
-Thus, you can specify the formatting and destinations as strings
-
-@code
-#include <hpx/logging/format/named_write.hpp>
-@endcode
-
-
-Contains a very easy interface for using @ref manipulator "formatters and destinations":
-- at construction, specify 2 params: the %formatter string and the destinations string
-
-Setting the @ref manipulator "formatters and destinations" to
-write to is extremely simple:
-
-@code
-// Set the formatters (first param) and destinatins (second step) in one step
-g_l()->writer().write("%time%($hh:$mm.$ss.$mili) [%idx%] |\n",
-"cout file(out.txt) debug");
-
-// set the formatter(s)
-g_l()->writer().format("%time%($hh:$mm.$ss.$mili) [%idx%] |\n");
-
-// set the destination(s)
-g_l()->writer().destination("cout file(out.txt) debug");
-@endcode
-
-
-@section format_string_syntax The syntax of the format string
-
-- The format string specifies how the message is to be logged
-- Every formatter is escaped using <tt>%</tt><em>fmt</em><tt>%</tt>
-  - Available formatters:
-    - <tt>"%idx%"</tt> - writes the index of the message (formatter::idx)
-    - <tt>"%time%"</tt> - writes the time (formatter::high_precision_time)
-    - <tt>"%thread_id%"</tt> - writes the thread id (formatter::thread_id)
-    - if you want to write @c "%", double it, like this: @c "%%"
-- @c "|" is used to specify the original message. What is before it,
-is prepended to the message, what is after, is appended to the message
-- If a formatter is configurable, append @em (params) to it
-  - For now, only @c "%time%" is configurable. For instance,
-  @c "%time%($hh:$mm.$ss.$mili)" writes time like @c "21:14.24.674"
-
-Example:
-@code
-"%time%($hh:$mm.$ss.$mili) [%idx%] |\n"
-@endcode
-
-The output can look like:
-
-@code
-21:03.17.243 [1] this is so cool
-21:03.17.243 [2] first error
-21:03.17.243 [3] hello, world
-@endcode
-
-
-@section dest_string_syntax The syntax of the destinations string
-
-- The syntax of the destination string specifies where the message is to be logged
-  - Every destination is specified by name
-  - Separate destinations by space (' ')
-- Available destinations
-  - <tt>"cout"</tt> - writes to std::cout (destination::cout)
-  - <tt>"cerr"</tt> - writes to std::cerr (destination::cerr)
-  - <tt>"debug"</tt> - writes to the debug window: OutputDebugString in Windows,
-  console on Linux (destination::dbg_window)
-  - <tt>"file"</tt> - writes to a file (destination::file)
-- If a destination is configurable, append @em (params) to it
-  - Right now, @c "file" is configurable
-    - Append <tt>(</tt><em>filename</em><tt>)</tt> to them to specify the file name.
-    Example: @c "file(out.txt)" will write to the out.txt file
-
-Examples:
-- <tt>"file(out.txt) cout"</tt> - will write to a file called out.txt and to cout
-- <tt>"cout debug"</tt> - will write to cout and debug window (see above)
-
-@note
-If you want to output to 2 files, don't use "file(one.txt) file(two.txt)".
-This will just configure "file" twice, ending up with writing only to "two.txt" file.
-
-@param format_write_ the underlying format writer
-
-
-*/
-    struct named_write
-    {
-        named_write()
-        {
-            m_writer.add_formatter(m_format_before);
-            m_writer.add_formatter(m_format_after);
-            m_writer.add_destination(m_destination);
-
-            init();
-        }
-
-        /** @brief sets the format string: what should be before,
-    and what after the original message, separated by "|"
-
-    Example: \n
-    "[%idx%] |\n" - this writes "[%idx%] " before the message,
-    and "\n" after the message
-
-    If "|" is not present, the whole message is prepended to the message
-    */
-        void format(const std::string& format_str)
-        {
-            m_format_str = format_str;
-
-            std::size_t idx = format_str.find('|');
-            std::string before, after;
-            if (idx != std::string::npos)
-            {
-                before = format_str.substr(0, idx);
-                after = format_str.substr(idx + 1);
-            }
-            else
-                before = format_str;
-
-            format(before, after);
-        };
-
-        /** @brief sets the format strings (what should be before,
-    and what after the original message)
-    */
-        void format(const std::string& format_before_str,
-            const std::string& format_after_str)
-        {
-            m_format_before_str = format_before_str;
-            m_format_after_str = format_after_str;
-
-            set_and_configure(
-                m_format_before, format_before_str, parse_formatter());
-            set_and_configure(
-                m_format_after, format_after_str, parse_formatter());
-        };
-
-        /** @brief sets the destinations string - where should logged messages
-         * be outputted
-    */
-        void destination(const std::string& destination_str)
-        {
-            m_destination_str = destination_str;
-            set_and_configure(
-                m_destination, destination_str, parse_destination());
-        }
-
-        /** @brief Specifies the formats and destinations in one step
-    */
-        void write(
-            const std::string& format_str, const std::string& destination_str)
-        {
-            format(format_str);
-            destination(destination_str);
-        }
-
-        const std::string& format() const
-        {
-            return m_format_str;
-        }
-        const std::string& destination() const
-        {
-            return m_destination_str;
-        }
-
-        void operator()(msg_type& msg) const
-        {
-            m_writer(msg);
-        }
-
-        /** @brief Replaces a destination from the named destination.
-
-    You can use this, for instance, when you want to share a
-    destination between multiple named writers.
-    */
-        template <class destination>
-        void replace_destination(const std::string& name, destination d)
-        {
-            m_destination.del(name);
-            m_destination.add(name, d);
-        }
-
-        /** @brief Replaces a formatter from the named formatter.
-
-    You can use this, for instance, when you want to share
-    a formatter between multiple named writers.
-    */
-        template <class formatter>
-        void replace_formatter(const std::string& name, formatter d)
-        {
-            if (m_format_before_str.find(name) != std::string::npos)
-            {
-                m_format_before.del(name);
-            }
-            m_format_before.add(name, d);
-
-            if (m_format_after_str.find(name) != std::string::npos)
-            {
-                m_format_after.del(name);
-            }
-            m_format_after.add(name, d);
-        }
-
-        template <class formatter>
-        void add_formatter(formatter fmt)
-        {
-            m_writer.add_formatter(fmt);
-        }
-
-        template <class destination>
-        void add_destination(const std::string& name, destination d)
-        {
-            m_destination.add(name, d);
-        }
-
-    private:
-        struct parse_destination
-        {
-            bool has_manipulator_name() const
-            {
-                return !m_manipulator.empty();
-            }
-            std::string get_manipulator_name() const
-            {
-                HPX_ASSERT(has_manipulator_name());
-                if (m_manipulator[0] == '-' || m_manipulator[0] == '+')
-                    // + or - -> turning on or off a destination
-                    return m_manipulator.substr(1);
-                else
-                    return m_manipulator;
-            }
-            void clear()
-            {
-                m_manipulator.clear();
-            }
-
-            void add(char c)
-            {
-                // destination always follows ' '
-                if (c == ' ')
-                    clear();
-                else
-                    m_manipulator += c;
-            }
-
-        private:
-            std::string m_manipulator;
-        };
-
-        struct parse_formatter
-        {
-            // formatter starts and ends with %
-            bool has_manipulator_name() const
-            {
-                if (m_manipulator.empty())
-                    return false;
-                if (m_manipulator.size() > 1)
-                    if (m_manipulator[0] == '%' &&
-                        (*m_manipulator.rbegin() == '%'))
-                        return true;
-
-                return false;
-            }
-
-            std::string get_manipulator_name() const
-            {
-                HPX_ASSERT(has_manipulator_name());
-                // ignore starting and ending %
-                return m_manipulator.substr(1, m_manipulator.size() - 2);
-            }
-            void clear()
-            {
-                m_manipulator.clear();
-            }
-
-            void add(char c)
-            {
-                if (has_manipulator_name())
-                    // was a manipulator until now
-                    clear();
-
-                if (c == '%')
-                {
-                    m_manipulator += c;
-                    if (!has_manipulator_name())
-                        // it could be the start of a formatter
-                        m_manipulator = '%';
-                }
-                else if (m_manipulator.empty())
-                {
-                    ;    // ignore this char - not from a manipulator
-                }
-                else if (m_manipulator[0] == '%')
-                {
-                    m_manipulator += c;
-                }
-                else
-                {
-                    // manipulator should always start with %
-                    HPX_ASSERT(false);
-                }
-            }
-
-        private:
-            std::string m_manipulator;
-        };
-
-        template <class manipulator, class parser_type>
-        void set_and_configure(
-            manipulator& manip, const std::string& name, parser_type parser)
-        {
-            // need to parse string
-            bool parsing_params = false;
-            std::string params;
-            std::string stripped_str;
-            for (std::string::const_iterator b = name.begin(), e = name.end();
-                 b != e; ++b)
-            {
-                if ((*b == '(') && !parsing_params)
-                {
-                    if (parser.has_manipulator_name())
-                    {
-                        parsing_params = true;
-                        params.clear();
-                    }
-                    else
-                    {
-                        stripped_str += *b;
-                        parser.add(*b);
-                    }
-                }
-                else if ((*b == ')') && parsing_params)
-                {
-                    HPX_ASSERT(parser.has_manipulator_name());
-                    manip.configure_inner(
-                        parser.get_manipulator_name(), params);
-                    parser.clear();
-                    parsing_params = false;
-                }
-                else
-                {
-                    if (parsing_params)
-                        params += *b;
-                    else
-                    {
-                        stripped_str += *b;
-                        parser.add(*b);
-                    }
-                }
-            }
-            manip.string(stripped_str);
-        }
-
-    private:
-        void init()
-        {
-            m_format_before.add("idx", formatter::idx())
-                .add("time",
-                    ::hpx::util::logging::detail::formatter_time_type(
-                        "$hh:$mm:$ss"))
-                .add("thread_id", formatter::thread_id());
-
-            m_format_after
-                .add("idx",
-                    formatter::idx_t<formatter::do_convert_format::append>())
-                .add("time",
-                    ::hpx::util::logging::detail::formatter_time_type_append(
-                        "$hh:$mm:$ss"))
-                .add("thread_id",
-                    formatter::thread_id_t<
-                        formatter::do_convert_format::append>());
-
-            m_destination.add("file", destination::file(""))
-                .add("cout", destination::cout())
-                .add("cerr", destination::cerr())
-                .add("debug", destination::dbg_window());
-        }
-
-    private:
-        formatter::named_spacer_t<formatter::do_convert_format::prepend>
-            m_format_before;
-        formatter::named_spacer_t<formatter::do_convert_format::append>
-            m_format_after;
-        destination::named m_destination;
-        format_write m_writer;
-
-        std::string m_format_str;
-        std::string m_format_before_str, m_format_after_str;
-        std::string m_destination_str;
-    };
-
-}}}}    // namespace hpx::util::logging::writer
-
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/cache_before_init.hpp b/libs/logging/include_compatibility/hpx/util/logging/detail/cache_before_init.hpp
deleted file mode 100644
index 6c93813aff..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/cache_before_init.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/cache_before_init.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message(                                                               \
-    "The header hpx/util/logging/detail/cache_before_init.hpp is deprecated,   \
-    please include hpx/logging/detail/cache_before_init.hpp instead")
-#else
-#warning                                                                       \
-    "The header hpx/util/logging/detail/cache_before_init.hpp is deprecated,   \
-    please include hpx/logging/detail/cache_before_init.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/error.hpp b/libs/logging/include_compatibility/hpx/util/logging/detail/error.hpp
deleted file mode 100644
index 148064bc15..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/error.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/error.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message(                                                               \
-    "The header hpx/util/logging/detail/error.hpp is deprecated,   \
-    please include hpx/logging/detail/error.hpp instead")
-#else
-#warning                                                                       \
-    "The header hpx/util/logging/detail/error.hpp is deprecated,          \
-    please include hpx/logging/detail/error.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/fwd.hpp b/libs/logging/include_compatibility/hpx/util/logging/detail/fwd.hpp
deleted file mode 100644
index d28305baea..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/fwd.hpp
+++ /dev/null
@@ -1,19 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/fwd.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message("The header hpx/util/logging/detail/fwd.hpp is deprecated, \
-    please include hpx/logging/detail/fwd.hpp instead")
-#else
-#warning "The header hpx/util/logging/detail/fwd.hpp is deprecated, \
-    please include hpx/logging/detail/fwd.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/level.hpp b/libs/logging/include_compatibility/hpx/util/logging/detail/level.hpp
index e0b313c7ef..de0b16bae9 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/level.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/detail/level.hpp
@@ -6,14 +6,14 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/level.hpp>
+#include <hpx/logging/level.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message("The header hpx/util/logging/detail/level.hpp is deprecated, \
-    please include hpx/logging/detail/level.hpp instead")
+    please include hpx/logging/level.hpp instead")
 #else
 #warning "The header hpx/util/logging/detail/level.hpp is deprecated, \
-    please include hpx/logging/detail/level.hpp instead"
+    please include hpx/logging/level.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/manipulator.hpp b/libs/logging/include_compatibility/hpx/util/logging/detail/manipulator.hpp
index 78d5967ec3..7d8dacdade 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/manipulator.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/detail/manipulator.hpp
@@ -6,16 +6,16 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/manipulator.hpp>
+#include <hpx/logging/manipulator.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/detail/manipulator.hpp is deprecated,         \
-    please include hpx/logging/detail/manipulator.hpp instead")
+    please include hpx/logging/manipulator.hpp instead")
 #else
 #warning                                                                       \
     "The header hpx/util/logging/detail/manipulator.hpp is deprecated,    \
-    please include hpx/logging/detail/manipulator.hpp instead"
+    please include hpx/logging/manipulator.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/template.hpp b/libs/logging/include_compatibility/hpx/util/logging/detail/template.hpp
deleted file mode 100644
index 9a48ea2da6..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/template.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/template.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message(                                                               \
-    "The header hpx/util/logging/detail/template.hpp is deprecated,            \
-    please include hpx/logging/detail/template.hpp instead")
-#else
-#warning                                                                       \
-    "The header hpx/util/logging/detail/template.hpp is deprecated,       \
-    please include hpx/logging/detail/template.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/time_format_holder.hpp b/libs/logging/include_compatibility/hpx/util/logging/detail/time_format_holder.hpp
deleted file mode 100644
index 62224b13a1..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/time_format_holder.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/time_format_holder.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message(                                                               \
-    "The header hpx/util/logging/detail/time_format_holder.hpp is deprecated,  \
-    please include hpx/logging/detail/time_format_holder.hpp instead")
-#else
-#warning                                                                       \
-    "The header hpx/util/logging/detail/time_format_holder.hpp is deprecated,  \
-    please include hpx/logging/detail/time_format_holder.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format.hpp b/libs/logging/include_compatibility/hpx/util/logging/format.hpp
deleted file mode 100644
index f5edbe9cc7..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/format.hpp
+++ /dev/null
@@ -1,19 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message("The header hpx/util/logging/format.hpp is deprecated, \
-    please include hpx/logging/format.hpp instead")
-#else
-#warning "The header hpx/util/logging/format.hpp is deprecated, \
-    please include hpx/logging/format.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/array.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/array.hpp
deleted file mode 100644
index a12aeb5d55..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/format/array.hpp
+++ /dev/null
@@ -1,19 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/array.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message("The header hpx/util/logging/format/array.hpp is deprecated, \
-    please include hpx/logging/format/array.hpp instead")
-#else
-#warning "The header hpx/util/logging/format/array.hpp is deprecated, \
-    please include hpx/logging/format/array.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/destination/convert_destination.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/destination/convert_destination.hpp
deleted file mode 100644
index 2f5a76e13e..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/format/destination/convert_destination.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/destination/convert_destination.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message(                                                               \
-    "The header hpx/util/logging/format/destination/convert_destination.hpp is \
-    deprecated, please include \
-    hpx/logging/format/destination/convert_destination.hpp instead")
-#else
-#warning                                                                       \
-    "The header hpx/util/logging/format/destination/convert_destination.hpp is \
-    deprecated, please include \
-    hpx/logging/format/destination/convert_destination.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/destination/defaults.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/destination/defaults.hpp
index 94a1be4ad4..6f6c84652d 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/destination/defaults.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/format/destination/defaults.hpp
@@ -6,16 +6,16 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/destination/defaults.hpp>
+#include <hpx/logging/format/destinations.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/format/destination/defaults.hpp is deprecated,\
-    please include hpx/logging/format/destination/defaults.hpp instead")
+    please include hpx/logging/format/destinations.hpp instead")
 #else
 #warning                                                                       \
     "The header hpx/util/logging/format/destination/defaults.hpp is deprecated,\
-    please include hpx/logging/format/destination/defaults.hpp instead"
+    please include hpx/logging/format/destinations.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/destination/file.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/destination/file.hpp
index 066870ea0a..478290054f 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/destination/file.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/format/destination/file.hpp
@@ -6,16 +6,16 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/destination/file.hpp>
+#include <hpx/logging/format/destinations.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/format/destination/file.hpp is deprecated,    \
-    please include hpx/logging/format/destination/file.hpp instead")
+    please include hpx/logging/format/destinations.hpp instead")
 #else
 #warning                                                                       \
     "The header hpx/util/logging/format/destination/file.hpp is deprecated,    \
-    please include hpx/logging/format/destination/file.hpp instead"
+    please include hpx/logging/format/destinations.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/destination/named.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/destination/named.hpp
deleted file mode 100644
index e126991cce..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/format/destination/named.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/destination/named.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message(                                                               \
-    "The header hpx/util/logging/format/destination/named.hpp is deprecated,   \
-    please include hpx/logging/format/destination/named.hpp instead")
-#else
-#warning                                                                       \
-    "The header hpx/util/logging/format/destination/named.hpp is deprecated,   \
-    please include hpx/logging/format/destination/named.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/defaults.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/formatter/defaults.hpp
index ddaebdec10..a2cb3858a6 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/defaults.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/format/formatter/defaults.hpp
@@ -6,16 +6,16 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/defaults.hpp>
+#include <hpx/logging/format/formatters.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/format/formatter/defaults.hpp is deprecated, \
-    please include hpx/logging/format/formatter/defaults.hpp instead")
+    please include hpx/logging/format/formatters.hpp instead")
 #else
 #warning                                                                       \
     "The header hpx/util/logging/format/formatter/defaults.hpp is deprecated, \
-    please include hpx/logging/format/formatter/defaults.hpp instead"
+    please include hpx/logging/format/formatters.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/high_precision_time.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/formatter/high_precision_time.hpp
index fc1deb0347..d2d66662de 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/high_precision_time.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/format/formatter/high_precision_time.hpp
@@ -6,16 +6,16 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/high_precision_time.hpp>
+#include <hpx/logging/format/formatters.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/format/formatter/high_precision_time.hpp is deprecated, \
-    please include hpx/logging/format/formatter/high_precision_time.hpp instead")
+    please include hpx/logging/format/formatters.hpp instead")
 #else
 #warning                                                                       \
     "The header hpx/util/logging/format/formatter/high_precision_time.hpp is deprecated, \
-    please include hpx/logging/format/formatter/high_precision_time.hpp instead"
+    please include hpx/logging/format/formatters.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/thread_id.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/formatter/thread_id.hpp
index 6a572e00de..3ab6a21298 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/thread_id.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/format/formatter/thread_id.hpp
@@ -6,16 +6,16 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/thread_id.hpp>
+#include <hpx/logging/format/formatters.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/format/formatter/thread_id.hpp is deprecated, \
-    please include hpx/logging/format/formatter/thread_id.hpp instead")
+    please include hpx/logging/format/formatters.hpp instead")
 #else
 #warning                                                                       \
     "The header hpx/util/logging/format/formatter/thread_id.hpp is deprecated, \
-    please include hpx/logging/format/formatter/thread_id.hpp instead"
+    please include hpx/logging/format/formatters.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/op_equal.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/op_equal.hpp
deleted file mode 100644
index 3a9f8f9b70..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/format/op_equal.hpp
+++ /dev/null
@@ -1,20 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/op_equal.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message(                                                               \
-    "The header hpx/util/logging/format/op_equal.hpp is deprecated, \
-    please include hpx/logging/format/op_equal.hpp instead")
-#else
-#warning "The header hpx/util/logging/format/op_equal.hpp is deprecated, \
-    please include hpx/logging/format/op_equal.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/optimize.hpp b/libs/logging/include_compatibility/hpx/util/logging/format/optimize.hpp
index af74820d23..cb47aef814 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/optimize.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/format/optimize.hpp
@@ -6,15 +6,15 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/optimize.hpp>
+#include <hpx/logging/message.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/format/optimize.hpp is deprecated, \
-    please include hpx/logging/format/optimize.hpp instead")
+    please include hpx/logging/message.hpp instead")
 #else
 #warning "The header hpx/util/logging/format/optimize.hpp is deprecated, \
-    please include hpx/logging/format/optimize.hpp instead"
+    please include hpx/logging/message.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format_fwd.hpp b/libs/logging/include_compatibility/hpx/util/logging/format_fwd.hpp
deleted file mode 100644
index 8da7978741..0000000000
--- a/libs/logging/include_compatibility/hpx/util/logging/format_fwd.hpp
+++ /dev/null
@@ -1,19 +0,0 @@
-//  Copyright (c) 2019 Mikael Simberg
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format_fwd.hpp>
-
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message("The header hpx/util/logging/format_fwd.hpp is deprecated, \
-    please include hpx/logging/format_fwd.hpp instead")
-#else
-#warning "The header hpx/util/logging/format_fwd.hpp is deprecated, \
-    please include hpx/logging/format_fwd.hpp instead"
-#endif
-#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/writer/format_write.hpp b/libs/logging/include_compatibility/hpx/util/logging/writer/format_write.hpp
index d1cc49ffaa..64a1e2ed33 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/writer/format_write.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/writer/format_write.hpp
@@ -6,15 +6,15 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/writer/format_write.hpp>
+#include <hpx/logging/format.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/writer/format_write.hpp is deprecated, \
-    please include hpx/logging/writer/format_write.hpp instead")
+    please include hpx/logging/format.hpp instead")
 #else
 #warning "The header hpx/util/logging/writer/format_write.hpp is deprecated, \
-    please include hpx/logging/writer/format_write.hpp instead"
+    please include hpx/logging/format.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/writer/named_write.hpp b/libs/logging/include_compatibility/hpx/util/logging/writer/named_write.hpp
index 80ccc7f94c..a9f87b450e 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/writer/named_write.hpp
+++ b/libs/logging/include_compatibility/hpx/util/logging/writer/named_write.hpp
@@ -6,15 +6,15 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/writer/named_write.hpp>
+#include <hpx/logging/named_write.hpp>
 
 #if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
     "The header hpx/util/logging/writer/named_write.hpp is deprecated, \
-    please include hpx/logging/writer/named_write.hpp instead")
+    please include hpx/logging/named_write.hpp instead")
 #else
 #warning "The header hpx/util/logging/writer/named_write.hpp is deprecated, \
-    please include hpx/logging/writer/named_write.hpp instead"
+    please include hpx/logging/named_write.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/src/format/destination/defaults.cpp b/libs/logging/src/format/destination/defaults.cpp
new file mode 100644
index 0000000000..8f2c8e87b6
--- /dev/null
+++ b/libs/logging/src/format/destination/defaults.cpp
@@ -0,0 +1,102 @@
+// destination_defaults.hpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#include <hpx/logging/format/destinations.hpp>
+
+#include <hpx/config.hpp>
+#include <hpx/logging/message.hpp>
+
+#include <iostream>
+#include <memory>
+
+#ifdef HPX_WINDOWS
+#include <windows.h>
+#endif
+
+namespace hpx { namespace util { namespace logging { namespace destination {
+
+    cout::~cout() = default;
+
+    struct cout_impl : cout
+    {
+        void operator()(const message& msg) override
+        {
+            std::cout << msg.full_string();
+        }
+    };
+
+    std::unique_ptr<cout> cout::make()
+    {
+        return std::unique_ptr<cout>(new cout_impl());
+    }
+
+    cerr::~cerr() = default;
+
+    struct cerr_impl : cerr
+    {
+        void operator()(const message& msg) override
+        {
+            std::cerr << msg.full_string();
+        }
+    };
+
+    std::unique_ptr<cerr> cerr::make()
+    {
+        return std::unique_ptr<cerr>(new cerr_impl());
+    }
+
+    stream::~stream() = default;
+
+    struct stream_impl : stream
+    {
+        explicit stream_impl(std::ostream* stream_ptr)
+          : stream(stream_ptr)
+        {
+        }
+
+        void operator()(const message& msg) override
+        {
+            if (ptr)
+                *ptr << msg.full_string();
+        }
+    };
+
+    std::unique_ptr<stream> stream::make(std::ostream* stream_ptr)
+    {
+        return std::unique_ptr<stream>(new stream_impl(stream_ptr));
+    }
+
+    dbg_window::~dbg_window() = default;
+
+    struct dbg_window_impl : dbg_window
+    {
+        void operator()(const message& msg) override
+        {
+#ifdef HPX_WINDOWS
+            ::OutputDebugStringA(msg.full_string().c_str());
+#else
+            // non windows - dump to console
+            std::cout << msg.full_string();
+#endif
+        }
+    };
+
+    std::unique_ptr<dbg_window> dbg_window::make()
+    {
+        return std::unique_ptr<dbg_window>(new dbg_window_impl());
+    }
+
+}}}}    // namespace hpx::util::logging::destination
diff --git a/libs/logging/src/format/destination/file.cpp b/libs/logging/src/format/destination/file.cpp
new file mode 100644
index 0000000000..b24e9aef0c
--- /dev/null
+++ b/libs/logging/src/format/destination/file.cpp
@@ -0,0 +1,96 @@
+// destination_file.hpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#include <hpx/logging/format/destinations.hpp>
+
+#include <hpx/config.hpp>
+#include <hpx/logging/message.hpp>
+
+#include <boost/config.hpp>
+#include <boost/smart_ptr/detail/spinlock.hpp>
+
+#include <fstream>
+#include <memory>
+#include <mutex>
+#include <string>
+
+namespace hpx { namespace util { namespace logging { namespace destination {
+
+    file::~file() = default;
+
+    static std::ios_base::openmode open_flags(file::file_settings fs)
+    {
+        std::ios_base::openmode flags = std::ios_base::out;
+        flags |= fs.extra_flags;
+        if (fs.do_append && !fs.initial_overwrite)
+            flags |= std::ios_base::app;
+        if (fs.initial_overwrite)
+            flags |= std::ios_base::trunc;
+        return flags;
+    }
+
+    struct file_impl : file
+    {
+        typedef boost::detail::spinlock mutex_type;
+
+        explicit file_impl(std::string const& file_name, file_settings set)
+          : file(file_name, set)
+        {
+        }
+
+        void operator()(const message& msg) override
+        {
+            std::lock_guard<mutex_type> l(mtx_);
+
+            open();    // make sure file is opened
+            out << msg.full_string();
+            if (settings.flush_each_time)
+                out.flush();
+        }
+
+        /** configure through script
+        right now, you can only specify the file name
+    */
+        void configure(std::string const& str) override
+        {
+            // configure - the file name, for now
+            close();
+            name = str;
+        }
+
+    private:
+        void open()
+        {
+            if (!out.is_open())
+                out.open(name.c_str(), open_flags(settings));
+        }
+
+        void close()
+        {
+            out.close();
+        }
+
+        std::ofstream out;
+        mutable mutex_type mtx_ = BOOST_DETAIL_SPINLOCK_INIT;
+    };
+
+    std::unique_ptr<file> file::make(
+        std::string const& file_name, file_settings set)
+    {
+        return std::unique_ptr<file>(new file_impl(file_name, set));
+    }
+
+}}}}    // namespace hpx::util::logging::destination
diff --git a/libs/logging/src/format/formatter/defaults.cpp b/libs/logging/src/format/formatter/defaults.cpp
new file mode 100644
index 0000000000..4cf3cf42ef
--- /dev/null
+++ b/libs/logging/src/format/formatter/defaults.cpp
@@ -0,0 +1,51 @@
+// defaults.cpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#include <hpx/logging/format/formatters.hpp>
+
+#include <hpx/config.hpp>
+#include <hpx/format.hpp>
+
+#include <cstdint>
+#include <memory>
+#include <ostream>
+
+namespace hpx { namespace util { namespace logging { namespace formatter {
+
+    idx::~idx() = default;
+
+    struct idx_impl : idx
+    {
+        idx_impl()
+          : value(0ull)
+        {
+        }
+
+        void operator()(std::ostream& to) const override
+        {
+            util::format_to(to, "{:016x}", ++value);
+        }
+
+    private:
+        mutable std::uint64_t value;
+    };
+
+    std::unique_ptr<idx> idx::make()
+    {
+        return std::unique_ptr<idx>(new idx_impl());
+    }
+
+}}}}    // namespace hpx::util::logging::formatter
diff --git a/libs/logging/src/format/formatter/high_precision_time.cpp b/libs/logging/src/format/formatter/high_precision_time.cpp
new file mode 100644
index 0000000000..c64da835c3
--- /dev/null
+++ b/libs/logging/src/format/formatter/high_precision_time.cpp
@@ -0,0 +1,129 @@
+// high_precision_time.hpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#include <hpx/logging/format/formatters.hpp>
+
+#include <hpx/config.hpp>
+#include <hpx/format.hpp>
+
+#include <chrono>
+#include <cstdint>
+#include <cstring>
+#include <ctime>
+#include <memory>
+#include <ostream>
+#include <string>
+
+#if !(defined(__linux) || defined(linux) || defined(__linux__) ||              \
+    defined(__FreeBSD__) || defined(__APPLE__) || defined(HPX_MSVC))
+#include <boost/smart_ptr/detail/spinlock.hpp>
+#include <mutex>
+#endif
+
+namespace hpx { namespace util { namespace logging { namespace formatter {
+
+    high_precision_time::~high_precision_time() = default;
+
+    struct high_precision_time_impl : high_precision_time
+    {
+        /**
+        constructs a high_precision_time object
+    */
+        explicit high_precision_time_impl(std::string const& format)
+          : high_precision_time(format)
+        {
+        }
+
+        void operator()(std::ostream& to) const override
+        {
+            auto const val = std::chrono::system_clock::now();
+            std::time_t tt = std::chrono::system_clock::to_time_t(val);
+
+#if defined(__linux) || defined(linux) || defined(__linux__) ||                \
+    defined(__FreeBSD__) || defined(__APPLE__)
+            std::tm local_tm;
+            localtime_r(&tt, &local_tm);
+#elif defined(HPX_MSVC)
+            std::tm local_tm;
+            localtime_s(&local_tm, &tt);
+#else
+            // fall back to non-thread-safe version on other platforms
+            std::tm local_tm;
+            {
+                static boost::detail::spinlock mutex =
+                    BOOST_DETAIL_SPINLOCK_INIT;
+                std::unique_lock<boost::detail::spinlock> ul(mutex);
+                local_tm = *std::localtime(&tt);
+            }
+#endif
+
+            std::chrono::nanoseconds nanosecs =
+                std::chrono::duration_cast<std::chrono::nanoseconds>(
+                    val.time_since_epoch());
+            std::chrono::microseconds microsecs =
+                std::chrono::duration_cast<std::chrono::microseconds>(
+                    val.time_since_epoch());
+            std::chrono::milliseconds millisecs =
+                std::chrono::duration_cast<std::chrono::milliseconds>(
+                    val.time_since_epoch());
+
+            util::format_to(to, m_format, local_tm.tm_mday, local_tm.tm_mon + 1,
+                local_tm.tm_year + 1900, local_tm.tm_year % 100,
+                local_tm.tm_hour, local_tm.tm_min, local_tm.tm_sec,
+                millisecs.count() % 1000, microsecs.count() % 1000,
+                nanosecs.count() % 1000);
+        }
+
+        /** @brief configure through script
+
+        the string = the time format
+    */
+        void configure(std::string const& str) override
+        {
+            m_format = str;
+            replace_format("$dd", "{1:02d}");
+            replace_format("$MM", "{2:02d}");
+            replace_format("$yyyy", "{3:04d}");
+            replace_format("$yy", "{4:02d}");
+            replace_format("$hh", "{5:02d}");
+            replace_format("$mm", "{6:02d}");
+            replace_format("$ss", "{7:02d}");
+            replace_format("$mili", "{8:03d}");
+            replace_format("$micro", "{9:06d}");
+            replace_format("$nano", "{10:09d}");
+        }
+
+    private:
+        bool replace_format(char const* from, char const* to)
+        {
+            size_t start_pos = m_format.find(from);
+            if (start_pos == std::string::npos)
+                return false;
+            m_format.replace(start_pos, std::strlen(from), to);
+            return true;
+        }
+
+        std::string m_format;
+    };
+
+    std::unique_ptr<high_precision_time> high_precision_time::make(
+        std::string const& format)
+    {
+        return std::unique_ptr<high_precision_time>(
+            new high_precision_time_impl(format));
+    }
+
+}}}}    // namespace hpx::util::logging::formatter
diff --git a/libs/logging/src/format/formatter/thread_id.cpp b/libs/logging/src/format/formatter/thread_id.cpp
new file mode 100644
index 0000000000..2dc357563b
--- /dev/null
+++ b/libs/logging/src/format/formatter/thread_id.cpp
@@ -0,0 +1,54 @@
+// thread_id.cpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#include <hpx/logging/format/formatters.hpp>
+
+#include <hpx/config.hpp>
+#include <hpx/format.hpp>
+
+#include <memory>
+#include <ostream>
+
+#if defined(HPX_WINDOWS)
+#include <windows.h>
+#else
+#include <pthread.h>
+#endif
+
+namespace hpx { namespace util { namespace logging { namespace formatter {
+
+    thread_id::~thread_id() = default;
+
+    struct thread_id_impl : thread_id
+    {
+        void operator()(std::ostream& to) const override
+        {
+            util::format_to(to, "{}",
+#if defined(HPX_WINDOWS)
+                ::GetCurrentThreadId()
+#else
+                pthread_self()
+#endif
+            );
+        }
+    };
+
+    std::unique_ptr<thread_id> thread_id::make()
+    {
+        return std::unique_ptr<thread_id>(new thread_id_impl());
+    }
+
+}}}}    // namespace hpx::util::logging::formatter
diff --git a/libs/logging/src/format/named_write.cpp b/libs/logging/src/format/named_write.cpp
new file mode 100644
index 0000000000..e30ae3dc60
--- /dev/null
+++ b/libs/logging/src/format/named_write.cpp
@@ -0,0 +1,300 @@
+// named_write.cpp
+
+// Boost Logging library
+//
+// Author: John Torjo, www.torjo.com
+//
+// Copyright (C) 2007 John Torjo (see www.torjo.com for email)
+//
+//  SPDX-License-Identifier: BSL-1.0
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org for updates, documentation, and revision history.
+// See http://www.torjo.com/log2/ for more details
+
+#include <hpx/logging/format/named_write.hpp>
+
+#include <hpx/config.hpp>
+#include <hpx/assertion.hpp>
+#include <hpx/logging/format/destinations.hpp>
+#include <hpx/logging/format/formatters.hpp>
+
+#include <cstddef>
+#include <memory>
+#include <sstream>
+#include <string>
+
+namespace hpx { namespace util { namespace logging { namespace detail {
+
+    static std::string unescape(std::string escaped)
+    {
+        typedef std::size_t size_type;
+        size_type idx_start = 0;
+        while (true)
+        {
+            size_type found = escaped.find("%%", idx_start);
+            if (found != std::string::npos)
+            {
+                escaped.erase(
+                    escaped.begin() + static_cast<std::ptrdiff_t>(found));
+                ++idx_start;
+            }
+            else
+                break;
+        }
+        return escaped;
+    }
+
+    void named_formatters::compute_write_steps()
+    {
+        typedef std::size_t size_type;
+
+        write_steps.clear();
+        std::string remaining = format_string;
+        size_type start_search_idx = 0;
+        while (!remaining.empty())
+        {
+            size_type idx = remaining.find_first_of("%|", start_search_idx);
+            switch (idx != std::string::npos ? remaining[idx] : '\0')
+            {
+            case '|':
+            {
+                // up to here, this is a spacer string
+                start_search_idx = 0;
+                std::string spacer = detail::unescape(remaining.substr(0, idx));
+                remaining.erase(0, idx + 1);
+
+                formatter::manipulator* fmt = (formatter::manipulator*) -1;
+                write_steps.push_back(write_step(spacer, fmt));
+                break;
+            }
+            case '%':
+            {
+                // see if just escaped
+                if ((idx < remaining.size() - 1) && remaining[idx + 1] == '%')
+                {
+                    // we found an escaped char
+                    start_search_idx = idx + 2;
+                    continue;
+                }
+
+                // up to here, this is a spacer string
+                start_search_idx = 0;
+                std::string spacer = detail::unescape(remaining.substr(0, idx));
+                remaining.erase(0, idx + 1);
+                // find end of formatter name
+                idx = remaining.find('%');
+                formatter::manipulator* fmt = nullptr;
+                if (idx != std::string::npos)
+                {
+                    std::string name = remaining.substr(0, idx);
+                    remaining.erase(0, idx + 1);
+                    auto iter = find_named(formatters, name);
+                    if (iter != formatters.end())
+                        fmt = iter->value.get();
+                }
+                // note: fmt could be null, in case
+                write_steps.push_back(write_step(spacer, fmt));
+                break;
+            }
+            case '\0':
+            {
+                // last part
+                write_steps.push_back(
+                    write_step(detail::unescape(remaining), nullptr));
+                remaining.clear();
+                break;
+            }
+            }
+        }
+    }
+
+    void named_destinations::compute_write_steps()
+    {
+        write_steps.clear();
+
+        std::istringstream in(format_string);
+        std::string word;
+        while (in >> word)
+        {
+            if (word[0] == '+')
+                word.erase(word.begin());
+            else if (word[0] == '-')
+                // ignore this word
+                continue;
+
+            auto iter = find_named(destinations, word);
+            if (iter != destinations.cend())
+                write_steps.push_back(iter->value.get());
+        }
+    }
+
+    namespace {
+        struct parse_formatter
+        {
+            // formatter starts and ends with %
+            bool has_manipulator_name() const
+            {
+                if (m_manipulator.empty())
+                    return false;
+                if (m_manipulator.size() > 1)
+                    if (m_manipulator[0] == '%' &&
+                        (*m_manipulator.rbegin() == '%'))
+                        return true;
+
+                return false;
+            }
+
+            std::string get_manipulator_name() const
+            {
+                HPX_ASSERT(has_manipulator_name());
+                // ignore starting and ending %
+                return m_manipulator.substr(1, m_manipulator.size() - 2);
+            }
+
+            void clear()
+            {
+                m_manipulator.clear();
+            }
+
+            void add(char c)
+            {
+                if (has_manipulator_name())
+                    // was a manipulator until now
+                    clear();
+
+                if (c == '%')
+                {
+                    m_manipulator += c;
+                    if (!has_manipulator_name())
+                        // it could be the start of a formatter
+                        m_manipulator = '%';
+                }
+                else if (m_manipulator.empty())
+                {
+                    ;    // ignore this char - not from a manipulator
+                }
+                else if (m_manipulator[0] == '%')
+                {
+                    m_manipulator += c;
+                }
+                else
+                {
+                    // manipulator should always start with %
+                    HPX_ASSERT(false);
+                }
+            }
+
+        private:
+            std::string m_manipulator;
+        };
+
+        struct parse_destination
+        {
+            bool has_manipulator_name() const
+            {
+                return !m_manipulator.empty();
+            }
+
+            std::string get_manipulator_name() const
+            {
+                HPX_ASSERT(has_manipulator_name());
+                if (m_manipulator[0] == '-' || m_manipulator[0] == '+')
+                    // + or - -> turning on or off a destination
+                    return m_manipulator.substr(1);
+                else
+                    return m_manipulator;
+            }
+
+            void clear()
+            {
+                m_manipulator.clear();
+            }
+
+            void add(char c)
+            {
+                // destination always follows ' '
+                if (c == ' ')
+                    clear();
+                else
+                    m_manipulator += c;
+            }
+
+        private:
+            std::string m_manipulator;
+        };
+
+        template <typename Named, typename ParserType>
+        void configure(
+            Named& named, std::string const& format, ParserType parser)
+        {
+            // need to parse string
+            bool parsing_params = false;
+            std::string params;
+            std::string stripped_str;
+            for (char c : format)
+            {
+                if ((c == '(') && !parsing_params)
+                {
+                    if (parser.has_manipulator_name())
+                    {
+                        parsing_params = true;
+                        params.clear();
+                    }
+                    else
+                    {
+                        stripped_str += c;
+                        parser.add(c);
+                    }
+                }
+                else if (c == ')' && parsing_params)
+                {
+                    HPX_ASSERT(parser.has_manipulator_name());
+                    named.configure(parser.get_manipulator_name(), params);
+                    parser.clear();
+                    parsing_params = false;
+                }
+                else
+                {
+                    if (parsing_params)
+                        params += c;
+                    else
+                    {
+                        stripped_str += c;
+                        parser.add(c);
+                    }
+                }
+            }
+            named.string(stripped_str);
+        }
+    }    // namespace
+
+}}}}    // namespace hpx::util::logging::detail
+
+namespace hpx { namespace util { namespace logging { namespace writer {
+
+    named_write::named_write()
+    {
+        set_formatter<formatter::idx>("idx");
+        set_formatter<formatter::high_precision_time>("time", "$hh:$mm:$ss");
+        set_formatter<formatter::thread_id>("thread_id");
+
+        set_destination<destination::file>("file", "");
+        set_destination<destination::cout>("cout");
+        set_destination<destination::cerr>("cerr");
+        set_destination<destination::dbg_window>("debug");
+    }
+
+    void named_write::configure_formatter(std::string const& format)
+    {
+        detail::configure(m_format, format, detail::parse_formatter{});
+    }
+
+    void named_write::configure_destination(std::string const& format)
+    {
+        detail::configure(m_destination, format, detail::parse_destination{});
+    }
+
+}}}}    // namespace hpx::util::logging::writer
diff --git a/libs/logging/src/level.cpp b/libs/logging/src/level.cpp
new file mode 100644
index 0000000000..215c35ab09
--- /dev/null
+++ b/libs/logging/src/level.cpp
@@ -0,0 +1,58 @@
+//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/logging/level.hpp>
+
+#if defined(HPX_HAVE_LOGGING)
+#include <boost/utility/string_ref.hpp>
+
+#include <cstddef>
+#include <iomanip>
+#include <ostream>
+#include <stdexcept>
+#include <string>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace hpx { namespace util { namespace logging {
+
+    static std::string levelname(level value)
+    {
+        switch (value)
+        {
+        case hpx::util::logging::level::enable_all:
+            return "<all>";
+        case hpx::util::logging::level::debug:
+            return "<debug>";
+        case hpx::util::logging::level::info:
+            return "<info>";
+        case hpx::util::logging::level::warning:
+            return "<warning>";
+        case hpx::util::logging::level::error:
+            return "<error>";
+        case hpx::util::logging::level::fatal:
+            return "<fatal>";
+        case hpx::util::logging::level::always:
+            return "<always>";
+        default:
+            break;
+        }
+
+        return '<' + std::to_string(static_cast<int>(value)) + '>';
+    }
+
+    void format_value(std::ostream& os, boost::string_ref spec, level value)
+    {
+        if (!spec.empty())
+            throw std::runtime_error("Not a valid format specifier");
+
+        os << std::right << std::setfill(' ') << std::setw(10)
+           << levelname(value);
+    }
+
+}}}    // namespace hpx::util::logging
+
+#endif    // HPX_HAVE_LOGGING
diff --git a/libs/logging/src/logging.cpp b/libs/logging/src/logging.cpp
index 1480032da9..7615d7ac56 100644
--- a/libs/logging/src/logging.cpp
+++ b/libs/logging/src/logging.cpp
@@ -10,12 +10,7 @@
 #if defined(HPX_HAVE_LOGGING)
 #include <hpx/filesystem.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/logging/format/destination/defaults.hpp>
-#include <hpx/logging/format/named_write.hpp>
-
-#include <boost/config.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/version.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -25,12 +20,6 @@
 #include <utility>
 #include <vector>
 
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(push)
-// 'class1' : inherits 'class2::member' via dominance
-#pragma warning(disable : 4250)
-#endif
-
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace util {
     HPX_DEFINE_LOG(agas, disable_all)
@@ -50,12 +39,12 @@ namespace hpx { namespace util {
     HPX_DEFINE_LOG(timing_console, disable_all)
 
     namespace detail {
-        hpx::util::logging::level::type get_log_level(
+        hpx::util::logging::level get_log_level(
             std::string const& env, bool allow_always)
         {
             try
             {
-                int env_val = boost::lexical_cast<int>(env);
+                int env_val = hpx::util::from_string<int>(env);
                 if (env_val < 0)
                     return hpx::util::logging::level::disable_all;
 
@@ -78,45 +67,20 @@ namespace hpx { namespace util {
                 }
                 return hpx::util::logging::level::debug;
             }
-            catch (boost::bad_lexical_cast const&)
+            catch (hpx::util::bad_lexical_cast const&)
             {
                 return hpx::util::logging::level::disable_all;
             }
         }
     }    // namespace detail
-
-    std::string levelname(int level)
-    {
-        switch (level)
-        {
-        case hpx::util::logging::level::enable_all:
-            return "     <all>";
-        case hpx::util::logging::level::debug:
-            return "   <debug>";
-        case hpx::util::logging::level::info:
-            return "    <info>";
-        case hpx::util::logging::level::warning:
-            return " <warning>";
-        case hpx::util::logging::level::error:
-            return "   <error>";
-        case hpx::util::logging::level::fatal:
-            return "   <fatal>";
-        case hpx::util::logging::level::always:
-            return "  <always>";
-        }
-
-        std::string unknown = std::to_string(level);
-        return std::string(
-                   (std::max)(7 - unknown.size(), std::size_t(0)), ' ') +
-            "<" + unknown + ">";
-    }
-}}    // namespace hpx::util
+}}       // namespace hpx::util
 
 ///////////////////////////////////////////////////////////////////////////////
-#include <hpx/logging/detail/cache_before_init.hpp>
+#include <hpx/logging/detail/logger.hpp>
 
-namespace hpx { namespace util { namespace logging { namespace detail {
-    void cache_before_init::turn_cache_off(writer::named_write const& writer_)
+namespace hpx { namespace util { namespace logging {
+
+    void logger::turn_cache_off()
     {
         if (m_is_caching_off)
             return;    // already turned off
@@ -124,105 +88,13 @@ namespace hpx { namespace util { namespace logging { namespace detail {
         m_is_caching_off = true;
 
         // dump messages
-        message_array msgs;
+        std::vector<message> msgs;
         std::swap(m_cache, msgs);
 
         for (auto& msg : msgs)
-        {
-            writer_(msg);
-        }
+            m_writer(msg);
     }
-}}}}    // namespace hpx::util::logging::detail
-
-///////////////////////////////////////////////////////////////////////////////
-#include <hpx/logging/format/destination/file.hpp>
-
-namespace hpx { namespace util { namespace logging { namespace destination {
-    file::mutex_type file::mtx_ = BOOST_DETAIL_SPINLOCK_INIT;
-}}}}    // namespace hpx::util::logging::destination
-
-///////////////////////////////////////////////////////////////////////////////
-#include <hpx/logging/format/destination/named.hpp>
-
-namespace hpx { namespace util { namespace logging { namespace destination {
-    namespace detail {
-        void named_context::compute_write_steps()
-        {
-            m_info.write_steps.clear();
-
-            std::istringstream in(m_info.format_string);
-            std::string word;
-            while (in >> word)
-            {
-                if (word[0] == '+')
-                    word.erase(word.begin());
-                else if (word[0] == '-')
-                    // ignore this word
-                    continue;
-
-                if (m_info.name_to_destination.find(word) !=
-                    m_info.name_to_destination.end())
-                    m_info.write_steps.push_back(
-                        m_info.name_to_destination.find(word)->second);
-            }
-        }
-}}}}}    // namespace hpx::util::logging::destination::detail
-
-///////////////////////////////////////////////////////////////////////////////
-#include <hpx/logging/format/formatter/named_spacer.hpp>
-
-namespace hpx { namespace util { namespace logging { namespace formatter {
-    namespace detail {
-        void base_named_spacer_context::compute_write_steps()
-        {
-            typedef std::size_t size_type;
-
-            m_info.write_steps.clear();
-            std::string remaining = m_info.format_string;
-            size_type start_search_idx = 0;
-            while (!remaining.empty())
-            {
-                size_type idx = remaining.find('%', start_search_idx);
-                if (idx != std::string::npos)
-                {
-                    // see if just escaped
-                    if ((idx < remaining.size() - 1) &&
-                        remaining[idx + 1] == '%')
-                    {
-                        // we found an escaped char
-                        start_search_idx = idx + 2;
-                        continue;
-                    }
-
-                    // up to here, this is a spacer string
-                    start_search_idx = 0;
-                    std::string spacer = unescape(remaining.substr(0, idx));
-                    remaining = remaining.substr(idx + 1);
-                    // find end of formatter name
-                    idx = remaining.find('%');
-                    format_base_type* fmt = nullptr;
-                    if (idx != std::string::npos)
-                    {
-                        std::string name = remaining.substr(0, idx);
-                        remaining = remaining.substr(idx + 1);
-                        fmt = m_info.name_to_formatter[name];
-                    }
-                    // note: fmt could be null, in case
-                    m_info.write_steps.push_back(write_step(spacer, fmt));
-                }
-                else
-                {
-                    // last part
-                    m_info.write_steps.push_back(
-                        write_step(unescape(remaining), nullptr));
-                    remaining.clear();
-                }
-            }
-        }
-}}}}}    // namespace hpx::util::logging::formatter::detail
 
-#if defined(HPX_MSVC_WARNING_PRAGMA)
-#pragma warning(pop)
-#endif
+}}}    // namespace hpx::util::logging
 
 #endif    // HPX_HAVE_LOGGING
diff --git a/libs/logging/include/hpx/logging/detail/template.hpp b/libs/logging/src/manipulator.cpp
similarity index 67%
rename from libs/logging/include/hpx/logging/detail/template.hpp
rename to libs/logging/src/manipulator.cpp
index 53e6d059a1..c37a5a43d8 100644
--- a/libs/logging/include/hpx/logging/detail/template.hpp
+++ b/libs/logging/src/manipulator.cpp
@@ -1,4 +1,4 @@
-// Template.hpp
+// manipulator.cpp
 
 // Boost Logging library
 //
@@ -14,13 +14,20 @@
 // See http://www.boost.org for updates, documentation, and revision history.
 // See http://www.torjo.com/log2/ for more details
 
-#ifndef JT28092007_TEMPLATE_HPP_DEFINED
-#define JT28092007_TEMPLATE_HPP_DEFINED
-
-#include <hpx/logging/detail/fwd.hpp>
+#include <hpx/logging/manipulator.hpp>
 
 namespace hpx { namespace util { namespace logging {
 
-}}}    // namespace hpx::util::logging
+    namespace formatter {
+
+        manipulator::~manipulator() = default;
+
+    }    // namespace formatter
 
-#endif
+    namespace destination {
+
+        manipulator::~manipulator() = default;
+
+    }    // namespace destination
+
+}}}    // namespace hpx::util::logging
diff --git a/libs/memory/CMakeLists.txt b/libs/memory/CMakeLists.txt
index b843dc9c78..6b31d1d879 100644
--- a/libs/memory/CMakeLists.txt
+++ b/libs/memory/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 # Default location is $HPX_ROOT/libs/memory/include
 set(memory_headers
diff --git a/libs/memory/README.rst b/libs/memory/README.rst
index 42e61bb23a..9ced8c892a 100644
--- a/libs/memory/README.rst
+++ b/libs/memory/README.rst
@@ -13,4 +13,4 @@ memory
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/memory/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/memory/docs/index.html>`__.
diff --git a/libs/memory/include/hpx/memory/intrusive_ptr.hpp b/libs/memory/include/hpx/memory/intrusive_ptr.hpp
index 22376ef720..9fd7c3a597 100644
--- a/libs/memory/include/hpx/memory/intrusive_ptr.hpp
+++ b/libs/memory/include/hpx/memory/intrusive_ptr.hpp
@@ -47,7 +47,7 @@ namespace hpx { namespace memory {
     public:
         using element_type = T;
 
-        HPX_CONSTEXPR intrusive_ptr() noexcept
+        constexpr intrusive_ptr() noexcept
           : px(nullptr)
         {
         }
@@ -121,6 +121,7 @@ namespace hpx { namespace memory {
             return *this;
         }
 
+        // NOLINTNEXTLINE(bugprone-unhandled-self-assignment)
         intrusive_ptr& operator=(intrusive_ptr const& rhs)
         {
             this_type(rhs).swap(*this);
diff --git a/libs/memory/tests/unit/intrusive_ptr.cpp b/libs/memory/tests/unit/intrusive_ptr.cpp
index 95c929ca11..fbc25248a1 100644
--- a/libs/memory/tests/unit/intrusive_ptr.cpp
+++ b/libs/memory/tests/unit/intrusive_ptr.cpp
@@ -125,36 +125,36 @@ namespace n_constructors {
             HPX_TEST(px.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             hpx::intrusive_ptr<X> px(p);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             intrusive_ptr_add_ref(p);
-            HPX_TEST(p->use_count() == 1);
+            HPX_TEST_EQ(p->use_count(), 1);
 
             hpx::intrusive_ptr<X> px(p, false);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     void copy_constructor()
@@ -162,60 +162,60 @@ namespace n_constructors {
         {
             hpx::intrusive_ptr<X> px;
             hpx::intrusive_ptr<X> px2(px);
-            HPX_TEST(px2.get() == px.get());
+            HPX_TEST_EQ(px2.get(), px.get());
         }
 
         {
             hpx::intrusive_ptr<Y> py;
             hpx::intrusive_ptr<X> px(py);
-            HPX_TEST(px.get() == py.get());
+            HPX_TEST_EQ(px.get(), py.get());
         }
 
         {
-            hpx::intrusive_ptr<X> px(0);
+            hpx::intrusive_ptr<X> px(nullptr);
             hpx::intrusive_ptr<X> px2(px);
-            HPX_TEST(px2.get() == px.get());
+            HPX_TEST_EQ(px2.get(), px.get());
         }
 
         {
             hpx::intrusive_ptr<Y> py(nullptr);
             hpx::intrusive_ptr<X> px(py);
-            HPX_TEST(px.get() == py.get());
+            HPX_TEST_EQ(px.get(), py.get());
         }
 
         {
             hpx::intrusive_ptr<X> px(nullptr, false);
             hpx::intrusive_ptr<X> px2(px);
-            HPX_TEST(px2.get() == px.get());
+            HPX_TEST_EQ(px2.get(), px.get());
         }
 
         {
             hpx::intrusive_ptr<Y> py(nullptr, false);
             hpx::intrusive_ptr<X> px(py);
-            HPX_TEST(px.get() == py.get());
+            HPX_TEST_EQ(px.get(), py.get());
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
             hpx::intrusive_ptr<X> px2(px);
-            HPX_TEST(px2.get() == px.get());
+            HPX_TEST_EQ(px2.get(), px.get());
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<Y> py(new Y);
             hpx::intrusive_ptr<X> px(py);
-            HPX_TEST(px.get() == py.get());
+            HPX_TEST_EQ(px.get(), py.get());
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     void test()
@@ -231,23 +231,23 @@ namespace n_destructor {
 
     void test()
     {
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             {
                 hpx::intrusive_ptr<X> px2(px);
-                HPX_TEST(px->use_count() == 2);
+                HPX_TEST_EQ(px->use_count(), 2);
             }
 
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
 }    // namespace n_destructor
@@ -256,7 +256,7 @@ namespace n_assignment {
 
     void copy_assignment()
     {
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> p1;
@@ -270,7 +270,7 @@ namespace n_assignment {
 #pragma clang diagnostic pop
 #endif
 
-            HPX_TEST(p1 == p1);
+            HPX_TEST_EQ(p1, p1);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
@@ -279,7 +279,7 @@ namespace n_assignment {
 
             p1 = p2;
 
-            HPX_TEST(p1 == p2);
+            HPX_TEST_EQ(p1, p2);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
@@ -288,40 +288,40 @@ namespace n_assignment {
 
             p1 = p3;
 
-            HPX_TEST(p1 == p3);
+            HPX_TEST_EQ(p1, p3);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
 
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(N::base::instances, 0);
 
             hpx::intrusive_ptr<X> p4(new X);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             p1 = p4;
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
-            HPX_TEST(p1 == p4);
+            HPX_TEST_EQ(p1, p4);
 
-            HPX_TEST(p1->use_count() == 2);
+            HPX_TEST_EQ(p1->use_count(), 2);
 
             p1 = p2;
 
-            HPX_TEST(p1 == p2);
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(p1, p2);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             p4 = p3;
 
-            HPX_TEST(p4 == p3);
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(p4, p3);
+            HPX_TEST_EQ(N::base::instances, 0);
         }
     }
 
     void conversion_assignment()
     {
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> p1;
@@ -330,54 +330,54 @@ namespace n_assignment {
 
             p1 = p2;
 
-            HPX_TEST(p1 == p2);
+            HPX_TEST_EQ(p1, p2);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
 
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(N::base::instances, 0);
 
             hpx::intrusive_ptr<Y> p4(new Y);
 
-            HPX_TEST(N::base::instances == 1);
-            HPX_TEST(p4->use_count() == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
+            HPX_TEST_EQ(p4->use_count(), 1);
 
             hpx::intrusive_ptr<X> p5(p4);
-            HPX_TEST(p4->use_count() == 2);
+            HPX_TEST_EQ(p4->use_count(), 2);
 
             p1 = p4;
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
-            HPX_TEST(p1 == p4);
+            HPX_TEST_EQ(p1, p4);
 
-            HPX_TEST(p1->use_count() == 3);
-            HPX_TEST(p4->use_count() == 3);
+            HPX_TEST_EQ(p1->use_count(), 3);
+            HPX_TEST_EQ(p4->use_count(), 3);
 
             p1 = p2;
 
-            HPX_TEST(p1 == p2);
-            HPX_TEST(N::base::instances == 1);
-            HPX_TEST(p4->use_count() == 2);
+            HPX_TEST_EQ(p1, p2);
+            HPX_TEST_EQ(N::base::instances, 1);
+            HPX_TEST_EQ(p4->use_count(), 2);
 
             p4 = p2;
             p5 = p2;
 
-            HPX_TEST(p4 == p2);
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(p4, p2);
+            HPX_TEST_EQ(N::base::instances, 0);
         }
     }
 
     void pointer_assignment()
     {
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> p1;
 
             p1 = p1.get();
 
-            HPX_TEST(p1 == p1);
+            HPX_TEST_EQ(p1, p1);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
@@ -386,7 +386,7 @@ namespace n_assignment {
 
             p1 = p2.get();
 
-            HPX_TEST(p1 == p2);
+            HPX_TEST_EQ(p1, p2);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
@@ -395,34 +395,34 @@ namespace n_assignment {
 
             p1 = p3.get();
 
-            HPX_TEST(p1 == p3);
+            HPX_TEST_EQ(p1, p3);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
 
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(N::base::instances, 0);
 
             hpx::intrusive_ptr<X> p4(new X);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             p1 = p4.get();
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
-            HPX_TEST(p1 == p4);
+            HPX_TEST_EQ(p1, p4);
 
-            HPX_TEST(p1->use_count() == 2);
+            HPX_TEST_EQ(p1->use_count(), 2);
 
             p1 = p2.get();
 
-            HPX_TEST(p1 == p2);
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(p1, p2);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             p4 = p3.get();
 
-            HPX_TEST(p4 == p3);
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(p4, p3);
+            HPX_TEST_EQ(N::base::instances, 0);
         }
 
         {
@@ -432,41 +432,41 @@ namespace n_assignment {
 
             p1 = p2.get();
 
-            HPX_TEST(p1 == p2);
+            HPX_TEST_EQ(p1, p2);
             HPX_TEST(p1 ? false : true);
             HPX_TEST(!p1);
             HPX_TEST(p1.get() == nullptr);
 
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(N::base::instances, 0);
 
             hpx::intrusive_ptr<Y> p4(new Y);
 
-            HPX_TEST(N::base::instances == 1);
-            HPX_TEST(p4->use_count() == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
+            HPX_TEST_EQ(p4->use_count(), 1);
 
             hpx::intrusive_ptr<X> p5(p4);
-            HPX_TEST(p4->use_count() == 2);
+            HPX_TEST_EQ(p4->use_count(), 2);
 
             p1 = p4.get();
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
-            HPX_TEST(p1 == p4);
+            HPX_TEST_EQ(p1, p4);
 
-            HPX_TEST(p1->use_count() == 3);
-            HPX_TEST(p4->use_count() == 3);
+            HPX_TEST_EQ(p1->use_count(), 3);
+            HPX_TEST_EQ(p4->use_count(), 3);
 
             p1 = p2.get();
 
-            HPX_TEST(p1 == p2);
-            HPX_TEST(N::base::instances == 1);
-            HPX_TEST(p4->use_count() == 2);
+            HPX_TEST_EQ(p1, p2);
+            HPX_TEST_EQ(N::base::instances, 1);
+            HPX_TEST_EQ(p4->use_count(), 2);
 
             p4 = p2.get();
             p5 = p2.get();
 
-            HPX_TEST(p4 == p2);
-            HPX_TEST(N::base::instances == 0);
+            HPX_TEST_EQ(p4, p2);
+            HPX_TEST_EQ(N::base::instances, 0);
         }
     }
 
@@ -483,7 +483,7 @@ namespace n_reset {
 
     void test()
     {
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px;
@@ -493,155 +493,155 @@ namespace n_reset {
             HPX_TEST(px.get() == nullptr);
 
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(p->use_count(), 0);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             px.reset(p);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
 
             px.reset();
             HPX_TEST(px.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
-            px.reset(0);
+            px.reset(nullptr);
             HPX_TEST(px.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
-            px.reset(0, false);
+            px.reset(nullptr, false);
             HPX_TEST(px.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
-            px.reset(0, true);
+            px.reset(nullptr, true);
             HPX_TEST(px.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             hpx::intrusive_ptr<X> px;
             HPX_TEST(px.get() == nullptr);
 
             px.reset(p, true);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
 #if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP)
             using hpx::intrusive_ptr_add_ref;
 #endif
             intrusive_ptr_add_ref(p);
-            HPX_TEST(p->use_count() == 1);
+            HPX_TEST_EQ(p->use_count(), 1);
 
             hpx::intrusive_ptr<X> px;
             HPX_TEST(px.get() == nullptr);
 
             px.reset(p, false);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
-            HPX_TEST(px.get() != 0);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST(px.get() != nullptr);
+            HPX_TEST_EQ(px->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
-            HPX_TEST(N::base::instances == 2);
+            HPX_TEST_EQ(N::base::instances, 2);
 
             px.reset(p);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
-            HPX_TEST(px.get() != 0);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST(px.get() != nullptr);
+            HPX_TEST_EQ(px->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
-            HPX_TEST(N::base::instances == 2);
+            HPX_TEST_EQ(N::base::instances, 2);
 
             px.reset(p, true);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new X);
-            HPX_TEST(px.get() != 0);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST(px.get() != nullptr);
+            HPX_TEST_EQ(px->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
 
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
 #if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP)
             using hpx::intrusive_ptr_add_ref;
 #endif
             intrusive_ptr_add_ref(p);
-            HPX_TEST(p->use_count() == 1);
+            HPX_TEST_EQ(p->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 2);
+            HPX_TEST_EQ(N::base::instances, 2);
 
             px.reset(p, false);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
 
-            HPX_TEST(N::base::instances == 1);
+            HPX_TEST_EQ(N::base::instances, 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
 }    // namespace n_reset
@@ -659,11 +659,11 @@ namespace n_access {
             using boost::get_pointer;
 #endif
 
-            HPX_TEST(get_pointer(px) == px.get());
+            HPX_TEST_EQ(get_pointer(px), px.get());
         }
 
         {
-            hpx::intrusive_ptr<X> px(0);
+            hpx::intrusive_ptr<X> px(nullptr);
             HPX_TEST(px ? false : true);
             HPX_TEST(!px);
 
@@ -671,43 +671,43 @@ namespace n_access {
             using boost::get_pointer;
 #endif
 
-            HPX_TEST(get_pointer(px) == px.get());
+            HPX_TEST_EQ(get_pointer(px), px.get());
         }
 
         {
             hpx::intrusive_ptr<X> px(new X);
             HPX_TEST(px ? true : false);
             HPX_TEST(!!px);
-            HPX_TEST(&*px == px.get());
-            HPX_TEST(px.operator->() == px.get());
+            HPX_TEST_EQ(&*px, px.get());
+            HPX_TEST_EQ(px.operator->(), px.get());
 
 #if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP)
             using boost::get_pointer;
 #endif
 
-            HPX_TEST(get_pointer(px) == px.get());
+            HPX_TEST_EQ(get_pointer(px), px.get());
         }
 
         {
             hpx::intrusive_ptr<X> px;
             X* detached = px.detach();
             HPX_TEST(px.get() == nullptr);
-            HPX_TEST(detached == 0);
+            HPX_TEST(detached == nullptr);
         }
 
         {
             X* p = new X;
-            HPX_TEST(p->use_count() == 0);
+            HPX_TEST_EQ(p->use_count(), 0);
 
             hpx::intrusive_ptr<X> px(p);
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 1);
 
             X* detached = px.detach();
             HPX_TEST(px.get() == nullptr);
 
-            HPX_TEST(detached == p);
-            HPX_TEST(detached->use_count() == 1);
+            HPX_TEST_EQ(detached, p);
+            HPX_TEST_EQ(detached->use_count(), 1);
 
             delete detached;
         }
@@ -743,20 +743,20 @@ namespace n_swap {
 
             px.swap(px2);
 
-            HPX_TEST(px.get() == p);
-            HPX_TEST(px->use_count() == 2);
+            HPX_TEST_EQ(px.get(), p);
+            HPX_TEST_EQ(px->use_count(), 2);
             HPX_TEST(px2.get() == nullptr);
-            HPX_TEST(px3.get() == p);
-            HPX_TEST(px3->use_count() == 2);
+            HPX_TEST_EQ(px3.get(), p);
+            HPX_TEST_EQ(px3->use_count(), 2);
 
             using std::swap;
             swap(px, px2);
 
             HPX_TEST(px.get() == nullptr);
-            HPX_TEST(px2.get() == p);
-            HPX_TEST(px2->use_count() == 2);
-            HPX_TEST(px3.get() == p);
-            HPX_TEST(px3->use_count() == 2);
+            HPX_TEST_EQ(px2.get(), p);
+            HPX_TEST_EQ(px2->use_count(), 2);
+            HPX_TEST_EQ(px3.get(), p);
+            HPX_TEST_EQ(px3->use_count(), 2);
         }
 
         {
@@ -768,22 +768,22 @@ namespace n_swap {
 
             px.swap(px2);
 
-            HPX_TEST(px.get() == p2);
-            HPX_TEST(px->use_count() == 2);
-            HPX_TEST(px2.get() == p1);
-            HPX_TEST(px2->use_count() == 1);
-            HPX_TEST(px3.get() == p2);
-            HPX_TEST(px3->use_count() == 2);
+            HPX_TEST_EQ(px.get(), p2);
+            HPX_TEST_EQ(px->use_count(), 2);
+            HPX_TEST_EQ(px2.get(), p1);
+            HPX_TEST_EQ(px2->use_count(), 1);
+            HPX_TEST_EQ(px3.get(), p2);
+            HPX_TEST_EQ(px3->use_count(), 2);
 
             using std::swap;
             swap(px, px2);
 
-            HPX_TEST(px.get() == p1);
-            HPX_TEST(px->use_count() == 1);
-            HPX_TEST(px2.get() == p2);
-            HPX_TEST(px2->use_count() == 2);
-            HPX_TEST(px3.get() == p2);
-            HPX_TEST(px3->use_count() == 2);
+            HPX_TEST_EQ(px.get(), p1);
+            HPX_TEST_EQ(px->use_count(), 1);
+            HPX_TEST_EQ(px2.get(), p2);
+            HPX_TEST_EQ(px2->use_count(), 2);
+            HPX_TEST_EQ(px3.get(), p2);
+            HPX_TEST_EQ(px3->use_count(), 2);
         }
     }
 
@@ -865,24 +865,24 @@ namespace n_static_cast {
             hpx::intrusive_ptr<X> px(new Y);
 
             hpx::intrusive_ptr<Y> py = hpx::static_pointer_cast<Y>(px);
-            HPX_TEST(px.get() == py.get());
-            HPX_TEST(px->use_count() == 2);
-            HPX_TEST(py->use_count() == 2);
+            HPX_TEST_EQ(px.get(), py.get());
+            HPX_TEST_EQ(px->use_count(), 2);
+            HPX_TEST_EQ(py->use_count(), 2);
 
             hpx::intrusive_ptr<X> px2(py);
-            HPX_TEST(px2.get() == px.get());
+            HPX_TEST_EQ(px2.get(), px.get());
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<Y> py =
                 hpx::static_pointer_cast<Y>(hpx::intrusive_ptr<X>(new Y));
-            HPX_TEST(py.get() != 0);
-            HPX_TEST(py->use_count() == 1);
+            HPX_TEST(py.get() != nullptr);
+            HPX_TEST_EQ(py->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
 }    // namespace n_static_cast
@@ -904,27 +904,27 @@ namespace n_const_cast {
             HPX_TEST(px2.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X const> px(new X);
 
             hpx::intrusive_ptr<X> px2 = hpx::const_pointer_cast<X>(px);
-            HPX_TEST(px2.get() == px.get());
-            HPX_TEST(px2->use_count() == 2);
-            HPX_TEST(px->use_count() == 2);
+            HPX_TEST_EQ(px2.get(), px.get());
+            HPX_TEST_EQ(px2->use_count(), 2);
+            HPX_TEST_EQ(px->use_count(), 2);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px =
                 hpx::const_pointer_cast<X>(hpx::intrusive_ptr<X const>(new X));
-            HPX_TEST(px.get() != 0);
-            HPX_TEST(px->use_count() == 1);
+            HPX_TEST(px.get() != nullptr);
+            HPX_TEST_EQ(px->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
 }    // namespace n_const_cast
@@ -947,7 +947,7 @@ namespace n_dynamic_cast {
         }
 
         {
-            hpx::intrusive_ptr<X> px(static_cast<X*>(0));
+            hpx::intrusive_ptr<X> px(static_cast<X*>(nullptr));
 
             hpx::intrusive_ptr<Y> py = hpx::dynamic_pointer_cast<Y>(px);
             HPX_TEST(py.get() == nullptr);
@@ -955,7 +955,7 @@ namespace n_dynamic_cast {
 
         {
             hpx::intrusive_ptr<Y> py = hpx::dynamic_pointer_cast<Y>(
-                hpx::intrusive_ptr<X>(static_cast<X*>(0)));
+                hpx::intrusive_ptr<X>(static_cast<X*>(nullptr)));
             HPX_TEST(py.get() == nullptr);
         }
 
@@ -966,7 +966,7 @@ namespace n_dynamic_cast {
             HPX_TEST(py.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<Y> py =
@@ -974,29 +974,29 @@ namespace n_dynamic_cast {
             HPX_TEST(py.get() == nullptr);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new Y);
 
             hpx::intrusive_ptr<Y> py = hpx::dynamic_pointer_cast<Y>(px);
-            HPX_TEST(py.get() == px.get());
-            HPX_TEST(py->use_count() == 2);
-            HPX_TEST(px->use_count() == 2);
+            HPX_TEST_EQ(py.get(), px.get());
+            HPX_TEST_EQ(py->use_count(), 2);
+            HPX_TEST_EQ(px->use_count(), 2);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
 
         {
             hpx::intrusive_ptr<X> px(new Y);
 
             hpx::intrusive_ptr<Y> py =
                 hpx::dynamic_pointer_cast<Y>(hpx::intrusive_ptr<X>(new Y));
-            HPX_TEST(py.get() != 0);
-            HPX_TEST(py->use_count() == 1);
+            HPX_TEST(py.get() != nullptr);
+            HPX_TEST_EQ(py->use_count(), 1);
         }
 
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
 }    // namespace n_dynamic_cast
diff --git a/libs/memory/tests/unit/intrusive_ptr_move.cpp b/libs/memory/tests/unit/intrusive_ptr_move.cpp
index 5581b32fa5..c6d3aa61f2 100644
--- a/libs/memory/tests/unit/intrusive_ptr_move.cpp
+++ b/libs/memory/tests/unit/intrusive_ptr_move.cpp
@@ -89,84 +89,90 @@ struct Y : public X
 
 int main()
 {
-    HPX_TEST(N::base::instances == 0);
+    HPX_TEST_EQ(N::base::instances, 0);
 
     {
         hpx::intrusive_ptr<X> p(new X);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
 
         hpx::intrusive_ptr<X> p2(std::move(p));
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(p.get() == nullptr);
 
         p2.reset();
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     {
         hpx::intrusive_ptr<Y> p(new Y);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
 
         hpx::intrusive_ptr<X> p2(std::move(p));
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(p.get() == nullptr);
 
         p2.reset();
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     {
         hpx::intrusive_ptr<X> p(new X);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
 
         hpx::intrusive_ptr<X> p2;
         p2 = std::move(p);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(p.get() == nullptr);
 
         p2.reset();
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     {
         hpx::intrusive_ptr<X> p(new X);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
 
         hpx::intrusive_ptr<X> p2(new X);
-        HPX_TEST(N::base::instances == 2);
+        HPX_TEST_EQ(N::base::instances, 2);
         p2 = std::move(p);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(p.get() == nullptr);
 
         p2.reset();
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     {
         hpx::intrusive_ptr<Y> p(new Y);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
 
         hpx::intrusive_ptr<X> p2;
         p2 = std::move(p);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(p.get() == nullptr);
 
         p2.reset();
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     {
         hpx::intrusive_ptr<Y> p(new Y);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
 
         hpx::intrusive_ptr<X> p2(new X);
-        HPX_TEST(N::base::instances == 2);
+        HPX_TEST_EQ(N::base::instances, 2);
         p2 = std::move(p);
-        HPX_TEST(N::base::instances == 1);
+        HPX_TEST_EQ(N::base::instances, 1);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(p.get() == nullptr);
 
         p2.reset();
-        HPX_TEST(N::base::instances == 0);
+        HPX_TEST_EQ(N::base::instances, 0);
     }
 
     {
@@ -175,12 +181,13 @@ int main()
         X* px2 = px.get();
 
         hpx::intrusive_ptr<Y> py = hpx::static_pointer_cast<Y>(std::move(px));
-        HPX_TEST(py.get() == px2);
+        HPX_TEST_EQ(py.get(), px2);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(px.get() == nullptr);
-        HPX_TEST(py->use_count() == 1);
+        HPX_TEST_EQ(py->use_count(), 1);
     }
 
-    HPX_TEST(N::base::instances == 0);
+    HPX_TEST_EQ(N::base::instances, 0);
 
     {
         hpx::intrusive_ptr<X const> px(new X);
@@ -188,12 +195,13 @@ int main()
         X const* px2 = px.get();
 
         hpx::intrusive_ptr<X> px3 = hpx::const_pointer_cast<X>(std::move(px));
-        HPX_TEST(px3.get() == px2);
+        HPX_TEST_EQ(px3.get(), px2);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(px.get() == nullptr);
-        HPX_TEST(px3->use_count() == 1);
+        HPX_TEST_EQ(px3->use_count(), 1);
     }
 
-    HPX_TEST(N::base::instances == 0);
+    HPX_TEST_EQ(N::base::instances, 0);
 
     {
         hpx::intrusive_ptr<X> px(new Y);
@@ -201,12 +209,13 @@ int main()
         X* px2 = px.get();
 
         hpx::intrusive_ptr<Y> py = hpx::dynamic_pointer_cast<Y>(std::move(px));
-        HPX_TEST(py.get() == px2);
+        HPX_TEST_EQ(py.get(), px2);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
         HPX_TEST(px.get() == nullptr);
-        HPX_TEST(py->use_count() == 1);
+        HPX_TEST_EQ(py->use_count(), 1);
     }
 
-    HPX_TEST(N::base::instances == 0);
+    HPX_TEST_EQ(N::base::instances, 0);
 
     {
         hpx::intrusive_ptr<X> px(new X);
@@ -215,11 +224,12 @@ int main()
 
         hpx::intrusive_ptr<Y> py = hpx::dynamic_pointer_cast<Y>(std::move(px));
         HPX_TEST(py.get() == nullptr);
-        HPX_TEST(px.get() == px2);
-        HPX_TEST(px->use_count() == 1);
+        // NOLINTNEXTLINE(bugprone-use-after-move)
+        HPX_TEST_EQ(px.get(), px2);
+        HPX_TEST_EQ(px->use_count(), 1);
     }
 
-    HPX_TEST(N::base::instances == 0);
+    HPX_TEST_EQ(N::base::instances, 0);
 
     return hpx::util::report_errors();
 }
diff --git a/libs/memory/tests/unit/ip_convertible.cpp b/libs/memory/tests/unit/ip_convertible.cpp
index e55444bed9..2c1b67ac22 100644
--- a/libs/memory/tests/unit/ip_convertible.cpp
+++ b/libs/memory/tests/unit/ip_convertible.cpp
@@ -44,6 +44,6 @@ int f(hpx::intrusive_ptr<Y>)
 
 int main()
 {
-    HPX_TEST(1 == f(hpx::intrusive_ptr<Z>()));
+    HPX_TEST_EQ(1, f(hpx::intrusive_ptr<Z>()));
     return hpx::util::report_errors();
 }
diff --git a/libs/naming_base/CMakeLists.txt b/libs/naming_base/CMakeLists.txt
new file mode 100644
index 0000000000..f35c02e590
--- /dev/null
+++ b/libs/naming_base/CMakeLists.txt
@@ -0,0 +1,29 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+# Default location is $HPX_ROOT/libs/naming_base/include
+set(naming_base_headers
+  hpx/naming_base.hpp
+  )
+
+# Default location is $HPX_ROOT/libs/naming_base/include_compatibility
+set(naming_base_compat_headers)
+
+set(naming_base_sources)
+
+include(HPX_AddModule)
+add_hpx_module(naming_base
+  COMPATIBILITY_HEADERS OFF
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN OFF
+  HEADERS ${naming_base_headers}
+  DEPENDENCIES
+    hpx_config
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/naming_base/README.rst b/libs/naming_base/README.rst
new file mode 100644
index 0000000000..7de3ad3a50
--- /dev/null
+++ b/libs/naming_base/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+===========
+naming_base
+===========
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/naming_base/docs/index.html>`__.
diff --git a/libs/naming_base/docs/index.rst b/libs/naming_base/docs/index.rst
new file mode 100644
index 0000000000..2a220472fe
--- /dev/null
+++ b/libs/naming_base/docs/index.rst
@@ -0,0 +1,19 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_naming_base:
+
+===========
+naming_base
+===========
+
+This module provides a forward declaration of `address_type`, `component_type`
+and `invalid_locality_id`.
+
+See the :ref:`API reference <libs_naming_base_api>` of this module for more
+details.
+
diff --git a/libs/naming_base/examples/CMakeLists.txt b/libs/naming_base/examples/CMakeLists.txt
new file mode 100644
index 0000000000..c84182683d
--- /dev/null
+++ b/libs/naming_base/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.naming_base)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.naming_base)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_NAMING_BASE_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.naming_base)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.naming_base)
+  endif()
+endif()
diff --git a/libs/naming_base/include/hpx/naming_base.hpp b/libs/naming_base/include/hpx/naming_base.hpp
new file mode 100644
index 0000000000..8649aba7c1
--- /dev/null
+++ b/libs/naming_base/include/hpx/naming_base.hpp
@@ -0,0 +1,25 @@
+//  Copyright (c) 2007-2016 Hartmut Kaiser
+//  Copyright (c) 2011      Bryce Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_RUNTIME_NAMING_TYPES_FWD_HPP
+#define HPX_RUNTIME_NAMING_TYPES_FWD_HPP
+
+#include <hpx/config.hpp>
+
+#include <cstdint>
+
+namespace hpx { namespace naming {
+
+    using component_type = std::int32_t;
+    using address_type = std::uint64_t;
+
+    constexpr std::uint32_t invalid_locality_id =
+        ~static_cast<std::uint32_t>(0);
+
+}}    // namespace hpx::naming
+
+#endif
diff --git a/libs/naming_base/tests/CMakeLists.txt b/libs/naming_base/tests/CMakeLists.txt
new file mode 100644
index 0000000000..ef7c878db9
--- /dev/null
+++ b/libs/naming_base/tests/CMakeLists.txt
@@ -0,0 +1,42 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_NAMING_BASE_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_NAMING_BASE_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.naming_base)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.naming_base)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.naming_base)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.naming_base)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.naming_base)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.naming_base)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.naming_base
+        HEADERS ${naming_base_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        NOLIBS
+        DEPENDENCIES hpx_naming_base)
+    endif()
+endif()
diff --git a/libs/naming_base/tests/performance/CMakeLists.txt b/libs/naming_base/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/naming_base/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/naming_base/tests/regressions/CMakeLists.txt b/libs/naming_base/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/naming_base/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/naming_base/tests/unit/CMakeLists.txt b/libs/naming_base/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/naming_base/tests/unit/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/performance_counters/CMakeLists.txt b/libs/performance_counters/CMakeLists.txt
new file mode 100644
index 0000000000..103efd6c48
--- /dev/null
+++ b/libs/performance_counters/CMakeLists.txt
@@ -0,0 +1,79 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(performance_counters_headers
+  hpx/performance_counters/base_performance_counter.hpp
+  hpx/performance_counters/counter_creators.hpp
+  hpx/performance_counters/counter_parser.hpp
+  hpx/performance_counters/counters.hpp
+  hpx/performance_counters/counters_fwd.hpp
+  hpx/performance_counters/manage_counter.hpp
+  hpx/performance_counters/manage_counter_type.hpp
+  hpx/performance_counters/performance_counter.hpp
+  hpx/performance_counters/performance_counter_base.hpp
+  hpx/performance_counters/performance_counter_set.hpp
+  hpx/performance_counters/registry.hpp
+  hpx/performance_counters/parcels/data_point.hpp
+  hpx/performance_counters/parcels/gatherer.hpp
+  hpx/performance_counters/server/arithmetics_counter.hpp
+  hpx/performance_counters/server/arithmetics_counter_extended.hpp
+  hpx/performance_counters/server/base_performance_counter.hpp
+  hpx/performance_counters/server/elapsed_time_counter.hpp
+  hpx/performance_counters/server/raw_counter.hpp
+  hpx/performance_counters/server/raw_values_counter.hpp
+  hpx/performance_counters/server/statistics_counter.hpp
+  hpx/performance_counters/stubs/performance_counter.hpp
+)
+
+set(performance_counters_sources
+  counter_creators.cpp
+  counter_parser.cpp
+  counters.cpp
+  manage_counter.cpp
+  manage_counter_type.cpp
+  registry.cpp
+  performance_counter.cpp
+  performance_counter_set.cpp
+  server/component_instance_counter.cpp
+  server/arithmetics_counter_extended.cpp
+  server/raw_values_counter.cpp
+  server/raw_counter.cpp
+  server/per_action_data_counters.cpp
+  server/elapsed_time_counter.cpp
+  server/action_invocation_counter.cpp
+  server/arithmetics_counter.cpp
+  server/statistics_counter.cpp
+  stubs/performance_counter_stub.cpp
+)
+
+include(HPX_AddModule)
+add_hpx_module(performance_counters
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${performance_counters_sources}
+  HEADERS ${performance_counters_headers}
+  DEPENDENCIES
+    hpx_assertion
+    hpx_config
+    hpx_errors
+    hpx_execution
+    hpx_format
+    hpx_functional
+    hpx_logging
+    hpx_serialization
+    hpx_synchronization
+    hpx_static_reinit
+    hpx_statistics
+    hpx_threading
+    hpx_threading_base
+    hpx_thread_support
+    hpx_timing
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/performance_counters/README.rst b/libs/performance_counters/README.rst
new file mode 100644
index 0000000000..a0321bde14
--- /dev/null
+++ b/libs/performance_counters/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+====================
+performance_counters
+====================
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/performance_counters/docs/index.html>`__.
diff --git a/libs/performance_counters/docs/index.rst b/libs/performance_counters/docs/index.rst
new file mode 100644
index 0000000000..fcac1a0d46
--- /dev/null
+++ b/libs/performance_counters/docs/index.rst
@@ -0,0 +1,18 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_performance_counters:
+
+====================
+performance_counters
+====================
+
+TODO: High-level description of the library.
+
+See the :ref:`API reference <libs_performance_counters_api>` of this module for more
+details.
+
diff --git a/libs/performance_counters/examples/CMakeLists.txt b/libs/performance_counters/examples/CMakeLists.txt
new file mode 100644
index 0000000000..84d1202030
--- /dev/null
+++ b/libs/performance_counters/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.performance_counters)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.performance_counters)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_PERFORMANCE_COUNTERS_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.performance_counters)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.performance_counters)
+  endif()
+endif()
diff --git a/hpx/performance_counters/base_performance_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/base_performance_counter.hpp
similarity index 72%
rename from hpx/performance_counters/base_performance_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/base_performance_counter.hpp
index 09e530b812..354ca4c958 100644
--- a/hpx/performance_counters/base_performance_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/base_performance_counter.hpp
@@ -4,7 +4,8 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_PERFORMANCE_COUNTERS_BASE_PERFORMANCE_COUNTER_JAN_18_2013_1036AM)
+#if !defined(                                                                  \
+    HPX_PERFORMANCE_COUNTERS_BASE_PERFORMANCE_COUNTER_JAN_18_2013_1036AM)
 #define HPX_PERFORMANCE_COUNTERS_BASE_PERFORMANCE_COUNTER_JAN_18_2013_1036AM
 
 #include <hpx/config.hpp>
@@ -16,20 +17,18 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 //[performance_counter_base_class
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     template <typename Derived>
     class base_performance_counter;
-}}
+}}    // namespace hpx::performance_counters
 //]
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     template <typename Derived>
     class base_performance_counter
-      : public hpx::performance_counters::server::base_performance_counter,
-        public hpx::components::component_base<Derived>
+      : public hpx::performance_counters::server::base_performance_counter
+      , public hpx::components::component_base<Derived>
     {
     private:
         typedef hpx::components::component_base<Derived> base_type;
@@ -39,12 +38,13 @@ namespace hpx { namespace performance_counters
         typedef hpx::performance_counters::server::base_performance_counter
             base_type_holder;
 
-        base_performance_counter()
-        {}
+        base_performance_counter() {}
 
-        base_performance_counter(hpx::performance_counters::counter_info const& info)
+        base_performance_counter(
+            hpx::performance_counters::counter_info const& info)
           : base_type_holder(info)
-        {}
+        {
+        }
 
         // Disambiguate finalize() which is implemented in both base classes
         void finalize()
@@ -53,6 +53,6 @@ namespace hpx { namespace performance_counters
             base_type::finalize();
         }
     };
-}}
+}}    // namespace hpx::performance_counters
 
 #endif
diff --git a/hpx/performance_counters/counter_creators.hpp b/libs/performance_counters/include/hpx/performance_counters/counter_creators.hpp
similarity index 94%
rename from hpx/performance_counters/counter_creators.hpp
rename to libs/performance_counters/include/hpx/performance_counters/counter_creators.hpp
index 1f274021be..83efb8bcfe 100644
--- a/hpx/performance_counters/counter_creators.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/counter_creators.hpp
@@ -9,16 +9,15 @@
 
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/performance_counters/counters_fwd.hpp>
 #include <hpx/functional/function.hpp>
+#include <hpx/performance_counters/counters_fwd.hpp>
 
 #include <cstdint>
 #include <string>
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     // Discoverer functions to be registered with counter types
 
@@ -71,8 +70,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>{locality#<locality_id>/pool#<poolname>/thread#<threadnum>}/<instancename>
     ///
     bool locality_pool_thread_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec);
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec);
 
     /// Default discoverer function for performance counters; to be registered
     /// with the counter types. It is suitable to be used for all counters
@@ -103,8 +102,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>(locality#<locality_id>/total)/<instancename>
     ///
     HPX_API_EXPORT naming::gid_type locality_raw_counter_creator(
-        counter_info const&, hpx::util::function_nonser<std::int64_t(bool)> const&,
-        error_code&);
+        counter_info const&,
+        hpx::util::function_nonser<std::int64_t(bool)> const&, error_code&);
 
     HPX_API_EXPORT naming::gid_type locality_raw_values_counter_creator(
         counter_info const&,
@@ -154,9 +153,8 @@ namespace hpx { namespace performance_counters
     // Creation function for per-action parcel data counters
     HPX_API_EXPORT naming::gid_type per_action_data_counter_creator(
         counter_info const& info,
-        hpx::util::function_nonser<
-            std::int64_t(std::string const&, bool)
-        > const& f,
+        hpx::util::function_nonser<std::int64_t(
+            std::string const&, bool)> const& f,
         error_code& ec);
 
     // Discoverer function for per-action parcel data counters
@@ -165,7 +163,6 @@ namespace hpx { namespace performance_counters
         discover_counters_mode mode, error_code& ec);
 #endif
 #endif
-}}
+}}    // namespace hpx::performance_counters
 
 #endif
-
diff --git a/hpx/performance_counters/counter_parser.hpp b/libs/performance_counters/include/hpx/performance_counters/counter_parser.hpp
similarity index 91%
rename from hpx/performance_counters/counter_parser.hpp
rename to libs/performance_counters/include/hpx/performance_counters/counter_parser.hpp
index 3553d273f6..b9a9adbade 100644
--- a/hpx/performance_counters/counter_parser.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/counter_parser.hpp
@@ -12,8 +12,7 @@
 #include <string>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     struct instance_name
     {
         std::string name_;
@@ -38,6 +37,6 @@ namespace hpx { namespace performance_counters
 
     HPX_API_EXPORT bool parse_counter_name(
         std::string const& name, path_elements& elements);
-}}
+}}    // namespace hpx::performance_counters
 
 #endif /*HPX_PERFORMANCE_COUNTERS_PARSER_HPP*/
diff --git a/hpx/performance_counters/counters.hpp b/libs/performance_counters/include/hpx/performance_counters/counters.hpp
similarity index 70%
rename from hpx/performance_counters/counters.hpp
rename to libs/performance_counters/include/hpx/performance_counters/counters.hpp
index 2e53ce4e9e..b8b8e95477 100644
--- a/hpx/performance_counters/counters.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/counters.hpp
@@ -8,12 +8,12 @@
 #define HPX_PERFORMANCE_COUNTERS_MAR_01_2009_0134PM
 
 #include <hpx/config.hpp>
-#include <hpx/performance_counters/counters_fwd.hpp>
+#include <hpx/errors.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/lcos/future.hpp>
+#include <hpx/performance_counters/counters_fwd.hpp>
 #include <hpx/runtime/naming/name.hpp>
 #include <hpx/serialization/serialization_fwd.hpp>
-#include <hpx/errors.hpp>
-#include <hpx/functional/function.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -22,8 +22,7 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     constexpr char const counter_prefix[] = "/counters";
     constexpr std::size_t counter_prefix_len =
@@ -37,7 +36,8 @@ namespace hpx { namespace performance_counters
         return name;
     }
 
-    inline std::string ensure_counter_prefix(std::string const& counter) //-V659
+    inline std::string ensure_counter_prefix(
+        std::string const& counter)    //-V659
     {
         std::string name(counter);
         return ensure_counter_prefix(name);
@@ -50,7 +50,8 @@ namespace hpx { namespace performance_counters
         return name;
     }
 
-    inline std::string remove_counter_prefix(std::string const& counter) //-V659
+    inline std::string remove_counter_prefix(
+        std::string const& counter)    //-V659
     {
         std::string name(counter);
         return remove_counter_prefix(name);
@@ -179,10 +180,10 @@ namespace hpx { namespace performance_counters
         status_valid_data,      ///< No error occurred, data is valid
         status_new_data,        ///< Data is valid and different from last call
         status_invalid_data,    ///< Some error occurred, data is not value
-        status_already_defined, ///< The type or instance already has been defined
-        status_counter_unknown, ///< The counter instance is unknown
-        status_counter_type_unknown,  ///< The counter type is unknown
-        status_generic_error    ///< A unknown error occurred
+        status_already_defined,    ///< The type or instance already has been defined
+        status_counter_unknown,         ///< The counter instance is unknown
+        status_counter_type_unknown,    ///< The counter type is unknown
+        status_generic_error            ///< A unknown error occurred
     };
 #endif
 
@@ -203,20 +204,20 @@ namespace hpx { namespace performance_counters
     ///
     struct counter_type_path_elements
     {
-        counter_type_path_elements()
-        {}
+        counter_type_path_elements() {}
 
         counter_type_path_elements(std::string const& objectname,
-                std::string const& countername, std::string const& parameters)
-          : objectname_(objectname),
-            countername_(countername),
-            parameters_(parameters)
-        {}
-
-        std::string objectname_;          ///< the name of the performance object
-        std::string countername_;         ///< contains the counter name
-        std::string parameters_;          ///< optional parameters for the
-                                          ///< counter instance
+            std::string const& countername, std::string const& parameters)
+          : objectname_(objectname)
+          , countername_(countername)
+          , parameters_(parameters)
+        {
+        }
+
+        std::string objectname_;     ///< the name of the performance object
+        std::string countername_;    ///< contains the counter name
+        std::string parameters_;     ///< optional parameters for the
+                                     ///< counter instance
 
     protected:
         // serialization support
@@ -248,44 +249,51 @@ namespace hpx { namespace performance_counters
           , instanceindex_(-1)
           , subinstanceindex_(-1)
           , parentinstance_is_basename_(false)
-        {}
+        {
+        }
 
         counter_path_elements(std::string const& objectname,
-                std::string const& countername, std::string const& parameters,
-                std::string const& parentname, std::string const& instancename,
-                std::int64_t parentindex = -1, std::int64_t instanceindex = -1,
-                bool parentinstance_is_basename = false)
-          : counter_type_path_elements(objectname, countername, parameters),
-            parentinstancename_(parentname), instancename_(instancename),
-            subinstancename_(),
-            parentinstanceindex_(parentindex), instanceindex_(instanceindex),
-            subinstanceindex_(-1),
-            parentinstance_is_basename_(parentinstance_is_basename)
-        {}
+            std::string const& countername, std::string const& parameters,
+            std::string const& parentname, std::string const& instancename,
+            std::int64_t parentindex = -1, std::int64_t instanceindex = -1,
+            bool parentinstance_is_basename = false)
+          : counter_type_path_elements(objectname, countername, parameters)
+          , parentinstancename_(parentname)
+          , instancename_(instancename)
+          , subinstancename_()
+          , parentinstanceindex_(parentindex)
+          , instanceindex_(instanceindex)
+          , subinstanceindex_(-1)
+          , parentinstance_is_basename_(parentinstance_is_basename)
+        {
+        }
 
         counter_path_elements(std::string const& objectname,
-                std::string const& countername, std::string const& parameters,
-                std::string const& parentname, std::string const& instancename,
-                std::string const& subinstancename,
-                std::int64_t parentindex = -1, std::int64_t instanceindex = -1,
-                std::int64_t subinstanceindex = -1,
-                bool parentinstance_is_basename = false)
-          : counter_type_path_elements(objectname, countername, parameters),
-            parentinstancename_(parentname), instancename_(instancename),
-            subinstancename_(subinstancename),
-            parentinstanceindex_(parentindex), instanceindex_(instanceindex),
-            subinstanceindex_(subinstanceindex),
-            parentinstance_is_basename_(parentinstance_is_basename)
-        {}
-
-        std::string parentinstancename_;  ///< the name of the parent instance
-        std::string instancename_;        ///< the name of the object instance
-        std::string subinstancename_;     ///< the name of the object sub-instance
+            std::string const& countername, std::string const& parameters,
+            std::string const& parentname, std::string const& instancename,
+            std::string const& subinstancename, std::int64_t parentindex = -1,
+            std::int64_t instanceindex = -1, std::int64_t subinstanceindex = -1,
+            bool parentinstance_is_basename = false)
+          : counter_type_path_elements(objectname, countername, parameters)
+          , parentinstancename_(parentname)
+          , instancename_(instancename)
+          , subinstancename_(subinstancename)
+          , parentinstanceindex_(parentindex)
+          , instanceindex_(instanceindex)
+          , subinstanceindex_(subinstanceindex)
+          , parentinstance_is_basename_(parentinstance_is_basename)
+        {
+        }
+
+        std::string parentinstancename_;    ///< the name of the parent instance
+        std::string instancename_;          ///< the name of the object instance
+        std::string
+            subinstancename_;    ///< the name of the object sub-instance
         std::int64_t parentinstanceindex_;    ///< the parent instance index
-        std::int64_t instanceindex_;    ///< the instance index
-        std::int64_t subinstanceindex_;    ///< the sub-instance index
-        bool parentinstance_is_basename_; ///< the parentinstancename_
-                                          ///member holds a base counter name
+        std::int64_t instanceindex_;          ///< the instance index
+        std::int64_t subinstanceindex_;       ///< the sub-instance index
+        bool parentinstance_is_basename_;     ///< the parentinstancename_
+            ///member holds a base counter name
 
     private:
         // serialization support
@@ -301,30 +309,42 @@ namespace hpx { namespace performance_counters
     struct counter_info
     {
         counter_info(counter_type type = counter_raw)
-          : type_(type), version_(HPX_PERFORMANCE_COUNTER_V1),
-            status_(status_invalid_data)
-        {}
+          : type_(type)
+          , version_(HPX_PERFORMANCE_COUNTER_V1)
+          , status_(status_invalid_data)
+        {
+        }
 
         counter_info(std::string const& name)
-          : type_(counter_raw), version_(HPX_PERFORMANCE_COUNTER_V1),
-            status_(status_invalid_data), fullname_(name)
-        {}
+          : type_(counter_raw)
+          , version_(HPX_PERFORMANCE_COUNTER_V1)
+          , status_(status_invalid_data)
+          , fullname_(name)
+        {
+        }
 
         counter_info(counter_type type, std::string const& name,
-                std::string const& helptext = "",
-                std::uint32_t version = HPX_PERFORMANCE_COUNTER_V1,
-                std::string const& uom = "")
-          : type_(type), version_(version), status_(status_invalid_data),
-            fullname_(name), helptext_(helptext), unit_of_measure_(uom)
-        {}
-
-        counter_type type_;         ///< The type of the described counter
-        std::uint32_t version_;     ///< The version of the described counter
-                                    ///< using the 0xMMmmSSSS scheme
-        counter_status status_;     ///< The status of the counter object
-        std::string fullname_;      ///< The full name of this counter
-        std::string helptext_;      ///< The full descriptive text for this counter
-        std::string unit_of_measure_; ///< The unit of measure for this counter
+            std::string const& helptext = "",
+            std::uint32_t version = HPX_PERFORMANCE_COUNTER_V1,
+            std::string const& uom = "")
+          : type_(type)
+          , version_(version)
+          , status_(status_invalid_data)
+          , fullname_(name)
+          , helptext_(helptext)
+          , unit_of_measure_(uom)
+        {
+        }
+
+        counter_type type_;        ///< The type of the described counter
+        std::uint32_t version_;    ///< The version of the described counter
+                                   ///< using the 0xMMmmSSSS scheme
+        counter_status status_;    ///< The status of the counter object
+        std::string fullname_;     ///< The full name of this counter
+        std::string
+            helptext_;    ///< The full descriptive text for this counter
+        std::string
+            unit_of_measure_;    ///< The unit of measure for this counter
 
     private:
         // serialization support
@@ -340,52 +360,49 @@ namespace hpx { namespace performance_counters
     /// \brief This declares the type of a function, which will be
     ///        called by HPX whenever a new performance counter instance of a
     ///        particular type needs to be created.
-    typedef hpx::util::function_nonser<
-        naming::gid_type(counter_info const&, error_code&)>
+    typedef hpx::util::function_nonser<naming::gid_type(
+        counter_info const&, error_code&)>
         create_counter_func;
 
     ///////////////////////////////////////////////////////////////////////////
     /// \brief This declares a type of a function, which will be passed to
     ///        a \a discover_counters_func in order to be called for each
     ///        discovered performance counter instance.
-    typedef hpx::util::function_nonser<
-        bool(counter_info const&, error_code&)>
+    typedef hpx::util::function_nonser<bool(counter_info const&, error_code&)>
         discover_counter_func;
 
     /// \brief This declares the type of a function, which will be called by
     ///        HPX whenever it needs to discover all performance counter
     ///        instances of a particular type.
-    typedef hpx::util::function_nonser<
-        bool(counter_info const&, discover_counter_func const&,
-            discover_counters_mode, error_code&)>
+    typedef hpx::util::function_nonser<bool(counter_info const&,
+        discover_counter_func const&, discover_counters_mode, error_code&)>
         discover_counters_func;
 
     ///////////////////////////////////////////////////////////////////////
-    inline counter_status add_counter_type(counter_info const& info,
-        error_code& ec)
+    inline counter_status add_counter_type(
+        counter_info const& info, error_code& ec)
     {
-        return add_counter_type(info, create_counter_func(),
-            discover_counters_func(), ec);
+        return add_counter_type(
+            info, create_counter_func(), discover_counters_func(), ec);
     }
 
-    inline naming::id_type get_counter(std::string const& name,
-        error_code& ec)
+    inline naming::id_type get_counter(std::string const& name, error_code& ec)
     {
         lcos::future<naming::id_type> f = get_counter_async(name, ec);
-        if (ec) return naming::invalid_id;
+        if (ec)
+            return naming::invalid_id;
 
         return f.get(ec);
     }
 
-    inline naming::id_type get_counter(counter_info const& info,
-        error_code& ec)
+    inline naming::id_type get_counter(counter_info const& info, error_code& ec)
     {
         lcos::future<naming::id_type> f = get_counter_async(info, ec);
-        if (ec) return naming::invalid_id;
+        if (ec)
+            return naming::invalid_id;
 
         return f.get(ec);
     }
-}}
+}}    // namespace hpx::performance_counters
 
 #endif
-
diff --git a/libs/performance_counters/include/hpx/performance_counters/counters_fwd.hpp b/libs/performance_counters/include/hpx/performance_counters/counters_fwd.hpp
new file mode 100644
index 0000000000..5aadd35260
--- /dev/null
+++ b/libs/performance_counters/include/hpx/performance_counters/counters_fwd.hpp
@@ -0,0 +1,624 @@
+//  Copyright (c) 2017 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#if !defined(HPX_PERFORMANCE_COUNTERS_FWD_NOV_26_2017_0107PM)
+#define HPX_PERFORMANCE_COUNTERS_FWD_NOV_26_2017_0107PM
+
+#include <hpx/config.hpp>
+#include <hpx/errors.hpp>
+#include <hpx/functional/function.hpp>
+#include <hpx/lcos_fwd.hpp>
+#include <hpx/runtime/naming/name.hpp>
+#include <hpx/serialization/serialization_fwd.hpp>
+
+#include <cstddef>
+#include <cstdint>
+#include <string>
+#include <utility>
+#include <vector>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace hpx { namespace performance_counters {
+    ///////////////////////////////////////////////////////////////////////////
+    inline std::string& ensure_counter_prefix(std::string& name);
+    inline std::string ensure_counter_prefix(std::string const& counter);
+    inline std::string& remove_counter_prefix(std::string& name);
+    inline std::string remove_counter_prefix(std::string const& counter);
+
+    ///////////////////////////////////////////////////////////////////////////
+    enum counter_type
+    {
+        // \a counter_text shows a variable-length text string. It does not
+        // deliver calculated values.
+        //
+        // Formula:  None
+        // Average:  None
+        // Type:     Text
+        counter_text,
+
+        // \a counter_raw shows the last observed value only. It does
+        // not deliver an average.
+        //
+        // Formula:  None. Shows raw data as collected.
+        // Average:  None
+        // Type:     Instantaneous
+        counter_raw,
+
+        // \a counter_average_base is used as the base data (denominator) in the
+        // computation of time or count averages for the \a counter_average_count
+        // and \a counter_average_timer counter types. This counter type
+        // collects the last observed value only.
+        //
+        // Formula:  None. This counter uses raw data in factional calculations
+        //           without delivering an output.
+        // Average:  SUM (N) / x
+        // Type:     Instantaneous
+        counter_average_base,
+
+        // \a counter_average_count shows how many items are processed, on
+        // average, during an operation. Counters of this type display a ratio
+        // of the items processed (such as bytes sent) to the number of
+        // operations completed. The ratio is calculated by comparing the
+        // number of items processed during the last interval to the number of
+        // operations completed during the last interval.
+        //
+        // Formula:  (N1 - N0) / (D1 - D0), where the numerator (N) represents
+        //           the number of items processed during the last sample
+        //           interval, and the denominator (D) represents the number
+        //           of operations completed during the last two sample
+        //           intervals.
+        // Average:  (Nx - N0) / (Dx - D0)
+        // Type:     Average
+        counter_average_count,
+
+        // \a counter_aggregating applies a function to an embedded counter
+        // instance. The embedded counter is usually evaluated repeatedly
+        // after a fixed (but configurable) time interval.
+        //
+        // Formula:  F(Nx)
+        counter_aggregating,
+
+        // \a counter_average_timer measures the average time it takes to
+        // complete a process or operation. Counters of this type display a
+        // ratio of the total elapsed time of the sample interval to the
+        // number of processes or operations completed during that time. This
+        // counter type measures time in ticks of the system clock. The
+        // variable F represents the number of ticks per second. The value of
+        // F is factored into the equation so that the result is displayed in
+        // seconds.
+        //
+        // Formula:  ((N1 - N0) / F) / (D1 - D0), where the numerator (N)
+        //           represents the number of ticks counted during the last
+        //           sample interval, the variable F represents the frequency
+        //           of the ticks, and the denominator (D) represents the
+        //           number of operations completed during the last sample
+        //           interval.
+        // Average:  ((Nx - N0) / F) / (Dx - D0)
+        // Type:     Average
+        counter_average_timer,
+
+        // \a counter_elapsed_time shows the total time between when the
+        // component or process started and the time when this value is
+        // calculated. The variable F represents the number of time units that
+        // elapse in one second. The value of F is factored into the equation
+        // so that the result is displayed in seconds.
+        //
+        // Formula:  (D0 - N0) / F, where the nominator (D) represents the
+        //           current time, the numerator (N) represents the time the
+        //           object was started, and the variable F represents the
+        //           number of time units that elapse in one second.
+        // Average:  (Dx - N0) / F
+        // Type:     Difference
+        counter_elapsed_time,
+
+        // \a counter_histogram exposes a histogram of the measured values
+        // instead of a single value as many of the other counter types.
+        // Counters of this type expose a \a counter_value_array instead of a
+        // \a counter_value. Those will also not implement the
+        // \a get_counter_value() functionality. The results are exposed
+        // through a separate \a get_counter_values_array() function.
+        //
+        // The first three values in the returned array represent the lower
+        // and upper boundaries, and the size of the histogram buckets. All
+        // remaining values in the returned array represent the number of
+        // measurements for each of the buckets in the histogram.
+        counter_histogram,
+
+        /// \a counter_raw_values exposes an array of measured values
+        /// instead of a single value as many of the other counter types.
+        /// Counters of this type expose a \a counter_value_array instead of a
+        /// \a counter_value. Those will also not implement the
+        /// \a get_counter_value() functionality. The results are exposed
+        /// through a separate \a get_counter_values_array() function.
+        counter_raw_values
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Return the readable name of a given counter type
+    HPX_API_EXPORT char const* get_counter_type_name(counter_type state);
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Status and error codes used by the functions related to
+    // performance counters.
+    enum counter_status
+    {
+        status_valid_data,         // No error occurred, data is valid
+        status_new_data,           // Data is valid and different from last call
+        status_invalid_data,       // Some error occurred, data is not value
+        status_already_defined,    // The type or instance already has been defined
+        status_counter_unknown,         // The counter instance is unknown
+        status_counter_type_unknown,    // The counter type is unknown
+        status_generic_error            // A unknown error occurred
+    };
+
+    inline bool status_is_valid(counter_status s);
+
+    ///////////////////////////////////////////////////////////////////////////
+    // A counter_type_path_elements holds the elements of a full name for a
+    // counter type.
+    struct counter_type_path_elements;
+
+    ///////////////////////////////////////////////////////////////////////////
+    // A counter_path_elements holds the elements of a full name for a counter
+    // instance.
+    struct counter_path_elements;
+
+    ///////////////////////////////////////////////////////////////////////////
+    /// \brief Create a full name of a counter type from the contents of the
+    ///        given \a counter_type_path_elements instance.The generated
+    ///        counter type name will not contain any parameters.
+    HPX_API_EXPORT counter_status get_counter_type_name(
+        counter_type_path_elements const& path, std::string& result,
+        error_code& ec = throws);
+
+    /// \brief Create a full name of a counter type from the contents of the
+    ///        given \a counter_type_path_elements instance. The generated
+    ///        counter type name will contain all parameters.
+    HPX_API_EXPORT counter_status get_full_counter_type_name(
+        counter_type_path_elements const& path, std::string& result,
+        error_code& ec = throws);
+
+    /// \brief Create a full name of a counter from the contents of the given
+    ///        \a counter_path_elements instance.
+    HPX_API_EXPORT counter_status get_counter_name(
+        counter_path_elements const& path, std::string& result,
+        error_code& ec = throws);
+
+    /// \brief Create a name of a counter instance from the contents of the
+    ///        given \a counter_path_elements instance.
+    HPX_API_EXPORT counter_status get_counter_instance_name(
+        counter_path_elements const& path, std::string& result,
+        error_code& ec = throws);
+
+    /// \brief Fill the given \a counter_type_path_elements instance from the
+    ///        given full name of a counter type
+    HPX_API_EXPORT counter_status get_counter_type_path_elements(
+        std::string const& name, counter_type_path_elements& path,
+        error_code& ec = throws);
+
+    /// \brief Fill the given \a counter_path_elements instance from the given
+    ///        full name of a counter
+    HPX_API_EXPORT counter_status get_counter_path_elements(
+        std::string const& name, counter_path_elements& path,
+        error_code& ec = throws);
+
+    /// \brief Return the canonical counter instance name from a given full
+    ///        instance name
+    HPX_API_EXPORT counter_status get_counter_name(std::string const& name,
+        std::string& countername, error_code& ec = throws);
+
+    /// \brief Return the canonical counter type name from a given (full)
+    ///        instance name
+    HPX_API_EXPORT counter_status get_counter_type_name(std::string const& name,
+        std::string& type_name, error_code& ec = throws);
+
+// default version of performance counter structures
+#define HPX_PERFORMANCE_COUNTER_V1 0x01000000
+
+        ///////////////////////////////////////////////////////////////////////////
+        struct counter_info;
+
+        ///////////////////////////////////////////////////////////////////////////
+        // This declares the type of a function, which will be
+        // called by HPX whenever a new performance counter instance of a
+        // particular type needs to be created.
+        typedef hpx::util::function_nonser<naming::gid_type(
+            counter_info const&, error_code&)>
+            create_counter_func;
+
+        ///////////////////////////////////////////////////////////////////////////
+        // This declares a type of a function, which will be passed to
+        // a \a discover_counters_func in order to be called for each
+        // discovered performance counter instance.
+        typedef hpx::util::function_nonser<bool(
+            counter_info const&, error_code&)>
+            discover_counter_func;
+
+        enum discover_counters_mode
+        {
+            discover_counters_minimal,
+            discover_counters_full    // fully expand all wild cards
+        };
+
+        // This declares the type of a function, which will be called by
+        // HPX whenever it needs to discover all performance counter
+        // instances of a particular type.
+        typedef hpx::util::function_nonser<bool(counter_info const&,
+            discover_counter_func const&, discover_counters_mode, error_code&)>
+            discover_counters_func;
+
+        ///////////////////////////////////////////////////////////////////////////
+        /// \brief Complement the counter info if parent instance name is missing
+        HPX_API_EXPORT counter_status complement_counter_info(
+            counter_info& info, counter_info const& type_info,
+            error_code& ec = throws);
+
+        HPX_API_EXPORT counter_status complement_counter_info(
+            counter_info& info, error_code& ec = throws);
+
+        ///////////////////////////////////////////////////////////////////////////
+        struct counter_value
+        {
+            counter_value(std::int64_t value = 0, std::int64_t scaling = 1,
+                bool scale_inverse = false)
+              : time_()
+              , count_(0)
+              , value_(value)
+              , scaling_(scaling)
+              , status_(status_new_data)
+              , scale_inverse_(scale_inverse)
+            {
+            }
+
+            std::uint64_t time_;     ///< The local time when data was collected
+            std::uint64_t count_;    ///< The invocation counter for the data
+            std::int64_t value_;     ///< The current counter value
+            std::int64_t
+                scaling_;    ///< The scaling of the current counter value
+            counter_status status_;    ///< The status of the counter value
+            bool scale_inverse_;    ///< If true, value_ needs to be divided by
+                                    ///< scaling_, otherwise it has to be
+                                    ///< multiplied.
+
+            /// \brief Retrieve the 'real' value of the counter_value, converted to
+            ///        the requested type \a T
+            template <typename T>
+            T get_value(error_code& ec = throws) const
+            {
+                if (!status_is_valid(status_))
+                {
+                    HPX_THROWS_IF(ec, invalid_status,
+                        "counter_value::get_value<T>",
+                        "counter value is in invalid status");
+                    return T();
+                }
+
+                T val = static_cast<T>(value_);
+
+                if (scaling_ != 1)
+                {
+                    if (scaling_ == 0)
+                    {
+                        HPX_THROWS_IF(ec, uninitialized_value,
+                            "counter_value::get_value<T>",
+                            "scaling should not be zero");
+                        return T();
+                    }
+
+                    // calculate and return the real counter value
+                    if (scale_inverse_)
+                        return val / static_cast<T>(scaling_);
+
+                    return val * static_cast<T>(scaling_);
+                }
+                return val;
+            }
+
+        private:
+            // serialization support
+            friend class hpx::serialization::access;
+
+            HPX_EXPORT void serialize(
+                serialization::output_archive& ar, const unsigned int);
+            HPX_EXPORT void serialize(
+                serialization::input_archive& ar, const unsigned int);
+        };
+
+        ///////////////////////////////////////////////////////////////////////////
+        struct counter_values_array
+        {
+            counter_values_array(
+                std::int64_t scaling = 1, bool scale_inverse = false)
+              : time_()
+              , count_(0)
+              , values_()
+              , scaling_(scaling)
+              , status_(status_new_data)
+              , scale_inverse_(scale_inverse)
+            {
+            }
+
+            counter_values_array(std::vector<std::int64_t>&& values,
+                std::int64_t scaling = 1, bool scale_inverse = false)
+              : time_()
+              , count_(0)
+              , values_(std::move(values))
+              , scaling_(scaling)
+              , status_(status_new_data)
+              , scale_inverse_(scale_inverse)
+            {
+            }
+
+            counter_values_array(std::vector<std::int64_t> const& values,
+                std::int64_t scaling = 1, bool scale_inverse = false)
+              : time_()
+              , count_(0)
+              , values_(values)
+              , scaling_(scaling)
+              , status_(status_new_data)
+              , scale_inverse_(scale_inverse)
+            {
+            }
+
+            std::uint64_t time_;     ///< The local time when data was collected
+            std::uint64_t count_;    ///< The invocation counter for the data
+            std::vector<std::int64_t>
+                values_;    ///< The current counter values
+            std::int64_t
+                scaling_;    ///< The scaling of the current counter values
+            counter_status status_;    ///< The status of the counter value
+            bool scale_inverse_;    ///< If true, value_ needs to be divided by
+                                    ///< scaling_, otherwise it has to be
+                                    ///< multiplied.
+
+            /// \brief Retrieve the 'real' value of the counter_value, converted to
+            ///        the requested type \a T
+            template <typename T>
+            T get_value(std::size_t index, error_code& ec = throws) const
+            {
+                if (!status_is_valid(status_))
+                {
+                    HPX_THROWS_IF(ec, invalid_status,
+                        "counter_values_array::get_value<T>",
+                        "counter value is in invalid status");
+                    return T();
+                }
+                if (index >= values_.size())
+                {
+                    HPX_THROWS_IF(ec, bad_parameter,
+                        "counter_values_array::get_value<T>",
+                        "index out of bounds");
+                    return T();
+                }
+
+                T val = static_cast<T>(values_[index]);
+
+                if (scaling_ != 1)
+                {
+                    if (scaling_ == 0)
+                    {
+                        HPX_THROWS_IF(ec, uninitialized_value,
+                            "counter_values_array::get_value<T>",
+                            "scaling should not be zero");
+                        return T();
+                    }
+
+                    // calculate and return the real counter value
+                    if (scale_inverse_)
+                        return val / static_cast<T>(scaling_);
+
+                    return val * static_cast<T>(scaling_);
+                }
+                return val;
+            }
+
+        private:
+            // serialization support
+            friend class hpx::serialization::access;
+
+            HPX_EXPORT void serialize(
+                serialization::output_archive& ar, const unsigned int);
+            HPX_EXPORT void serialize(
+                serialization::input_archive& ar, const unsigned int);
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        // Add a new performance counter type to the (local) registry
+        HPX_API_EXPORT counter_status add_counter_type(counter_info const& info,
+            create_counter_func const& create_counter,
+            discover_counters_func const& discover_counters,
+            error_code& ec = throws);
+
+        inline counter_status add_counter_type(
+            counter_info const& info, error_code& ec = throws);
+
+        ///////////////////////////////////////////////////////////////////////////
+        /// \brief Call the supplied function for each registered counter type
+        HPX_API_EXPORT counter_status discover_counter_types(
+            discover_counter_func const& discover_counter,
+            discover_counters_mode mode = discover_counters_minimal,
+            error_code& ec = throws);
+
+        /// \brief Return a list of all available counter descriptions.
+        HPX_API_EXPORT counter_status discover_counter_types(
+            std::vector<counter_info>& counters,
+            discover_counters_mode mode = discover_counters_minimal,
+            error_code& ec = throws);
+
+        /// \brief Call the supplied function for the given registered counter type.
+        HPX_API_EXPORT counter_status discover_counter_type(
+            std::string const& name,
+            discover_counter_func const& discover_counter,
+            discover_counters_mode mode = discover_counters_minimal,
+            error_code& ec = throws);
+
+        HPX_API_EXPORT counter_status discover_counter_type(
+            counter_info const& info,
+            discover_counter_func const& discover_counter,
+            discover_counters_mode mode = discover_counters_minimal,
+            error_code& ec = throws);
+
+        /// \brief Return a list of matching counter descriptions for the given
+        ///        registered counter type.
+        HPX_API_EXPORT counter_status discover_counter_type(
+            std::string const& name, std::vector<counter_info>& counters,
+            discover_counters_mode mode = discover_counters_minimal,
+            error_code& ec = throws);
+
+        HPX_API_EXPORT counter_status discover_counter_type(
+            counter_info const& info, std::vector<counter_info>& counters,
+            discover_counters_mode mode = discover_counters_minimal,
+            error_code& ec = throws);
+
+        /// \brief call the supplied function will all expanded versions of the
+        /// supplied counter info.
+        ///
+        /// This function expands all locality#* and worker-thread#* wild
+        /// cards only.
+        HPX_API_EXPORT bool expand_counter_info(
+            counter_info const&, discover_counter_func const&, error_code&);
+
+        /// \brief Remove an existing counter type from the (local) registry
+        ///
+        /// \note This doesn't remove existing counters of this type, it just
+        ///       inhibits defining new counters using this type.
+        HPX_API_EXPORT counter_status remove_counter_type(
+            counter_info const& info, error_code& ec = throws);
+
+        /// \brief Retrieve the counter type for the given counter name from the
+        ///        (local) registry
+        HPX_API_EXPORT counter_status get_counter_type(std::string const& name,
+            counter_info& info, error_code& ec = throws);
+
+        ///////////////////////////////////////////////////////////////////////////
+        /// \brief Get the global id of an existing performance counter, if the
+        ///        counter does not exist yet, the function attempts to create the
+        ///        counter based on the given counter name.
+        HPX_API_EXPORT lcos::future<naming::id_type> get_counter_async(
+            std::string name, error_code& ec = throws);
+
+        inline naming::id_type get_counter(
+            std::string const& name, error_code& ec = throws);
+
+        /// \brief Get the global id of an existing performance counter, if the
+        ///        counter does not exist yet, the function attempts to create the
+        ///        counter based on the given counter info.
+        HPX_API_EXPORT lcos::future<naming::id_type> get_counter_async(
+            counter_info const& info, error_code& ec = throws);
+
+        inline naming::id_type get_counter(
+            counter_info const& info, error_code& ec = throws);
+
+        ///////////////////////////////////////////////////////////////////////////
+        /// \brief Retrieve the meta data specific for the given counter instance
+        HPX_API_EXPORT void get_counter_infos(counter_info const& info,
+            counter_type& type, std::string& helptext, std::uint32_t& version,
+            error_code& ec = throws);
+
+        /// \brief Retrieve the meta data specific for the given counter instance
+        HPX_API_EXPORT void get_counter_infos(std::string name,
+            counter_type& type, std::string& helptext, std::uint32_t& version,
+            error_code& ec = throws);
+
+        ///////////////////////////////////////////////////////////////////////////
+        namespace detail {
+            /// \brief Add an existing performance counter instance to the registry
+            HPX_API_EXPORT counter_status add_counter(naming::id_type const& id,
+                counter_info const& info, error_code& ec = throws);
+
+            /// \brief Remove an existing performance counter instance with the
+            ///        given id (as returned from \a create_counter)
+            HPX_API_EXPORT counter_status remove_counter(
+                counter_info const& info, naming::id_type const& id,
+                error_code& ec = throws);
+
+            ///////////////////////////////////////////////////////////////////////
+            // Helper function for creating counters encapsulating a function
+            // returning the counter value.
+            HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
+                hpx::util::function_nonser<std::int64_t()> const&, error_code&);
+
+            // Helper function for creating counters encapsulating a function
+            // returning the counter value.
+            HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
+                hpx::util::function_nonser<std::int64_t(bool)> const&,
+                error_code&);
+
+            // Helper function for creating counters encapsulating a function
+            // returning the counter values array.
+            HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
+                hpx::util::function_nonser<std::vector<std::int64_t>()> const&,
+                error_code&);
+
+            // Helper function for creating counters encapsulating a function
+            // returning the counter values array.
+            HPX_EXPORT naming::gid_type create_raw_counter(counter_info const&,
+                hpx::util::function_nonser<std::vector<std::int64_t>(
+                    bool)> const&,
+                error_code&);
+
+            // Helper function for creating a new performance counter instance
+            // based on a given counter value.
+            HPX_EXPORT naming::gid_type create_raw_counter_value(
+                counter_info const&, std::int64_t*, error_code&);
+
+            // Creation function for aggregating performance counters; to be
+            // registered with the counter types.
+            HPX_EXPORT naming::gid_type statistics_counter_creator(
+                counter_info const&, error_code&);
+
+            // Creation function for aggregating performance counters; to be
+            // registered with the counter types.
+            HPX_EXPORT naming::gid_type arithmetics_counter_creator(
+                counter_info const&, error_code&);
+
+            // Creation function for extended aggregating performance counters; to
+            // be registered with the counter types.
+            HPX_EXPORT naming::gid_type arithmetics_counter_extended_creator(
+                counter_info const&, error_code&);
+
+            // Creation function for uptime counters.
+            HPX_EXPORT naming::gid_type uptime_counter_creator(
+                counter_info const&, error_code&);
+
+            // Creation function for instance counters.
+            HPX_EXPORT naming::gid_type component_instance_counter_creator(
+                counter_info const&, error_code&);
+
+            // \brief Create a new statistics performance counter instance based on
+            //        the given base counter name and given base time interval
+            //        (milliseconds).
+            HPX_EXPORT naming::gid_type create_statistics_counter(
+                counter_info const& info, std::string const& base_counter_name,
+                std::vector<std::size_t> const& parameters,
+                error_code& ec = throws);
+
+            // \brief Create a new arithmetics performance counter instance based on
+            //        the given base counter names
+            HPX_EXPORT naming::gid_type create_arithmetics_counter(
+                counter_info const& info,
+                std::vector<std::string> const& base_counter_names,
+                error_code& ec = throws);
+
+            // \brief Create a new extended arithmetics performance counter instance
+            //        based on the given base counter names
+            HPX_EXPORT naming::gid_type create_arithmetics_counter_extended(
+                counter_info const& info,
+                std::vector<std::string> const& base_counter_names,
+                error_code& ec = throws);
+
+            // \brief Create a new performance counter instance based on given
+            //        counter info
+            HPX_EXPORT naming::gid_type create_counter(
+                counter_info const& info, error_code& ec = throws);
+
+            // \brief Create an arbitrary counter on this locality
+            HPX_EXPORT naming::gid_type create_counter_local(
+                counter_info const& info);
+        }    // namespace detail
+}}           // namespace hpx::performance_counters
+
+#endif
diff --git a/hpx/performance_counters/manage_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/manage_counter.hpp
similarity index 86%
rename from hpx/performance_counters/manage_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/manage_counter.hpp
index 16e4f683ba..e22429855f 100644
--- a/hpx/performance_counters/manage_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/manage_counter.hpp
@@ -15,13 +15,11 @@
 #include <hpx/performance_counters/counters_fwd.hpp>
 #include <hpx/runtime/naming_fwd.hpp>
 
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     /// Install a new performance counter in a way, which will uninstall it
     /// automatically during shutdown.
     HPX_EXPORT void install_counter(naming::id_type const& id,
         counter_info const& info, error_code& ec = throws);
-}}
-
-#endif // HPX_8B1A4443_7D95_4C0D_9970_7CEA4D049608
+}}    // namespace hpx::performance_counters
 
+#endif    // HPX_8B1A4443_7D95_4C0D_9970_7CEA4D049608
diff --git a/hpx/performance_counters/manage_counter_type.hpp b/libs/performance_counters/include/hpx/performance_counters/manage_counter_type.hpp
similarity index 92%
rename from hpx/performance_counters/manage_counter_type.hpp
rename to libs/performance_counters/include/hpx/performance_counters/manage_counter_type.hpp
index 2753b82617..8d624b13c7 100644
--- a/hpx/performance_counters/manage_counter_type.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/manage_counter_type.hpp
@@ -14,16 +14,15 @@
 
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/performance_counters/counters_fwd.hpp>
 #include <hpx/functional/function.hpp>
+#include <hpx/performance_counters/counters_fwd.hpp>
 
 #include <cstddef>
 #include <cstdint>
 #include <string>
 #include <vector>
 
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     /// \brief Install a new generic performance counter type in a way, which
     ///        will uninstall it automatically during shutdown.
     ///
@@ -145,8 +144,8 @@ namespace hpx { namespace performance_counters
     /// \note As long as \a ec is not pre-initialized to \a hpx#throws this
     ///       function doesn't throw but returns the result code using the
     ///       parameter \a ec. Otherwise it throws an instance of hpx#exception.
-    HPX_EXPORT void install_counter_type(std::string const& name,
-        counter_type type, error_code& ec = throws);
+    HPX_EXPORT void install_counter_type(
+        std::string const& name, counter_type type, error_code& ec = throws);
 
     /// \brief Install a new performance counter type in a way, which will
     ///        uninstall it automatically during shutdown.
@@ -235,21 +234,21 @@ namespace hpx { namespace performance_counters
     /// A small data structure holding all data needed to install a counter type
     struct generic_counter_type_data
     {
-        std::string name_;          ///< Name of the counter type
-        counter_type type_;         ///< Type of the counter instances of this
-                                    ///< counter type
-        std::string helptext_;      ///< Longer descriptive text explaining the
-                                    ///< counter type
-        std::uint32_t version_;   ///< Version of this counter type definition
-                                    ///< (default: HPX_PERFORMANCE_COUNTER_V1)
+        std::string name_;         ///< Name of the counter type
+        counter_type type_;        ///< Type of the counter instances of this
+                                   ///< counter type
+        std::string helptext_;     ///< Longer descriptive text explaining the
+                                   ///< counter type
+        std::uint32_t version_;    ///< Version of this counter type definition
+                                   ///< (default: HPX_PERFORMANCE_COUNTER_V1)
         create_counter_func create_counter_;
-            ///< Function used to create a counter instance of this type.
+        ///< Function used to create a counter instance of this type.
         discover_counters_func discover_counters_;
-            ///< Function used to discover all supported counter instances of
-            ///< this type.
+        ///< Function used to discover all supported counter instances of
+        ///< this type.
         std::string unit_of_measure_;
-            ///< The textual representation of the unit of measure for counter
-            ///< instances of this type. Use ISO unit names.
+        ///< The textual representation of the unit of measure for counter
+        ///< instances of this type. Use ISO unit names.
     };
 
     /// Install several new performance counter types in a way, which will
@@ -258,7 +257,6 @@ namespace hpx { namespace performance_counters
         std::size_t count, error_code& ec = throws);
 
     /// \endcond
-}}
-
-#endif // HPX_F26CC3F9_3E30_4C54_90E0_0CD02146320F
+}}    // namespace hpx::performance_counters
 
+#endif    // HPX_F26CC3F9_3E30_4C54_90E0_0CD02146320F
diff --git a/hpx/performance_counters/parcels/data_point.hpp b/libs/performance_counters/include/hpx/performance_counters/parcels/data_point.hpp
similarity index 54%
rename from hpx/performance_counters/parcels/data_point.hpp
rename to libs/performance_counters/include/hpx/performance_counters/parcels/data_point.hpp
index 75861a8db6..bdcac71c2d 100644
--- a/hpx/performance_counters/parcels/data_point.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/parcels/data_point.hpp
@@ -14,8 +14,7 @@
 #include <cstddef>
 #include <cstdint>
 
-namespace hpx { namespace performance_counters { namespace parcels
-{
+namespace hpx { namespace performance_counters { namespace parcels {
     /// \brief A \a data_point collects all timing and statistical information
     ///        for a single parcel (either sent or received).
     struct data_point
@@ -27,22 +26,25 @@ namespace hpx { namespace performance_counters { namespace parcels
           , num_parcels_(0)
           , raw_bytes_(0)
           , buffer_allocate_time_(0)
-        {}
+        {
+        }
 
-        std::size_t bytes_;           ///< number of bytes on tyhe wire for this parcel
-                                      ///< (possibly compressed)
-        std::int64_t time_;           ///< during processing holds start timestamp
-                                      ///< after processing holds elapsed time
+        std::size_t bytes_;    ///< number of bytes on the wire for this parcel
+                               ///< (possibly compressed)
+        std::int64_t time_;    ///< during processing holds start timestamp
+                               ///< after processing holds elapsed time
         std::int64_t serialization_time_;    ///< during processing holds
-                                   ///< start serialization timestamp after
-                                   ///< processing holds elapsed serialization time
-        std::size_t num_parcels_;  ///< The number of parcels processed by this message
-        std::size_t raw_bytes_;    ///< number of bytes processed for the action in
-                                   ///< this parcel (uncompressed)
-
-        std::int64_t buffer_allocate_time_; ///< The time spent for allocating buffers
+            ///< start serialization timestamp after
+            ///< processing holds elapsed serialization time
+        std::size_t
+            num_parcels_;    ///< The number of parcels processed by this message
+        std::size_t
+            raw_bytes_;    ///< number of bytes processed for the action in
+                           ///< this parcel (uncompressed)
+
+        std::int64_t
+            buffer_allocate_time_;    ///< The time spent for allocating buffers
     };
-}}}
-
-#endif // HPX_76311D67_43DA_4B3A_8A2A_14B8A1A266D9
+}}}    // namespace hpx::performance_counters::parcels
 
+#endif    // HPX_76311D67_43DA_4B3A_8A2A_14B8A1A266D9
diff --git a/hpx/performance_counters/parcels/gatherer.hpp b/libs/performance_counters/include/hpx/performance_counters/parcels/gatherer.hpp
similarity index 86%
rename from hpx/performance_counters/parcels/gatherer.hpp
rename to libs/performance_counters/include/hpx/performance_counters/parcels/gatherer.hpp
index 4c886bd9cd..682a7023ea 100644
--- a/hpx/performance_counters/parcels/gatherer.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/parcels/gatherer.hpp
@@ -10,18 +10,16 @@
 #define HPX_05A1C29B_DB73_463A_8C9D_B8EDC3B69F5E
 
 #include <hpx/assertion.hpp>
+#include <hpx/performance_counters/parcels/data_point.hpp>
 #include <hpx/synchronization/no_mutex.hpp>
 #include <hpx/synchronization/spinlock.hpp>
-#include <hpx/performance_counters/parcels/data_point.hpp>
 #include <hpx/util/get_and_reset_value.hpp>
 
 #include <cstdint>
 #include <mutex>
 
-namespace hpx { namespace performance_counters { namespace parcels
-{
-    namespace detail
-    {
+namespace hpx { namespace performance_counters { namespace parcels {
+    namespace detail {
         /// \brief Collect statistics information about parcels sent and received.
         template <typename Mutex>
         class gatherer
@@ -30,15 +28,16 @@ namespace hpx { namespace performance_counters { namespace parcels
 
         public:
             gatherer()
-              : overall_bytes_(0),
-                overall_time_(0),
-                serialization_time_(0),
-                num_parcels_(0),
-                num_messages_(0),
-                overall_raw_bytes_(0),
-                buffer_allocate_time_(0),
-                acc_mtx()
-            {}
+              : overall_bytes_(0)
+              , overall_time_(0)
+              , serialization_time_(0)
+              , num_parcels_(0)
+              , num_messages_(0)
+              , overall_raw_bytes_(0)
+              , buffer_allocate_time_(0)
+              , acc_mtx()
+            {
+            }
 
             void add_data(data_point const& x);
 
@@ -100,8 +99,8 @@ namespace hpx { namespace performance_counters { namespace parcels
         }
 
         template <typename Mutex>
-        inline std::int64_t
-        gatherer<Mutex>::total_serialization_time(bool reset)
+        inline std::int64_t gatherer<Mutex>::total_serialization_time(
+            bool reset)
         {
             std::lock_guard<mutex_type> l(acc_mtx);
             return util::get_and_reset_value(serialization_time_, reset);
@@ -122,18 +121,17 @@ namespace hpx { namespace performance_counters { namespace parcels
         }
 
         template <typename Mutex>
-        inline std::int64_t
-        gatherer<Mutex>::total_buffer_allocate_time(bool reset)
+        inline std::int64_t gatherer<Mutex>::total_buffer_allocate_time(
+            bool reset)
         {
             std::lock_guard<mutex_type> l(acc_mtx);
             return util::get_and_reset_value(buffer_allocate_time_, reset);
         }
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
     using gatherer = detail::gatherer<lcos::local::spinlock>;
     using gatherer_nolock = detail::gatherer<lcos::local::no_mutex>;
-}}}
-
-#endif // HPX_05A1C29B_DB73_463A_8C9D_B8EDC3B69F5E
+}}}    // namespace hpx::performance_counters::parcels
 
+#endif    // HPX_05A1C29B_DB73_463A_8C9D_B8EDC3B69F5E
diff --git a/hpx/performance_counters/performance_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/performance_counter.hpp
similarity index 64%
rename from hpx/performance_counters/performance_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/performance_counter.hpp
index b81988fbca..3d6c1a2d4f 100644
--- a/hpx/performance_counters/performance_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/performance_counter.hpp
@@ -8,10 +8,10 @@
 #define HPX_PERFORMANCE_COUNTERS_PERFORMANCE_COUNTER_JAN_18_2013_0939AM
 
 #include <hpx/config.hpp>
+#include <hpx/functional/bind_front.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/runtime/components/client_base.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/functional/bind_front.hpp>
 
 #include <hpx/performance_counters/counters_fwd.hpp>
 #include <hpx/performance_counters/stubs/performance_counter.hpp>
@@ -21,50 +21,53 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     struct HPX_EXPORT performance_counter
       : components::client_base<performance_counter, stubs::performance_counter>
     {
-        typedef components::client_base<
-            performance_counter, stubs::performance_counter
-        > base_type;
+        typedef components::client_base<performance_counter,
+            stubs::performance_counter>
+            base_type;
 
         performance_counter() {}
 
         performance_counter(std::string const& name);
 
-        performance_counter(std::string const& name, hpx::id_type const& locality);
+        performance_counter(
+            std::string const& name, hpx::id_type const& locality);
 
-        performance_counter(future<id_type> && id)
+        performance_counter(future<id_type>&& id)
           : base_type(std::move(id))
-        {}
+        {
+        }
 
-        performance_counter(hpx::future<performance_counter> && c)
+        performance_counter(hpx::future<performance_counter>&& c)
           : base_type(std::move(c))
-        {}
+        {
+        }
 
         ///////////////////////////////////////////////////////////////////////
         future<counter_info> get_info() const;
-        counter_info get_info(launch::sync_policy,
-            error_code& ec = throws) const;
+        counter_info get_info(
+            launch::sync_policy, error_code& ec = throws) const;
 
         future<counter_value> get_counter_value(bool reset = false);
-        counter_value get_counter_value(launch::sync_policy,
-            bool reset = false, error_code& ec = throws);
+        counter_value get_counter_value(
+            launch::sync_policy, bool reset = false, error_code& ec = throws);
 
         future<counter_value> get_counter_value() const;
-        counter_value get_counter_value(launch::sync_policy,
-            error_code& ec = throws) const;
+        counter_value get_counter_value(
+            launch::sync_policy, error_code& ec = throws) const;
 
-        future<counter_values_array> get_counter_values_array(bool reset = false);
-        counter_values_array get_counter_values_array(launch::sync_policy,
-            bool reset = false, error_code& ec = throws);
+        future<counter_values_array> get_counter_values_array(
+            bool reset = false);
+        counter_values_array get_counter_values_array(
+            launch::sync_policy, bool reset = false, error_code& ec = throws);
 
         future<counter_values_array> get_counter_values_array() const;
-        counter_values_array get_counter_values_array(launch::sync_policy,
-            error_code& ec = throws) const;
+        counter_values_array get_counter_values_array(
+            launch::sync_policy, error_code& ec = throws) const;
 
         ///////////////////////////////////////////////////////////////////////
         future<bool> start();
@@ -82,11 +85,12 @@ namespace hpx { namespace performance_counters
 
         ///////////////////////////////////////////////////////////////////////
         future<std::string> get_name() const;
-        std::string get_name(launch::sync_policy, error_code& ec = throws) const;
+        std::string get_name(
+            launch::sync_policy, error_code& ec = throws) const;
 
     private:
         template <typename T>
-        static T extract_value(future<counter_value> && value)
+        static T extract_value(future<counter_value>&& value)
         {
             return value.get().get_value<T>();
         }
@@ -95,14 +99,12 @@ namespace hpx { namespace performance_counters
         template <typename T>
         future<T> get_value(bool reset = false)
         {
-            return get_counter_value(reset).then(
-                hpx::launch::sync,
-                util::bind_front(
-                    &performance_counter::extract_value<T>));
+            return get_counter_value(reset).then(hpx::launch::sync,
+                util::bind_front(&performance_counter::extract_value<T>));
         }
         template <typename T>
-        T get_value(launch::sync_policy, bool reset = false,
-            error_code& ec = throws)
+        T get_value(
+            launch::sync_policy, bool reset = false, error_code& ec = throws)
         {
             return get_counter_value(launch::sync, reset).get_value<T>(ec);
         }
@@ -110,10 +112,8 @@ namespace hpx { namespace performance_counters
         template <typename T>
         future<T> get_value() const
         {
-            return get_counter_value().then(
-                hpx::launch::sync,
-                util::bind_front(
-                    &performance_counter::extract_value<T>));
+            return get_counter_value().then(hpx::launch::sync,
+                util::bind_front(&performance_counter::extract_value<T>));
         }
         template <typename T>
         T get_value(launch::sync_policy, error_code& ec = throws) const
@@ -125,6 +125,6 @@ namespace hpx { namespace performance_counters
     /// Return all counters matching the given name (with optional wildcards).
     HPX_API_EXPORT std::vector<performance_counter> discover_counters(
         std::string const& name, error_code& ec = throws);
-}}
+}}    // namespace hpx::performance_counters
 
 #endif
diff --git a/hpx/performance_counters/performance_counter_base.hpp b/libs/performance_counters/include/hpx/performance_counters/performance_counter_base.hpp
similarity index 87%
rename from hpx/performance_counters/performance_counter_base.hpp
rename to libs/performance_counters/include/hpx/performance_counters/performance_counter_base.hpp
index a211388580..f99e571d22 100644
--- a/hpx/performance_counters/performance_counter_base.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/performance_counter_base.hpp
@@ -4,15 +4,15 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_PERFORMANCE_COUNTERS_PERFORMANCE_COUNTER_BASE_SEP_18_2014_0732PM)
+#if !defined(                                                                  \
+    HPX_PERFORMANCE_COUNTERS_PERFORMANCE_COUNTER_BASE_SEP_18_2014_0732PM)
 #define HPX_PERFORMANCE_COUNTERS_PERFORMANCE_COUNTER_BASE_SEP_18_2014_0732PM
 
 #include <hpx/config.hpp>
 #include <hpx/performance_counters/counters_fwd.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     //[performance_counter_interface
     // Abstract base interface for all Performance Counters.
     struct performance_counter_base
@@ -48,6 +48,6 @@ namespace hpx { namespace performance_counters
         virtual void reinit(bool reset) = 0;
     };
     //]
-}}
+}}    // namespace hpx::performance_counters
 
 #endif
diff --git a/hpx/performance_counters/performance_counter_set.hpp b/libs/performance_counters/include/hpx/performance_counters/performance_counter_set.hpp
similarity index 72%
rename from hpx/performance_counters/performance_counter_set.hpp
rename to libs/performance_counters/include/hpx/performance_counters/performance_counter_set.hpp
index d9f11ae231..3e8888de01 100644
--- a/hpx/performance_counters/performance_counter_set.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/performance_counter_set.hpp
@@ -4,16 +4,17 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_PERFORMANCE_COUNTERS_PERFORMANCE_COUNTER_SET_DEC_19_2016_1055AM)
+#if !defined(                                                                  \
+    HPX_PERFORMANCE_COUNTERS_PERFORMANCE_COUNTER_SET_DEC_19_2016_1055AM)
 #define HPX_PERFORMANCE_COUNTERS_PERFORMANCE_COUNTER_SET_DEC_19_2016_1055AM
 
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/lcos/dataflow.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/synchronization/spinlock.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/runtime/launch_policy.hpp>
+#include <hpx/synchronization/spinlock.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <cstddef>
@@ -25,8 +26,7 @@
 #include <hpx/config/warnings_prefix.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     // Make a collection of performance counters available as a set
     class HPX_EXPORT performance_counter_set
     {
@@ -37,14 +37,15 @@ namespace hpx { namespace performance_counters
         performance_counter_set(bool print_counters_locally = false)
           : invocation_count_(0)
           , print_counters_locally_(print_counters_locally)
-        {}
+        {
+        }
 
         /// Create a set of performance counters from a name, possibly
         /// containing wild-card characters
-        explicit performance_counter_set(std::string const& names,
-            bool reset = false);
-        explicit performance_counter_set(std::vector<std::string> const& names,
-            bool reset = false);
+        explicit performance_counter_set(
+            std::string const& names, bool reset = false);
+        explicit performance_counter_set(
+            std::vector<std::string> const& names, bool reset = false);
 
         /// Add more performance counters to the set based on the given name,
         /// possibly containing wild-card characters
@@ -58,33 +59,35 @@ namespace hpx { namespace performance_counters
 
         /// Retrieve the values for all counters in this set supporting
         /// this operation
-        std::vector<hpx::future<counter_value> > get_counter_values(
+        std::vector<hpx::future<counter_value>> get_counter_values(
             bool reset = false) const;
         std::vector<counter_value> get_counter_values(launch::sync_policy,
             bool reset = false, error_code& ec = throws) const;
 
         /// Retrieve the array-values for all counters in this set supporting
         /// this operation
-        std::vector<hpx::future<counter_values_array> >
-            get_counter_values_array(bool reset = false) const;
+        std::vector<hpx::future<counter_values_array>> get_counter_values_array(
+            bool reset = false) const;
         std::vector<counter_values_array> get_counter_values_array(
-            launch::sync_policy, bool reset = false, error_code& ec = throws) const;
+            launch::sync_policy, bool reset = false,
+            error_code& ec = throws) const;
 
         /// Reset all counters in this set
-        std::vector<hpx::future<void> > reset();
-        void reset (launch::sync_policy, error_code& ec = throws);
+        std::vector<hpx::future<void>> reset();
+        void reset(launch::sync_policy, error_code& ec = throws);
 
         /// Start all counters in this set
-        std::vector<hpx::future<bool> > start();
+        std::vector<hpx::future<bool>> start();
         bool start(launch::sync_policy, error_code& ec = throws);
 
         /// Stop all counters in this set
-        std::vector<hpx::future<bool> > stop();
+        std::vector<hpx::future<bool>> stop();
         bool stop(launch::sync_policy, error_code& ec = throws);
 
         /// Re-initialize all counters in this set
-        std::vector<hpx::future<void> > reinit(bool reset = true);
-        void reinit(launch::sync_policy, bool reset = true, error_code& ec = throws);
+        std::vector<hpx::future<void>> reinit(bool reset = true);
+        void reinit(
+            launch::sync_policy, bool reset = true, error_code& ec = throws);
 
         /// Release all references to counters in the set
         void release();
@@ -93,10 +96,9 @@ namespace hpx { namespace performance_counters
         std::size_t size() const;
 
         template <typename T>
-        hpx::future<std::vector<T> > get_values(bool reset = false) const
+        hpx::future<std::vector<T>> get_values(bool reset = false) const
         {
-            return hpx::dataflow(
-                &performance_counter_set::extract_values<T>,
+            return hpx::dataflow(&performance_counter_set::extract_values<T>,
                 get_counter_values(reset));
         }
         template <typename T>
@@ -113,11 +115,11 @@ namespace hpx { namespace performance_counters
 
         template <typename T>
         static std::vector<T> extract_values(
-            std::vector<hpx::future<counter_value> > && values)
+            std::vector<hpx::future<counter_value>>&& values)
         {
             std::vector<T> results;
             results.reserve(values.size());
-            for (hpx::future<counter_value> & f : values)
+            for (hpx::future<counter_value>& f : values)
                 results.push_back(f.get().get_value<T>());
             return results;
         }
@@ -130,11 +132,10 @@ namespace hpx { namespace performance_counters
         std::vector<std::uint8_t> reset_;     // != 0 if counter should be reset
 
         mutable std::uint64_t invocation_count_;
-        bool print_counters_locally_;         // handle only local counters
+        bool print_counters_locally_;    // handle only local counters
     };
-}}
+}}    // namespace hpx::performance_counters
 
 #include <hpx/config/warnings_suffix.hpp>
 
 #endif
-
diff --git a/hpx/performance_counters/registry.hpp b/libs/performance_counters/include/hpx/performance_counters/registry.hpp
similarity index 80%
rename from hpx/performance_counters/registry.hpp
rename to libs/performance_counters/include/hpx/performance_counters/registry.hpp
index ac436e64ac..cf71faf192 100644
--- a/hpx/performance_counters/registry.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/registry.hpp
@@ -8,9 +8,9 @@
 #define HPX_PERFORMANCE_COUNTERS_REGISTRY_MAR_01_2009_0424PM
 
 #include <hpx/config.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/runtime/naming/name.hpp>
-#include <hpx/functional/function.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -19,8 +19,7 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     class registry
     {
@@ -28,11 +27,13 @@ namespace hpx { namespace performance_counters
         struct counter_data
         {
             counter_data(counter_info const& info,
-                    create_counter_func const& create_counter,
-                    discover_counters_func const& discover_counters)
-              : info_(info), create_counter_(create_counter),
-                discover_counters_(discover_counters)
-            {}
+                create_counter_func const& create_counter,
+                discover_counters_func const& discover_counters)
+              : info_(info)
+              , create_counter_(create_counter)
+              , discover_counters_(discover_counters)
+            {
+            }
 
             counter_info info_;
             create_counter_func create_counter_;
@@ -51,18 +52,17 @@ namespace hpx { namespace performance_counters
 
         /// \brief Call the supplied function for all registered counter types.
         counter_status discover_counter_types(
-            discover_counter_func discover_counter,
-            discover_counters_mode mode, error_code& ec = throws);
+            discover_counter_func discover_counter, discover_counters_mode mode,
+            error_code& ec = throws);
 
         /// \brief Call the supplied function for the given registered counter type.
-        counter_status discover_counter_type(
-            std::string const& fullname,
-            discover_counter_func discover_counter,
-            discover_counters_mode mode, error_code& ec = throws);
-
-        counter_status discover_counter_type(
-            counter_info const& info, discover_counter_func const& f,
-            discover_counters_mode mode, error_code& ec = throws)
+        counter_status discover_counter_type(std::string const& fullname,
+            discover_counter_func discover_counter, discover_counters_mode mode,
+            error_code& ec = throws);
+
+        counter_status discover_counter_type(counter_info const& info,
+            discover_counter_func const& f, discover_counters_mode mode,
+            error_code& ec = throws)
         {
             return discover_counter_type(info.fullname_, f, mode, ec);
         }
@@ -70,21 +70,19 @@ namespace hpx { namespace performance_counters
         /// \brief Retrieve the counter creation function which is associated
         ///        with a given counter type.
         counter_status get_counter_create_function(counter_info const& info,
-            create_counter_func& create_counter,
-            error_code& ec = throws) const;
+            create_counter_func& create_counter, error_code& ec = throws) const;
 
         /// \brief Retrieve the counter discovery function which is associated
         ///        with a given counter type.
         counter_status get_counter_discovery_function(counter_info const& info,
-            discover_counters_func& func,
-            error_code& ec) const;
+            discover_counters_func& func, error_code& ec) const;
 
         /// \brief Remove an existing counter type from the (local) registry
         ///
         /// \note This doesn't remove existing counters of this type, it just
         ///       inhibits defining new counters using this type.
-        counter_status remove_counter_type(counter_info const& info,
-            error_code& ec = throws);
+        counter_status remove_counter_type(
+            counter_info const& info, error_code& ec = throws);
 
         /// \brief Create a new performance counter instance of type
         ///        raw_counter based on given counter value
@@ -117,7 +115,8 @@ namespace hpx { namespace performance_counters
         ///        raw_counter based on given function returning the counter
         ///        value
         counter_status create_raw_counter(counter_info const& info,
-            hpx::util::function_nonser<std::vector<std::int64_t>(bool)> const& f,
+            hpx::util::function_nonser<std::vector<std::int64_t>(bool)> const&
+                f,
             naming::gid_type& id, error_code& ec = throws);
 
         /// \brief Create a new performance counter instance based on given
@@ -130,8 +129,8 @@ namespace hpx { namespace performance_counters
         ///        (milliseconds).
         counter_status create_statistics_counter(counter_info const& info,
             std::string const& base_counter_name,
-            std::vector<std::size_t> const& parameters,
-            naming::gid_type& id, error_code& ec = throws);
+            std::vector<std::size_t> const& parameters, naming::gid_type& id,
+            error_code& ec = throws);
 
         /// \brief Create a new arithmetics performance counter instance based
         ///        on given base counter names
@@ -159,15 +158,14 @@ namespace hpx { namespace performance_counters
             counter_info& info, error_code& ec = throws);
 
     protected:
-        counter_type_map_type::iterator
-            locate_counter_type(std::string const& type_name);
-        counter_type_map_type::const_iterator
-            locate_counter_type(std::string const& type_name) const;
+        counter_type_map_type::iterator locate_counter_type(
+            std::string const& type_name);
+        counter_type_map_type::const_iterator locate_counter_type(
+            std::string const& type_name) const;
 
     private:
         counter_type_map_type countertypes_;
     };
-}}
+}}    // namespace hpx::performance_counters
 
 #endif
-
diff --git a/hpx/performance_counters/server/arithmetics_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/server/arithmetics_counter.hpp
similarity index 76%
rename from hpx/performance_counters/server/arithmetics_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/server/arithmetics_counter.hpp
index 71f56a7cde..8974f71b0f 100644
--- a/hpx/performance_counters/server/arithmetics_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/server/arithmetics_counter.hpp
@@ -4,7 +4,8 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_PERFORMANCE_COUNTERS_SERVER_ARITHMETICS_COUNTER_APR_10_2013_1002AM)
+#if !defined(                                                                  \
+    HPX_PERFORMANCE_COUNTERS_SERVER_ARITHMETICS_COUNTER_APR_10_2013_1002AM)
 #define HPX_PERFORMANCE_COUNTERS_SERVER_ARITHMETICS_COUNTER_APR_10_2013_1002AM
 
 #include <hpx/config.hpp>
@@ -17,18 +18,17 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     ///////////////////////////////////////////////////////////////////////////
     // This counter exposes the result of an arithmetic operation The counter
     // relies on querying two base counters.
     template <typename Operation>
     class arithmetics_counter
-      : public base_performance_counter,
-        public components::component_base<arithmetics_counter<Operation> >
+      : public base_performance_counter
+      , public components::component_base<arithmetics_counter<Operation>>
     {
-        typedef components::component_base<
-            arithmetics_counter<Operation> > base_type;
+        typedef components::component_base<arithmetics_counter<Operation>>
+            base_type;
 
     public:
         typedef arithmetics_counter type_holder;
@@ -40,8 +40,8 @@ namespace hpx { namespace performance_counters { namespace server
             std::vector<std::string> const& base_counter_names);
 
         /// Overloads from the base_counter base class.
-        hpx::performance_counters::counter_value
-            get_counter_value(bool reset = false);
+        hpx::performance_counters::counter_value get_counter_value(
+            bool reset = false);
 
         bool start();
         bool stop();
@@ -57,6 +57,6 @@ namespace hpx { namespace performance_counters { namespace server
         // base counters to be queried
         performance_counter_set counters_;
     };
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 #endif
diff --git a/hpx/performance_counters/server/arithmetics_counter_extended.hpp b/libs/performance_counters/include/hpx/performance_counters/server/arithmetics_counter_extended.hpp
similarity index 83%
rename from hpx/performance_counters/server/arithmetics_counter_extended.hpp
rename to libs/performance_counters/include/hpx/performance_counters/server/arithmetics_counter_extended.hpp
index a699e6cfc8..9c410f60c2 100644
--- a/hpx/performance_counters/server/arithmetics_counter_extended.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/server/arithmetics_counter_extended.hpp
@@ -18,19 +18,19 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     ///////////////////////////////////////////////////////////////////////////
     // This counter exposes the result of an arithmetic operation The counter
     // relies on querying two base counters.
     template <typename Statistic>
     class arithmetics_counter_extended
-      : public base_performance_counter,
-        public components::component_base<
-            arithmetics_counter_extended<Statistic> >
+      : public base_performance_counter
+      , public components::component_base<
+            arithmetics_counter_extended<Statistic>>
     {
         typedef components::component_base<
-            arithmetics_counter_extended<Statistic> > base_type;
+            arithmetics_counter_extended<Statistic>>
+            base_type;
 
     public:
         typedef arithmetics_counter_extended type_holder;
@@ -42,8 +42,8 @@ namespace hpx { namespace performance_counters { namespace server
             std::vector<std::string> const& base_counter_names);
 
         /// Overloads from the base_counter base class.
-        hpx::performance_counters::counter_value
-            get_counter_value(bool reset = false);
+        hpx::performance_counters::counter_value get_counter_value(
+            bool reset = false);
 
         bool start();
         bool stop();
@@ -59,6 +59,6 @@ namespace hpx { namespace performance_counters { namespace server
         // base counters to be queried
         performance_counter_set counters_;
     };
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 #endif
diff --git a/hpx/performance_counters/server/base_performance_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/server/base_performance_counter.hpp
similarity index 82%
rename from hpx/performance_counters/server/base_performance_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/server/base_performance_counter.hpp
index 29bdf45d47..4834a4af5f 100644
--- a/hpx/performance_counters/server/base_performance_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/server/base_performance_counter.hpp
@@ -18,11 +18,10 @@
 #include <hpx/thread_support/atomic_count.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     class base_performance_counter
-        : public hpx::performance_counters::performance_counter_base,
-          public hpx::traits::detail::component_tag
+      : public hpx::performance_counters::performance_counter_base
+      , public hpx::traits::detail::component_tag
     {
     protected:
         /// the following functions are not implemented by default, they will
@@ -65,9 +64,7 @@ namespace hpx { namespace performance_counters { namespace server
             return false;    // nothing to do
         }
 
-        virtual void reinit(bool /*reset*/) override
-        {
-        }
+        virtual void reinit(bool /*reset*/) override {}
 
         virtual counter_info get_counter_info() const override
         {
@@ -88,15 +85,12 @@ namespace hpx { namespace performance_counters { namespace server
         // components must contain a typedef for wrapping_type defining the
         // component type used to encapsulate instances of this
         // component
-        typedef components::component<base_performance_counter>
-            wrapping_type;
+        typedef components::component<base_performance_counter> wrapping_type;
         typedef base_performance_counter base_type_holder;
 
         /// \brief finalize() will be called just before the instance gets
         ///        destructed
-        void finalize()
-        {
-        }
+        void finalize() {}
 
         static components::component_type get_component_type()
         {
@@ -165,8 +159,7 @@ namespace hpx { namespace performance_counters { namespace server
         /// The \a get_counter_value_action queries the value of a performance
         /// counter.
         HPX_DEFINE_COMPONENT_ACTION(base_performance_counter,
-            get_counter_values_array_nonvirt,
-            get_counter_values_array_action);
+            get_counter_values_array_nonvirt, get_counter_values_array_action);
 
         /// The \a set_counter_value_action
         HPX_DEFINE_COMPONENT_ACTION(base_performance_counter,
@@ -192,46 +185,41 @@ namespace hpx { namespace performance_counters { namespace server
         hpx::performance_counters::counter_info info_;
         util::atomic_count invocation_count_;
     };
-}}}
+}}}    // namespace hpx::performance_counters::server
 
-HPX_ACTION_HAS_CRITICAL_PRIORITY(
-    hpx::performance_counters::server::base_performance_counter
-    ::get_counter_info_action)
+HPX_ACTION_HAS_CRITICAL_PRIORITY(hpx::performance_counters::server::
+        base_performance_counter ::get_counter_info_action)
 HPX_REGISTER_ACTION_DECLARATION(
-    hpx::performance_counters::server::base_performance_counter
-    ::get_counter_info_action,
+    hpx::performance_counters::server::base_performance_counter ::
+        get_counter_info_action,
     performance_counter_get_counter_info_action)
 
-HPX_ACTION_HAS_CRITICAL_PRIORITY(
-    hpx::performance_counters::server::base_performance_counter
-    ::get_counter_value_action)
+HPX_ACTION_HAS_CRITICAL_PRIORITY(hpx::performance_counters::server::
+        base_performance_counter ::get_counter_value_action)
 HPX_REGISTER_ACTION_DECLARATION(
-    hpx::performance_counters::server::base_performance_counter
-    ::get_counter_value_action,
+    hpx::performance_counters::server::base_performance_counter ::
+        get_counter_value_action,
     performance_counter_get_counter_value_action)
 
-HPX_ACTION_HAS_CRITICAL_PRIORITY(
-    hpx::performance_counters::server::base_performance_counter
-    ::get_counter_values_array_action)
+HPX_ACTION_HAS_CRITICAL_PRIORITY(hpx::performance_counters::server::
+        base_performance_counter ::get_counter_values_array_action)
 HPX_REGISTER_ACTION_DECLARATION(
-    hpx::performance_counters::server::base_performance_counter
-    ::get_counter_values_array_action,
+    hpx::performance_counters::server::base_performance_counter ::
+        get_counter_values_array_action,
     performance_counter_get_counter_values_array_action)
 
-HPX_ACTION_HAS_CRITICAL_PRIORITY(
-    hpx::performance_counters::server::base_performance_counter
-    ::set_counter_value_action)
+HPX_ACTION_HAS_CRITICAL_PRIORITY(hpx::performance_counters::server::
+        base_performance_counter ::set_counter_value_action)
 HPX_REGISTER_ACTION_DECLARATION(
-    hpx::performance_counters::server::base_performance_counter
-    ::set_counter_value_action,
+    hpx::performance_counters::server::base_performance_counter ::
+        set_counter_value_action,
     performance_counter_set_counter_value_action)
 
-HPX_ACTION_HAS_CRITICAL_PRIORITY(
-    hpx::performance_counters::server::base_performance_counter
-    ::reset_counter_value_action)
+HPX_ACTION_HAS_CRITICAL_PRIORITY(hpx::performance_counters::server::
+        base_performance_counter ::reset_counter_value_action)
 HPX_REGISTER_ACTION_DECLARATION(
-    hpx::performance_counters::server::base_performance_counter
-    ::reset_counter_value_action,
+    hpx::performance_counters::server::base_performance_counter ::
+        reset_counter_value_action,
     performance_counter_reset_counter_value_action)
 
 HPX_ACTION_HAS_CRITICAL_PRIORITY(
@@ -254,4 +242,3 @@ HPX_REGISTER_BASE_LCO_WITH_VALUE_DECLARATION(
     hpx::performance_counters::counter_values_array, hpx_counter_values_array)
 
 #endif
-
diff --git a/hpx/performance_counters/server/elapsed_time_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/server/elapsed_time_counter.hpp
similarity index 75%
rename from hpx/performance_counters/server/elapsed_time_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/server/elapsed_time_counter.hpp
index e665f8c315..895cfc4401 100644
--- a/hpx/performance_counters/server/elapsed_time_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/server/elapsed_time_counter.hpp
@@ -4,7 +4,8 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_PERFORMANCE_COUNTERS_SERVER_ELAPSED_TIME_COUNTER_SEP_18_2011_1133AM)
+#if !defined(                                                                  \
+    HPX_PERFORMANCE_COUNTERS_SERVER_ELAPSED_TIME_COUNTER_SEP_18_2011_1133AM)
 #define HPX_PERFORMANCE_COUNTERS_SERVER_ELAPSED_TIME_COUNTER_SEP_18_2011_1133AM
 
 #include <hpx/config.hpp>
@@ -13,11 +14,10 @@
 #include <hpx/timing/high_resolution_timer.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     class HPX_EXPORT elapsed_time_counter
-      : public base_performance_counter,
-        public components::component_base<elapsed_time_counter>
+      : public base_performance_counter
+      , public components::component_base<elapsed_time_counter>
     {
         typedef components::component_base<elapsed_time_counter> base_type;
 
@@ -31,8 +31,14 @@ namespace hpx { namespace performance_counters { namespace server
         hpx::performance_counters::counter_value get_counter_value(bool reset);
         void reset_counter_value();
 
-        bool start() { return false; }
-        bool stop() { return false; }
+        bool start()
+        {
+            return false;
+        }
+        bool stop()
+        {
+            return false;
+        }
 
         /// \brief finalize() will be called just before the instance gets
         ///        destructed
@@ -42,6 +48,6 @@ namespace hpx { namespace performance_counters { namespace server
             base_type::finalize();
         }
     };
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 #endif
diff --git a/hpx/performance_counters/server/raw_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/server/raw_counter.hpp
similarity index 84%
rename from hpx/performance_counters/server/raw_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/server/raw_counter.hpp
index de2a5c2687..86d26b34f7 100644
--- a/hpx/performance_counters/server/raw_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/server/raw_counter.hpp
@@ -8,18 +8,17 @@
 #define HPX_PERFORMANCE_COUNTERS_SERVER_RAW_COUNTER_MAR_03_2009_0743M
 
 #include <hpx/config.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/server/base_performance_counter.hpp>
 #include <hpx/runtime/components/server/component_base.hpp>
-#include <hpx/functional/function.hpp>
 
 #include <cstdint>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     class HPX_EXPORT raw_counter
-      : public base_performance_counter,
-        public components::component_base<raw_counter>
+      : public base_performance_counter
+      , public components::component_base<raw_counter>
     {
         typedef components::component_base<raw_counter> base_type;
 
@@ -29,13 +28,14 @@ namespace hpx { namespace performance_counters { namespace server
 
         raw_counter()
           : reset_(false)
-        {}
+        {
+        }
 
         raw_counter(counter_info const& info,
             hpx::util::function_nonser<std::int64_t(bool)> f);
 
-        hpx::performance_counters::counter_value
-            get_counter_value(bool reset = false);
+        hpx::performance_counters::counter_value get_counter_value(
+            bool reset = false);
         void reset_counter_value();
 
         /// \brief finalize() will be called just before the instance gets
@@ -50,6 +50,6 @@ namespace hpx { namespace performance_counters { namespace server
         hpx::util::function_nonser<std::int64_t(bool)> f_;
         bool reset_;
     };
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 #endif
diff --git a/hpx/performance_counters/server/raw_values_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/server/raw_values_counter.hpp
similarity index 80%
rename from hpx/performance_counters/server/raw_values_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/server/raw_values_counter.hpp
index a14369ab6c..7f57c13b30 100644
--- a/hpx/performance_counters/server/raw_values_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/server/raw_values_counter.hpp
@@ -4,23 +4,23 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_PERFORMANCE_COUNTERS_SERVER_RAW_VALUES_COUNTER_JUL_16_2016_1019AM)
+#if !defined(                                                                  \
+    HPX_PERFORMANCE_COUNTERS_SERVER_RAW_VALUES_COUNTER_JUL_16_2016_1019AM)
 #define HPX_PERFORMANCE_COUNTERS_SERVER_RAW_VALUES_COUNTER_JUL_16_2016_1019AM
 
 #include <hpx/config.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/server/base_performance_counter.hpp>
 #include <hpx/runtime/components/server/component_base.hpp>
-#include <hpx/functional/function.hpp>
 
 #include <cstdint>
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     class HPX_EXPORT raw_values_counter
-      : public base_performance_counter,
-        public components::component_base<raw_values_counter>
+      : public base_performance_counter
+      , public components::component_base<raw_values_counter>
     {
         typedef components::component_base<raw_values_counter> base_type;
 
@@ -30,13 +30,14 @@ namespace hpx { namespace performance_counters { namespace server
 
         raw_values_counter()
           : reset_(false)
-        {}
+        {
+        }
 
         raw_values_counter(counter_info const& info,
             hpx::util::function_nonser<std::vector<std::int64_t>(bool)> f);
 
         hpx::performance_counters::counter_values_array
-            get_counter_values_array(bool reset = false);
+        get_counter_values_array(bool reset = false);
         void reset_counter_value();
 
         /// \brief finalize() will be called just before the instance gets
@@ -51,6 +52,6 @@ namespace hpx { namespace performance_counters { namespace server
         hpx::util::function_nonser<std::vector<std::int64_t>(bool)> f_;
         bool reset_;
     };
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 #endif
diff --git a/hpx/performance_counters/server/statistics_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/server/statistics_counter.hpp
similarity index 73%
rename from hpx/performance_counters/server/statistics_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/server/statistics_counter.hpp
index c56a499aea..0eca965aea 100644
--- a/hpx/performance_counters/server/statistics_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/server/statistics_counter.hpp
@@ -4,14 +4,15 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if !defined(HPX_PERFORMANCE_COUNTERS_SERVER_AVERAGE_COUNT_COUNTER_SEP_30_2011_1045AM)
+#if !defined(                                                                  \
+    HPX_PERFORMANCE_COUNTERS_SERVER_AVERAGE_COUNT_COUNTER_SEP_30_2011_1045AM)
 #define HPX_PERFORMANCE_COUNTERS_SERVER_AVERAGE_COUNT_COUNTER_SEP_30_2011_1045AM
 
 #include <hpx/config.hpp>
-#include <hpx/synchronization/spinlock.hpp>
 #include <hpx/performance_counters/server/base_performance_counter.hpp>
 #include <hpx/runtime/components/server/component_base.hpp>
 #include <hpx/runtime/naming/id_type.hpp>
+#include <hpx/synchronization/spinlock.hpp>
 #include <hpx/util/interval_timer.hpp>
 
 #include <cstddef>
@@ -20,10 +21,8 @@
 #include <string>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
-    namespace detail
-    {
+namespace hpx { namespace performance_counters { namespace server {
+    namespace detail {
         struct counter_type_from_statistic_base
         {
             virtual ~counter_type_from_statistic_base() {}
@@ -32,7 +31,7 @@ namespace hpx { namespace performance_counters { namespace server
             virtual double get_value() = 0;
             virtual void add_value(double value) = 0;
         };
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
     // This counter exposes the average count of items processed during the
@@ -40,14 +39,17 @@ namespace hpx { namespace performance_counters { namespace server
     // growing counter value.
     template <typename Statistic>
     class statistics_counter
-      : public base_performance_counter,
-        public components::component_base<statistics_counter<Statistic> >
+      : public base_performance_counter
+      , public components::component_base<statistics_counter<Statistic>>
     {
-        typedef components::component_base<
-            statistics_counter<Statistic> > base_type;
+        typedef components::component_base<statistics_counter<Statistic>>
+            base_type;
 
         // avoid warnings about using this in member initializer list
-        statistics_counter* this_() { return this; }
+        statistics_counter* this_()
+        {
+            return this;
+        }
 
     public:
         typedef statistics_counter type_holder;
@@ -58,16 +60,16 @@ namespace hpx { namespace performance_counters { namespace server
           , parameter1_(0)
           , parameter2_(0)
           , reset_base_counter_(false)
-        {}
+        {
+        }
 
         statistics_counter(counter_info const& info,
-            std::string const& base_counter_name,
-            std::size_t parameter1, std::size_t parameter2,
-            bool reset_base_counter);
+            std::string const& base_counter_name, std::size_t parameter1,
+            std::size_t parameter2, bool reset_base_counter);
 
         /// Overloads from the base_counter base class.
-        hpx::performance_counters::counter_value
-            get_counter_value(bool reset = false) override;
+        hpx::performance_counters::counter_value get_counter_value(
+            bool reset = false) override;
 
         bool start() override;
 
@@ -94,8 +96,10 @@ namespace hpx { namespace performance_counters { namespace server
         typedef lcos::local::spinlock mutex_type;
         mutable mutex_type mtx_;
 
-        hpx::util::interval_timer timer_; ///< base time interval in milliseconds
-        std::string base_counter_name_;   ///< name of base counter to be queried
+        hpx::util::interval_timer
+            timer_;    ///< base time interval in milliseconds
+        std::string
+            base_counter_name_;    ///< name of base counter to be queried
         naming::id_type base_counter_id_;
 
         std::unique_ptr<detail::counter_type_from_statistic_base> value_;
@@ -105,6 +109,6 @@ namespace hpx { namespace performance_counters { namespace server
         std::size_t parameter1_, parameter2_;
         bool reset_base_counter_;
     };
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 #endif
diff --git a/hpx/performance_counters/stubs/performance_counter.hpp b/libs/performance_counters/include/hpx/performance_counters/stubs/performance_counter.hpp
similarity index 74%
rename from hpx/performance_counters/stubs/performance_counter.hpp
rename to libs/performance_counters/include/hpx/performance_counters/stubs/performance_counter.hpp
index 55e62fd40e..6333b5384d 100644
--- a/hpx/performance_counters/stubs/performance_counter.hpp
+++ b/libs/performance_counters/include/hpx/performance_counters/stubs/performance_counter.hpp
@@ -13,8 +13,7 @@
 #include <hpx/runtime/launch_policy.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace stubs
-{
+namespace hpx { namespace performance_counters { namespace stubs {
     ///////////////////////////////////////////////////////////////////////////
     struct HPX_EXPORT performance_counter
       : components::stub_base<
@@ -27,11 +26,11 @@ namespace hpx { namespace performance_counters { namespace stubs
             naming::id_type const& targetid, bool reset = false,
             error_code& ec = throws);
         static counter_values_array get_values_array(launch::sync_policy,
-            naming::id_type const& targetid,
-            bool reset = false, error_code& ec = throws);
+            naming::id_type const& targetid, bool reset = false,
+            error_code& ec = throws);
 
-        static lcos::future<counter_info> get_info(launch::async_policy,
-            naming::id_type const& targetid);
+        static lcos::future<counter_info> get_info(
+            launch::async_policy, naming::id_type const& targetid);
         static lcos::future<counter_value> get_value(launch::async_policy,
             naming::id_type const& targetid, bool reset = false);
         static lcos::future<counter_values_array> get_values_array(
@@ -39,14 +38,14 @@ namespace hpx { namespace performance_counters { namespace stubs
             bool reset = false);
 
         ///////////////////////////////////////////////////////////////////////
-        static lcos::future<bool> start(launch::async_policy,
-            naming::id_type const& targetid);
-        static lcos::future<bool> stop(launch::async_policy,
-            naming::id_type const& targetid);
-        static lcos::future<void> reset(launch::async_policy,
-            naming::id_type const& targetid);
-        static lcos::future<void> reinit(launch::async_policy,
-            naming::id_type const& targetid, bool reset);
+        static lcos::future<bool> start(
+            launch::async_policy, naming::id_type const& targetid);
+        static lcos::future<bool> stop(
+            launch::async_policy, naming::id_type const& targetid);
+        static lcos::future<void> reset(
+            launch::async_policy, naming::id_type const& targetid);
+        static lcos::future<void> reinit(
+            launch::async_policy, naming::id_type const& targetid, bool reset);
 
         static bool start(launch::sync_policy, naming::id_type const& targetid,
             error_code& ec = throws);
@@ -58,14 +57,13 @@ namespace hpx { namespace performance_counters { namespace stubs
             bool reset, error_code& ec = throws);
 
         template <typename T>
-        static T
-        get_typed_value(naming::id_type const& targetid, bool reset = false,
-            error_code& ec = throws)
+        static T get_typed_value(naming::id_type const& targetid,
+            bool reset = false, error_code& ec = throws)
         {
             counter_value value = get_value(launch::sync, targetid, reset);
             return value.get_value<T>(ec);
         }
     };
-}}}
+}}}    // namespace hpx::performance_counters::stubs
 
 #endif
diff --git a/src/performance_counters/counter_creators.cpp b/libs/performance_counters/src/counter_creators.cpp
similarity index 81%
rename from src/performance_counters/counter_creators.cpp
rename to libs/performance_counters/src/counter_creators.cpp
index b18a52ecc7..f45eb48222 100644
--- a/src/performance_counters/counter_creators.cpp
+++ b/libs/performance_counters/src/counter_creators.cpp
@@ -6,24 +6,23 @@
 
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/lcos/async.hpp>
-#include <hpx/runtime/naming/name.hpp>
+#include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
+#include <hpx/runtime/agas/namespace_action_code.hpp>
 #include <hpx/runtime/agas/server/component_namespace.hpp>
 #include <hpx/runtime/agas/server/locality_namespace.hpp>
-#include <hpx/runtime/agas/server/symbol_namespace.hpp>
 #include <hpx/runtime/agas/server/primary_namespace.hpp>
-#include <hpx/runtime/agas/namespace_action_code.hpp>
-#include <hpx/performance_counters/counters.hpp>
-#include <hpx/performance_counters/counter_creators.hpp>
-#include <hpx/functional/function.hpp>
+#include <hpx/runtime/agas/server/symbol_namespace.hpp>
+#include <hpx/runtime/naming/name.hpp>
 
 #include <cstdint>
 #include <string>
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     // Creation functions to be registered with counter types
 
@@ -31,8 +30,8 @@ namespace hpx { namespace performance_counters
     /// with the counter types. It will pass the \a counter_info and the
     /// \a error_code to the supplied function.
     bool default_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec)
     {
         return f(info, ec);
     }
@@ -44,8 +43,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>{locality#<locality_id>/total}/<instancename>
     ///
     bool locality_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec)
     {
         performance_counters::counter_info i = info;
 
@@ -53,7 +52,8 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         if (mode == discover_counters_minimal ||
             p.parentinstancename_.empty() || p.instancename_.empty())
@@ -74,7 +74,8 @@ namespace hpx { namespace performance_counters
             if (!status_is_valid(status) || !f(i, ec) || ec)
                 return false;
         }
-        else if (!f(i, ec) || ec) {
+        else if (!f(i, ec) || ec)
+        {
             return false;
         }
 
@@ -91,8 +92,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>(locality#<locality_id>/pool#<pool_name>/total)/<instancename>
     ///
     bool locality_pool_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec)
     {
         performance_counters::counter_info i = info;
 
@@ -100,7 +101,8 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         if (mode == discover_counters_minimal ||
             p.parentinstancename_.empty() || p.instancename_.empty())
@@ -136,7 +138,8 @@ namespace hpx { namespace performance_counters
             if (!status_is_valid(status) || !f(i, ec) || ec)
                 return false;
         }
-        else if (!f(i, ec) || ec) {
+        else if (!f(i, ec) || ec)
+        {
             return false;
         }
 
@@ -153,8 +156,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>{locality#0/total}/<instancename>
     ///
     bool locality0_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec)
     {
         performance_counters::counter_info i = info;
 
@@ -162,7 +165,8 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         // restrict to locality zero
         if (p.parentinstancename_ == "locality#*")
@@ -204,8 +208,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>{locality#<locality_id>/thread#<threadnum>}/<instancename>
     ///
     bool locality_thread_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec)
     {
         performance_counters::counter_info i = info;
 
@@ -213,7 +217,8 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         if (mode == discover_counters_minimal ||
             p.parentinstancename_.empty() || p.instancename_.empty())
@@ -241,7 +246,8 @@ namespace hpx { namespace performance_counters
             if (!status_is_valid(status) || !f(i, ec) || ec)
                 return false;
         }
-        else if (!f(i, ec) || ec) {
+        else if (!f(i, ec) || ec)
+        {
             return false;
         }
 
@@ -258,8 +264,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>{locality#<locality_id>/pool#<pool_name>/thread#<threadnum>}/<instancename>
     ///
     bool locality_pool_thread_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec)
     {
         performance_counters::counter_info i = info;
 
@@ -267,7 +273,8 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         if (mode == discover_counters_minimal ||
             p.parentinstancename_.empty() || p.instancename_.empty() ||
@@ -304,7 +311,8 @@ namespace hpx { namespace performance_counters
             if (!status_is_valid(status) || !f(i, ec) || ec)
                 return false;
         }
-        else if (!f(i, ec) || ec) {
+        else if (!f(i, ec) || ec)
+        {
             return false;
         }
 
@@ -332,7 +340,8 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         if (mode == discover_counters_minimal ||
             p.parentinstancename_.empty() || p.instancename_.empty() ||
@@ -354,7 +363,8 @@ namespace hpx { namespace performance_counters
             if (!status_is_valid(status) || !f(i, ec) || ec)
                 return false;
         }
-        else if (!f(i, ec) || ec) {
+        else if (!f(i, ec) || ec)
+        {
             return false;
         }
 
@@ -371,8 +381,8 @@ namespace hpx { namespace performance_counters
     ///   /<objectname>(locality#<locality_id>/numa#<threadnum>)/<instancename>
     ///
     bool locality_numa_counter_discoverer(counter_info const& info,
-        discover_counter_func const& f,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func const& f, discover_counters_mode mode,
+        error_code& ec)
     {
         performance_counters::counter_info i = info;
 
@@ -380,7 +390,8 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         if (mode == discover_counters_minimal ||
             p.parentinstancename_.empty() || p.instancename_.empty())
@@ -408,7 +419,8 @@ namespace hpx { namespace performance_counters
             if (!status_is_valid(status) || !f(i, ec) || ec)
                 return false;
         }
-        else if (!f(i, ec) || ec) {
+        else if (!f(i, ec) || ec)
+        {
             return false;
         }
 
@@ -431,9 +443,11 @@ namespace hpx { namespace performance_counters
         // verify the validity of the counter instance name
         counter_path_elements paths;
         get_counter_path_elements(info.fullname_, paths, ec);
-        if (ec) return naming::invalid_gid;
+        if (ec)
+            return naming::invalid_gid;
 
-        if (paths.parentinstance_is_basename_) {
+        if (paths.parentinstance_is_basename_)
+        {
             HPX_THROWS_IF(ec, bad_parameter, "locality_raw_counter_creator",
                 "invalid counter instance parent name: " +
                     paths.parentinstancename_);
@@ -441,33 +455,38 @@ namespace hpx { namespace performance_counters
         }
 
         if (paths.instancename_ == "total" && paths.instanceindex_ == -1)
-            return detail::create_raw_counter(info, f, ec);   // overall counter
+            return detail::create_raw_counter(
+                info, f, ec);    // overall counter
 
         HPX_THROWS_IF(ec, bad_parameter, "locality_raw_counter_creator",
             "invalid counter instance name: " + paths.instancename_);
         return naming::invalid_gid;
     }
 
-    naming::gid_type locality_raw_values_counter_creator(counter_info const& info,
+    naming::gid_type locality_raw_values_counter_creator(
+        counter_info const& info,
         hpx::util::function_nonser<std::vector<std::int64_t>(bool)> const& f,
         error_code& ec)
     {
         // verify the validity of the counter instance name
         counter_path_elements paths;
         get_counter_path_elements(info.fullname_, paths, ec);
-        if (ec) return naming::invalid_gid;
+        if (ec)
+            return naming::invalid_gid;
 
-        if (paths.parentinstance_is_basename_) {
+        if (paths.parentinstance_is_basename_)
+        {
             HPX_THROWS_IF(ec, bad_parameter,
                 "locality_raw_values_counter_creator",
-                    "invalid counter instance parent name: " +
+                "invalid counter instance parent name: " +
                     paths.parentinstancename_);
             return naming::invalid_gid;
         }
 
         if (paths.instancename_ == "total" && paths.instanceindex_ == -1)
         {
-            return detail::create_raw_counter(info, f, ec);   // overall counter
+            return detail::create_raw_counter(
+                info, f, ec);    // overall counter
         }
 
         HPX_THROWS_IF(ec, bad_parameter, "locality_raw_values_counter_creator",
@@ -475,8 +494,7 @@ namespace hpx { namespace performance_counters
         return naming::invalid_gid;
     }
 
-    namespace detail
-    {
+    namespace detail {
         naming::gid_type retrieve_agas_counter(std::string const& name,
             naming::id_type const& agas_id, error_code& ec)
         {
@@ -485,42 +503,44 @@ namespace hpx { namespace performance_counters
             //  get action code from counter type
             agas::namespace_action_code service_code =
                 agas::detail::retrieve_action_service_code(name, ec);
-            if (agas::invalid_request == service_code) return id;
-
-            switch (service_code) {
-                case agas::component_ns_statistics_counter:
-                    {
-                        agas::server::component_namespace::statistics_counter_action
-                        action;
-                        return action(agas_id, name).get_gid();
-                    }
-                case agas::locality_ns_statistics_counter:
-                    {
-                        agas::server::locality_namespace::statistics_counter_action
-                        action;
-                        return action(agas_id, name).get_gid();
-                    }
-                case agas::symbol_ns_statistics_counter:
-                    {
-                        agas::server::symbol_namespace::statistics_counter_action
-                        action;
-                        return action(agas_id, name).get_gid();
-                    }
-                case agas::primary_ns_statistics_counter:
-                    {
-                        agas::server::primary_namespace::statistics_counter_action
-                        action;
-                        return action(agas_id, name).get_gid();
-                    }
-                default:
-                    HPX_THROWS_IF(ec, bad_parameter, "retrieve_statistics_counter",
-                        "unknown counter agas counter name: " + name);
-                    break;
+            if (agas::invalid_request == service_code)
+                return id;
+
+            switch (service_code)
+            {
+            case agas::component_ns_statistics_counter:
+            {
+                agas::server::component_namespace::statistics_counter_action
+                    action;
+                return action(agas_id, name).get_gid();
+            }
+            case agas::locality_ns_statistics_counter:
+            {
+                agas::server::locality_namespace::statistics_counter_action
+                    action;
+                return action(agas_id, name).get_gid();
+            }
+            case agas::symbol_ns_statistics_counter:
+            {
+                agas::server::symbol_namespace::statistics_counter_action
+                    action;
+                return action(agas_id, name).get_gid();
+            }
+            case agas::primary_ns_statistics_counter:
+            {
+                agas::server::primary_namespace::statistics_counter_action
+                    action;
+                return action(agas_id, name).get_gid();
+            }
+            default:
+                HPX_THROWS_IF(ec, bad_parameter, "retrieve_statistics_counter",
+                    "unknown counter agas counter name: " + name);
+                break;
             }
 
             return id;
         }
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
     /// Creation function for raw AGAS counters. This function checks the
@@ -528,20 +548,23 @@ namespace hpx { namespace performance_counters
     ///
     ///   /agas(<objectinstance>/total)/<instancename>
     ///
-    naming::gid_type agas_raw_counter_creator(
-        counter_info const& info, error_code& ec, char const* const service_name)
+    naming::gid_type agas_raw_counter_creator(counter_info const& info,
+        error_code& ec, char const* const service_name)
     {
         // verify the validity of the counter instance name
         counter_path_elements paths;
         get_counter_path_elements(info.fullname_, paths, ec);
-        if (ec) return naming::invalid_gid;
+        if (ec)
+            return naming::invalid_gid;
 
-        if (paths.objectname_ != "agas") {
+        if (paths.objectname_ != "agas")
+        {
             HPX_THROWS_IF(ec, bad_parameter, "agas_raw_counter_creator",
                 "unknown performance counter (unrelated to AGAS)");
             return naming::invalid_gid;
         }
-        if (paths.parentinstance_is_basename_) {
+        if (paths.parentinstance_is_basename_)
+        {
             HPX_THROWS_IF(ec, bad_parameter, "agas_raw_counter_creator",
                 "invalid counter instance parent name: " +
                     paths.parentinstancename_);
@@ -556,7 +579,8 @@ namespace hpx { namespace performance_counters
             std::string service(agas::service_name);
             service += paths.parentinstancename_;
 
-            if (-1 == paths.parentinstanceindex_) {
+            if (-1 == paths.parentinstanceindex_)
+            {
                 HPX_THROWS_IF(ec, bad_parameter, "agas_raw_counter_creator",
                     "invalid parent instance index: -1");
                 return naming::invalid_gid;
@@ -568,9 +592,9 @@ namespace hpx { namespace performance_counters
             service += service_name;
 
             naming::id_type id = agas::resolve_name(launch::sync, service, ec);
-            if (id == naming::invalid_id) {
-                HPX_THROWS_IF(ec, not_implemented,
-                    "agas_raw_counter_creator",
+            if (id == naming::invalid_id)
+            {
+                HPX_THROWS_IF(ec, not_implemented, "agas_raw_counter_creator",
                     "invalid counter name: " +
                         remove_counter_prefix(info.fullname_));
                 return naming::invalid_gid;
@@ -583,4 +607,4 @@ namespace hpx { namespace performance_counters
             "invalid counter type name: " + paths.instancename_);
         return naming::invalid_gid;
     }
-}}
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/counter_parser.cpp b/libs/performance_counters/src/counter_parser.cpp
similarity index 53%
rename from src/performance_counters/counter_parser.cpp
rename to libs/performance_counters/src/counter_parser.cpp
index 66156454b4..85af513efb 100644
--- a/src/performance_counters/counter_parser.cpp
+++ b/libs/performance_counters/src/counter_parser.cpp
@@ -22,30 +22,19 @@
 
 #include <string>
 
-BOOST_FUSION_ADAPT_STRUCT(
-    hpx::performance_counters::instance_name,
-    (std::string, name_)
-    (std::string, index_)
-    (bool, basename_)
-)
+BOOST_FUSION_ADAPT_STRUCT(hpx::performance_counters::instance_name,
+    (std::string, name_)(std::string, index_)(bool, basename_))
 
-BOOST_FUSION_ADAPT_STRUCT(
-    hpx::performance_counters::instance_elements,
-    (hpx::performance_counters::instance_name, parent_)
-    (hpx::performance_counters::instance_name, child_)
-    (hpx::performance_counters::instance_name, subchild_)
-)
+BOOST_FUSION_ADAPT_STRUCT(hpx::performance_counters::instance_elements,
+    (hpx::performance_counters::instance_name, parent_)(
+        hpx::performance_counters::instance_name, child_)(
+        hpx::performance_counters::instance_name, subchild_))
 
-BOOST_FUSION_ADAPT_STRUCT(
-    hpx::performance_counters::path_elements,
-    (std::string, object_)
-    (hpx::performance_counters::instance_elements, instance_)
-    (std::string, counter_)
-    (std::string, parameters_)
-)
+BOOST_FUSION_ADAPT_STRUCT(hpx::performance_counters::path_elements,
+    (std::string, object_)(hpx::performance_counters::instance_elements,
+        instance_)(std::string, counter_)(std::string, parameters_))
 
-namespace
-{
+namespace {
     ///
     ///    /objectname{parentinstancename#parentindex/instancename#instanceindex}
     ///       /countername#parameters
@@ -61,49 +50,45 @@ namespace
         path_parser()
           : path_parser::base_type(start)
         {
-            start = -qi::lit(hpx::performance_counters::counter_prefix)
-                >> '/' >> +~qi::char_("/{#@") >> -instance
-                >> -('/' >>  +~qi::char_("#}@")) >> -('@' >> +qi::char_);
+            start = -qi::lit(hpx::performance_counters::counter_prefix) >>
+                '/' >> +~qi::char_("/{#@") >> -instance >>
+                -('/' >> +~qi::char_("#}@")) >> -('@' >> +qi::char_);
             instance =
-                    '{' >> parent >> -('/' >> child) >> -('/' >> subchild) >> '}'
-                ;
-            parent =
-                    &qi::lit('/') >> qi::raw[start] >> qi::attr(-1) >> qi::attr(true)
-                    // base counter
-                |  +~qi::char_("#/}")
-                    >>  (   '#' >> raw_uint     // counter parent-instance name
-                        |  -qi::string("#*")    // counter parent-instance skeleton name
-                        )
-                    >> qi::attr(false)
-                ;
-            child =
-                   +~qi::char_("#/}")
-                    >>  (   qi::char_('#') >> +~qi::char_("/}") // counter instance name
-                        |  -qi::string("#*")    // counter instance skeleton name
-                        )
-                    >> qi::attr(false)
-                ;
-            subchild =
-                   +~qi::char_("#}")
-                    >>  (   '#' >> raw_uint     // counter (sub-)instance name
-                        |  -qi::string("#*")    // counter (sub-)instance skeleton name
-                        )
-                    >> qi::attr(false)
-                ;
+                '{' >> parent >> -('/' >> child) >> -('/' >> subchild) >> '}';
+            parent = &qi::lit('/') >> qi::raw[start] >> qi::attr(-1) >>
+                    qi::attr(true)
+                // base counter
+                | +~qi::char_("#/}") >>
+                    ('#' >> raw_uint    // counter parent-instance name
+                        | -qi::string(
+                              "#*")    // counter parent-instance skeleton name
+                        ) >>
+                    qi::attr(false);
+            child = +~qi::char_("#/}") >>
+                (qi::char_('#') >> +~qi::char_("/}")    // counter instance name
+                    | -qi::string("#*")    // counter instance skeleton name
+                    ) >>
+                qi::attr(false);
+            subchild = +~qi::char_("#}") >>
+                ('#' >> raw_uint    // counter (sub-)instance name
+                    |
+                    -qi::string("#*")    // counter (sub-)instance skeleton name
+                    ) >>
+                qi::attr(false);
             raw_uint = qi::raw[qi::uint_];
         }
 
         qi::rule<Iterator, hpx::performance_counters::path_elements()> start;
-        qi::rule<Iterator, hpx::performance_counters::instance_elements()> instance;
+        qi::rule<Iterator, hpx::performance_counters::instance_elements()>
+            instance;
         qi::rule<Iterator, hpx::performance_counters::instance_name()> parent;
         qi::rule<Iterator, hpx::performance_counters::instance_name()> child;
         qi::rule<Iterator, hpx::performance_counters::instance_name()> subchild;
         qi::rule<Iterator, std::string()> raw_uint;
     };
-}
+}    // namespace
 
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     bool parse_counter_name(std::string const& name, path_elements& elements)
     {
         path_parser<std::string::const_iterator> p;
@@ -112,4 +97,4 @@ namespace hpx { namespace performance_counters
         std::string::const_iterator begin = name.begin();
         return qi::parse(begin, name.end(), p, elements) && begin == name.end();
     }
-}}
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/counters.cpp b/libs/performance_counters/src/counters.cpp
similarity index 76%
rename from src/performance_counters/counters.cpp
rename to libs/performance_counters/src/counters.cpp
index f4469ce9d7..ff0159a9e8 100644
--- a/src/performance_counters/counters.cpp
+++ b/libs/performance_counters/src/counters.cpp
@@ -7,6 +7,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/format.hpp>
+#include <hpx/functional/bind_front.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/lcos/local/packaged_continuation.hpp>
 #include <hpx/performance_counters/base_performance_counter.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
@@ -17,16 +20,15 @@
 #include <hpx/runtime.hpp>
 #include <hpx/runtime/actions/continuation.hpp>
 #include <hpx/runtime/agas/interface.hpp>
-#include <hpx/runtime/components/stubs/runtime_support.hpp>
 #include <hpx/runtime/applier/apply.hpp>
+#include <hpx/runtime/components/stubs/runtime_support.hpp>
 #include <hpx/runtime/get_num_localities.hpp>
+#include <hpx/runtime/thread_pool_helpers.hpp>
 #include <hpx/serialization/base_object.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/serialization/vector.hpp>
-#include <hpx/functional/bind_front.hpp>
-#include <hpx/format.hpp>
-#include <hpx/functional/function.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -37,29 +39,25 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 // Initialization support for the performance counter actions
-HPX_REGISTER_ACTION_ID(
-    hpx::performance_counters::server
-    ::base_performance_counter::get_counter_info_action,
+HPX_REGISTER_ACTION_ID(hpx::performance_counters::server ::
+                           base_performance_counter::get_counter_info_action,
     performance_counter_get_counter_info_action,
     hpx::actions::performance_counter_get_counter_info_action_id)
-HPX_REGISTER_ACTION_ID(
-    hpx::performance_counters::server
-    ::base_performance_counter::get_counter_value_action,
+HPX_REGISTER_ACTION_ID(hpx::performance_counters::server ::
+                           base_performance_counter::get_counter_value_action,
     performance_counter_get_counter_value_action,
     hpx::actions::performance_counter_get_counter_value_action_id)
 HPX_REGISTER_ACTION_ID(
-    hpx::performance_counters::server
-    ::base_performance_counter::get_counter_values_array_action,
+    hpx::performance_counters::server ::base_performance_counter::
+        get_counter_values_array_action,
     performance_counter_get_counter_values_array_action,
     hpx::actions::performance_counter_get_counter_values_array_action_id)
-HPX_REGISTER_ACTION_ID(
-    hpx::performance_counters::server
-    ::base_performance_counter::set_counter_value_action,
+HPX_REGISTER_ACTION_ID(hpx::performance_counters::server ::
+                           base_performance_counter::set_counter_value_action,
     performance_counter_set_counter_value_action,
     hpx::actions::performance_counter_set_counter_value_action_id)
-HPX_REGISTER_ACTION_ID(
-    hpx::performance_counters::server
-    ::base_performance_counter::reset_counter_value_action,
+HPX_REGISTER_ACTION_ID(hpx::performance_counters::server ::
+                           base_performance_counter::reset_counter_value_action,
     performance_counter_reset_counter_value_action,
     hpx::actions::performance_counter_reset_counter_value_action_id)
 HPX_REGISTER_ACTION_ID(
@@ -71,13 +69,11 @@ HPX_REGISTER_ACTION_ID(
     performance_counter_stop_action,
     hpx::actions::performance_counter_stop_action_id)
 
-HPX_REGISTER_BASE_LCO_WITH_VALUE_ID(
-    hpx::performance_counters::counter_info, hpx_counter_info,
-    hpx::actions::base_lco_with_value_hpx_counter_info_get,
+HPX_REGISTER_BASE_LCO_WITH_VALUE_ID(hpx::performance_counters::counter_info,
+    hpx_counter_info, hpx::actions::base_lco_with_value_hpx_counter_info_get,
     hpx::actions::base_lco_with_value_hpx_counter_info_set)
-HPX_REGISTER_BASE_LCO_WITH_VALUE_ID(
-    hpx::performance_counters::counter_value, hpx_counter_value,
-    hpx::actions::base_lco_with_value_hpx_counter_value_get,
+HPX_REGISTER_BASE_LCO_WITH_VALUE_ID(hpx::performance_counters::counter_value,
+    hpx_counter_value, hpx::actions::base_lco_with_value_hpx_counter_value_get,
     hpx::actions::base_lco_with_value_hpx_counter_value_set)
 HPX_REGISTER_BASE_LCO_WITH_VALUE_ID(
     hpx::performance_counters::counter_values_array, hpx_counter_values_array,
@@ -88,14 +84,14 @@ HPX_DEFINE_GET_COMPONENT_TYPE(
     hpx::performance_counters::server::base_performance_counter)
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     /// \brief Create a full name of a counter from the contents of the given
     ///        \a counter_path_elements instance.
-    counter_status get_counter_name(counter_path_elements const& path,
-        std::string& result, error_code& ec)
+    counter_status get_counter_name(
+        counter_path_elements const& path, std::string& result, error_code& ec)
     {
-        if (path.objectname_.empty()) {
+        if (path.objectname_.empty())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "get_counter_name",
                 "empty counter object name");
             return status_invalid_data;
@@ -146,12 +142,14 @@ namespace hpx { namespace performance_counters
             }
             result += "}";
         }
-        if (!path.countername_.empty()) {
+        if (!path.countername_.empty())
+        {
             result += "/";
             result += path.countername_;
         }
 
-        if (!path.parameters_.empty()) {
+        if (!path.parameters_.empty())
+        {
             result += "@";
             result += path.parameters_;
         }
@@ -166,7 +164,8 @@ namespace hpx { namespace performance_counters
     counter_status get_counter_type_name(counter_type_path_elements const& path,
         std::string& result, error_code& ec)
     {
-        if (path.objectname_.empty()) {
+        if (path.objectname_.empty())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "get_counter_type_name",
                 "empty counter object name");
             return status_invalid_data;
@@ -175,7 +174,8 @@ namespace hpx { namespace performance_counters
         result = "/";
         result += path.objectname_;
 
-        if (!path.countername_.empty()) {
+        if (!path.countername_.empty())
+        {
             result += "/";
             result += path.countername_;
         }
@@ -191,7 +191,8 @@ namespace hpx { namespace performance_counters
         counter_type_path_elements const& path, std::string& result,
         error_code& ec)
     {
-        if (path.objectname_.empty()) {
+        if (path.objectname_.empty())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "get_full_counter_type_name",
                 "empty counter object name");
             return status_invalid_data;
@@ -200,12 +201,14 @@ namespace hpx { namespace performance_counters
         result = "/";
         result += path.objectname_;
 
-        if (!path.countername_.empty()) {
+        if (!path.countername_.empty())
+        {
             result += "/";
             result += path.countername_;
         }
 
-        if (!path.parameters_.empty()) {
+        if (!path.parameters_.empty())
+        {
             result += "@";
             result += path.parameters_;
         }
@@ -218,19 +221,21 @@ namespace hpx { namespace performance_counters
     /// \brief Create a name of a counter instance from the contents of the
     ///        given \a counter_path_elements instance.
     counter_status get_counter_instance_name(
-        counter_path_elements const& path, std::string& result,
-        error_code& ec)
+        counter_path_elements const& path, std::string& result, error_code& ec)
     {
-        if (path.parentinstancename_.empty()) {
+        if (path.parentinstancename_.empty())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "get_counter_instance_name",
                 "empty counter instance name");
             return status_invalid_data;
         }
 
-        if (path.parentinstance_is_basename_) {
+        if (path.parentinstance_is_basename_)
+        {
             result = path.parentinstancename_;
         }
-        else {
+        else
+        {
             result = "/";
             result += path.parentinstancename_;
             if (path.parentinstanceindex_ == -1)
@@ -252,8 +257,8 @@ namespace hpx { namespace performance_counters
                 }
                 else if (path.instancename_ == "pool")
                 {
-                    result += "#" +
-                        hpx::resource::get_pool_name(path.instanceindex_);
+                    result +=
+                        "#" + hpx::resource::get_pool_name(path.instanceindex_);
                 }
                 else
                 {
@@ -287,8 +292,8 @@ namespace hpx { namespace performance_counters
     ///    /objectname{parentinstancename#parentindex
     ///       /instancename#instanceindex}/countername
     ///
-    counter_status get_counter_path_elements(std::string const& name,
-        counter_path_elements& path, error_code& ec)
+    counter_status get_counter_path_elements(
+        std::string const& name, counter_path_elements& path, error_code& ec)
     {
         path_elements elements;
         if (!parse_counter_name(name, elements))
@@ -322,7 +327,7 @@ namespace hpx { namespace performance_counters
             else if (!elements.instance_.parent_.index_.empty())
             {
                 path.parentinstanceindex_ =
-                    hpx::util::safe_lexical_cast<std::int64_t>(
+                    hpx::util::from_string<std::int64_t>(
                         elements.instance_.parent_.index_);
             }
 
@@ -342,9 +347,8 @@ namespace hpx { namespace performance_counters
                 }
                 else
                 {
-                    path.instanceindex_ =
-                        hpx::util::safe_lexical_cast<std::int64_t>(
-                            elements.instance_.child_.index_, std::int64_t(-2));
+                    path.instanceindex_ = hpx::util::from_string<std::int64_t>(
+                        elements.instance_.child_.index_, std::int64_t(-2));
                     if (path.instanceindex_ == std::int64_t(-2))
                     {
                         HPX_THROWS_IF(ec, bad_parameter,
@@ -362,9 +366,8 @@ namespace hpx { namespace performance_counters
             }
             else if (!elements.instance_.subchild_.index_.empty())
             {
-                path.subinstanceindex_ =
-                    hpx::util::safe_lexical_cast<std::uint64_t>(
-                        elements.instance_.subchild_.index_);
+                path.subinstanceindex_ = hpx::util::from_string<std::uint64_t>(
+                    elements.instance_.subchild_.index_);
             }
         }
 
@@ -404,32 +407,34 @@ namespace hpx { namespace performance_counters
     }
 
     /// \brief Return the counter type name from a given full instance name
-    counter_status get_counter_type_name(std::string const& name,
-        std::string& type_name, error_code& ec)
+    counter_status get_counter_type_name(
+        std::string const& name, std::string& type_name, error_code& ec)
     {
         counter_type_path_elements p;
 
         counter_status status = get_counter_type_path_elements(name, p, ec);
-        if (!status_is_valid(status)) return status;
+        if (!status_is_valid(status))
+            return status;
 
         return get_counter_type_name(p, type_name, ec);
     }
 
     /// \brief Return the counter type name from a given full instance name
-    counter_status get_counter_name(std::string const& name,
-        std::string& countername, error_code& ec)
+    counter_status get_counter_name(
+        std::string const& name, std::string& countername, error_code& ec)
     {
         counter_path_elements p;
 
         counter_status status = get_counter_path_elements(name, p, ec);
-        if (!status_is_valid(status)) return status;
+        if (!status_is_valid(status))
+            return status;
 
         return get_counter_name(p, countername, ec);
     }
 
     /// \brief Complement the counter info if parent instance name is missing
-    counter_status complement_counter_info(counter_info& info,
-        counter_info const& type_info, error_code& ec)
+    counter_status complement_counter_info(
+        counter_info& info, counter_info const& type_info, error_code& ec)
     {
         info.type_ = type_info.type_;
         if (info.helptext_.empty())
@@ -441,12 +446,16 @@ namespace hpx { namespace performance_counters
     {
         counter_path_elements p;
 
-        counter_status status = get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_path_elements(info.fullname_, p, ec);
+        if (!status_is_valid(status))
+            return status;
 
-        if (p.parentinstancename_.empty()) {
+        if (p.parentinstancename_.empty())
+        {
             p.parentinstancename_ = "locality";
-            p.parentinstanceindex_ = static_cast<std::int64_t>(get_locality_id());
+            p.parentinstanceindex_ =
+                static_cast<std::int64_t>(get_locality_id());
             if (p.instancename_.empty())
             {
                 p.instancename_ = "total";
@@ -461,10 +470,12 @@ namespace hpx { namespace performance_counters
         // fill with complete counter type info
         std::string type_name;
         get_counter_type_name(p, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        if (!status_is_valid(status))
+            return status;
 
         get_counter_type(type_name, info, ec);
-        if (!status_is_valid(status)) return status;
+        if (!status_is_valid(status))
+            return status;
 
         // last, set full counter name
         return get_counter_name(p, info.fullname_, ec);
@@ -472,10 +483,8 @@ namespace hpx { namespace performance_counters
 
     ///////////////////////////////////////////////////////////////////////////
     /// \brief Get the name for a given counter type
-    namespace strings
-    {
-        char const* const counter_type_names[] =
-        {
+    namespace strings {
+        char const* const counter_type_names[] = {
             "counter_text",
             "counter_raw",
             "counter_average_base",
@@ -498,12 +507,12 @@ namespace hpx { namespace performance_counters
     ///////////////////////////////////////////////////////////////////////////
     counter_status add_counter_type(counter_info const& info,
         create_counter_func const& create_counter,
-        discover_counters_func const& discover_counters,
-        error_code& ec)
+        discover_counters_func const& discover_counters, error_code& ec)
     {
         runtime* rt = get_runtime_ptr();
         return rt ? rt->get_counter_registry().add_counter_type(
-            info, create_counter, discover_counters, ec) : status_generic_error;
+                        info, create_counter, discover_counters, ec) :
+                    status_generic_error;
     }
 
     ///////////////////////////////////////////////////////////////////////////
@@ -514,67 +523,67 @@ namespace hpx { namespace performance_counters
     {
         runtime* rt = get_runtime_ptr();
         return rt ? rt->get_counter_registry().discover_counter_types(
-            discover_counter, mode, ec) : status_generic_error;
+                        discover_counter, mode, ec) :
+                    status_generic_error;
     }
 
     ///////////////////////////////////////////////////////////////////////////
     /// \brief Call the supplied function for the given registered counter type.
-    counter_status discover_counter_type(
-        counter_info const& info,
+    counter_status discover_counter_type(counter_info const& info,
         discover_counter_func const& discover_counter,
         discover_counters_mode mode, error_code& ec)
     {
         runtime* rt = get_runtime_ptr();
         return rt ? rt->get_counter_registry().discover_counter_type(
-            info, discover_counter, mode, ec) : status_generic_error;
+                        info, discover_counter, mode, ec) :
+                    status_generic_error;
     }
 
-    counter_status discover_counter_type(
-        std::string const& name,
+    counter_status discover_counter_type(std::string const& name,
         discover_counter_func const& discover_counter,
         discover_counters_mode mode, error_code& ec)
     {
         runtime* rt = get_runtime_ptr();
         return rt ? rt->get_counter_registry().discover_counter_type(
-            name, discover_counter, mode, ec) : status_generic_error;
+                        name, discover_counter, mode, ec) :
+                    status_generic_error;
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
+    namespace detail {
         bool discover_counters(std::vector<counter_info>& counters,
             counter_info const& info, error_code& ec)
         {
             counters.push_back(info);
             return true;
         }
-    }
+    }    // namespace detail
 
     counter_status discover_counter_types(std::vector<counter_info>& counters,
         discover_counters_mode mode, error_code& ec)
     {
-        discover_counter_func func(
-            hpx::util::bind_front(&detail::discover_counters, std::ref(counters)));
+        discover_counter_func func(hpx::util::bind_front(
+            &detail::discover_counters, std::ref(counters)));
 
         return discover_counter_types(std::move(func), mode, ec);
     }
 
-    counter_status discover_counter_type(
-        std::string const& name, std::vector<counter_info>& counters,
-        discover_counters_mode mode, error_code& ec)
+    counter_status discover_counter_type(std::string const& name,
+        std::vector<counter_info>& counters, discover_counters_mode mode,
+        error_code& ec)
     {
-        discover_counter_func func(
-            hpx::util::bind_front(&detail::discover_counters, std::ref(counters)));
+        discover_counter_func func(hpx::util::bind_front(
+            &detail::discover_counters, std::ref(counters)));
 
         return discover_counter_type(name, std::move(func), mode, ec);
     }
 
-    counter_status discover_counter_type(
-        counter_info const& info, std::vector<counter_info>& counters,
-        discover_counters_mode mode, error_code& ec)
+    counter_status discover_counter_type(counter_info const& info,
+        std::vector<counter_info>& counters, discover_counters_mode mode,
+        error_code& ec)
     {
-        discover_counter_func func(
-            hpx::util::bind_front(&detail::discover_counters, std::ref(counters)));
+        discover_counter_func func(hpx::util::bind_front(
+            &detail::discover_counters, std::ref(counters)));
 
         return discover_counter_type(info, std::move(func), mode, ec);
     }
@@ -585,13 +594,13 @@ namespace hpx { namespace performance_counters
         // the runtime might not be available any more
         runtime* rt = get_runtime_ptr();
         return rt ? rt->get_counter_registry().remove_counter_type(info, ec) :
-            status_generic_error;
+                    status_generic_error;
     }
 
     /// \brief Retrieve the counter type for the given counter name from the
     ///        (local) registry
-    counter_status get_counter_type(std::string const& name,
-        counter_info& info, error_code& ec)
+    counter_status get_counter_type(
+        std::string const& name, counter_info& info, error_code& ec)
     {
         // the runtime might not be available any more
         runtime* rt = get_runtime_ptr();
@@ -600,11 +609,9 @@ namespace hpx { namespace performance_counters
             status_generic_error;
     }
 
-    namespace detail
-    {
-        naming::gid_type create_raw_counter_value(
-            counter_info const& info, std::int64_t* countervalue,
-            error_code& ec)
+    namespace detail {
+        naming::gid_type create_raw_counter_value(counter_info const& info,
+            std::int64_t* countervalue, error_code& ec)
         {
             naming::gid_type gid;
             get_runtime().get_counter_registry().create_raw_counter_value(
@@ -622,7 +629,8 @@ namespace hpx { namespace performance_counters
         }
 
         naming::gid_type create_raw_counter(counter_info const& info,
-            hpx::util::function_nonser<std::int64_t(bool)> const& f, error_code& ec)
+            hpx::util::function_nonser<std::int64_t(bool)> const& f,
+            error_code& ec)
         {
             naming::gid_type gid;
             get_runtime().get_counter_registry().create_raw_counter(
@@ -641,7 +649,8 @@ namespace hpx { namespace performance_counters
         }
 
         naming::gid_type create_raw_counter(counter_info const& info,
-            hpx::util::function_nonser<std::vector<std::int64_t>(bool)> const& f,
+            hpx::util::function_nonser<std::vector<std::int64_t>(bool)> const&
+                f,
             error_code& ec)
         {
             naming::gid_type gid;
@@ -652,7 +661,8 @@ namespace hpx { namespace performance_counters
 
         // \brief Create a new performance counter instance based on given
         //        counter info
-        naming::gid_type create_counter(counter_info const& info, error_code& ec)
+        naming::gid_type create_counter(
+            counter_info const& info, error_code& ec)
         {
             naming::gid_type gid;
             get_runtime().get_counter_registry().create_counter(info, gid, ec);
@@ -662,14 +672,13 @@ namespace hpx { namespace performance_counters
         // \brief Create a new aggregating performance counter instance based
         //        on given base counter name and given base time interval
         //        (milliseconds).
-        naming::gid_type create_statistics_counter(
-            counter_info const& info, std::string const& base_counter_name,
+        naming::gid_type create_statistics_counter(counter_info const& info,
+            std::string const& base_counter_name,
             std::vector<std::size_t> const& parameters, error_code& ec)
         {
             naming::gid_type gid;
-            get_runtime().get_counter_registry().
-                create_statistics_counter(info, base_counter_name,
-                    parameters, gid, ec);
+            get_runtime().get_counter_registry().create_statistics_counter(
+                info, base_counter_name, parameters, gid, ec);
             return gid;
         }
 
@@ -680,8 +689,8 @@ namespace hpx { namespace performance_counters
             std::vector<std::string> const& base_counter_names, error_code& ec)
         {
             naming::gid_type gid;
-            get_runtime().get_counter_registry().
-                create_arithmetics_counter(info, base_counter_names, gid, ec);
+            get_runtime().get_counter_registry().create_arithmetics_counter(
+                info, base_counter_names, gid, ec);
             return gid;
         }
 
@@ -693,21 +702,23 @@ namespace hpx { namespace performance_counters
             std::vector<std::string> const& base_counter_names, error_code& ec)
         {
             naming::gid_type gid;
-            get_runtime().get_counter_registry().
-                create_arithmetics_counter_extended(info, base_counter_names,
-                    gid, ec);
+            get_runtime()
+                .get_counter_registry()
+                .create_arithmetics_counter_extended(
+                    info, base_counter_names, gid, ec);
             return gid;
         }
 
         ///////////////////////////////////////////////////////////////////////
-        counter_status add_counter(naming::id_type const& id,
-            counter_info const& info, error_code& ec)
+        counter_status add_counter(
+            naming::id_type const& id, counter_info const& info, error_code& ec)
         {
-            return get_runtime().get_counter_registry().add_counter(id, info, ec);
+            return get_runtime().get_counter_registry().add_counter(
+                id, info, ec);
         }
 
-        counter_status remove_counter(counter_info const& info,
-            naming::id_type const& id, error_code& ec)
+        counter_status remove_counter(
+            counter_info const& info, naming::id_type const& id, error_code& ec)
         {
             return get_runtime().get_counter_registry().remove_counter(
                 info, id, ec);
@@ -722,35 +733,38 @@ namespace hpx { namespace performance_counters
             create_counter_func f;
             get_runtime().get_counter_registry().get_counter_create_function(
                 info, f, ec);
-            if (ec) {
+            if (ec)
+            {
                 HPX_THROW_EXCEPTION(bad_parameter, "create_counter_local",
                     "no create function for performance counter found: " +
-                    remove_counter_prefix(info.fullname_) +
-                        " (" + ec.get_message() + ")");
+                        remove_counter_prefix(info.fullname_) + " (" +
+                        ec.get_message() + ")");
                 return naming::invalid_gid;
             }
 
             counter_path_elements paths;
             get_counter_path_elements(info.fullname_, paths, ec);
-            if (ec) return hpx::naming::invalid_gid;
+            if (ec)
+                return hpx::naming::invalid_gid;
 
             if (paths.parentinstancename_ == "locality" &&
                 paths.parentinstanceindex_ !=
                     static_cast<std::int64_t>(hpx::get_locality_id()))
             {
                 HPX_THROW_EXCEPTION(bad_parameter, "create_counter_local",
-                    "attempt to create counter on wrong locality ("
-                     + ec.get_message() + ")");
+                    "attempt to create counter on wrong locality (" +
+                        ec.get_message() + ")");
                 return hpx::naming::invalid_gid;
             }
 
             // attempt to create the new counter instance
             naming::gid_type gid = f(info, ec);
-            if (ec) {
+            if (ec)
+            {
                 HPX_THROW_EXCEPTION(bad_parameter, "create_counter_local",
                     "couldn't create performance counter: " +
-                    remove_counter_prefix(info.fullname_) +
-                        " (" + ec.get_message() + ")");
+                        remove_counter_prefix(info.fullname_) + " (" +
+                        ec.get_message() + ")");
                 return naming::invalid_gid;
             }
 
@@ -798,9 +812,9 @@ namespace hpx { namespace performance_counters
 
         ///////////////////////////////////////////////////////////////////////
         /// Expand all wild-cards in a counter base name (for aggregate counters)
-        bool expand_basecounter(
-            counter_info const& info, counter_path_elements& p,
-            discover_counter_func const& f, error_code& ec)
+        bool expand_basecounter(counter_info const& info,
+            counter_path_elements& p, discover_counter_func const& f,
+            error_code& ec)
         {
             // discover all base names
             std::vector<counter_info> counter_infos;
@@ -822,9 +836,9 @@ namespace hpx { namespace performance_counters
 
         ///////////////////////////////////////////////////////////////////////
         // expand main counter name
-        bool expand_counter_info_pools(bool expand_threads,
-            counter_info& i, counter_path_elements& p,
-            discover_counter_func const& f, error_code& ec)
+        bool expand_counter_info_pools(bool expand_threads, counter_info& i,
+            counter_path_elements& p, discover_counter_func const& f,
+            error_code& ec)
         {
             std::size_t num_pools = hpx::resource::get_num_thread_pools();
             for (std::size_t l = 0; l != num_pools; ++l)
@@ -856,9 +870,9 @@ namespace hpx { namespace performance_counters
             return true;
         }
 
-        bool expand_counter_info_pool_threads(
-            counter_info& i, counter_path_elements& p,
-            discover_counter_func const& f, error_code& ec)
+        bool expand_counter_info_pool_threads(counter_info& i,
+            counter_path_elements& p, discover_counter_func const& f,
+            error_code& ec)
         {
             std::size_t num_threads =
                 hpx::resource::get_num_threads(p.instanceindex_);
@@ -873,9 +887,9 @@ namespace hpx { namespace performance_counters
             return true;
         }
 
-        bool expand_counter_info_threads(
-            counter_info& i, counter_path_elements& p,
-            discover_counter_func const& f, error_code& ec)
+        bool expand_counter_info_threads(counter_info& i,
+            counter_path_elements& p, discover_counter_func const& f,
+            error_code& ec)
         {
             std::size_t num_threads = get_os_thread_count();
             for (std::size_t l = 0; l != num_threads; ++l)
@@ -888,12 +902,12 @@ namespace hpx { namespace performance_counters
             return true;
         }
 
-        bool expand_counter_info_nodes(
-            counter_info& i, counter_path_elements& p,
-            discover_counter_func const& f, error_code& ec)
+        bool expand_counter_info_nodes(counter_info& i,
+            counter_path_elements& p, discover_counter_func const& f,
+            error_code& ec)
         {
-            std::size_t num_nodes
-                = hpx::threads::get_topology().get_number_of_numa_nodes();
+            std::size_t num_nodes =
+                hpx::threads::get_topology().get_number_of_numa_nodes();
             for (std::size_t l = 0; l != num_nodes; ++l)
             {
                 p.instanceindex_ = static_cast<std::int64_t>(l);
@@ -904,9 +918,9 @@ namespace hpx { namespace performance_counters
             return true;
         }
 
-        bool expand_counter_info_localities(
-            counter_info& i, counter_path_elements& p,
-            discover_counter_func const& f, error_code& ec)
+        bool expand_counter_info_localities(counter_info& i,
+            counter_path_elements& p, discover_counter_func const& f,
+            error_code& ec)
         {
             bool expand_pools = false;
             bool expand_threads = false;
@@ -935,28 +949,32 @@ namespace hpx { namespace performance_counters
                 expand_nodes = true;
             }
 
-            std::uint32_t last_locality =
-                get_num_localities(hpx::launch::sync);
+            std::uint32_t last_locality = get_num_localities(hpx::launch::sync);
             for (std::uint32_t l = 0; l != last_locality; ++l)
             {
                 p.parentinstanceindex_ = static_cast<std::int32_t>(l);
-                if (expand_pools) {
+                if (expand_pools)
+                {
                     if (!detail::expand_counter_info_pools(
                             expand_threads, i, p, f, ec))
                     {
                         return false;
                     }
                 }
-                else if (expand_threads) {
+                else if (expand_threads)
+                {
                     if (!detail::expand_counter_info_threads(i, p, f, ec))
                         return false;
                 }
-                else if(expand_nodes) {
+                else if (expand_nodes)
+                {
                     if (!detail::expand_counter_info_nodes(i, p, f, ec))
                         return false;
                 }
-                else {
-                    counter_status status = get_counter_name(p, i.fullname_, ec);
+                else
+                {
+                    counter_status status =
+                        get_counter_name(p, i.fullname_, ec);
                     if (!status_is_valid(status) || !f(i, ec) || ec)
                         return false;
                 }
@@ -965,9 +983,9 @@ namespace hpx { namespace performance_counters
         }
 
         ///////////////////////////////////////////////////////////////////////
-        bool expand_counter_info(
-            counter_info const& info, counter_path_elements& p,
-            discover_counter_func const& f, error_code& ec)
+        bool expand_counter_info(counter_info const& info,
+            counter_path_elements& p, discover_counter_func const& f,
+            error_code& ec)
         {
             // A '*' wild-card as the instance name is equivalent to no instance
             // name at all.
@@ -988,14 +1006,15 @@ namespace hpx { namespace performance_counters
             // now expand "pool#*"
             if (detail::is_pool_kind(p.instancename_))
             {
-                bool expand_threads = detail::is_thread_kind(p.subinstancename_);
+                bool expand_threads =
+                    detail::is_thread_kind(p.subinstancename_);
 
                 counter_info i = info;
                 p.instancename_ = detail::get_pool_kind(p.instancename_);
                 if (expand_threads)
                 {
-                    p.subinstancename_ = detail::get_thread_kind(
-                        p.subinstancename_) + "-thread";
+                    p.subinstancename_ =
+                        detail::get_thread_kind(p.subinstancename_) + "-thread";
                 }
                 return detail::expand_counter_info_pools(
                     expand_threads, i, p, f, ec);
@@ -1012,7 +1031,8 @@ namespace hpx { namespace performance_counters
             {
                 // now expand "<...>-thread#*"
                 counter_info i = info;
-                p.instancename_ = detail::get_thread_kind(p.instancename_) + "-thread";
+                p.instancename_ =
+                    detail::get_thread_kind(p.instancename_) + "-thread";
                 return detail::expand_counter_info_threads(i, p, f, ec);
             }
 
@@ -1020,7 +1040,8 @@ namespace hpx { namespace performance_counters
             if (detail::is_node_kind(p.instancename_))
             {
                 counter_info i = info;
-                p.instancename_ = detail::get_node_kind(p.instancename_) + "-node";
+                p.instancename_ =
+                    detail::get_node_kind(p.instancename_) + "-node";
                 return detail::expand_counter_info_nodes(i, p, f, ec);
             }
 
@@ -1033,7 +1054,7 @@ namespace hpx { namespace performance_counters
             // everything else is handled directly
             return f(info, ec);
         }
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
     /// \brief call the supplied function will all expanded versions of the
@@ -1042,15 +1063,17 @@ namespace hpx { namespace performance_counters
         discover_counter_func const& f, error_code& ec)
     {
         counter_path_elements p;
-        counter_status status = get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        counter_status status =
+            get_counter_path_elements(info.fullname_, p, ec);
+        if (!status_is_valid(status))
+            return false;
 
         return detail::expand_counter_info(info, p, f, ec);
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    static naming::id_type register_with_agas(std::string const& fullname,
-        lcos::future<naming::id_type> f)
+    static naming::id_type register_with_agas(
+        std::string const& fullname, lcos::future<naming::id_type> f)
     {
         // register the canonical name with AGAS
         naming::id_type id = f.get();
@@ -1067,36 +1090,39 @@ namespace hpx { namespace performance_counters
         // complement counter info data
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, ec);
-        if (ec) result_type();
+        if (ec)
+            result_type();
 
         ensure_counter_prefix(complemented_info.fullname_);
         // pre-pend prefix, if necessary
 
         // ask AGAS for the id of the given counter
-        naming::id_type id = agas::resolve_name(launch::sync,
-            complemented_info.fullname_, ec);
-        if (id == naming::invalid_id) {
-            try {
+        naming::id_type id =
+            agas::resolve_name(launch::sync, complemented_info.fullname_, ec);
+        if (id == naming::invalid_id)
+        {
+            try
+            {
                 // figure out target locality
                 counter_path_elements p;
                 get_counter_path_elements(complemented_info.fullname_, p, ec);
-                if (ec) return result_type();
+                if (ec)
+                    return result_type();
 
                 // Take target locality from base counter if if this is an
                 // aggregating counter (the instance name is a base counter).
                 if (p.parentinstance_is_basename_)
                 {
                     get_counter_path_elements(p.parentinstancename_, p, ec);
-                    if (ec) return result_type();
+                    if (ec)
+                        return result_type();
                 }
 
                 if (p.parentinstancename_ == "locality" &&
-                        (   p.parentinstanceindex_ < 0 ||
-                            p.parentinstanceindex_ >=
-                                static_cast<std::int32_t>(
-                                    get_num_localities(hpx::launch::sync))
-                        )
-                    )
+                    (p.parentinstanceindex_ < 0 ||
+                        p.parentinstanceindex_ >=
+                            static_cast<std::int32_t>(
+                                get_num_localities(hpx::launch::sync))))
                 {
                     HPX_THROWS_IF(ec, bad_parameter, "get_counter",
                         "attempt to create counter on non-existing locality");
@@ -1107,34 +1133,38 @@ namespace hpx { namespace performance_counters
                 // create the new performance counter
                 using namespace components::stubs;
                 lcos::future<naming::id_type> f;
-                if (p.parentinstanceindex_ >= 0) {
+                if (p.parentinstanceindex_ >= 0)
+                {
                     f = runtime_support::create_performance_counter_async(
                         naming::get_id_from_locality_id(
                             static_cast<std::uint32_t>(p.parentinstanceindex_)),
                         complemented_info);
                 }
-                else {
+                else
+                {
                     f = runtime_support::create_performance_counter_async(
                         find_here(), complemented_info);
                 }
 
                 // attach the function which registers the id_type with AGAS
-                return f.then(
-                    hpx::launch::sync,
-                    hpx::util::bind_front(&register_with_agas,
-                        complemented_info.fullname_));
+                return f.then(hpx::launch::sync,
+                    hpx::util::bind_front(
+                        &register_with_agas, complemented_info.fullname_));
             }
-            catch (hpx::exception const& e) {
+            catch (hpx::exception const& e)
+            {
                 if (&ec == &throws)
                     throw;
                 ec = make_error_code(e.get_error(), e.what());
-                LPCS_(warning) << hpx::util::format(
-                    "failed to create counter {} ({})",
-                    remove_counter_prefix(complemented_info.fullname_), e.what());
+                LPCS_(warning)
+                    << hpx::util::format("failed to create counter {} ({})",
+                           remove_counter_prefix(complemented_info.fullname_),
+                           e.what());
                 return lcos::future<naming::id_type>();
             }
         }
-        if (ec) return result_type();
+        if (ec)
+            return result_type();
 
         return lcos::make_ready_future(id);
     }
@@ -1142,9 +1172,9 @@ namespace hpx { namespace performance_counters
     lcos::future<naming::id_type> get_counter_async(
         std::string name, error_code& ec)
     {
-        ensure_counter_prefix(name);      // pre-pend prefix, if necessary
+        ensure_counter_prefix(name);    // pre-pend prefix, if necessary
 
-        counter_info info(name);          // set full counter name
+        counter_info info(name);    // set full counter name
         return get_counter_async(info, ec);
     }
 
@@ -1152,38 +1182,38 @@ namespace hpx { namespace performance_counters
     void counter_value::serialize(
         serialization::output_archive& ar, const unsigned int)
     {
-        ar & status_ & time_ & count_ & value_ & scaling_ & scale_inverse_;
+        ar& status_& time_& count_& value_& scaling_& scale_inverse_;
     }
 
     void counter_value::serialize(
         serialization::input_archive& ar, const unsigned int)
     {
-        ar & status_ & time_ & count_ & value_ & scaling_ & scale_inverse_;
+        ar& status_& time_& count_& value_& scaling_& scale_inverse_;
     }
 
     void counter_values_array::serialize(
         serialization::output_archive& ar, const unsigned int)
     {
-        ar & status_ & time_ & count_ & values_ & scaling_ & scale_inverse_;
+        ar& status_& time_& count_& values_& scaling_& scale_inverse_;
     }
 
     void counter_values_array::serialize(
         serialization::input_archive& ar, const unsigned int)
     {
-        ar & status_ & time_ & count_ & values_ & scaling_ & scale_inverse_;
+        ar& status_& time_& count_& values_& scaling_& scale_inverse_;
     }
 
     ///////////////////////////////////////////////////////////////////////////
     void counter_type_path_elements::serialize(
         serialization::output_archive& ar, const unsigned int)
     {
-        ar & objectname_ & countername_ & parameters_;
+        ar& objectname_& countername_& parameters_;
     }
 
     void counter_type_path_elements::serialize(
         serialization::input_archive& ar, const unsigned int)
     {
-        ar & objectname_ & countername_ & parameters_;
+        ar& objectname_& countername_& parameters_;
     }
 
     ///////////////////////////////////////////////////////////////////////////
@@ -1194,10 +1224,9 @@ namespace hpx { namespace performance_counters
         hpx::serialization::base_object_type<counter_path_elements, base_type>
             base = hpx::serialization::base_object<base_type>(*this);
 
-        ar & base &
-            parentinstancename_ & instancename_ & subinstancename_ &
-            parentinstanceindex_ & instanceindex_ & subinstanceindex_ &
-            parentinstance_is_basename_;
+        ar& base& parentinstancename_& instancename_& subinstancename_&
+            parentinstanceindex_& instanceindex_& subinstanceindex_&
+                parentinstance_is_basename_;
     }
 
     void counter_path_elements::serialize(
@@ -1207,23 +1236,21 @@ namespace hpx { namespace performance_counters
         hpx::serialization::base_object_type<counter_path_elements, base_type>
             base = hpx::serialization::base_object<base_type>(*this);
 
-        ar & base &
-            parentinstancename_ & instancename_ & subinstancename_ &
-            parentinstanceindex_ & instanceindex_ & subinstanceindex_ &
-            parentinstance_is_basename_;
+        ar& base& parentinstancename_& instancename_& subinstancename_&
+            parentinstanceindex_& instanceindex_& subinstanceindex_&
+                parentinstance_is_basename_;
     }
 
     ///////////////////////////////////////////////////////////////////////////
     void counter_info::serialize(
         serialization::output_archive& ar, const unsigned int)
     {
-        ar & type_ & version_ & status_ & fullname_ & helptext_ & unit_of_measure_;
+        ar& type_& version_& status_& fullname_& helptext_& unit_of_measure_;
     }
 
     void counter_info::serialize(
         serialization::input_archive& ar, const unsigned int)
     {
-        ar & type_ & version_ & status_ & fullname_ & helptext_ & unit_of_measure_;
+        ar& type_& version_& status_& fullname_& helptext_& unit_of_measure_;
     }
-}}
-
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/manage_counter.cpp b/libs/performance_counters/src/manage_counter.cpp
similarity index 78%
rename from src/performance_counters/manage_counter.cpp
rename to libs/performance_counters/src/manage_counter.cpp
index f361de98f9..11101f0077 100644
--- a/src/performance_counters/manage_counter.cpp
+++ b/libs/performance_counters/src/manage_counter.cpp
@@ -6,22 +6,24 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/errors.hpp>
+#include <hpx/functional/bind_front.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/manage_counter.hpp>
 #include <hpx/runtime.hpp>
 #include <hpx/runtime/actions/continuation.hpp>
-#include <hpx/errors.hpp>
-#include <hpx/functional/bind_front.hpp>
 #include <hpx/version.hpp>
 
 #include <memory>
 
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     struct manage_counter
     {
-        manage_counter() : counter_(naming::invalid_id) {}
+        manage_counter()
+          : counter_(naming::invalid_id)
+        {
+        }
 
         ~manage_counter()
         {
@@ -40,10 +42,11 @@ namespace hpx { namespace performance_counters
         naming::id_type counter_;
     };
 
-    counter_status manage_counter::install(naming::id_type const& id,
-        counter_info const& info, error_code& ec)
+    counter_status manage_counter::install(
+        naming::id_type const& id, counter_info const& info, error_code& ec)
     {
-        if (counter_ != naming::invalid_id) {
+        if (counter_ != naming::invalid_id)
+        {
             HPX_THROWS_IF(ec, hpx::invalid_status, "manage_counter::install",
                 "counter has been already installed");
             return status_invalid_data;
@@ -72,8 +75,8 @@ namespace hpx { namespace performance_counters
         p->uninstall();
     }
 
-    void install_counter(naming::id_type const& id, counter_info const& info,
-        error_code& ec)
+    void install_counter(
+        naming::id_type const& id, counter_info const& info, error_code& ec)
     {
         std::shared_ptr<manage_counter> p = std::make_shared<manage_counter>();
 
@@ -81,7 +84,7 @@ namespace hpx { namespace performance_counters
         p->install(id, info, ec);
 
         // Register the shutdown function which will clean up this counter.
-        get_runtime().add_shutdown_function(util::bind_front(&counter_shutdown, p));
+        get_runtime().add_shutdown_function(
+            util::bind_front(&counter_shutdown, p));
     }
-}}
-
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/manage_counter_type.cpp b/libs/performance_counters/src/manage_counter_type.cpp
similarity index 85%
rename from src/performance_counters/manage_counter_type.cpp
rename to libs/performance_counters/src/manage_counter_type.cpp
index 5eada8f8da..88d488b6d7 100644
--- a/src/performance_counters/manage_counter_type.cpp
+++ b/libs/performance_counters/src/manage_counter_type.cpp
@@ -8,15 +8,15 @@
 ////////////////////////////////////////////////////////////////////////////////
 
 #include <hpx/config.hpp>
-#include <hpx/performance_counters/counters.hpp>
-#include <hpx/performance_counters/counter_creators.hpp>
-#include <hpx/performance_counters/manage_counter_type.hpp>
-#include <hpx/runtime.hpp>
-#include <hpx/runtime/actions/continuation.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/functional/bind_front.hpp>
 #include <hpx/functional/function.hpp>
+#include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
+#include <hpx/performance_counters/manage_counter_type.hpp>
+#include <hpx/runtime.hpp>
+#include <hpx/runtime/actions/continuation.hpp>
 #include <hpx/version.hpp>
 
 #include <cstddef>
@@ -25,13 +25,14 @@
 #include <string>
 #include <vector>
 
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     struct manage_counter_type
     {
         manage_counter_type(counter_info const& info)
-          : status_(status_invalid_data), info_(info)
-        {}
+          : status_(status_invalid_data)
+          , info_(info)
+        {
+        }
 
         ~manage_counter_type()
         {
@@ -40,38 +41,39 @@ namespace hpx { namespace performance_counters
 
         counter_status install(error_code& ec = throws)
         {
-            if (status_invalid_data != status_) {
+            if (status_invalid_data != status_)
+            {
                 HPX_THROWS_IF(ec, hpx::invalid_status,
                     "manage_counter_type::install",
                     "counter type " + info_.fullname_ +
-                    " has been already installed.");
+                        " has been already installed.");
                 return status_invalid_data;
             }
 
             return status_ = add_counter_type(info_, ec);
         }
 
-        counter_status install(
-            create_counter_func const& create_counter,
+        counter_status install(create_counter_func const& create_counter,
             discover_counters_func const& discover_counters,
             error_code& ec = throws)
         {
-            if (status_invalid_data != status_) {
+            if (status_invalid_data != status_)
+            {
                 HPX_THROWS_IF(ec, hpx::invalid_status,
                     "manage_counter_type::install",
                     "generic counter type " + info_.fullname_ +
-                    " has been already installed.");
+                        " has been already installed.");
                 return status_invalid_data;
             }
 
             return status_ = add_counter_type(
-                info_, create_counter, discover_counters, ec);
+                       info_, create_counter, discover_counters, ec);
         }
 
         void uninstall(error_code& ec = throws)
         {
             if (status_invalid_data != status_)
-                remove_counter_type(info_, ec); // ignore errors
+                remove_counter_type(info_, ec);    // ignore errors
         }
 
     private:
@@ -79,7 +81,8 @@ namespace hpx { namespace performance_counters
         counter_info info_;
     };
 
-    static void counter_type_shutdown(std::shared_ptr<manage_counter_type> const& p)
+    static void counter_type_shutdown(
+        std::shared_ptr<manage_counter_type> const& p)
     {
         error_code ec(lightweight);
         p->uninstall(ec);
@@ -87,8 +90,8 @@ namespace hpx { namespace performance_counters
 
     ///////////////////////////////////////////////////////////////////////////
     counter_status install_counter_type(std::string const& name,
-        counter_type type, std::string const& helptext,
-        std::string const& uom, std::uint32_t version, error_code& ec)
+        counter_type type, std::string const& helptext, std::string const& uom,
+        std::uint32_t version, error_code& ec)
     {
         counter_info info(type, name, helptext,
             version ? version : HPX_PERFORMANCE_COUNTER_V1, uom);
@@ -110,8 +113,8 @@ namespace hpx { namespace performance_counters
     counter_status install_counter_type(std::string const& name,
         counter_type type, std::string const& helptext,
         create_counter_func const& create_counter,
-        discover_counters_func const& discover_counters,
-        std::uint32_t version, std::string const& uom, error_code& ec)
+        discover_counters_func const& discover_counters, std::uint32_t version,
+        std::string const& uom, error_code& ec)
     {
         counter_info info(type, name, helptext,
             version ? version : HPX_PERFORMANCE_COUNTER_V1, uom);
@@ -169,8 +172,8 @@ namespace hpx { namespace performance_counters
                 data[i].helptext_, data[i].create_counter_,
                 data[i].discover_counters_, data[i].version_,
                 data[i].unit_of_measure_, ec);
-            if (ec) break;
+            if (ec)
+                break;
         }
     }
-}}
-
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/performance_counter.cpp b/libs/performance_counters/src/performance_counter.cpp
similarity index 59%
rename from src/performance_counters/performance_counter.cpp
rename to libs/performance_counters/src/performance_counter.cpp
index e45f564539..ce3993b1ca 100644
--- a/src/performance_counters/performance_counter.cpp
+++ b/libs/performance_counters/src/performance_counter.cpp
@@ -17,15 +17,15 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     performance_counter::performance_counter(std::string const& name)
       : base_type(performance_counters::get_counter_async(name))
-    {}
+    {
+    }
 
-    performance_counter::performance_counter(std::string const& name,
-        hpx::id_type const& locality)
+    performance_counter::performance_counter(
+        std::string const& name, hpx::id_type const& locality)
     {
         HPX_ASSERT(naming::is_locality(locality));
 
@@ -36,7 +36,8 @@ namespace hpx { namespace performance_counters
         p.parentinstanceindex_ = naming::get_locality_id_from_id(locality);
         get_counter_name(p, full_name);
 
-        this->base_type::reset(performance_counters::get_counter_async(full_name));
+        this->base_type::reset(
+            performance_counters::get_counter_async(full_name));
     }
 
     ///////////////////////////////////////////////////////////////////////////
@@ -44,62 +45,60 @@ namespace hpx { namespace performance_counters
     {
         return stubs::performance_counter::get_info(launch::async, get_id());
     }
-    counter_info performance_counter::get_info(launch::sync_policy,
-        error_code& ec) const
+    counter_info performance_counter::get_info(
+        launch::sync_policy, error_code& ec) const
     {
         return stubs::performance_counter::get_info(launch::sync, get_id(), ec);
     }
 
     future<counter_value> performance_counter::get_counter_value(bool reset)
     {
-        return stubs::performance_counter::get_value(launch::async,
-            get_id(), reset);
+        return stubs::performance_counter::get_value(
+            launch::async, get_id(), reset);
     }
-    counter_value performance_counter::get_counter_value(launch::sync_policy,
-        bool reset, error_code& ec)
+    counter_value performance_counter::get_counter_value(
+        launch::sync_policy, bool reset, error_code& ec)
     {
-        return stubs::performance_counter::get_value(launch::sync,
-            get_id(), reset, ec);
+        return stubs::performance_counter::get_value(
+            launch::sync, get_id(), reset, ec);
     }
 
     future<counter_value> performance_counter::get_counter_value() const
     {
-        return stubs::performance_counter::get_value(launch::async,
-            get_id(), false);
+        return stubs::performance_counter::get_value(
+            launch::async, get_id(), false);
     }
-    counter_value performance_counter::get_counter_value(launch::sync_policy,
-        error_code& ec) const
+    counter_value performance_counter::get_counter_value(
+        launch::sync_policy, error_code& ec) const
     {
-        return stubs::performance_counter::get_value(launch::sync,
-            get_id(), false, ec);
+        return stubs::performance_counter::get_value(
+            launch::sync, get_id(), false, ec);
     }
 
-    future<counter_values_array>
-    performance_counter::get_counter_values_array(bool reset)
+    future<counter_values_array> performance_counter::get_counter_values_array(
+        bool reset)
     {
-        return stubs::performance_counter::get_values_array(launch::async,
-            get_id(), reset);
+        return stubs::performance_counter::get_values_array(
+            launch::async, get_id(), reset);
     }
-    counter_values_array
-    performance_counter::get_counter_values_array(launch::sync_policy,
-        bool reset, error_code& ec)
+    counter_values_array performance_counter::get_counter_values_array(
+        launch::sync_policy, bool reset, error_code& ec)
     {
-        return stubs::performance_counter::get_values_array(launch::sync,
-            get_id(), reset, ec);
+        return stubs::performance_counter::get_values_array(
+            launch::sync, get_id(), reset, ec);
     }
 
-    future<counter_values_array>
-    performance_counter::get_counter_values_array() const
+    future<counter_values_array> performance_counter::get_counter_values_array()
+        const
     {
-        return stubs::performance_counter::get_values_array(launch::async,
-            get_id(), false);
+        return stubs::performance_counter::get_values_array(
+            launch::async, get_id(), false);
     }
-    counter_values_array
-    performance_counter::get_counter_values_array(launch::sync_policy,
-        error_code& ec) const
+    counter_values_array performance_counter::get_counter_values_array(
+        launch::sync_policy, error_code& ec) const
     {
-        return stubs::performance_counter::get_values_array(launch::sync,
-            get_id(), false, ec);
+        return stubs::performance_counter::get_values_array(
+            launch::sync, get_id(), false, ec);
     }
 
     ///////////////////////////////////////////////////////////////////////////
@@ -133,7 +132,8 @@ namespace hpx { namespace performance_counters
 
     future<void> performance_counter::reinit(bool reset)
     {
-        return stubs::performance_counter::reinit(launch::async, get_id(), reset);
+        return stubs::performance_counter::reinit(
+            launch::async, get_id(), reset);
     }
     void performance_counter::reinit(
         launch::sync_policy, bool reset, error_code& ec)
@@ -144,34 +144,31 @@ namespace hpx { namespace performance_counters
     ///
     future<std::string> performance_counter::get_name() const
     {
-        return lcos::make_future<std::string>(
-            get_info(),
-            [](counter_info && info) -> std::string
-            {
-                return info.fullname_;
-            });
+        return lcos::make_future<std::string>(get_info(),
+            [](counter_info&& info) -> std::string { return info.fullname_; });
     }
 
-    std::string performance_counter::get_name(launch::sync_policy,
-        error_code& ec) const
+    std::string performance_counter::get_name(
+        launch::sync_policy, error_code& ec) const
     {
         return get_name().get(ec);
     }
 
     ///////////////////////////////////////////////////////////////////////////
     /// Return all counters matching the given name (with optional wild-cards).
-    std::vector<performance_counter>
-    discover_counters(std::string const& name, error_code& ec)
+    std::vector<performance_counter> discover_counters(
+        std::string const& name, error_code& ec)
     {
         std::vector<performance_counter> counters;
 
         std::vector<counter_info> infos;
-        counter_status status = discover_counter_type(name, infos,
-            discover_counters_full, ec);
+        counter_status status =
+            discover_counter_type(name, infos, discover_counters_full, ec);
         if (!status_is_valid(status) || ec)
             return counters;
 
-        try {
+        try
+        {
             counters.reserve(infos.size());
             for (counter_info const& info : infos)
             {
@@ -179,10 +176,11 @@ namespace hpx { namespace performance_counters
                 counters.push_back(counter);
             }
         }
-        catch (hpx::exception const& e) {
+        catch (hpx::exception const& e)
+        {
             HPX_RETHROWS_IF(ec, e, "discover_counters");
         }
 
         return counters;
     }
-}}
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/performance_counter_set.cpp b/libs/performance_counters/src/performance_counter_set.cpp
similarity index 79%
rename from src/performance_counters/performance_counter_set.cpp
rename to libs/performance_counters/src/performance_counter_set.cpp
index af03ec808c..61fe1cfcc0 100644
--- a/src/performance_counters/performance_counter_set.cpp
+++ b/libs/performance_counters/src/performance_counter_set.cpp
@@ -7,6 +7,8 @@
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/format.hpp>
+#include <hpx/functional/bind.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/performance_counter_set.hpp>
@@ -14,8 +16,6 @@
 #include <hpx/runtime/get_locality_id.hpp>
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/runtime_fwd.hpp>
-#include <hpx/functional/bind.hpp>
-#include <hpx/format.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <algorithm>
@@ -26,10 +26,9 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
-    performance_counter_set::performance_counter_set(std::string const& name,
-            bool reset)
+namespace hpx { namespace performance_counters {
+    performance_counter_set::performance_counter_set(
+        std::string const& name, bool reset)
       : invocation_count_(0)
       , print_counters_locally_(false)
     {
@@ -37,7 +36,7 @@ namespace hpx { namespace performance_counters
     }
 
     performance_counter_set::performance_counter_set(
-            std::vector<std::string> const& names, bool reset)
+        std::vector<std::string> const& names, bool reset)
       : invocation_count_(0)
       , print_counters_locally_(false)
     {
@@ -68,15 +67,16 @@ namespace hpx { namespace performance_counters
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    bool performance_counter_set::find_counter(counter_info const& info,
-        bool reset, error_code& ec)
+    bool performance_counter_set::find_counter(
+        counter_info const& info, bool reset, error_code& ec)
     {
         // keep only local counters if requested
         if (print_counters_locally_)
         {
             counter_path_elements p;
             get_counter_path_elements(info.fullname_, p, ec);
-            if (ec) return false;
+            if (ec)
+                return false;
 
             if (p.parentinstanceindex_ != hpx::get_locality_id())
             {
@@ -91,8 +91,7 @@ namespace hpx { namespace performance_counters
         {
             HPX_THROWS_IF(ec, bad_parameter,
                 "performance_counter_set::find_counter",
-                hpx::util::format(
-                    "unknown performance counter: '{1}' ({2})",
+                hpx::util::format("unknown performance counter: '{1}' ({2})",
                     info.fullname_, ec.get_message()));
             return false;
         }
@@ -110,8 +109,8 @@ namespace hpx { namespace performance_counters
         return true;
     }
 
-    void performance_counter_set::add_counters(std::string const& name,
-        bool reset, error_code& ec)
+    void performance_counter_set::add_counters(
+        std::string const& name, bool reset, error_code& ec)
     {
         using util::placeholders::_1;
         using util::placeholders::_2;
@@ -125,7 +124,8 @@ namespace hpx { namespace performance_counters
 
         // find matching counter types
         discover_counter_type(n, std::move(func), discover_counters_full, ec);
-        if (ec) return;
+        if (ec)
+            return;
 
         HPX_ASSERT(ids_.size() == infos_.size());
     }
@@ -147,14 +147,15 @@ namespace hpx { namespace performance_counters
 
             // find matching counter types
             discover_counter_type(n, func, discover_counters_full, ec);
-            if (ec) return;
+            if (ec)
+                return;
         }
 
         HPX_ASSERT(ids_.size() == infos_.size());
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    std::vector<hpx::future<bool> > performance_counter_set::start()
+    std::vector<hpx::future<bool>> performance_counter_set::start()
     {
         std::vector<hpx::id_type> ids;
 
@@ -163,7 +164,7 @@ namespace hpx { namespace performance_counters
             ids = ids_;
         }
 
-        std::vector<hpx::future<bool> > v;
+        std::vector<hpx::future<bool>> v;
         v.reserve(ids.size());
 
         // start all performance counters
@@ -178,17 +179,20 @@ namespace hpx { namespace performance_counters
 
     bool performance_counter_set::start(launch::sync_policy, error_code& ec)
     {
-        try {
+        try
+        {
             auto v = hpx::util::unwrap(start());
-            return std::all_of(v.begin(), v.end(), [](bool val) { return val; });
+            return std::all_of(
+                v.begin(), v.end(), [](bool val) { return val; });
         }
-        catch (hpx::exception const& e) {
+        catch (hpx::exception const& e)
+        {
             HPX_RETHROWS_IF(ec, e, "performance_counter_set::start");
             return false;
         }
     }
 
-    std::vector<hpx::future<bool> > performance_counter_set::stop()
+    std::vector<hpx::future<bool>> performance_counter_set::stop()
     {
         std::vector<hpx::id_type> ids;
 
@@ -197,7 +201,7 @@ namespace hpx { namespace performance_counters
             ids = ids_;
         }
 
-        std::vector<hpx::future<bool> > v;
+        std::vector<hpx::future<bool>> v;
         v.reserve(ids.size());
 
         // stop all performance counters
@@ -212,17 +216,20 @@ namespace hpx { namespace performance_counters
 
     bool performance_counter_set::stop(launch::sync_policy, error_code& ec)
     {
-        try {
+        try
+        {
             auto v = hpx::util::unwrap(stop());
-            return std::all_of(v.begin(), v.end(), [](bool val) { return val; });
+            return std::all_of(
+                v.begin(), v.end(), [](bool val) { return val; });
         }
-        catch (hpx::exception const& e) {
+        catch (hpx::exception const& e)
+        {
             HPX_RETHROWS_IF(ec, e, "performance_counter_set::stop");
             return false;
         }
     }
 
-    std::vector<hpx::future<void> > performance_counter_set::reset()
+    std::vector<hpx::future<void>> performance_counter_set::reset()
     {
         std::vector<hpx::id_type> ids;
 
@@ -231,7 +238,7 @@ namespace hpx { namespace performance_counters
             ids = ids_;
         }
 
-        std::vector<hpx::future<void> > v;
+        std::vector<hpx::future<void>> v;
         v.reserve(ids.size());
 
         // reset all performance counters
@@ -246,15 +253,17 @@ namespace hpx { namespace performance_counters
 
     void performance_counter_set::reset(launch::sync_policy, error_code& ec)
     {
-        try {
+        try
+        {
             hpx::util::unwrap(reset());
         }
-        catch (hpx::exception const& e) {
+        catch (hpx::exception const& e)
+        {
             HPX_RETHROWS_IF(ec, e, "performance_counter_set::reset");
         }
     }
 
-    std::vector<hpx::future<void> > performance_counter_set::reinit(bool reset)
+    std::vector<hpx::future<void>> performance_counter_set::reinit(bool reset)
     {
         std::vector<hpx::id_type> ids;
 
@@ -263,7 +272,7 @@ namespace hpx { namespace performance_counters
             ids = ids_;
         }
 
-        std::vector<hpx::future<void> > v;
+        std::vector<hpx::future<void>> v;
         v.reserve(ids.size());
 
         // re-initialize all performance counters
@@ -280,17 +289,19 @@ namespace hpx { namespace performance_counters
     void performance_counter_set::reinit(
         launch::sync_policy, bool reset, error_code& ec)
     {
-        try {
+        try
+        {
             hpx::util::unwrap(reinit(reset));
         }
-        catch (hpx::exception const& e) {
+        catch (hpx::exception const& e)
+        {
             HPX_RETHROWS_IF(ec, e, "performance_counter_set::reinit");
         }
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    std::vector<hpx::future<counter_value> >
-        performance_counter_set::get_counter_values(bool reset) const
+    std::vector<hpx::future<counter_value>>
+    performance_counter_set::get_counter_values(bool reset) const
     {
         std::vector<hpx::id_type> ids;
 
@@ -300,7 +311,7 @@ namespace hpx { namespace performance_counters
             ++invocation_count_;
         }
 
-        std::vector<hpx::future<counter_value> > v;
+        std::vector<hpx::future<counter_value>> v;
         v.reserve(ids.size());
 
         // reset all performance counters
@@ -323,19 +334,21 @@ namespace hpx { namespace performance_counters
     std::vector<counter_value> performance_counter_set::get_counter_values(
         launch::sync_policy, bool reset, error_code& ec) const
     {
-        try {
+        try
+        {
             return hpx::util::unwrap(get_counter_values(reset));
         }
-        catch (hpx::exception const& e) {
-            HPX_RETHROWS_IF(ec, e,
-                "performance_counter_set::get_counter_values");
+        catch (hpx::exception const& e)
+        {
+            HPX_RETHROWS_IF(
+                ec, e, "performance_counter_set::get_counter_values");
             return std::vector<counter_value>();
         }
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    std::vector<hpx::future<counter_values_array> >
-        performance_counter_set::get_counter_values_array(bool reset) const
+    std::vector<hpx::future<counter_values_array>>
+    performance_counter_set::get_counter_values_array(bool reset) const
     {
         std::vector<hpx::id_type> ids;
 
@@ -345,7 +358,7 @@ namespace hpx { namespace performance_counters
             ++invocation_count_;
         }
 
-        std::vector<hpx::future<counter_values_array> > v;
+        std::vector<hpx::future<counter_values_array>> v;
         v.reserve(ids.size());
 
         // reset all performance counters
@@ -366,15 +379,17 @@ namespace hpx { namespace performance_counters
     }
 
     std::vector<counter_values_array>
-        performance_counter_set::get_counter_values_array(
-            launch::sync_policy, bool reset, error_code& ec) const
+    performance_counter_set::get_counter_values_array(
+        launch::sync_policy, bool reset, error_code& ec) const
     {
-        try {
+        try
+        {
             return hpx::util::unwrap(get_counter_values_array(reset));
         }
-        catch (hpx::exception const& e) {
-            HPX_RETHROWS_IF(ec, e,
-                "performance_counter_set::get_counter_values_aray");
+        catch (hpx::exception const& e)
+        {
+            HPX_RETHROWS_IF(
+                ec, e, "performance_counter_set::get_counter_values_aray");
             return std::vector<counter_values_array>();
         }
     }
@@ -385,5 +400,4 @@ namespace hpx { namespace performance_counters
         std::unique_lock<mutex_type> l(mtx_);
         return invocation_count_;
     }
-}}
-
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/registry.cpp b/libs/performance_counters/src/registry.cpp
similarity index 67%
rename from src/performance_counters/registry.cpp
rename to libs/performance_counters/src/registry.cpp
index 34c8d0e71d..92f8692163 100644
--- a/src/performance_counters/registry.cpp
+++ b/libs/performance_counters/src/registry.cpp
@@ -6,6 +6,11 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/format.hpp>
+#include <hpx/functional/bind.hpp>
+#include <hpx/functional/bind_front.hpp>
+#include <hpx/functional/function.hpp>
+#include <hpx/logging.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/registry.hpp>
 #include <hpx/performance_counters/server/arithmetics_counter.hpp>
@@ -16,17 +21,12 @@
 #include <hpx/performance_counters/server/statistics_counter.hpp>
 #include <hpx/runtime/agas/interface.hpp>
 #include <hpx/runtime/components/server/create_component.hpp>
-#include <hpx/functional/bind.hpp>
-#include <hpx/functional/bind_front.hpp>
-#include <hpx/format.hpp>
-#include <hpx/functional/function.hpp>
-#include <hpx/logging.hpp>
-#include <hpx/util/regex_from_pattern.hpp>
 #include <hpx/statistics/rolling_max.hpp>
 #include <hpx/statistics/rolling_min.hpp>
+#include <hpx/util/regex_from_pattern.hpp>
 
-#include <boost/accumulators/statistics_fwd.hpp>
 #include <boost/accumulators/statistics/rolling_variance.hpp>
+#include <boost/accumulators/statistics_fwd.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -37,14 +37,14 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
-    registry::counter_type_map_type::iterator
-        registry::locate_counter_type(std::string const& type_name)
+    registry::counter_type_map_type::iterator registry::locate_counter_type(
+        std::string const& type_name)
     {
         counter_type_map_type::iterator it = countertypes_.find(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             // if the full type is not available, try to locate the object name
             // as a type only
             error_code ec(lightweight);
@@ -57,10 +57,12 @@ namespace hpx { namespace performance_counters
     }
 
     registry::counter_type_map_type::const_iterator
-        registry::locate_counter_type(std::string const& type_name) const
+    registry::locate_counter_type(std::string const& type_name) const
     {
-        counter_type_map_type::const_iterator it = countertypes_.find(type_name);
-        if (it == countertypes_.end()) {
+        counter_type_map_type::const_iterator it =
+            countertypes_.find(type_name);
+        if (it == countertypes_.end())
+        {
             // if the full type is not available, try to locate the object name
             // as a type only
             error_code ec(lightweight);
@@ -75,16 +77,18 @@ namespace hpx { namespace performance_counters
     ///////////////////////////////////////////////////////////////////////////
     counter_status registry::add_counter_type(counter_info const& info,
         create_counter_func const& create_counter_,
-        discover_counters_func const& discover_counters_,
-        error_code& ec)
+        discover_counters_func const& discover_counters_, error_code& ec)
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it != countertypes_.end()) {
+        if (it != countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "registry::add_counter_type",
                 hpx::util::format(
                     "counter type already defined: {}", type_name));
@@ -92,19 +96,18 @@ namespace hpx { namespace performance_counters
         }
 
         std::pair<counter_type_map_type::iterator, bool> p =
-            countertypes_.insert(counter_type_map_type::value_type(
-            type_name, counter_data(info, create_counter_, discover_counters_)));
+            countertypes_.insert(counter_type_map_type::value_type(type_name,
+                counter_data(info, create_counter_, discover_counters_)));
 
-        if (!p.second) {
+        if (!p.second)
+        {
             LPCS_(warning) << hpx::util::format(
-                "failed to register counter type {}",
-                type_name);
+                "failed to register counter type {}", type_name);
             return status_invalid_data;
         }
 
         LPCS_(info) << hpx::util::format(
-            "counter type {} registered",
-            type_name);
+            "counter type {} registered", type_name);
 
         if (&ec != &throws)
             ec = make_success_code();
@@ -112,24 +115,26 @@ namespace hpx { namespace performance_counters
     }
 
     /// \brief Call the supplied function for the given registered counter type.
-    counter_status registry::discover_counter_type(
-        std::string const& fullname,
-        discover_counter_func discover_counter,
-        discover_counters_mode mode, error_code& ec)
+    counter_status registry::discover_counter_type(std::string const& fullname,
+        discover_counter_func discover_counter, discover_counters_mode mode,
+        error_code& ec)
     {
         // create canonical type name
         std::string type_name;
         counter_status status = get_counter_type_name(fullname, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        if (!status_is_valid(status))
+            return status;
 
         if (type_name.find_first_of("*?[]") == std::string::npos)
         {
             counter_type_map_type::iterator it = locate_counter_type(type_name);
-            if (it == countertypes_.end()) {
+            if (it == countertypes_.end())
+            {
                 // compose a list of known counter types
                 std::string types;
                 counter_type_map_type::const_iterator end = countertypes_.end();
-                for (counter_type_map_type::const_iterator it = countertypes_.begin();
+                for (counter_type_map_type::const_iterator it =
+                         countertypes_.begin();
                      it != end; ++it)
                 {
                     types += "  " + (*it).first + "\n";
@@ -137,24 +142,25 @@ namespace hpx { namespace performance_counters
 
                 HPX_THROWS_IF(ec, bad_parameter,
                     "registry::discover_counter_type",
-                    hpx::util::format(
-                        "unknown counter type: {}, known counter "
-                        "types: \n{}", type_name, types));
+                    hpx::util::format("unknown counter type: {}, known counter "
+                                      "types: \n{}",
+                        type_name, types));
                 return status_counter_type_unknown;
             }
 
             if (mode == discover_counters_full)
             {
                 using hpx::util::placeholders::_1;
-                discover_counter = hpx::util::bind(&expand_counter_info, _1,
-                    discover_counter, std::ref(ec));
+                discover_counter = hpx::util::bind(
+                    &expand_counter_info, _1, discover_counter, std::ref(ec));
             }
 
             counter_info info = (*it).second.info_;
             info.fullname_ = fullname;
 
             if (!(*it).second.discover_counters_.empty() &&
-                !(*it).second.discover_counters_(info, discover_counter, mode, ec))
+                !(*it).second.discover_counters_(
+                    info, discover_counter, mode, ec))
             {
                 return status_invalid_data;
             }
@@ -162,25 +168,28 @@ namespace hpx { namespace performance_counters
         else
         {
             std::string str_rx(util::regex_from_pattern(type_name, ec));
-            if (ec) return status_invalid_data;
+            if (ec)
+                return status_invalid_data;
 
             if (mode == discover_counters_full)
             {
                 using hpx::util::placeholders::_1;
-                discover_counter = hpx::util::bind(&expand_counter_info, _1,
-                    discover_counter, std::ref(ec));
+                discover_counter = hpx::util::bind(
+                    &expand_counter_info, _1, discover_counter, std::ref(ec));
             }
 
             // split name
             counter_path_elements p;
             get_counter_path_elements(fullname, p, ec);
-            if (ec) return status_invalid_data;
+            if (ec)
+                return status_invalid_data;
 
             bool found_one = false;
             std::regex rx(str_rx);
 
             counter_type_map_type::const_iterator end = countertypes_.end();
-            for (counter_type_map_type::const_iterator it = countertypes_.begin();
+            for (counter_type_map_type::const_iterator it =
+                     countertypes_.begin();
                  it != end; ++it)
             {
                 if (!std::regex_match((*it).first, rx))
@@ -193,27 +202,31 @@ namespace hpx { namespace performance_counters
                     info.fullname_ += "@" + p.parameters_;
 
                 if (!(*it).second.discover_counters_.empty() &&
-                    !(*it).second.discover_counters_(info,
-                        discover_counter, mode, ec))
+                    !(*it).second.discover_counters_(
+                        info, discover_counter, mode, ec))
                 {
                     return status_invalid_data;
                 }
             }
 
-            if (!found_one) {
+            if (!found_one)
+            {
                 // compose a list of known counter types
                 std::string types;
                 counter_type_map_type::const_iterator end = countertypes_.end();
-                for (counter_type_map_type::const_iterator it = countertypes_.begin();
+                for (counter_type_map_type::const_iterator it =
+                         countertypes_.begin();
                      it != end; ++it)
                 {
                     types += "  " + (*it).first + "\n";
                 }
 
-                HPX_THROWS_IF(ec, bad_parameter, "registry::discover_counter_type",
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "registry::discover_counter_type",
                     hpx::util::format(
                         "counter type {} does not match any known type, "
-                        "known counter types: \n{}", type_name, types));
+                        "known counter types: \n{}",
+                        type_name, types));
                 return status_counter_type_unknown;
             }
         }
@@ -226,8 +239,8 @@ namespace hpx { namespace performance_counters
 
     /// \brief Call the supplied function for all registered counter types.
     counter_status registry::discover_counter_types(
-        discover_counter_func discover_counter,
-        discover_counters_mode mode, error_code& ec)
+        discover_counter_func discover_counter, discover_counters_mode mode,
+        error_code& ec)
     {
         // Introducing this temporary silence a report about a potential memory
         // from clang's static analyzer
@@ -247,7 +260,7 @@ namespace hpx { namespace performance_counters
         {
             if (!d.second.discover_counters_.empty() &&
                 !d.second.discover_counters_(
-                      d.second.info_, discover_counter_, mode, ec))
+                    d.second.info_, discover_counter_, mode, ec))
             {
                 return status_invalid_data;
             }
@@ -266,16 +279,21 @@ namespace hpx { namespace performance_counters
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
-
-        counter_type_map_type::const_iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
+
+        counter_type_map_type::const_iterator it =
+            locate_counter_type(type_name);
+        if (it == countertypes_.end())
+        {
             // compose a list of known counter types
             std::string types;
             counter_type_map_type::const_iterator end = countertypes_.end();
-            for (counter_type_map_type::const_iterator it = countertypes_.begin();
-                    it != end; ++it)
+            for (counter_type_map_type::const_iterator it =
+                     countertypes_.begin();
+                 it != end; ++it)
             {
                 types += "  " + (*it).first + "\n";
             }
@@ -284,16 +302,18 @@ namespace hpx { namespace performance_counters
                 "registry::get_counter_create_function",
                 hpx::util::format(
                     "counter type {} is not defined, known counter "
-                    "types: \n{}", type_name, types));
+                    "types: \n{}",
+                    type_name, types));
             return status_counter_type_unknown;
         }
 
-        if ((*it).second.create_counter_.empty()) {
+        if ((*it).second.create_counter_.empty())
+        {
             HPX_THROWS_IF(ec, bad_parameter,
                 "registry::get_counter_create_function",
-                hpx::util::format(
-                    "counter type {} has no associated create "
-                    "function", type_name));
+                hpx::util::format("counter type {} has no associated create "
+                                  "function",
+                    type_name));
             return status_invalid_data;
         }
 
@@ -311,24 +331,28 @@ namespace hpx { namespace performance_counters
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
-
-        counter_type_map_type::const_iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
+
+        counter_type_map_type::const_iterator it =
+            locate_counter_type(type_name);
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter,
                 "registry::get_counter_discovery_function",
-                hpx::util::format(
-                    "counter type {} is not defined", type_name));
+                hpx::util::format("counter type {} is not defined", type_name));
             return status_counter_type_unknown;
         }
 
-        if ((*it).second.discover_counters_.empty()) {
+        if ((*it).second.discover_counters_.empty())
+        {
             HPX_THROWS_IF(ec, bad_parameter,
                 "registry::get_counter_discovery_function",
-                hpx::util::format(
-                    "counter type {} has no associated discovery "
-                    "function", type_name));
+                hpx::util::format("counter type {} has no associated discovery "
+                                  "function",
+                    type_name));
             return status_invalid_data;
         }
 
@@ -340,24 +364,26 @@ namespace hpx { namespace performance_counters
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    counter_status registry::remove_counter_type(counter_info const& info,
-        error_code& ec)
+    counter_status registry::remove_counter_type(
+        counter_info const& info, error_code& ec)
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "registry::remove_counter_type",
                 "counter type is not defined");
             return status_counter_type_unknown;
         }
 
         LPCS_(info) << hpx::util::format(
-            "counter type {} unregistered",
-            type_name);
+            "counter type {} unregistered", type_name);
 
         countertypes_.erase(it);
 
@@ -384,22 +410,21 @@ namespace hpx { namespace performance_counters
         return create_raw_counter(info, func, id, ec);
     }
 
-    static std::int64_t
-    wrap_raw_counter(hpx::util::function_nonser<std::int64_t()> const& f, bool)
+    static std::int64_t wrap_raw_counter(
+        hpx::util::function_nonser<std::int64_t()> const& f, bool)
     {
         return f();
     }
 
-    static std::vector<std::int64_t>
-    wrap_raw_values_counter(
+    static std::vector<std::int64_t> wrap_raw_values_counter(
         hpx::util::function_nonser<std::vector<std::int64_t>()> const& f, bool)
     {
         return f();
     }
 
     counter_status registry::create_raw_counter(counter_info const& info,
-        hpx::util::function_nonser<std::int64_t()> const& f, naming::gid_type& id,
-        error_code& ec)
+        hpx::util::function_nonser<std::int64_t()> const& f,
+        naming::gid_type& id, error_code& ec)
     {
         using util::placeholders::_1;
         hpx::util::function_nonser<std::int64_t(bool)> func(
@@ -408,41 +433,49 @@ namespace hpx { namespace performance_counters
     }
 
     counter_status registry::create_raw_counter(counter_info const& info,
-        hpx::util::function_nonser<std::int64_t(bool)> const& f, naming::gid_type& id,
-        error_code& ec)
+        hpx::util::function_nonser<std::int64_t(bool)> const& f,
+        naming::gid_type& id, error_code& ec)
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "registry::create_raw_counter",
                 hpx::util::format("unknown counter type {}", type_name));
             return status_counter_type_unknown;
         }
 
         // make sure the counter type requested is supported
-        if (counter_raw != (*it).second.info_.type_ || counter_raw != info.type_)
+        if (counter_raw != (*it).second.info_.type_ ||
+            counter_raw != info.type_)
         {
             HPX_THROWS_IF(ec, bad_parameter, "registry::create_raw_counter",
-                "invalid counter type requested (only counter_raw is supported)");
+                "invalid counter type requested (only counter_raw is "
+                "supported)");
             return status_counter_type_unknown;
         }
 
         // make sure parent instance name is set properly
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, (*it).second.info_, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create the counter as requested
-        try {
+        try
+        {
             typedef components::component<server::raw_counter> counter_t;
             id = components::server::construct<counter_t>(complemented_info, f);
         }
-        catch (hpx::exception const& e) {
-            id = naming::invalid_gid;        // reset result
+        catch (hpx::exception const& e)
+        {
+            id = naming::invalid_gid;    // reset result
             if (&ec == &throws)
                 throw;
             ec = make_error_code(e.get_error(), e.what());
@@ -453,8 +486,7 @@ namespace hpx { namespace performance_counters
         }
 
         LPCS_(info) << hpx::util::format(
-            "raw counter {} created at {}",
-            complemented_info.fullname_, id);
+            "raw counter {} created at {}", complemented_info.fullname_, id);
 
         if (&ec != &throws)
             ec = make_success_code();
@@ -477,11 +509,14 @@ namespace hpx { namespace performance_counters
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "registry::create_raw_counter",
                 hpx::util::format("unknown counter type {}", type_name));
             return status_counter_type_unknown;
@@ -489,9 +524,9 @@ namespace hpx { namespace performance_counters
 
         // make sure the counter type requested is supported
         if (!((counter_histogram == (*it).second.info_.type_ &&
-               counter_histogram == info.type_) ||
-              (counter_raw_values == (*it).second.info_.type_ &&
-               counter_raw_values == info.type_)))
+                  counter_histogram == info.type_) ||
+                (counter_raw_values == (*it).second.info_.type_ &&
+                    counter_raw_values == info.type_)))
         {
             HPX_THROWS_IF(ec, bad_parameter, "registry::create_raw_counter",
                 "invalid counter type requested (only counter_histogram "
@@ -502,15 +537,18 @@ namespace hpx { namespace performance_counters
         // make sure parent instance name is set properly
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, (*it).second.info_, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create the counter as requested
-        try {
+        try
+        {
             typedef components::component<server::raw_values_counter> counter_t;
             id = components::server::construct<counter_t>(complemented_info, f);
         }
-        catch (hpx::exception const& e) {
-            id = naming::invalid_gid;        // reset result
+        catch (hpx::exception const& e)
+        {
+            id = naming::invalid_gid;    // reset result
             if (&ec == &throws)
                 throw;
             ec = make_error_code(e.get_error(), e.what());
@@ -521,8 +559,7 @@ namespace hpx { namespace performance_counters
         }
 
         LPCS_(info) << hpx::util::format(
-            "raw counter {} created at {}",
-            complemented_info.fullname_, id);
+            "raw counter {} created at {}", complemented_info.fullname_, id);
 
         if (&ec != &throws)
             ec = make_success_code();
@@ -530,16 +567,19 @@ namespace hpx { namespace performance_counters
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    counter_status registry::create_counter(counter_info const& info,
-        naming::gid_type& id, error_code& ec)
+    counter_status registry::create_counter(
+        counter_info const& info, naming::gid_type& id, error_code& ec)
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "registry::create_counter",
                 hpx::util::format("unknown counter type {}", type_name));
             return status_counter_type_unknown;
@@ -548,18 +588,22 @@ namespace hpx { namespace performance_counters
         // make sure parent instance name is set properly
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, (*it).second.info_, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create the counter as requested
-        try {
-            switch (complemented_info.type_) {
+        try
+        {
+            switch (complemented_info.type_)
+            {
             case counter_elapsed_time:
-                {
-                    typedef components::component<server::elapsed_time_counter>
-                        counter_t;
-                    id = components::server::construct<counter_t>(complemented_info);
-                }
-                break;
+            {
+                typedef components::component<server::elapsed_time_counter>
+                    counter_t;
+                id =
+                    components::server::construct<counter_t>(complemented_info);
+            }
+            break;
 
             case counter_raw:
                 HPX_THROWS_IF(ec, bad_parameter, "registry::create_counter",
@@ -572,20 +616,20 @@ namespace hpx { namespace performance_counters
                 return status_counter_type_unknown;
             }
         }
-        catch (hpx::exception const& e) {
-            id = naming::invalid_gid;        // reset result
+        catch (hpx::exception const& e)
+        {
+            id = naming::invalid_gid;    // reset result
             if (&ec == &throws)
                 throw;
             ec = make_error_code(e.get_error(), e.what());
             LPCS_(warning) << hpx::util::format(
-                "failed to create counter {} ({})",
-                complemented_info.fullname_, e.what());
+                "failed to create counter {} ({})", complemented_info.fullname_,
+                e.what());
             return status_invalid_data;
         }
 
         LPCS_(info) << hpx::util::format(
-            "counter {} created at {}",
-            complemented_info.fullname_, id);
+            "counter {} created at {}", complemented_info.fullname_, id);
 
         if (&ec != &throws)
             ec = make_success_code();
@@ -595,19 +639,23 @@ namespace hpx { namespace performance_counters
     /// \brief Create a new statistics performance counter instance based
     ///        on given base counter name and given base time interval
     ///        (milliseconds).
-    counter_status registry::create_statistics_counter(
-        counter_info const& info, std::string const& base_counter_name,
-        std::vector<std::size_t> const& parameters,
-        naming::gid_type& gid, error_code& ec)
+    counter_status registry::create_statistics_counter(counter_info const& info,
+        std::string const& base_counter_name,
+        std::vector<std::size_t> const& parameters, naming::gid_type& gid,
+        error_code& ec)
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
-            HPX_THROWS_IF(ec, bad_parameter, "registry::create_statistics_counter",
+        if (it == countertypes_.end())
+        {
+            HPX_THROWS_IF(ec, bad_parameter,
+                "registry::create_statistics_counter",
                 hpx::util::format("unknown counter type {}", type_name));
             return status_counter_type_unknown;
         }
@@ -616,7 +664,8 @@ namespace hpx { namespace performance_counters
         if (counter_aggregating != (*it).second.info_.type_ ||
             counter_aggregating != info.type_)
         {
-            HPX_THROWS_IF(ec, bad_parameter, "registry::create_statistics_counter",
+            HPX_THROWS_IF(ec, bad_parameter,
+                "registry::create_statistics_counter",
                 "invalid counter type requested \
                  (only counter_aggregating is supported)");
             return status_counter_type_unknown;
@@ -625,28 +674,32 @@ namespace hpx { namespace performance_counters
         // make sure parent instance name is set properly
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, (*it).second.info_, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // split name
         counter_path_elements p;
         get_counter_path_elements(complemented_info.fullname_, p, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create the counter as requested
-        try {
+        try
+        {
             // extract parameters
-            std::size_t sample_interval = 1000;   // default sampling interval
+            std::size_t sample_interval = 1000;    // default sampling interval
             bool reset_base_counter = false;
 
             if (!parameters.empty())
                 sample_interval = parameters[0];
 
             // create base counter only if it does not exist yet
-            if (p.countername_ == "average") {
+            if (p.countername_ == "average")
+            {
                 typedef hpx::components::component<
                     hpx::performance_counters::server::statistics_counter<
-                        boost::accumulators::tag::mean>
-                > counter_t;
+                        boost::accumulators::tag::mean>>
+                    counter_t;
 
                 if (parameters.size() > 1)
                     reset_base_counter = (parameters[1] != 0) ? true : false;
@@ -655,11 +708,12 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval, 0,
                     reset_base_counter);
             }
-            else if (p.countername_ == "stddev") {
+            else if (p.countername_ == "stddev")
+            {
                 typedef hpx::components::component<
                     hpx::performance_counters::server::statistics_counter<
-                        boost::accumulators::tag::variance>
-                > counter_t;
+                        boost::accumulators::tag::variance>>
+                    counter_t;
 
                 if (parameters.size() > 1)
                     reset_base_counter = (parameters[1] != 0) ? true : false;
@@ -668,13 +722,14 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval, 0,
                     reset_base_counter);
             }
-            else if (p.countername_ == "rolling_average") {
+            else if (p.countername_ == "rolling_average")
+            {
                 typedef hpx::components::component<
                     hpx::performance_counters::server::statistics_counter<
-                        boost::accumulators::tag::rolling_mean>
-                > counter_t;
+                        boost::accumulators::tag::rolling_mean>>
+                    counter_t;
 
-                std::size_t window_size = 10;   // default rolling window size
+                std::size_t window_size = 10;    // default rolling window size
                 if (parameters.size() > 1)
                     window_size = parameters[1];
 
@@ -685,13 +740,14 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval,
                     window_size, reset_base_counter);
             }
-            else if (p.countername_ == "rolling_stddev") {
+            else if (p.countername_ == "rolling_stddev")
+            {
                 typedef hpx::components::component<
                     hpx::performance_counters::server::statistics_counter<
-                        boost::accumulators::tag::rolling_variance>
-                > counter_t;
+                        boost::accumulators::tag::rolling_variance>>
+                    counter_t;
 
-                std::size_t window_size = 10;   // default rolling window size
+                std::size_t window_size = 10;    // default rolling window size
                 if (parameters.size() > 1)
                     window_size = parameters[1];
 
@@ -702,11 +758,12 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval,
                     window_size, reset_base_counter);
             }
-            else if (p.countername_ == "median") {
+            else if (p.countername_ == "median")
+            {
                 typedef hpx::components::component<
                     hpx::performance_counters::server::statistics_counter<
-                        boost::accumulators::tag::median>
-                > counter_t;
+                        boost::accumulators::tag::median>>
+                    counter_t;
 
                 if (parameters.size() > 1)
                     reset_base_counter = (parameters[1] != 0) ? true : false;
@@ -715,11 +772,12 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval, 0,
                     reset_base_counter);
             }
-            else if (p.countername_ == "max") {
+            else if (p.countername_ == "max")
+            {
                 typedef hpx::components::component<
                     hpx::performance_counters::server::statistics_counter<
-                        boost::accumulators::tag::max>
-                > counter_t;
+                        boost::accumulators::tag::max>>
+                    counter_t;
 
                 if (parameters.size() > 1)
                     reset_base_counter = (parameters[1] != 0) ? true : false;
@@ -728,11 +786,12 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval, 0,
                     reset_base_counter);
             }
-            else if (p.countername_ == "min") {
+            else if (p.countername_ == "min")
+            {
                 typedef hpx::components::component<
                     hpx::performance_counters::server::statistics_counter<
-                        boost::accumulators::tag::min>
-                > counter_t;
+                        boost::accumulators::tag::min>>
+                    counter_t;
 
                 if (parameters.size() > 1)
                     reset_base_counter = (parameters[1] != 0) ? true : false;
@@ -741,13 +800,13 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval, 0,
                     reset_base_counter);
             }
-            else if (p.countername_ == "rolling_min") {
-                typedef hpx::components::component<
-                    hpx::performance_counters::server::statistics_counter<
-                        hpx::util::tag::rolling_min>
-                > counter_t;
+            else if (p.countername_ == "rolling_min")
+            {
+                typedef hpx::components::component<hpx::performance_counters::
+                        server::statistics_counter<hpx::util::tag::rolling_min>>
+                    counter_t;
 
-                std::size_t window_size = 10;   // default rolling window size
+                std::size_t window_size = 10;    // default rolling window size
                 if (parameters.size() > 1)
                     window_size = parameters[1];
 
@@ -758,13 +817,13 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval,
                     window_size, reset_base_counter);
             }
-            else if (p.countername_ == "rolling_max") {
-                typedef hpx::components::component<
-                    hpx::performance_counters::server::statistics_counter<
-                        hpx::util::tag::rolling_max>
-                > counter_t;
+            else if (p.countername_ == "rolling_max")
+            {
+                typedef hpx::components::component<hpx::performance_counters::
+                        server::statistics_counter<hpx::util::tag::rolling_max>>
+                    counter_t;
 
-                std::size_t window_size = 10;   // default rolling window size
+                std::size_t window_size = 10;    // default rolling window size
                 if (parameters.size() > 1)
                     window_size = parameters[1];
 
@@ -775,15 +834,17 @@ namespace hpx { namespace performance_counters
                     complemented_info, base_counter_name, sample_interval,
                     window_size, reset_base_counter);
             }
-            else {
+            else
+            {
                 HPX_THROWS_IF(ec, bad_parameter,
                     "registry::create_statistics_counter",
                     "invalid counter type requested: " + p.countername_);
                 return status_counter_type_unknown;
             }
         }
-        catch (hpx::exception const& e) {
-            gid = naming::invalid_gid;        // reset result
+        catch (hpx::exception const& e)
+        {
+            gid = naming::invalid_gid;    // reset result
             if (&ec == &throws)
                 throw;
 
@@ -794,8 +855,7 @@ namespace hpx { namespace performance_counters
             return status_invalid_data;
         }
 
-        LPCS_(info) << hpx::util::format(
-            "statistics counter {} created at {}",
+        LPCS_(info) << hpx::util::format("statistics counter {} created at {}",
             complemented_info.fullname_, gid);
 
         if (&ec != &throws)
@@ -806,16 +866,20 @@ namespace hpx { namespace performance_counters
     /// \brief Create a new arithmetics performance counter instance based
     ///        on given base counter names
     counter_status registry::create_arithmetics_counter(
-        counter_info const& info, std::vector<std::string> const& base_counter_names,
+        counter_info const& info,
+        std::vector<std::string> const& base_counter_names,
         naming::gid_type& gid, error_code& ec)
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter,
                 "registry::create_arithmetics_counter",
                 hpx::util::format("unknown counter type {}", type_name));
@@ -829,60 +893,69 @@ namespace hpx { namespace performance_counters
             HPX_THROWS_IF(ec, bad_parameter,
                 "registry::create_arithmetics_counter",
                 "invalid counter type requested "
-                    "(only counter_aggregating is supported)");
+                "(only counter_aggregating is supported)");
             return status_counter_type_unknown;
         }
 
         // make sure parent instance name is set properly
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, (*it).second.info_, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // split name
         counter_path_elements p;
         get_counter_path_elements(complemented_info.fullname_, p, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create the counter as requested
-        try {
+        try
+        {
             // create base counter only if it does not exist yet
-            if (p.countername_ == "add") {
-                typedef hpx::components::component<
-                    hpx::performance_counters::server::arithmetics_counter<
-                        std::plus<double> > > counter_t;
+            if (p.countername_ == "add")
+            {
+                typedef hpx::components::component<hpx::performance_counters::
+                        server::arithmetics_counter<std::plus<double>>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "subtract") {
-                typedef hpx::components::component<
-                    hpx::performance_counters::server::arithmetics_counter<
-                        std::minus<double> > > counter_t;
+            else if (p.countername_ == "subtract")
+            {
+                typedef hpx::components::component<hpx::performance_counters::
+                        server::arithmetics_counter<std::minus<double>>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "multiply") {
-                typedef hpx::components::component<
-                    hpx::performance_counters::server::arithmetics_counter<
-                        std::multiplies<double> > > counter_t;
+            else if (p.countername_ == "multiply")
+            {
+                typedef hpx::components::component<hpx::performance_counters::
+                        server::arithmetics_counter<std::multiplies<double>>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "divide") {
-                typedef hpx::components::component<
-                    hpx::performance_counters::server::arithmetics_counter<
-                        std::divides<double> > > counter_t;
+            else if (p.countername_ == "divide")
+            {
+                typedef hpx::components::component<hpx::performance_counters::
+                        server::arithmetics_counter<std::divides<double>>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else {
+            else
+            {
                 HPX_THROWS_IF(ec, bad_parameter,
                     "registry::create_arithmetics_counter",
                     "invalid counter type requested: " + p.countername_);
                 return status_counter_type_unknown;
             }
         }
-        catch (hpx::exception const& e) {
-            gid = naming::invalid_gid;        // reset result
+        catch (hpx::exception const& e)
+        {
+            gid = naming::invalid_gid;    // reset result
             if (&ec == &throws)
                 throw;
 
@@ -893,8 +966,7 @@ namespace hpx { namespace performance_counters
             return status_invalid_data;
         }
 
-        LPCS_(info) << hpx::util::format(
-            "aggregating counter {} created at {}",
+        LPCS_(info) << hpx::util::format("aggregating counter {} created at {}",
             complemented_info.fullname_, gid);
 
         if (&ec != &throws)
@@ -905,16 +977,20 @@ namespace hpx { namespace performance_counters
     /// \brief Create a new arithmetics extended performance counter instance
     ///        based on given base counter names
     counter_status registry::create_arithmetics_counter_extended(
-        counter_info const& info, std::vector<std::string> const& base_counter_names,
+        counter_info const& info,
+        std::vector<std::string> const& base_counter_names,
         naming::gid_type& gid, error_code& ec)
     {
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter,
                 "registry::create_arithmetics_counter_extended",
                 hpx::util::format("unknown counter type {}", type_name));
@@ -928,80 +1004,91 @@ namespace hpx { namespace performance_counters
             HPX_THROWS_IF(ec, bad_parameter,
                 "registry::create_arithmetics_counter_extended",
                 "invalid counter type requested "
-                    "(only counter_aggregating is supported)");
+                "(only counter_aggregating is supported)");
             return status_counter_type_unknown;
         }
 
         // make sure parent instance name is set properly
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, (*it).second.info_, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // split name
         counter_path_elements p;
         get_counter_path_elements(complemented_info.fullname_, p, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create the counter as requested
-        try {
+        try
+        {
             // create base counter only if it does not exist yet
-            if (p.countername_ == "mean") {
-                typedef hpx::components::component<
-                    hpx::performance_counters::server::arithmetics_counter_extended<
-                        boost::accumulators::tag::mean>
-                > counter_t;
+            if (p.countername_ == "mean")
+            {
+                typedef hpx::components::component<hpx::performance_counters::
+                        server::arithmetics_counter_extended<
+                            boost::accumulators::tag::mean>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "variance") {
+            else if (p.countername_ == "variance")
+            {
                 typedef hpx::components::component<
                     performance_counters::server::arithmetics_counter_extended<
-                        boost::accumulators::tag::variance>
-                > counter_t;
+                        boost::accumulators::tag::variance>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "median") {
+            else if (p.countername_ == "median")
+            {
                 typedef hpx::components::component<
                     performance_counters::server::arithmetics_counter_extended<
-                        boost::accumulators::tag::median>
-                > counter_t;
+                        boost::accumulators::tag::median>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "min") {
+            else if (p.countername_ == "min")
+            {
                 typedef hpx::components::component<
                     performance_counters::server::arithmetics_counter_extended<
-                        boost::accumulators::tag::min>
-                > counter_t;
+                        boost::accumulators::tag::min>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "max") {
+            else if (p.countername_ == "max")
+            {
                 typedef hpx::components::component<
                     performance_counters::server::arithmetics_counter_extended<
-                        boost::accumulators::tag::max>
-                > counter_t;
+                        boost::accumulators::tag::max>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else if (p.countername_ == "count") {
+            else if (p.countername_ == "count")
+            {
                 typedef hpx::components::component<
                     performance_counters::server::arithmetics_counter_extended<
-                        boost::accumulators::tag::count>
-                > counter_t;
+                        boost::accumulators::tag::count>>
+                    counter_t;
                 gid = components::server::construct<counter_t>(
                     complemented_info, base_counter_names);
             }
-            else {
+            else
+            {
                 HPX_THROWS_IF(ec, bad_parameter,
                     "registry::create_arithmetics_counter",
                     "invalid counter type requested: " + p.countername_);
                 return status_counter_type_unknown;
             }
         }
-        catch (hpx::exception const& e) {
-            gid = naming::invalid_gid;        // reset result
+        catch (hpx::exception const& e)
+        {
+            gid = naming::invalid_gid;    // reset result
             if (&ec == &throws)
                 throw;
 
@@ -1012,8 +1099,7 @@ namespace hpx { namespace performance_counters
             return status_invalid_data;
         }
 
-        LPCS_(info) << hpx::util::format(
-            "aggregating counter {} created at {}",
+        LPCS_(info) << hpx::util::format("aggregating counter {} created at {}",
             complemented_info.fullname_, gid);
 
         if (&ec != &throws)
@@ -1023,23 +1109,26 @@ namespace hpx { namespace performance_counters
 
     ///////////////////////////////////////////////////////////////////////////
     /// \brief Add an existing performance counter instance to the registry
-    counter_status registry::add_counter(naming::id_type const& id,
-        counter_info const& info, error_code& ec)
+    counter_status registry::add_counter(
+        naming::id_type const& id, counter_info const& info, error_code& ec)
     {
         // complement counter info data
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create canonical type name
         std::string type_name;
-        counter_status status = get_counter_type_name(
-            complemented_info.fullname_, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_type_name(complemented_info.fullname_, type_name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         // make sure the type of the new counter is known to the registry
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "registry::add_counter",
                 hpx::util::format("unknown counter type {}", type_name));
             return status_counter_type_unknown;
@@ -1047,9 +1136,10 @@ namespace hpx { namespace performance_counters
 
         // register the canonical name with AGAS
         std::string name(complemented_info.fullname_);
-        ensure_counter_prefix(name);      // pre-pend prefix, if necessary
+        ensure_counter_prefix(name);    // pre-pend prefix, if necessary
         agas::register_name(launch::sync, name, id, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         if (&ec != &throws)
             ec = make_success_code();
@@ -1057,64 +1147,68 @@ namespace hpx { namespace performance_counters
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    counter_status registry::remove_counter(counter_info const& info,
-        naming::id_type const& id, error_code& ec)
+    counter_status registry::remove_counter(
+        counter_info const& info, naming::id_type const& id, error_code& ec)
     {
         // make sure parent instance name is set properly
         counter_info complemented_info = info;
         complement_counter_info(complemented_info, ec);
-        if (ec) return status_invalid_data;
+        if (ec)
+            return status_invalid_data;
 
         // create canonical name for the counter
         std::string name;
-        counter_status status = get_counter_name(complemented_info.fullname_,
-            name, ec);
-        if (!status_is_valid(status)) return status;
+        counter_status status =
+            get_counter_name(complemented_info.fullname_, name, ec);
+        if (!status_is_valid(status))
+            return status;
 
         // unregister this counter from AGAS
-        ensure_counter_prefix(name);      // pre-pend prefix, if necessary
+        ensure_counter_prefix(name);    // pre-pend prefix, if necessary
         agas::unregister_name(launch::sync, name, ec);
-        if (ec) {
+        if (ec)
+        {
             LPCS_(warning) << hpx::util::format(
-                "failed to remove counter {}",
-                complemented_info.fullname_);
+                "failed to remove counter {}", complemented_info.fullname_);
             return status_invalid_data;
         }
 
-//         // delete the counter
-//         switch (info.type_) {
-//         case counter_elapsed_time:
-//         case counter_raw:
-// //             {
-// //                 typedef
-// //                     components::component<server::raw_counter>
-// //                 counter_type;
-// //                 components::server::destroy<counter_type>(id.get_gid(), ec);
-// //                 if (ec) return status_invalid_data;
-// //             }
-//             break;
-//
-//         default:
-//             HPX_THROWS_IF(ec, bad_parameter, "registry::remove_counter",
-//                 "invalid counter type requested");
-//             return status_counter_type_unknown;
-//         }
+        //         // delete the counter
+        //         switch (info.type_) {
+        //         case counter_elapsed_time:
+        //         case counter_raw:
+        // //             {
+        // //                 typedef
+        // //                     components::component<server::raw_counter>
+        // //                 counter_type;
+        // //                 components::server::destroy<counter_type>(id.get_gid(), ec);
+        // //                 if (ec) return status_invalid_data;
+        // //             }
+        //             break;
+        //
+        //         default:
+        //             HPX_THROWS_IF(ec, bad_parameter, "registry::remove_counter",
+        //                 "invalid counter type requested");
+        //             return status_counter_type_unknown;
+        //         }
         return status_valid_data;
     }
 
     ///////////////////////////////////////////////////////////////////////////
     /// \brief Retrieve counter type information for given counter name
-    counter_status registry::get_counter_type(std::string const& name,
-        counter_info& info, error_code& ec)
+    counter_status registry::get_counter_type(
+        std::string const& name, counter_info& info, error_code& ec)
     {
         // create canonical type name
         std::string type_name;
         counter_status status = get_counter_type_name(name, type_name, ec);
-        if (!status_is_valid(status)) return status;
+        if (!status_is_valid(status))
+            return status;
 
         // make sure the type of the counter is known to the registry
         counter_type_map_type::iterator it = locate_counter_type(type_name);
-        if (it == countertypes_.end()) {
+        if (it == countertypes_.end())
+        {
             HPX_THROWS_IF(ec, bad_parameter, "registry::get_counter_type",
                 hpx::util::format("unknown counter type {}", type_name));
             return status_counter_type_unknown;
@@ -1126,6 +1220,4 @@ namespace hpx { namespace performance_counters
             ec = make_success_code();
         return status_valid_data;
     }
-}}
-
-
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/server/action_invocation_counter.cpp b/libs/performance_counters/src/server/action_invocation_counter.cpp
similarity index 60%
rename from src/performance_counters/server/action_invocation_counter.cpp
rename to libs/performance_counters/src/server/action_invocation_counter.cpp
index be54bb457b..e1e1f6f9f3 100644
--- a/src/performance_counters/server/action_invocation_counter.cpp
+++ b/libs/performance_counters/src/server/action_invocation_counter.cpp
@@ -5,17 +5,16 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/performance_counters/counters.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
 #include <hpx/runtime/actions/detail/invocation_count_registry.hpp>
-#include <hpx/functional/function.hpp>
 
 #include <cstdint>
 #include <utility>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     // Discoverer function for action invocation counters
     bool action_invocation_counter_discoverer(counter_info const& info,
@@ -27,10 +26,12 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         bool result = registry.counter_discoverer(info, p, f, mode, ec);
-        if (!result || ec) return false;
+        if (!result || ec)
+            return false;
 
         if (&ec != &throws)
             ec = make_success_code();
@@ -43,8 +44,8 @@ namespace hpx { namespace performance_counters
         error_code& ec)
     {
         using hpx::actions::detail::invocation_count_registry;
-        return action_invocation_counter_discoverer(info, f, mode,
-            invocation_count_registry::local_instance(), ec);
+        return action_invocation_counter_discoverer(
+            info, f, mode, invocation_count_registry::local_instance(), ec);
     }
 
 #if defined(HPX_HAVE_NETWORKING)
@@ -53,8 +54,8 @@ namespace hpx { namespace performance_counters
         error_code& ec)
     {
         using hpx::actions::detail::invocation_count_registry;
-        return action_invocation_counter_discoverer(info, f, mode,
-            invocation_count_registry::remote_instance(), ec);
+        return action_invocation_counter_discoverer(
+            info, f, mode, invocation_count_registry::remote_instance(), ec);
     }
 #endif
 
@@ -64,36 +65,40 @@ namespace hpx { namespace performance_counters
         hpx::actions::detail::invocation_count_registry& registry,
         error_code& ec)
     {
-        switch (info.type_) {
+        switch (info.type_)
+        {
         case counter_raw:
+        {
+            counter_path_elements paths;
+            get_counter_path_elements(info.fullname_, paths, ec);
+            if (ec)
+                return naming::invalid_gid;
+
+            if (paths.parentinstance_is_basename_)
+            {
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "action_invocation_counter_creator",
+                    "invalid action invocation counter name (instance name "
+                    "must not be a valid base counter name)");
+                return naming::invalid_gid;
+            }
+
+            if (paths.parameters_.empty())
             {
-                counter_path_elements paths;
-                get_counter_path_elements(info.fullname_, paths, ec);
-                if (ec) return naming::invalid_gid;
-
-                if (paths.parentinstance_is_basename_) {
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "action_invocation_counter_creator",
-                        "invalid action invocation counter name (instance name "
-                        "must not be a valid base counter name)");
-                    return naming::invalid_gid;
-                }
-
-                if (paths.parameters_.empty()) {
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "action_invocation_counter_creator",
-                        "invalid action invocation counter parameter: must "
-                        "specify an action type");
-                    return naming::invalid_gid;
-                }
-
-                // ask registry
-                hpx::util::function_nonser<std::int64_t(bool)> f =
-                    registry.get_invocation_counter(paths.parameters_);
-
-                return detail::create_raw_counter(info, std::move(f), ec);
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "action_invocation_counter_creator",
+                    "invalid action invocation counter parameter: must "
+                    "specify an action type");
+                return naming::invalid_gid;
             }
-            break;
+
+            // ask registry
+            hpx::util::function_nonser<std::int64_t(bool)> f =
+                registry.get_invocation_counter(paths.parameters_);
+
+            return detail::create_raw_counter(info, std::move(f), ec);
+        }
+        break;
 
         default:
             HPX_THROWS_IF(ec, bad_parameter,
@@ -107,8 +112,8 @@ namespace hpx { namespace performance_counters
         counter_info const& info, error_code& ec)
     {
         using hpx::actions::detail::invocation_count_registry;
-        return action_invocation_counter_creator(info,
-            invocation_count_registry::local_instance(), ec);
+        return action_invocation_counter_creator(
+            info, invocation_count_registry::local_instance(), ec);
     }
 
 #if defined(HPX_HAVE_NETWORKING)
@@ -116,9 +121,8 @@ namespace hpx { namespace performance_counters
         counter_info const& info, error_code& ec)
     {
         using hpx::actions::detail::invocation_count_registry;
-        return action_invocation_counter_creator(info,
-            invocation_count_registry::remote_instance(), ec);
+        return action_invocation_counter_creator(
+            info, invocation_count_registry::remote_instance(), ec);
     }
 #endif
-}}
-
+}}    // namespace hpx::performance_counters
diff --git a/src/performance_counters/server/arithmetics_counter.cpp b/libs/performance_counters/src/server/arithmetics_counter.cpp
similarity index 57%
rename from src/performance_counters/server/arithmetics_counter.cpp
rename to libs/performance_counters/src/server/arithmetics_counter.cpp
index d6bc8e3f0a..478e1fc3cc 100644
--- a/src/performance_counters/server/arithmetics_counter.cpp
+++ b/libs/performance_counters/src/server/arithmetics_counter.cpp
@@ -4,21 +4,18 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #include <hpx/config.hpp>
-#include <hpx/runtime/runtime_fwd.hpp>
-#include <hpx/runtime/components/derived_component_factory.hpp>
+#include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
+#include <hpx/performance_counters/server/arithmetics_counter.hpp>
+#include <hpx/performance_counters/stubs/performance_counter.hpp>
 #include <hpx/runtime/actions/continuation.hpp>
 #include <hpx/runtime/agas/interface.hpp>
+#include <hpx/runtime/components/derived_component_factory.hpp>
 #include <hpx/runtime/launch_policy.hpp>
+#include <hpx/runtime/runtime_fwd.hpp>
+#include <hpx/string_util.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
-#include <hpx/performance_counters/counters.hpp>
-#include <hpx/performance_counters/counter_creators.hpp>
-#include <hpx/performance_counters/stubs/performance_counter.hpp>
-#include <hpx/performance_counters/server/arithmetics_counter.hpp>
-
-#include <boost/algorithm/string.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -28,48 +25,59 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     ///////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
+    namespace detail {
         template <typename Operation>
         struct init_value;
 
         template <>
-        struct init_value<std::plus<double> >
+        struct init_value<std::plus<double>>
         {
-            static double call() { return 0.0; }
+            static double call()
+            {
+                return 0.0;
+            }
         };
 
         template <>
-        struct init_value<std::minus<double> >
+        struct init_value<std::minus<double>>
         {
-            static double call() { return 0.0; }
+            static double call()
+            {
+                return 0.0;
+            }
         };
 
         template <>
-        struct init_value<std::multiplies<double> >
+        struct init_value<std::multiplies<double>>
         {
-            static double call() { return 1.0; }
+            static double call()
+            {
+                return 1.0;
+            }
         };
 
         template <>
-        struct init_value<std::divides<double> >
+        struct init_value<std::divides<double>>
         {
-            static double call() { return 1.0; }
+            static double call()
+            {
+                return 1.0;
+            }
         };
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename Operation>
     arithmetics_counter<Operation>::arithmetics_counter(
-            counter_info const& info,
-            std::vector<std::string> const& base_counter_names)
-      : base_type_holder(info),
-        counters_(base_counter_names)
+        counter_info const& info,
+        std::vector<std::string> const& base_counter_names)
+      : base_type_holder(info)
+      , counters_(base_counter_names)
     {
-        if (info.type_ != counter_aggregating) {
+        if (info.type_ != counter_aggregating)
+        {
             HPX_THROW_EXCEPTION(bad_parameter,
                 "arithmetics_counter<Operation>::arithmetics_counter",
                 "unexpected counter type specified");
@@ -86,14 +94,15 @@ namespace hpx { namespace performance_counters { namespace server
                     "arithmetics_counter<Operation>::arithmetics_counter",
                     "the parameter specification for an arithmetic counter "
                     "'/arithmetics/divide' has to expand to more than one "
-                    "counter name: " + paths.parameters_);
+                    "counter name: " +
+                        paths.parameters_);
             }
         }
     }
 
     template <typename Operation>
     hpx::performance_counters::counter_value
-        arithmetics_counter<Operation>::get_counter_value(bool reset)
+    arithmetics_counter<Operation>::get_counter_value(bool reset)
     {
         std::vector<counter_value> base_values =
             counters_.get_counter_values(hpx::launch::sync);
@@ -105,17 +114,20 @@ namespace hpx { namespace performance_counters { namespace server
             value = Operation()(value, base_value.get_value<double>());
         }
 
-        if (base_values[0].scale_inverse_ && base_values[0].scaling_ != 1.0) //-V550
+        if (base_values[0].scale_inverse_ &&
+            base_values[0].scaling_ != 1.0)    //-V550
         {
             base_values[0].value_ =
                 static_cast<std::int64_t>(value * base_values[0].scaling_);
         }
-        else {
+        else
+        {
             base_values[0].value_ =
                 static_cast<std::int64_t>(value / base_values[0].scaling_);
         }
 
-        base_values[0].time_ = static_cast<std::int64_t>(hpx::get_system_uptime());
+        base_values[0].time_ =
+            static_cast<std::int64_t>(hpx::get_system_uptime());
         base_values[0].count_ = counters_.get_invocation_count();
 
         return base_values[0];
@@ -138,120 +150,122 @@ namespace hpx { namespace performance_counters { namespace server
     {
         counters_.reset(hpx::launch::sync);
     }
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 ///////////////////////////////////////////////////////////////////////////////
-template class HPX_EXPORT hpx::performance_counters::server::arithmetics_counter<
-    std::plus<double> >;
-template class HPX_EXPORT hpx::performance_counters::server::arithmetics_counter<
-    std::minus<double> >;
-template class HPX_EXPORT hpx::performance_counters::server::arithmetics_counter<
-    std::multiplies<double> >;
-template class HPX_EXPORT hpx::performance_counters::server::arithmetics_counter<
-    std::divides<double> >;
+template class HPX_EXPORT
+    hpx::performance_counters::server::arithmetics_counter<std::plus<double>>;
+template class HPX_EXPORT
+    hpx::performance_counters::server::arithmetics_counter<std::minus<double>>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter<std::multiplies<double>>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter<std::divides<double>>;
 
 ///////////////////////////////////////////////////////////////////////////////
 // Addition
 typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter<std::plus<double> >
-> adding_counter_type;
+    hpx::performance_counters::server::arithmetics_counter<std::plus<double>>>
+    adding_counter_type;
 
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    adding_counter_type, adding_counter,
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(adding_counter_type, adding_counter,
     "base_performance_counter", hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(adding_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Subtraction
 typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter<std::minus<double> >
-> subtracting_counter_type;
+    hpx::performance_counters::server::arithmetics_counter<std::minus<double>>>
+    subtracting_counter_type;
 
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    subtracting_counter_type, subtracting_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(subtracting_counter_type,
+    subtracting_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(subtracting_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Multiply
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter<std::multiplies<double> >
-> multiplying_counter_type;
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter<std::multiplies<double>>>
+    multiplying_counter_type;
 
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    multiplying_counter_type, multiplying_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(multiplying_counter_type,
+    multiplying_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(multiplying_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Division
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter<std::divides<double> >
-> dividing_counter_type;
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter<std::divides<double>>>
+    dividing_counter_type;
 
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    dividing_counter_type, dividing_counter,
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(dividing_counter_type, dividing_counter,
     "base_performance_counter", hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(dividing_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace detail
-{
+namespace hpx { namespace performance_counters { namespace detail {
     /// Creation function for aggregating performance counters to be registered
     /// with the counter types.
-    naming::gid_type arithmetics_counter_creator(counter_info const& info,
-        error_code& ec)
+    naming::gid_type arithmetics_counter_creator(
+        counter_info const& info, error_code& ec)
     {
-        switch (info.type_) {
+        switch (info.type_)
+        {
         case counter_aggregating:
-            {
-                counter_path_elements paths;
-                get_counter_path_elements(info.fullname_, paths, ec);
-                if (ec) return naming::invalid_gid;
+        {
+            counter_path_elements paths;
+            get_counter_path_elements(info.fullname_, paths, ec);
+            if (ec)
+                return naming::invalid_gid;
 
-                if (!paths.parameters_.empty()) {
-                    // try to interpret the additional parameter as a list of
-                    // two performance counter names
-                    std::vector<std::string> names;
-                    boost::split(names, paths.parameters_, boost::is_any_of(","));
+            if (!paths.parameters_.empty())
+            {
+                // try to interpret the additional parameter as a list of
+                // two performance counter names
+                std::vector<std::string> names;
+                hpx::string_util::split(
+                    names, paths.parameters_, hpx::string_util::is_any_of(","));
+
+                if (names.empty())
+                {
+                    HPX_THROWS_IF(ec, bad_parameter,
+                        "arithmetics_counter_creator",
+                        "the parameter specification for an arithmetic counter "
+                        "has to expand to at least one counter name: " +
+                            paths.parameters_);
+                    return naming::invalid_gid;
+                }
 
-                    if (names.empty())
+                for (std::string const& name : names)
+                {
+                    counter_path_elements paths;
+                    if (status_valid_data !=
+                            get_counter_path_elements(name, paths, ec) ||
+                        ec)
                     {
                         HPX_THROWS_IF(ec, bad_parameter,
                             "arithmetics_counter_creator",
-                            "the parameter specification for an arithmetic counter "
-                            "has to expand to at least one counter name: " +
-                            paths.parameters_);
+                            "the given (expanded) counter name is not "
+                            "a validly formed performance counter name: " +
+                                name);
                         return naming::invalid_gid;
                     }
-
-                    for (std::string const& name : names)
-                    {
-                        counter_path_elements paths;
-                        if (status_valid_data != get_counter_path_elements(
-                                name, paths, ec) || ec)
-                        {
-                            HPX_THROWS_IF(ec, bad_parameter,
-                                "arithmetics_counter_creator",
-                                "the given (expanded) counter name is not "
-                                "a validly formed performance counter name: " +
-                                    name);
-                            return naming::invalid_gid;
-                        }
-                    }
-
-                    return create_arithmetics_counter(info, names, ec);
-                }
-                else {
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "arithmetics_counter_creator",
-                        "the parameter specification for an arithmetic counter "
-                        "has to be a comma separated list of performance "
-                        "counter names, none is given: " +
-                            remove_counter_prefix(info.fullname_));
                 }
+
+                return create_arithmetics_counter(info, names, ec);
             }
-            break;
+            else
+            {
+                HPX_THROWS_IF(ec, bad_parameter, "arithmetics_counter_creator",
+                    "the parameter specification for an arithmetic counter "
+                    "has to be a comma separated list of performance "
+                    "counter names, none is given: " +
+                        remove_counter_prefix(info.fullname_));
+            }
+        }
+        break;
 
         default:
             HPX_THROWS_IF(ec, bad_parameter, "arithmetics_counter_creator",
@@ -260,5 +274,4 @@ namespace hpx { namespace performance_counters { namespace detail
         }
         return naming::invalid_gid;
     }
-}}}
-
+}}}    // namespace hpx::performance_counters::detail
diff --git a/src/performance_counters/server/arithmetics_counter_extended.cpp b/libs/performance_counters/src/server/arithmetics_counter_extended.cpp
similarity index 57%
rename from src/performance_counters/server/arithmetics_counter_extended.cpp
rename to libs/performance_counters/src/server/arithmetics_counter_extended.cpp
index 428fe05207..44a9963d76 100644
--- a/src/performance_counters/server/arithmetics_counter_extended.cpp
+++ b/libs/performance_counters/src/server/arithmetics_counter_extended.cpp
@@ -4,26 +4,24 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #include <hpx/config.hpp>
-#include <hpx/runtime/runtime_fwd.hpp>
-#include <hpx/runtime/components/derived_component_factory.hpp>
-#include <hpx/runtime/launch_policy.hpp>
-#include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
-#include <hpx/performance_counters/stubs/performance_counter.hpp>
+#include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/server/arithmetics_counter_extended.hpp>
+#include <hpx/performance_counters/stubs/performance_counter.hpp>
+#include <hpx/runtime/components/derived_component_factory.hpp>
+#include <hpx/runtime/launch_policy.hpp>
+#include <hpx/runtime/runtime_fwd.hpp>
+#include <hpx/string_util.hpp>
 
-#include <boost/algorithm/string.hpp>
 #include <boost/accumulators/accumulators.hpp>
-#include <boost/accumulators/statistics/stats.hpp>
+#include <boost/accumulators/statistics/count.hpp>
+#include <boost/accumulators/statistics/max.hpp>
 #include <boost/accumulators/statistics/mean.hpp>
 #include <boost/accumulators/statistics/median.hpp>
-#include <boost/accumulators/statistics/variance.hpp>
-#include <boost/accumulators/statistics/max.hpp>
 #include <boost/accumulators/statistics/min.hpp>
-#include <boost/accumulators/statistics/count.hpp>
+#include <boost/accumulators/statistics/stats.hpp>
+#include <boost/accumulators/statistics/variance.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -33,26 +31,25 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     ///////////////////////////////////////////////////////////////////////////
     template <typename Statistic>
     arithmetics_counter_extended<Statistic>::arithmetics_counter_extended(
-            counter_info const& info,
-            std::vector<std::string> const& base_counter_names)
-      : base_type_holder(info),
-        counters_(base_counter_names)
+        counter_info const& info,
+        std::vector<std::string> const& base_counter_names)
+      : base_type_holder(info)
+      , counters_(base_counter_names)
     {
-        if (info.type_ != counter_aggregating) {
+        if (info.type_ != counter_aggregating)
+        {
             HPX_THROW_EXCEPTION(bad_parameter,
                 "arithmetics_counter_extended<Statistic>::"
-                    "arithmetics_counter_extended",
+                "arithmetics_counter_extended",
                 "unexpected counter type specified");
         }
     }
 
-    namespace detail
-    {
+    namespace detail {
         template <typename Statistic>
         struct statistic_get_value;
 
@@ -115,19 +112,19 @@ namespace hpx { namespace performance_counters { namespace server
                 return static_cast<double>(boost::accumulators::count(accum));
             }
         };
-    }
+    }    // namespace detail
 
     template <typename Statistic>
     hpx::performance_counters::counter_value
-        arithmetics_counter_extended<Statistic>::get_counter_value(bool reset)
+    arithmetics_counter_extended<Statistic>::get_counter_value(bool reset)
     {
         std::vector<counter_value> base_values =
             counters_.get_counter_values(hpx::launch::sync);
 
         // apply arithmetic Statistic
-        typedef boost::accumulators::accumulator_set<
-            double, boost::accumulators::stats<Statistic>
-        > accumulator_type;
+        typedef boost::accumulators::accumulator_set<double,
+            boost::accumulators::stats<Statistic>>
+            accumulator_type;
 
         accumulator_type accum;
         for (counter_value const& base_value : base_values)
@@ -136,17 +133,20 @@ namespace hpx { namespace performance_counters { namespace server
         }
         double value = detail::statistic_get_value<Statistic>::call(accum);
 
-        if (base_values[0].scale_inverse_ && base_values[0].scaling_ != 1.0) //-V550
+        if (base_values[0].scale_inverse_ &&
+            base_values[0].scaling_ != 1.0)    //-V550
         {
             base_values[0].value_ =
                 static_cast<std::int64_t>(value * base_values[0].scaling_);
         }
-        else {
+        else
+        {
             base_values[0].value_ =
                 static_cast<std::int64_t>(value / base_values[0].scaling_);
         }
 
-        base_values[0].time_ = static_cast<std::int64_t>(hpx::get_system_uptime());
+        base_values[0].time_ =
+            static_cast<std::int64_t>(hpx::get_system_uptime());
         base_values[0].count_ = counters_.get_invocation_count();
 
         return base_values[0];
@@ -169,158 +169,151 @@ namespace hpx { namespace performance_counters { namespace server
     {
         counters_.reset(hpx::launch::sync);
     }
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 ///////////////////////////////////////////////////////////////////////////////
-template class HPX_EXPORT
-hpx::performance_counters::server::arithmetics_counter_extended<
-    boost::accumulators::tag::mean>;
-template class HPX_EXPORT
-hpx::performance_counters::server::arithmetics_counter_extended<
-    boost::accumulators::tag::variance>;
-template class HPX_EXPORT
-hpx::performance_counters::server::arithmetics_counter_extended<
-    boost::accumulators::tag::median>;
-template class HPX_EXPORT
-hpx::performance_counters::server::arithmetics_counter_extended<
-    boost::accumulators::tag::min>;
-template class HPX_EXPORT
-hpx::performance_counters::server::arithmetics_counter_extended<
-    boost::accumulators::tag::max>;
-template class HPX_EXPORT
-hpx::performance_counters::server::arithmetics_counter_extended<
-    boost::accumulators::tag::count>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter_extended<boost::accumulators::tag::mean>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter_extended<boost::accumulators::tag::variance>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter_extended<boost::accumulators::tag::median>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter_extended<boost::accumulators::tag::min>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter_extended<boost::accumulators::tag::max>;
+template class HPX_EXPORT hpx::performance_counters::server::
+    arithmetics_counter_extended<boost::accumulators::tag::count>;
 
 ///////////////////////////////////////////////////////////////////////////////
 // /arithmetic/mean
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter_extended<
-        boost::accumulators::tag::mean>
-> mean_arithmetics_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    mean_arithmetics_counter_type, mean_arithmetics_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter_extended<boost::accumulators::tag::mean>>
+    mean_arithmetics_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(mean_arithmetics_counter_type,
+    mean_arithmetics_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(mean_arithmetics_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // /arithmetic/variance
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter_extended<
-        boost::accumulators::tag::variance>
-> variance_arithmetics_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    variance_arithmetics_counter_type, variance_arithmetics_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter_extended<boost::accumulators::tag::variance>>
+    variance_arithmetics_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(variance_arithmetics_counter_type,
+    variance_arithmetics_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(variance_arithmetics_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // /arithmetic/median
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter_extended<
-        boost::accumulators::tag::median>
-> median_arithmetics_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    median_arithmetics_counter_type, median_arithmetics_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter_extended<boost::accumulators::tag::median>>
+    median_arithmetics_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(median_arithmetics_counter_type,
+    median_arithmetics_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(median_arithmetics_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // /arithmetic/min
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter_extended<
-        boost::accumulators::tag::min>
-> min_arithmetics_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    min_arithmetics_counter_type, min_arithmetics_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter_extended<boost::accumulators::tag::min>>
+    min_arithmetics_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(min_arithmetics_counter_type,
+    min_arithmetics_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(min_arithmetics_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // /arithmetic/max
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter_extended<
-        boost::accumulators::tag::max>
-> max_arithmetics_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    max_arithmetics_counter_type, max_arithmetics_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter_extended<boost::accumulators::tag::max>>
+    max_arithmetics_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(max_arithmetics_counter_type,
+    max_arithmetics_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(max_arithmetics_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // /arithmetic/count
-typedef hpx::components::component<
-    hpx::performance_counters::server::arithmetics_counter_extended<
-        boost::accumulators::tag::count>
-> count_arithmetics_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    count_arithmetics_counter_type, count_arithmetics_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        arithmetics_counter_extended<boost::accumulators::tag::count>>
+    count_arithmetics_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(count_arithmetics_counter_type,
+    count_arithmetics_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(count_arithmetics_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace detail
-{
+namespace hpx { namespace performance_counters { namespace detail {
     /// Creation function for aggregating performance counters to be registered
     /// with the counter types.
     naming::gid_type arithmetics_counter_extended_creator(
         counter_info const& info, error_code& ec)
     {
-        switch (info.type_) {
+        switch (info.type_)
+        {
         case counter_aggregating:
-            {
-                counter_path_elements paths;
-                get_counter_path_elements(info.fullname_, paths, ec);
-                if (ec) return naming::invalid_gid;
+        {
+            counter_path_elements paths;
+            get_counter_path_elements(info.fullname_, paths, ec);
+            if (ec)
+                return naming::invalid_gid;
 
-                if (!paths.parameters_.empty()) {
-                    // try to interpret the additional parameter as a list of
-                    // two performance counter names
-                    std::vector<std::string> names;
-                    boost::split(names, paths.parameters_, boost::is_any_of(","));
+            if (!paths.parameters_.empty())
+            {
+                // try to interpret the additional parameter as a list of
+                // two performance counter names
+                std::vector<std::string> names;
+                hpx::string_util::split(
+                    names, paths.parameters_, hpx::string_util::is_any_of(","));
+
+                if (names.empty())
+                {
+                    HPX_THROWS_IF(ec, bad_parameter,
+                        "arithmetics_counter_extended_creator",
+                        "the parameter specification for an arithmetic counter "
+                        "has to expand to at least one counter name: " +
+                            paths.parameters_);
+                    return naming::invalid_gid;
+                }
 
-                    if (names.empty())
+                for (std::string const& name : names)
+                {
+                    counter_path_elements paths;
+                    if (status_valid_data !=
+                            get_counter_path_elements(name, paths, ec) ||
+                        ec)
                     {
                         HPX_THROWS_IF(ec, bad_parameter,
                             "arithmetics_counter_extended_creator",
-                            "the parameter specification for an arithmetic counter "
-                            "has to expand to at least one counter name: " +
-                            paths.parameters_);
+                            "the given (expanded) counter name is not "
+                            "a validly formed performance counter name: " +
+                                name);
                         return naming::invalid_gid;
                     }
-
-                    for (std::string const& name : names)
-                    {
-                        counter_path_elements paths;
-                        if (status_valid_data != get_counter_path_elements(
-                                name, paths, ec) || ec)
-                        {
-                            HPX_THROWS_IF(ec, bad_parameter,
-                                "arithmetics_counter_extended_creator",
-                                "the given (expanded) counter name is not "
-                                "a validly formed performance counter name: " +
-                                    name);
-                            return naming::invalid_gid;
-                        }
-                    }
-
-                    return create_arithmetics_counter_extended(info, names, ec);
-                }
-                else {
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "arithmetics_counter_extended_creator",
-                        "the parameter specification for an arithmetic counter "
-                        "has to be a comma separated list of performance "
-                        "counter names, none is given: " +
-                            remove_counter_prefix(info.fullname_));
                 }
+
+                return create_arithmetics_counter_extended(info, names, ec);
             }
-            break;
+            else
+            {
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "arithmetics_counter_extended_creator",
+                    "the parameter specification for an arithmetic counter "
+                    "has to be a comma separated list of performance "
+                    "counter names, none is given: " +
+                        remove_counter_prefix(info.fullname_));
+            }
+        }
+        break;
 
         default:
             HPX_THROWS_IF(ec, bad_parameter,
@@ -330,5 +323,4 @@ namespace hpx { namespace performance_counters { namespace detail
         }
         return naming::invalid_gid;
     }
-}}}
-
+}}}    // namespace hpx::performance_counters::detail
diff --git a/libs/performance_counters/src/server/component_instance_counter.cpp b/libs/performance_counters/src/server/component_instance_counter.cpp
new file mode 100644
index 0000000000..c86bb8c872
--- /dev/null
+++ b/libs/performance_counters/src/server/component_instance_counter.cpp
@@ -0,0 +1,98 @@
+//  Copyright (c) 2007-2019 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/functional/bind_front.hpp>
+#include <hpx/functional/function.hpp>
+#include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
+#include <hpx/runtime/agas/addressing_service.hpp>
+#include <hpx/runtime/agas/interface.hpp>
+#include <hpx/runtime/components/component_type.hpp>
+
+#include <cstdint>
+#include <sstream>
+#include <utility>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace hpx { namespace performance_counters { namespace detail {
+    ///////////////////////////////////////////////////////////////////////////
+    // Extract the current number of instances for the given component type
+    static std::int64_t get_instance_count(components::component_type type)
+    {
+        return hpx::components::instance_count(type);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    /// Creation function for instance counter
+    naming::gid_type component_instance_counter_creator(
+        counter_info const& info, error_code& ec)
+    {
+        switch (info.type_)
+        {
+        case counter_raw:
+        {
+            counter_path_elements paths;
+            get_counter_path_elements(info.fullname_, paths, ec);
+            if (ec)
+                return naming::invalid_gid;
+
+            if (paths.parentinstance_is_basename_)
+            {
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "component_instance_counter_creator",
+                    "invalid instance counter name (instance name must not "
+                    "be a valid base counter name)");
+                return naming::invalid_gid;
+            }
+
+            if (paths.parameters_.empty())
+            {
+                std::stringstream strm;
+                strm << "invalid instance counter parameter: must specify "
+                        "a component type\n"
+                        "known component types:\n";
+
+                components::enumerate_instance_counts(
+                    [&strm](components::component_type type) -> bool {
+                        strm << "  " << agas::get_component_type_name(type)
+                             << "\n";
+                        return true;
+                    });
+
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "component_instance_counter_creator", strm.str());
+
+                return naming::invalid_gid;
+            }
+
+            // ask AGAS to resolve the component type
+            components::component_type type =
+                naming::get_agas_client().get_component_id(paths.parameters_);
+
+            if (type == components::component_invalid)
+            {
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "component_instance_counter_creator",
+                    "invalid component type as counter parameter: " +
+                        paths.parameters_);
+                return naming::invalid_gid;
+            }
+
+            hpx::util::function_nonser<std::int64_t()> f =
+                util::bind_front(&get_instance_count, type);
+            return create_raw_counter(info, std::move(f), ec);
+        }
+        break;
+
+        default:
+            HPX_THROWS_IF(ec, bad_parameter,
+                "component_instance_counter_creator",
+                "invalid counter type requested");
+            return naming::invalid_gid;
+        }
+    }
+}}}    // namespace hpx::performance_counters::detail
diff --git a/src/performance_counters/server/elapsed_time_counter.cpp b/libs/performance_counters/src/server/elapsed_time_counter.cpp
similarity index 65%
rename from src/performance_counters/server/elapsed_time_counter.cpp
rename to libs/performance_counters/src/server/elapsed_time_counter.cpp
index 1965010818..f3516ddb32 100644
--- a/src/performance_counters/server/elapsed_time_counter.cpp
+++ b/libs/performance_counters/src/server/elapsed_time_counter.cpp
@@ -5,12 +5,12 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/components/derived_component_factory.hpp>
-#include <hpx/runtime/actions/continuation.hpp>
-#include <hpx/timing/high_resolution_clock.hpp>
-#include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/server/elapsed_time_counter.hpp>
+#include <hpx/runtime/actions/continuation.hpp>
+#include <hpx/runtime/components/derived_component_factory.hpp>
+#include <hpx/timing/high_resolution_clock.hpp>
 
 #include <boost/version.hpp>
 
@@ -18,22 +18,22 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 typedef hpx::components::component<
-    hpx::performance_counters::server::elapsed_time_counter
-> elapsed_time_counter_type;
+    hpx::performance_counters::server::elapsed_time_counter>
+    elapsed_time_counter_type;
 
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    elapsed_time_counter_type, elapsed_time_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(elapsed_time_counter_type,
+    elapsed_time_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(
     hpx::performance_counters::server::elapsed_time_counter)
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     elapsed_time_counter::elapsed_time_counter(counter_info const& info)
       : base_type_holder(info)
     {
-        if (info.type_ != counter_elapsed_time) {
+        if (info.type_ != counter_elapsed_time)
+        {
             HPX_THROW_EXCEPTION(bad_parameter,
                 "elapsed_time_counter::elapsed_time_counter",
                 "unexpected counter type specified for elapsed_time_counter");
@@ -41,7 +41,7 @@ namespace hpx { namespace performance_counters { namespace server
     }
 
     hpx::performance_counters::counter_value
-        elapsed_time_counter::get_counter_value(bool reset)
+    elapsed_time_counter::get_counter_value(bool reset)
     {
         if (reset)
         {
@@ -54,7 +54,7 @@ namespace hpx { namespace performance_counters { namespace server
         std::int64_t now = static_cast<std::int64_t>(hpx::get_system_uptime());
         hpx::performance_counters::counter_value value;
         value.value_ = now;
-        value.scaling_ = 1000000000LL;      // coefficient to get seconds
+        value.scaling_ = 1000000000LL;    // coefficient to get seconds
         value.scale_inverse_ = true;
         value.status_ = status_new_data;
         value.time_ = now;
@@ -68,40 +68,41 @@ namespace hpx { namespace performance_counters { namespace server
             "elapsed_time_counter::reset_counter_value",
             "counter /runtime/uptime does no support reset");
     }
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace detail
-{
+namespace hpx { namespace performance_counters { namespace detail {
     /// Creation function for uptime counters.
-    naming::gid_type uptime_counter_creator(counter_info const& info,
-        error_code& ec)
+    naming::gid_type uptime_counter_creator(
+        counter_info const& info, error_code& ec)
     {
-        switch (info.type_) {
+        switch (info.type_)
+        {
         case counter_elapsed_time:
-            {
-                // verify the validity of the counter instance name
-                counter_path_elements paths;
-                get_counter_path_elements(info.fullname_, paths, ec);
-                if (ec) return naming::invalid_gid;
-
-                // allowed counter names: /runtime(locality#%d/*)/uptime
-                if (paths.parentinstance_is_basename_) {
-                    HPX_THROWS_IF(ec, bad_parameter, "uptime_counter_creator",
-                        "invalid counter instance parent name: " +
-                            paths.parentinstancename_);
-                    return naming::invalid_gid;
-                }
+        {
+            // verify the validity of the counter instance name
+            counter_path_elements paths;
+            get_counter_path_elements(info.fullname_, paths, ec);
+            if (ec)
+                return naming::invalid_gid;
 
-                // create the counter
-                return create_counter(info, ec);
+            // allowed counter names: /runtime(locality#%d/*)/uptime
+            if (paths.parentinstance_is_basename_)
+            {
+                HPX_THROWS_IF(ec, bad_parameter, "uptime_counter_creator",
+                    "invalid counter instance parent name: " +
+                        paths.parentinstancename_);
+                return naming::invalid_gid;
             }
 
+            // create the counter
+            return create_counter(info, ec);
+        }
+
         default:
             HPX_THROWS_IF(ec, bad_parameter, "uptime_counter_creator",
                 "invalid counter type requested");
             return naming::invalid_gid;
         }
     }
-}}}
-
+}}}    // namespace hpx::performance_counters::detail
diff --git a/src/performance_counters/server/per_action_data_counters.cpp b/libs/performance_counters/src/server/per_action_data_counters.cpp
similarity index 53%
rename from src/performance_counters/server/per_action_data_counters.cpp
rename to libs/performance_counters/src/server/per_action_data_counters.cpp
index 2a1da38fb8..e5b27a630a 100644
--- a/src/performance_counters/server/per_action_data_counters.cpp
+++ b/libs/performance_counters/src/server/per_action_data_counters.cpp
@@ -7,19 +7,18 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_PARCELPORT_ACTION_COUNTERS) && defined(HPX_HAVE_NETWORKING)
-#include <hpx/performance_counters/counters.hpp>
+#include <hpx/functional/bind_front.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
 #include <hpx/runtime/parcelset/detail/per_action_data_counter_registry.hpp>
-#include <hpx/functional/function.hpp>
-#include <hpx/functional/bind_front.hpp>
 
 #include <cstdint>
 #include <string>
 #include <utility>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters
-{
+namespace hpx { namespace performance_counters {
     ///////////////////////////////////////////////////////////////////////////
     // Discoverer function for per-action parcel data counters
     bool per_action_data_counter_discoverer(counter_info const& info,
@@ -31,10 +30,12 @@ namespace hpx { namespace performance_counters
         performance_counters::counter_path_elements p;
         performance_counters::counter_status status =
             get_counter_path_elements(info.fullname_, p, ec);
-        if (!status_is_valid(status)) return false;
+        if (!status_is_valid(status))
+            return false;
 
         bool result = registry.counter_discoverer(info, p, f, mode, ec);
-        if (!result || ec) return false;
+        if (!result || ec)
+            return false;
 
         if (&ec != &throws)
             ec = make_success_code();
@@ -47,70 +48,70 @@ namespace hpx { namespace performance_counters
         error_code& ec)
     {
         using hpx::parcelset::detail::per_action_data_counter_registry;
-        return per_action_data_counter_discoverer(info, f, mode,
-            per_action_data_counter_registry::instance(), ec);
+        return per_action_data_counter_discoverer(
+            info, f, mode, per_action_data_counter_registry::instance(), ec);
     }
 
     ///////////////////////////////////////////////////////////////////////////
     // Creation function for per-action parcel data counters
     naming::gid_type per_action_data_counter_creator(counter_info const& info,
         hpx::parcelset::detail::per_action_data_counter_registry& registry,
-        hpx::util::function_nonser<
-            std::int64_t(std::string const&, bool)
-        > const& counter_func,
+        hpx::util::function_nonser<std::int64_t(
+            std::string const&, bool)> const& counter_func,
         error_code& ec)
     {
-        switch (info.type_) {
+        switch (info.type_)
+        {
         case counter_raw:
+        {
+            counter_path_elements paths;
+            get_counter_path_elements(info.fullname_, paths, ec);
+            if (ec)
+                return naming::invalid_gid;
+
+            if (paths.parentinstance_is_basename_)
             {
-                counter_path_elements paths;
-                get_counter_path_elements(info.fullname_, paths, ec);
-                if (ec) return naming::invalid_gid;
-
-                if (paths.parentinstance_is_basename_) {
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "per_action_data_counter_creator",
-                        "invalid action invocation counter name (instance name "
-                        "must not be a valid base counter name)");
-                    return naming::invalid_gid;
-                }
-
-                if (paths.parameters_.empty()) {
-                    // if no parameters (action name) is given assume that this
-                    // counter should report the overall value for all actions
-                    auto const& f =
-                        util::bind_front(counter_func, paths.parameters_);
-                    return performance_counters::locality_raw_counter_creator(
-                        info, f,ec);
-                }
-
-                // ask registry
-                hpx::util::function_nonser<std::int64_t(bool)> f =
-                    registry.get_counter(paths.parameters_, counter_func);
-
-                return detail::create_raw_counter(info, std::move(f), ec);
+                HPX_THROWS_IF(ec, bad_parameter,
+                    "per_action_data_counter_creator",
+                    "invalid action invocation counter name (instance name "
+                    "must not be a valid base counter name)");
+                return naming::invalid_gid;
             }
-            break;
+
+            if (paths.parameters_.empty())
+            {
+                // if no parameters (action name) is given assume that this
+                // counter should report the overall value for all actions
+                auto const& f =
+                    util::bind_front(counter_func, paths.parameters_);
+                return performance_counters::locality_raw_counter_creator(
+                    info, f, ec);
+            }
+
+            // ask registry
+            hpx::util::function_nonser<std::int64_t(bool)> f =
+                registry.get_counter(paths.parameters_, counter_func);
+
+            return detail::create_raw_counter(info, std::move(f), ec);
+        }
+        break;
 
         default:
-            HPX_THROWS_IF(ec, bad_parameter,
-                "per_action_data_counter_creator",
+            HPX_THROWS_IF(ec, bad_parameter, "per_action_data_counter_creator",
                 "invalid counter type requested");
             return naming::invalid_gid;
         }
     }
 
-    naming::gid_type per_action_data_counter_creator(
-        counter_info const& info,
-        hpx::util::function_nonser<
-            std::int64_t(std::string const&, bool)
-        > const& f,
+    naming::gid_type per_action_data_counter_creator(counter_info const& info,
+        hpx::util::function_nonser<std::int64_t(
+            std::string const&, bool)> const& f,
         error_code& ec)
     {
         using hpx::parcelset::detail::per_action_data_counter_registry;
-        return per_action_data_counter_creator(info,
-            per_action_data_counter_registry::instance(), f, ec);
+        return per_action_data_counter_creator(
+            info, per_action_data_counter_registry::instance(), f, ec);
     }
-}}
+}}    // namespace hpx::performance_counters
 
 #endif
diff --git a/src/performance_counters/server/raw_counter.cpp b/libs/performance_counters/src/server/raw_counter.cpp
similarity index 65%
rename from src/performance_counters/server/raw_counter.cpp
rename to libs/performance_counters/src/server/raw_counter.cpp
index 06bccab36a..8f345ea9bc 100644
--- a/src/performance_counters/server/raw_counter.cpp
+++ b/libs/performance_counters/src/server/raw_counter.cpp
@@ -5,47 +5,46 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/runtime_fwd.hpp>
-#include <hpx/runtime/components/derived_component_factory.hpp>
-#include <hpx/runtime/actions/continuation.hpp>
-#include <hpx/timing/high_resolution_clock.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/server/raw_counter.hpp>
-#include <hpx/functional/function.hpp>
+#include <hpx/runtime/actions/continuation.hpp>
+#include <hpx/runtime/components/derived_component_factory.hpp>
+#include <hpx/runtime/runtime_fwd.hpp>
+#include <hpx/timing/high_resolution_clock.hpp>
 
 #include <cstdint>
 #include <utility>
 
 ///////////////////////////////////////////////////////////////////////////////
 typedef hpx::components::component<
-    hpx::performance_counters::server::raw_counter
-> raw_counter_type;
+    hpx::performance_counters::server::raw_counter>
+    raw_counter_type;
 
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    raw_counter_type, raw_counter, "base_performance_counter",
-    hpx::components::factory_enabled)
-HPX_DEFINE_GET_COMPONENT_TYPE(
-    hpx::performance_counters::server::raw_counter)
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(raw_counter_type, raw_counter,
+    "base_performance_counter", hpx::components::factory_enabled)
+HPX_DEFINE_GET_COMPONENT_TYPE(hpx::performance_counters::server::raw_counter)
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     raw_counter::raw_counter(counter_info const& info,
-            hpx::util::function_nonser<std::int64_t(bool)> f)
-      : base_type_holder(info), f_(std::move(f)), reset_(false)
+        hpx::util::function_nonser<std::int64_t(bool)> f)
+      : base_type_holder(info)
+      , f_(std::move(f))
+      , reset_(false)
     {
-        if (info.type_ != counter_raw) {
-            HPX_THROW_EXCEPTION(bad_parameter,
-                "raw_counter::raw_counter",
+        if (info.type_ != counter_raw)
+        {
+            HPX_THROW_EXCEPTION(bad_parameter, "raw_counter::raw_counter",
                 "unexpected counter type specified for raw_counter");
         }
     }
 
-    hpx::performance_counters::counter_value
-        raw_counter::get_counter_value(bool reset)
+    hpx::performance_counters::counter_value raw_counter::get_counter_value(
+        bool reset)
     {
         hpx::performance_counters::counter_value value;
-        value.value_ = f_(reset);               // gather the current value
+        value.value_ = f_(reset);    // gather the current value
         reset_ = false;
         value.scaling_ = 1;
         value.scale_inverse_ = false;
@@ -59,5 +58,4 @@ namespace hpx { namespace performance_counters { namespace server
     {
         f_(true);
     }
-}}}
-
+}}}    // namespace hpx::performance_counters::server
diff --git a/src/performance_counters/server/raw_values_counter.cpp b/libs/performance_counters/src/server/raw_values_counter.cpp
similarity index 72%
rename from src/performance_counters/server/raw_values_counter.cpp
rename to libs/performance_counters/src/server/raw_values_counter.cpp
index 562caca311..04e36971cb 100644
--- a/src/performance_counters/server/raw_values_counter.cpp
+++ b/libs/performance_counters/src/server/raw_values_counter.cpp
@@ -5,12 +5,12 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/components/derived_component_factory.hpp>
-#include <hpx/runtime/actions/continuation.hpp>
-#include <hpx/timing/high_resolution_clock.hpp>
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/server/raw_values_counter.hpp>
-#include <hpx/functional/function.hpp>
+#include <hpx/runtime/actions/continuation.hpp>
+#include <hpx/runtime/components/derived_component_factory.hpp>
+#include <hpx/timing/high_resolution_clock.hpp>
 
 #include <cstdint>
 #include <utility>
@@ -18,37 +18,37 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 typedef hpx::components::component<
-    hpx::performance_counters::server::raw_values_counter
-> raw_values_counter_type;
+    hpx::performance_counters::server::raw_values_counter>
+    raw_values_counter_type;
 
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    raw_values_counter_type, raw_values_counter, "base_performance_counter",
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(raw_values_counter_type,
+    raw_values_counter, "base_performance_counter",
     hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(
     hpx::performance_counters::server::raw_values_counter)
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     raw_values_counter::raw_values_counter(counter_info const& info,
-            hpx::util::function_nonser<std::vector<std::int64_t>(bool)> f)
-      : base_type_holder(info), f_(std::move(f)), reset_(false)
+        hpx::util::function_nonser<std::vector<std::int64_t>(bool)> f)
+      : base_type_holder(info)
+      , f_(std::move(f))
+      , reset_(false)
     {
-        if (info.type_ != counter_histogram &&
-            info.type_ != counter_raw_values)
+        if (info.type_ != counter_histogram && info.type_ != counter_raw_values)
         {
             HPX_THROW_EXCEPTION(bad_parameter,
                 "raw_values_counter::raw_values_counter",
                 "unexpected counter type specified for raw_values_counter "
-                    "should be counter_histogram or counter_raw_values");
+                "should be counter_histogram or counter_raw_values");
         }
     }
 
     hpx::performance_counters::counter_values_array
-        raw_values_counter::get_counter_values_array(bool reset)
+    raw_values_counter::get_counter_values_array(bool reset)
     {
         hpx::performance_counters::counter_values_array values;
-        values.values_ = f_(reset);               // gather the current value
+        values.values_ = f_(reset);    // gather the current value
         reset_ = false;
         values.scaling_ = 1;
         values.scale_inverse_ = false;
@@ -62,5 +62,4 @@ namespace hpx { namespace performance_counters { namespace server
     {
         f_(true);
     }
-}}}
-
+}}}    // namespace hpx::performance_counters::server
diff --git a/src/performance_counters/server/statistics_counter.cpp b/libs/performance_counters/src/server/statistics_counter.cpp
similarity index 67%
rename from src/performance_counters/server/statistics_counter.cpp
rename to libs/performance_counters/src/server/statistics_counter.cpp
index 5405cec895..39ebbd6ffa 100644
--- a/src/performance_counters/server/statistics_counter.cpp
+++ b/libs/performance_counters/src/server/statistics_counter.cpp
@@ -7,36 +7,36 @@
 #include <hpx/config.hpp>
 #include <hpx/format.hpp>
 #include <hpx/functional/bind_front.hpp>
-#include <hpx/runtime/components/derived_component_factory.hpp>
+#include <hpx/performance_counters/counter_creators.hpp>
+#include <hpx/performance_counters/counters.hpp>
+#include <hpx/performance_counters/server/statistics_counter.hpp>
+#include <hpx/performance_counters/stubs/performance_counter.hpp>
 #include <hpx/runtime/actions/continuation.hpp>
 #include <hpx/runtime/agas/interface.hpp>
+#include <hpx/runtime/components/derived_component_factory.hpp>
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
-#include <hpx/performance_counters/counters.hpp>
-#include <hpx/performance_counters/counter_creators.hpp>
-#include <hpx/performance_counters/stubs/performance_counter.hpp>
-#include <hpx/performance_counters/server/statistics_counter.hpp>
 
 #include <boost/accumulators/accumulators.hpp>
-#include <boost/accumulators/statistics/stats.hpp>
-#include <boost/accumulators/statistics/mean.hpp>
-#include <boost/accumulators/statistics/variance.hpp>
 #include <boost/accumulators/statistics/max.hpp>
+#include <boost/accumulators/statistics/mean.hpp>
 #include <boost/accumulators/statistics/min.hpp>
 #include <boost/accumulators/statistics/rolling_mean.hpp>
 #include <boost/accumulators/statistics/rolling_variance.hpp>
+#include <boost/accumulators/statistics/stats.hpp>
+#include <boost/accumulators/statistics/variance.hpp>
 
-#include <hpx/statistics/rolling_min.hpp>
 #include <hpx/statistics/rolling_max.hpp>
+#include <hpx/statistics/rolling_min.hpp>
 
 #if defined(HPX_MSVC)
-#  pragma warning(push)
-#  pragma warning(disable: 4244)
+#pragma warning(push)
+#pragma warning(disable : 4244)
 #endif
 #include <boost/accumulators/statistics/median.hpp>
 #if defined(HPX_MSVC)
-#  pragma warning(pop)
+#pragma warning(pop)
 #endif
 
 #include <boost/version.hpp>
@@ -54,11 +54,9 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace server
-{
+namespace hpx { namespace performance_counters { namespace server {
     ///////////////////////////////////////////////////////////////////////////
-    namespace detail
-    {
+    namespace detail {
         template <typename Statistic>
         struct counter_type_from_statistic;
 
@@ -67,12 +65,11 @@ namespace hpx { namespace performance_counters { namespace server
           : counter_type_from_statistic_base
         {
             typedef boost::accumulators::tag::mean aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
-            counter_type_from_statistic(std::size_t /*parameter2*/)
-            {}
+            counter_type_from_statistic(std::size_t /*parameter2*/) {}
 
             double get_value()
             {
@@ -98,12 +95,11 @@ namespace hpx { namespace performance_counters { namespace server
           : counter_type_from_statistic_base
         {
             typedef boost::accumulators::tag::variance aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
-            counter_type_from_statistic(std::size_t /*parameter2*/)
-            {}
+            counter_type_from_statistic(std::size_t /*parameter2*/) {}
 
             double get_value()
             {
@@ -129,13 +125,14 @@ namespace hpx { namespace performance_counters { namespace server
           : counter_type_from_statistic_base
         {
             typedef boost::accumulators::tag::median aggregating_tag;
-            typedef boost::accumulators::with_p_square_quantile aggregating_type_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag(aggregating_type_tag)>
-            > accumulator_type;
+            typedef boost::accumulators::with_p_square_quantile
+                aggregating_type_tag;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag(
+                    aggregating_type_tag)>>
+                accumulator_type;
 
-            counter_type_from_statistic(std::size_t /*parameter2*/)
-            {}
+            counter_type_from_statistic(std::size_t /*parameter2*/) {}
 
             double get_value()
             {
@@ -157,20 +154,21 @@ namespace hpx { namespace performance_counters { namespace server
         };
 
         template <>
-        struct counter_type_from_statistic<boost::accumulators::tag::rolling_mean>
+        struct counter_type_from_statistic<
+            boost::accumulators::tag::rolling_mean>
           : counter_type_from_statistic_base
         {
             typedef boost::accumulators::tag::rolling_mean aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
             counter_type_from_statistic(std::size_t parameter2)
               : accum_(boost::accumulators::tag::rolling_window::window_size =
-                    parameter2
-                )
+                           parameter2)
             {
-                if (parameter2 == 0) {
+                if (parameter2 == 0)
+                {
                     HPX_THROW_EXCEPTION(bad_parameter,
                         "counter_type_from_statistic<Statistic>",
                         "base rolling window size is specified to be zero");
@@ -197,20 +195,21 @@ namespace hpx { namespace performance_counters { namespace server
         };
 
         template <>
-        struct counter_type_from_statistic<boost::accumulators::tag::rolling_variance>
+        struct counter_type_from_statistic<
+            boost::accumulators::tag::rolling_variance>
           : counter_type_from_statistic_base
         {
             typedef boost::accumulators::tag::rolling_variance aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
             counter_type_from_statistic(std::size_t parameter2)
               : accum_(boost::accumulators::tag::rolling_window::window_size =
-                    parameter2
-                )
+                           parameter2)
             {
-                if (parameter2 == 0) {
+                if (parameter2 == 0)
+                {
                     HPX_THROW_EXCEPTION(bad_parameter,
                         "counter_type_from_statistic<Statistic>",
                         "base rolling window size is specified to be zero");
@@ -241,12 +240,11 @@ namespace hpx { namespace performance_counters { namespace server
           : counter_type_from_statistic_base
         {
             typedef boost::accumulators::tag::max aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
-            counter_type_from_statistic(std::size_t /*parameter2*/)
-            {}
+            counter_type_from_statistic(std::size_t /*parameter2*/) {}
 
             double get_value()
             {
@@ -272,12 +270,11 @@ namespace hpx { namespace performance_counters { namespace server
           : counter_type_from_statistic_base
         {
             typedef boost::accumulators::tag::min aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
-            counter_type_from_statistic(std::size_t /*parameter2*/)
-            {}
+            counter_type_from_statistic(std::size_t /*parameter2*/) {}
 
             double get_value()
             {
@@ -303,16 +300,16 @@ namespace hpx { namespace performance_counters { namespace server
           : counter_type_from_statistic_base
         {
             typedef hpx::util::tag::rolling_min aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
             counter_type_from_statistic(std::size_t parameter2)
               : accum_(boost::accumulators::tag::rolling_window::window_size =
-                    parameter2
-                )
+                           parameter2)
             {
-                if (parameter2 == 0) {
+                if (parameter2 == 0)
+                {
                     HPX_THROW_EXCEPTION(bad_parameter,
                         "counter_type_from_statistic<Statistic>",
                         "base rolling window size is specified to be zero");
@@ -343,16 +340,16 @@ namespace hpx { namespace performance_counters { namespace server
           : counter_type_from_statistic_base
         {
             typedef hpx::util::tag::rolling_max aggregating_tag;
-            typedef boost::accumulators::accumulator_set<
-                double, boost::accumulators::stats<aggregating_tag>
-            > accumulator_type;
+            typedef boost::accumulators::accumulator_set<double,
+                boost::accumulators::stats<aggregating_tag>>
+                accumulator_type;
 
             counter_type_from_statistic(std::size_t parameter2)
               : accum_(boost::accumulators::tag::rolling_window::window_size =
-                    parameter2
-                )
+                           parameter2)
             {
-                if (parameter2 == 0) {
+                if (parameter2 == 0)
+                {
                     HPX_THROW_EXCEPTION(bad_parameter,
                         "counter_type_from_statistic<Statistic>",
                         "base rolling window size is specified to be zero");
@@ -377,31 +374,33 @@ namespace hpx { namespace performance_counters { namespace server
         private:
             accumulator_type accum_;
         };
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
     template <typename Statistic>
-    statistics_counter<Statistic>::statistics_counter(
-            counter_info const& info, std::string const& base_counter_name,
-            std::size_t parameter1, std::size_t parameter2,
-            bool reset_base_counter)
-      : base_type_holder(info),
-        timer_(util::bind_front(&statistics_counter::evaluate, this_()),
+    statistics_counter<Statistic>::statistics_counter(counter_info const& info,
+        std::string const& base_counter_name, std::size_t parameter1,
+        std::size_t parameter2, bool reset_base_counter)
+      : base_type_holder(info)
+      , timer_(util::bind_front(&statistics_counter::evaluate, this_()),
             util::bind_front(&statistics_counter::on_terminate, this_()),
-            1000 * parameter1, info.fullname_, true),
-        base_counter_name_(ensure_counter_prefix(base_counter_name)),
-        value_(new detail::counter_type_from_statistic<Statistic>(parameter2)),
-        has_prev_value_(false),
-        parameter1_(parameter1), parameter2_(parameter2),
-        reset_base_counter_(reset_base_counter)
+            1000 * parameter1, info.fullname_, true)
+      , base_counter_name_(ensure_counter_prefix(base_counter_name))
+      , value_(new detail::counter_type_from_statistic<Statistic>(parameter2))
+      , has_prev_value_(false)
+      , parameter1_(parameter1)
+      , parameter2_(parameter2)
+      , reset_base_counter_(reset_base_counter)
     {
-        if (parameter1 == 0) {
+        if (parameter1 == 0)
+        {
             HPX_THROW_EXCEPTION(bad_parameter,
                 "statistics_counter<Statistic>::statistics_counter",
                 "base interval is specified to be zero");
         }
 
-        if (info.type_ != counter_aggregating) {
+        if (info.type_ != counter_aggregating)
+        {
             HPX_THROW_EXCEPTION(bad_parameter,
                 "statistics_counter<Statistic>::statistics_counter",
                 "unexpected counter type specified");
@@ -413,7 +412,7 @@ namespace hpx { namespace performance_counters { namespace server
 
     template <typename Statistic>
     hpx::performance_counters::counter_value
-        statistics_counter<Statistic>::get_counter_value(bool reset)
+    statistics_counter<Statistic>::get_counter_value(bool reset)
     {
         std::lock_guard<mutex_type> l(mtx_);
 
@@ -425,12 +424,12 @@ namespace hpx { namespace performance_counters { namespace server
         prev_value_.count_ = ++invocation_count_;
         has_prev_value_ = true;
 
-        value = prev_value_;                              // return value
+        value = prev_value_;    // return value
 
         if (reset || value_->need_reset())
         {
             value_.reset(new detail::counter_type_from_statistic<Statistic>(
-                parameter2_)); // reset accumulator
+                parameter2_));    // reset accumulator
             value_->add_value(static_cast<double>(prev_value_.value_));
             // start off with last base value
         }
@@ -458,7 +457,8 @@ namespace hpx { namespace performance_counters { namespace server
                 "base counter should keep scaling constant over time");
             return false;
         }
-        else {
+        else
+        {
             // accumulate new value
             std::lock_guard<mutex_type> l(mtx_);
             value_->add_value(static_cast<double>(base_value.value_));
@@ -473,13 +473,14 @@ namespace hpx { namespace performance_counters { namespace server
         // from AGAS. This
         std::unique_lock<mutex_type> l(mtx_);
 
-        if (!base_counter_id_) {
+        if (!base_counter_id_)
+        {
             // get or create the base counter
             error_code ec(lightweight);
             hpx::id_type base_counter_id;
             {
                 // We need to unlock the lock here since get_counter might suspend
-                util::unlock_guard<std::unique_lock<mutex_type> > unlock(l);
+                util::unlock_guard<std::unique_lock<mutex_type>> unlock(l);
                 base_counter_id = get_counter(base_counter_name_, ec);
             }
 
@@ -536,14 +537,16 @@ namespace hpx { namespace performance_counters { namespace server
     template <typename Statistic>
     bool statistics_counter<Statistic>::start()
     {
-        if (!timer_.is_started()) {
+        if (!timer_.is_started())
+        {
             // start base counter
             if (!base_counter_id_ && !ensure_base_counter())
                 return false;
 
             bool result = stubs::performance_counter::start(
                 launch::sync, base_counter_id_);
-            if (result) {
+            if (result)
+            {
                 // acquire the current value of the base counter
                 counter_value base_value;
                 if (evaluate_base_counter(base_value))
@@ -556,7 +559,8 @@ namespace hpx { namespace performance_counters { namespace server
                 // start timer
                 timer_.start();
             }
-            else {
+            else
+            {
                 // start timer even if base counter does not support being
                 // start/stop operations
                 timer_.start(true);
@@ -569,7 +573,8 @@ namespace hpx { namespace performance_counters { namespace server
     template <typename Statistic>
     bool statistics_counter<Statistic>::stop()
     {
-        if (timer_.is_started()) {
+        if (timer_.is_started())
+        {
             timer_.stop();
 
             if (!base_counter_id_ && !ensure_base_counter())
@@ -586,13 +591,13 @@ namespace hpx { namespace performance_counters { namespace server
         std::lock_guard<mutex_type> l(mtx_);
 
         // reset accumulator
-        value_.reset(new detail::counter_type_from_statistic<Statistic>(
-            parameter2_));
+        value_.reset(
+            new detail::counter_type_from_statistic<Statistic>(parameter2_));
 
         // start off with last base value
         value_->add_value(static_cast<double>(prev_value_.value_));
     }
-}}}
+}}}    // namespace hpx::performance_counters::server
 
 ///////////////////////////////////////////////////////////////////////////////
 template class HPX_EXPORT hpx::performance_counters::server::statistics_counter<
@@ -616,183 +621,183 @@ template class HPX_EXPORT hpx::performance_counters::server::statistics_counter<
 
 ///////////////////////////////////////////////////////////////////////////////
 // Average
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        boost::accumulators::tag::mean>
-> average_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    average_count_counter_type, average_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<boost::accumulators::tag::mean>>
+    average_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(average_count_counter_type,
+    average_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(average_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Rolling variance
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        boost::accumulators::tag::rolling_variance>
-> rolling_variance_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    rolling_variance_count_counter_type, rolling_variance_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<boost::accumulators::tag::rolling_variance>>
+    rolling_variance_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(rolling_variance_count_counter_type,
+    rolling_variance_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(rolling_variance_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Variance
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        boost::accumulators::tag::variance>
-> variance_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    variance_count_counter_type, variance_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<boost::accumulators::tag::variance>>
+    variance_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(variance_count_counter_type,
+    variance_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(variance_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Rolling average
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        boost::accumulators::tag::rolling_mean>
-> rolling_mean_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    rolling_mean_count_counter_type, rolling_mean_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<boost::accumulators::tag::rolling_mean>>
+    rolling_mean_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(rolling_mean_count_counter_type,
+    rolling_mean_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(rolling_mean_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Median
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        boost::accumulators::tag::median>
-> median_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    median_count_counter_type, median_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<boost::accumulators::tag::median>>
+    median_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(median_count_counter_type,
+    median_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(median_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Max
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        boost::accumulators::tag::max>
-> max_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    max_count_counter_type, max_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<boost::accumulators::tag::max>>
+    max_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(max_count_counter_type,
+    max_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(max_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Min
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        boost::accumulators::tag::min>
-> min_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    min_count_counter_type, min_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<boost::accumulators::tag::min>>
+    min_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(min_count_counter_type,
+    min_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(min_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Rolling min
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        hpx::util::tag::rolling_min>
-> rolling_min_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    rolling_min_count_counter_type, rolling_min_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<hpx::util::tag::rolling_min>>
+    rolling_min_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(rolling_min_count_counter_type,
+    rolling_min_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(rolling_min_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
 // Rolling max
-typedef hpx::components::component<
-    hpx::performance_counters::server::statistics_counter<
-        hpx::util::tag::rolling_max>
-> rolling_max_count_counter_type;
-
-HPX_REGISTER_DERIVED_COMPONENT_FACTORY(
-    rolling_max_count_counter_type, rolling_max_count_counter,
-    "base_performance_counter", hpx::components::factory_enabled)
+typedef hpx::components::component<hpx::performance_counters::server::
+        statistics_counter<hpx::util::tag::rolling_max>>
+    rolling_max_count_counter_type;
+
+HPX_REGISTER_DERIVED_COMPONENT_FACTORY(rolling_max_count_counter_type,
+    rolling_max_count_counter, "base_performance_counter",
+    hpx::components::factory_enabled)
 HPX_DEFINE_GET_COMPONENT_TYPE(rolling_max_count_counter_type::wrapped_type)
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace detail
-{
+namespace hpx { namespace performance_counters { namespace detail {
     /// Creation function for aggregating performance counters to be registered
     /// with the counter types.
-    naming::gid_type statistics_counter_creator(counter_info const& info,
-        error_code& ec)
+    naming::gid_type statistics_counter_creator(
+        counter_info const& info, error_code& ec)
     {
-        switch (info.type_) {
+        switch (info.type_)
+        {
         case counter_aggregating:
+        {
+            counter_path_elements paths;
+            get_counter_path_elements(info.fullname_, paths, ec);
+            if (ec)
+                return naming::invalid_gid;
+
+            if (!paths.parentinstance_is_basename_)
             {
-                counter_path_elements paths;
-                get_counter_path_elements(info.fullname_, paths, ec);
-                if (ec) return naming::invalid_gid;
+                HPX_THROWS_IF(ec, bad_parameter, "statistics_counter_creator",
+                    "invalid aggregate counter "
+                    "name (instance name must be valid base counter name)");
+                return naming::invalid_gid;
+            }
+
+            std::string base_name;
+            get_counter_name(paths.parentinstancename_, base_name, ec);
+            if (ec)
+                return naming::invalid_gid;
 
-                if (!paths.parentinstance_is_basename_) {
+            std::vector<std::size_t> parameters;
+            if (!paths.parameters_.empty())
+            {
+                // try to interpret the additional parameters
+                namespace qi = boost::spirit::qi;
+                if (!qi::parse(paths.parameters_.begin(),
+                        paths.parameters_.end(), qi::uint_ % ',', parameters))
+                {
                     HPX_THROWS_IF(ec, bad_parameter,
-                        "statistics_counter_creator", "invalid aggregate counter "
-                            "name (instance name must be valid base counter name)");
+                        "statistics_counter_creator",
+                        "invalid parameter specification format for "
+                        "this counter: " +
+                            paths.parameters_);
                     return naming::invalid_gid;
                 }
-
-                std::string base_name;
-                get_counter_name(paths.parentinstancename_, base_name, ec);
-                if (ec) return naming::invalid_gid;
-
-                std::vector<std::size_t> parameters;
-                if (!paths.parameters_.empty()) {
-                    // try to interpret the additional parameters
-                    namespace qi = boost::spirit::qi;
-                    if (!qi::parse(paths.parameters_.begin(), paths.parameters_.end(),
-                            qi::uint_ % ',', parameters))
-                    {
-                        HPX_THROWS_IF(ec, bad_parameter,
-                            "statistics_counter_creator",
-                            "invalid parameter specification format for "
-                            "this counter: " + paths.parameters_);
-                        return naming::invalid_gid;
-                    }
-                    if (paths.countername_.find("rolling") != std::string::npos)
-                    {
-                        if (parameters.size() > 3)
-                        {
-                            HPX_THROWS_IF(ec, bad_parameter,
-                                "statistics_counter_creator",
-                                "too many parameter specifications for "
-                                "this counter: " + paths.parameters_);
-                            return naming::invalid_gid;
-                        }
-                    }
-                    else if (parameters.size() > 2)
+                if (paths.countername_.find("rolling") != std::string::npos)
+                {
+                    if (parameters.size() > 3)
                     {
                         HPX_THROWS_IF(ec, bad_parameter,
                             "statistics_counter_creator",
                             "too many parameter specifications for "
-                            "this counter: " + paths.parameters_);
+                            "this counter: " +
+                                paths.parameters_);
                         return naming::invalid_gid;
                     }
                 }
-                else if (paths.countername_.find("rolling") != std::string::npos) {
-                    parameters.push_back(1000); // sample interval
-                    parameters.push_back(10);   // rolling window
-                    parameters.push_back(0);    // don't reset underlying counter
-                }
-                else {
-                    parameters.push_back(1000); // sample interval
-                    parameters.push_back(0);    // don't reset underlying counter
+                else if (parameters.size() > 2)
+                {
+                    HPX_THROWS_IF(ec, bad_parameter,
+                        "statistics_counter_creator",
+                        "too many parameter specifications for "
+                        "this counter: " +
+                            paths.parameters_);
+                    return naming::invalid_gid;
                 }
-                return create_statistics_counter(info, base_name, parameters, ec);
             }
-            break;
+            else if (paths.countername_.find("rolling") != std::string::npos)
+            {
+                parameters.push_back(1000);    // sample interval
+                parameters.push_back(10);      // rolling window
+                parameters.push_back(0);       // don't reset underlying counter
+            }
+            else
+            {
+                parameters.push_back(1000);    // sample interval
+                parameters.push_back(0);       // don't reset underlying counter
+            }
+            return create_statistics_counter(info, base_name, parameters, ec);
+        }
+        break;
 
         default:
             HPX_THROWS_IF(ec, bad_parameter, "statistics_counter_creator",
@@ -800,5 +805,4 @@ namespace hpx { namespace performance_counters { namespace detail
             return naming::invalid_gid;
         }
     }
-}}}
-
+}}}    // namespace hpx::performance_counters::detail
diff --git a/src/performance_counters/stubs/performance_counter_stub.cpp b/libs/performance_counters/src/stubs/performance_counter_stub.cpp
similarity index 61%
rename from src/performance_counters/stubs/performance_counter_stub.cpp
rename to libs/performance_counters/src/stubs/performance_counter_stub.cpp
index f527953283..e49e404023 100644
--- a/src/performance_counters/stubs/performance_counter_stub.cpp
+++ b/libs/performance_counters/src/stubs/performance_counter_stub.cpp
@@ -5,42 +5,40 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/async.hpp>
 #include <hpx/apply.hpp>
+#include <hpx/async.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/stubs/performance_counter.hpp>
 #include <hpx/runtime/actions/continuation.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace stubs
-{
+namespace hpx { namespace performance_counters { namespace stubs {
     lcos::future<counter_info> performance_counter::get_info(
         launch::async_policy, naming::id_type const& targetid)
     {
-        typedef server::base_performance_counter::
-            get_counter_info_action action_type;
+        typedef server::base_performance_counter::get_counter_info_action
+            action_type;
         return hpx::async<action_type>(targetid);
     }
 
     lcos::future<counter_value> performance_counter::get_value(
         launch::async_policy, naming::id_type const& targetid, bool reset)
     {
-        typedef server::base_performance_counter::
-            get_counter_value_action action_type;
+        typedef server::base_performance_counter::get_counter_value_action
+            action_type;
         return hpx::async<action_type>(targetid, reset);
     }
 
-    lcos::future<counter_values_array>
-    performance_counter::get_values_array(launch::async_policy,
-        naming::id_type const& targetid, bool reset)
+    lcos::future<counter_values_array> performance_counter::get_values_array(
+        launch::async_policy, naming::id_type const& targetid, bool reset)
     {
         typedef server::base_performance_counter::
             get_counter_values_array_action action_type;
         return hpx::async<action_type>(targetid, reset);
     }
 
-    counter_info performance_counter::get_info(launch::sync_policy,
-        naming::id_type const& targetid, error_code& ec)
+    counter_info performance_counter::get_info(
+        launch::sync_policy, naming::id_type const& targetid, error_code& ec)
     {
         return get_info(launch::async, targetid).get(ec);
     }
@@ -51,57 +49,56 @@ namespace hpx { namespace performance_counters { namespace stubs
         return get_value(launch::async, targetid, reset).get(ec);
     }
 
-    counter_values_array
-    performance_counter::get_values_array(launch::sync_policy,
-        naming::id_type const& targetid, bool reset, error_code& ec)
+    counter_values_array performance_counter::get_values_array(
+        launch::sync_policy, naming::id_type const& targetid, bool reset,
+        error_code& ec)
     {
         return get_values_array(launch::async, targetid, reset).get(ec);
     }
 
-    lcos::future<bool> performance_counter::start(launch::async_policy,
-        naming::id_type const& targetid)
+    lcos::future<bool> performance_counter::start(
+        launch::async_policy, naming::id_type const& targetid)
     {
         typedef server::base_performance_counter::start_action action_type;
         return hpx::async<action_type>(targetid);
     }
 
-    lcos::future<bool> performance_counter::stop(launch::async_policy,
-        naming::id_type const& targetid)
+    lcos::future<bool> performance_counter::stop(
+        launch::async_policy, naming::id_type const& targetid)
     {
         typedef server::base_performance_counter::stop_action action_type;
         return hpx::async<action_type>(targetid);
     }
 
-    lcos::future<void> performance_counter::reset(launch::async_policy,
-        naming::id_type const& targetid)
+    lcos::future<void> performance_counter::reset(
+        launch::async_policy, naming::id_type const& targetid)
     {
         typedef server::base_performance_counter::reset_counter_value_action
             action_type;
         return hpx::async<action_type>(targetid);
     }
 
-    lcos::future<void> performance_counter::reinit(launch::async_policy,
-        naming::id_type const& targetid, bool reset)
+    lcos::future<void> performance_counter::reinit(
+        launch::async_policy, naming::id_type const& targetid, bool reset)
     {
-        typedef server::base_performance_counter::reinit_action
-            action_type;
+        typedef server::base_performance_counter::reinit_action action_type;
         return hpx::async<action_type>(targetid, reset);
     }
 
-    bool performance_counter::start(launch::sync_policy,
-        naming::id_type const& targetid, error_code& ec)
+    bool performance_counter::start(
+        launch::sync_policy, naming::id_type const& targetid, error_code& ec)
     {
         return start(launch::async, targetid).get(ec);
     }
 
-    bool performance_counter::stop(launch::sync_policy,
-        naming::id_type const& targetid, error_code& ec)
+    bool performance_counter::stop(
+        launch::sync_policy, naming::id_type const& targetid, error_code& ec)
     {
         return stop(launch::async, targetid).get(ec);
     }
 
-    void performance_counter::reset(launch::sync_policy,
-        naming::id_type const& targetid, error_code& ec)
+    void performance_counter::reset(
+        launch::sync_policy, naming::id_type const& targetid, error_code& ec)
     {
         reset(launch::async, targetid).get(ec);
     }
@@ -111,4 +108,4 @@ namespace hpx { namespace performance_counters { namespace stubs
     {
         reinit(launch::async, targetid, reset).get(ec);
     }
-}}}
+}}}    // namespace hpx::performance_counters::stubs
diff --git a/libs/performance_counters/tests/CMakeLists.txt b/libs/performance_counters/tests/CMakeLists.txt
new file mode 100644
index 0000000000..522935bb0e
--- /dev/null
+++ b/libs/performance_counters/tests/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_PERFORMANCE_COUNTERS_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_PERFORMANCE_COUNTERS_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.performance_counters)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.performance_counters)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.performance_counters)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.performance_counters)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.performance_counters)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.performance_counters)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.performance_counters
+        HEADERS ${performance_counters_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        DEPENDENCIES hpx_performance_counters)
+    endif()
+endif()
diff --git a/libs/performance_counters/tests/performance/CMakeLists.txt b/libs/performance_counters/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/performance_counters/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/performance_counters/tests/regressions/CMakeLists.txt b/libs/performance_counters/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..9bd8768105
--- /dev/null
+++ b/libs/performance_counters/tests/regressions/CMakeLists.txt
@@ -0,0 +1,32 @@
+# Copyright (c) 2007-2015 Hartmut Kaiser
+# Copyright (c) 2013,2016 Maciej Brodowicz
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+set(tests
+    discover_counters_1787
+    dynamic_counters_loaded_1508
+    statistics_2666
+    uptime_1737)
+
+set(dynamic_counters_loaded_1508_FLAGS DEPENDENCIES memory_component)
+
+foreach(test ${tests})
+  set(sources
+      ${test}.cpp)
+
+  source_group("Source Files" FILES ${sources})
+
+  add_hpx_executable(${test}_test
+    INTERNAL_FLAGS
+    SOURCES ${sources}
+    ${${test}_FLAGS}
+    EXCLUDE_FROM_ALL
+    HPX_PREFIX ${HPX_BUILD_PREFIX}
+    FOLDER "Tests/Regressions/Modues/PerformanceCounters")
+
+  add_hpx_regression_test("modules.performance_counters" ${test} ${${test}_PARAMETERS})
+
+endforeach()
diff --git a/tests/regressions/performance_counters/discover_counters_1787.cpp b/libs/performance_counters/tests/regressions/discover_counters_1787.cpp
similarity index 83%
rename from tests/regressions/performance_counters/discover_counters_1787.cpp
rename to libs/performance_counters/tests/regressions/discover_counters_1787.cpp
index 2e65076b9c..0744e7f524 100644
--- a/tests/regressions/performance_counters/discover_counters_1787.cpp
+++ b/libs/performance_counters/tests/regressions/discover_counters_1787.cpp
@@ -13,14 +13,14 @@
 
 #include <iostream>
 
-bool discover_callback(hpx::performance_counters::counter_info const& c,
-    hpx::error_code& ec)
+bool discover_callback(
+    hpx::performance_counters::counter_info const& c, hpx::error_code& ec)
 {
     std::cout << "counter: " << c.fullname_ << std::endl;
     return true;
 }
 
-int hpx_main(int argc,char **argv)
+int hpx_main(int argc, char** argv)
 {
     std::cout << "Counters:" << std::endl;
 
@@ -32,7 +32,7 @@ int hpx_main(int argc,char **argv)
     return hpx::finalize();
 }
 
-int main(int argc,char **argv)
+int main(int argc, char** argv)
 {
     return hpx::init(argc, argv);
 }
diff --git a/tests/regressions/dynamic_counters_loaded_1508.cpp b/libs/performance_counters/tests/regressions/dynamic_counters_loaded_1508.cpp
similarity index 90%
rename from tests/regressions/dynamic_counters_loaded_1508.cpp
rename to libs/performance_counters/tests/regressions/dynamic_counters_loaded_1508.cpp
index 039ffcbfaf..f82cade9b7 100644
--- a/tests/regressions/dynamic_counters_loaded_1508.cpp
+++ b/libs/performance_counters/tests/regressions/dynamic_counters_loaded_1508.cpp
@@ -11,14 +11,15 @@
 #include <hpx/include/performance_counters.hpp>
 #include <hpx/testing.hpp>
 
-int hpx_main(int argc, char ** argv)
+int hpx_main(int argc, char** argv)
 {
     using hpx::performance_counters::performance_counter;
 
     bool counter_created = false;
     bool value_retrieved = false;
 
-    try {
+    try
+    {
         performance_counter memory("/runtime/memory/resident");
         counter_created = true;
 
@@ -33,7 +34,8 @@ int hpx_main(int argc, char ** argv)
 
         value_retrieved = true;
     }
-    catch (hpx::exception const&) {
+    catch (hpx::exception const&)
+    {
         HPX_TEST(false);
     }
 
@@ -43,7 +45,7 @@ int hpx_main(int argc, char ** argv)
     return hpx::finalize();
 }
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
     HPX_TEST_EQ(hpx::init(argc, argv), 0);
     return hpx::util::report_errors();
diff --git a/tests/regressions/performance_counters/statistics_2666.cpp b/libs/performance_counters/tests/regressions/statistics_2666.cpp
similarity index 100%
rename from tests/regressions/performance_counters/statistics_2666.cpp
rename to libs/performance_counters/tests/regressions/statistics_2666.cpp
diff --git a/tests/regressions/performance_counters/uptime_1737.cpp b/libs/performance_counters/tests/regressions/uptime_1737.cpp
similarity index 85%
rename from tests/regressions/performance_counters/uptime_1737.cpp
rename to libs/performance_counters/tests/regressions/uptime_1737.cpp
index 6f3696f7dd..01c1e8683b 100644
--- a/tests/regressions/performance_counters/uptime_1737.cpp
+++ b/libs/performance_counters/tests/regressions/uptime_1737.cpp
@@ -13,7 +13,7 @@
 
 #include <chrono>
 
-int hpx_main(int argc, char ** argv)
+int hpx_main(int argc, char** argv)
 {
     using hpx::performance_counters::performance_counter;
 
@@ -22,11 +22,13 @@ int hpx_main(int argc, char ** argv)
     // verify that attempts to reset the uptime counter fail
     {
         bool exception_thrown = false;
-        try {
+        try
+        {
             uptime.reset(hpx::launch::sync);
             HPX_TEST(false);
         }
-        catch (hpx::exception const&) {
+        catch (hpx::exception const&)
+        {
             exception_thrown = true;
         }
         HPX_TEST(exception_thrown);
@@ -34,11 +36,13 @@ int hpx_main(int argc, char ** argv)
 
     {
         bool exception_thrown = false;
-        try {
+        try
+        {
             uptime.get_value<double>(hpx::launch::sync, true);
             HPX_TEST(false);
         }
-        catch (hpx::exception const&) {
+        catch (hpx::exception const&)
+        {
             exception_thrown = true;
         }
         HPX_TEST(exception_thrown);
@@ -49,7 +53,7 @@ int hpx_main(int argc, char ** argv)
     hpx::this_thread::sleep_for(std::chrono::seconds(1));
     double end = uptime.get_value<double>(hpx::launch::sync);
 
-    HPX_TEST(end - start >= 1.0 && end - start < 1.1);
+    HPX_TEST_LT(end - start >= 1.0 && end - start, 1.1);
 
     // make sure start/stop return false
     HPX_TEST(!uptime.start(hpx::launch::sync));
@@ -58,7 +62,7 @@ int hpx_main(int argc, char ** argv)
     return hpx::finalize();
 }
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
     HPX_TEST_EQ(hpx::init(argc, argv), 0);
     return hpx::util::report_errors();
diff --git a/tests/unit/performance_counter/CMakeLists.txt b/libs/performance_counters/tests/unit/CMakeLists.txt
similarity index 82%
rename from tests/unit/performance_counter/CMakeLists.txt
rename to libs/performance_counters/tests/unit/CMakeLists.txt
index 73ebcd6bd5..fc0bc3ec3b 100644
--- a/tests/unit/performance_counter/CMakeLists.txt
+++ b/libs/performance_counters/tests/unit/CMakeLists.txt
@@ -23,9 +23,8 @@ foreach(test ${tests})
     ${${test}_FLAGS}
     EXCLUDE_FROM_ALL
     HPX_PREFIX ${HPX_BUILD_PREFIX}
-    FOLDER "Tests/Unit/PerformanceCounters/")
+    FOLDER "Tests/Unit/Modules/PerformanceCounters/")
 
-  add_hpx_unit_test("performance_counter" ${test} ${${test}_PARAMETERS})
+  add_hpx_unit_test("modules.performance_counters" ${test} ${${test}_PARAMETERS})
 
 endforeach()
-
diff --git a/tests/unit/performance_counter/all_counters.cpp b/libs/performance_counters/tests/unit/all_counters.cpp
similarity index 90%
rename from tests/unit/performance_counter/all_counters.cpp
rename to libs/performance_counters/tests/unit/all_counters.cpp
index 14e037f576..0ac60e8da3 100644
--- a/tests/unit/performance_counter/all_counters.cpp
+++ b/libs/performance_counters/tests/unit/all_counters.cpp
@@ -15,6 +15,7 @@
 #include <string>
 #include <vector>
 
+// clang-format off
 char const* const locality_pool_thread_counter_names[] =
 {
     "/threadqueue/length",
@@ -65,6 +66,7 @@ char const* const locality_pool_thread_no_total_counter_names[] =
     "/threads/busy-loop-count/instantaneous",
     nullptr
 };
+// clang-format on
 
 ///////////////////////////////////////////////////////////////////////////////
 // char const* const locality_thread_counter_names[] =
@@ -72,23 +74,20 @@ char const* const locality_pool_thread_no_total_counter_names[] =
 //     nullptr
 // };
 
-char const* const locality_counter_names[] =
-{
+char const* const locality_counter_names[] = {
 #if defined(HPX_HAVE_COROUTINE_COUNTERS)
     "/threads/count/stack-recycles",
 #if !defined(HPX_WINDOWS) && !defined(HPX_HAVE_GENERIC_CONTEXT_COROUTINES)
     "/threads/count/stack-unbinds",
 #endif
 #endif
-    "/scheduler/utilization/instantaneous",
-    nullptr
-};
+    "/scheduler/utilization/instantaneous", nullptr};
 
 ///////////////////////////////////////////////////////////////////////////////
 void test_all_locality_thread_counters(char const* const* counter_names,
     std::size_t locality_id, std::size_t pool, std::size_t core)
 {
-    for (char const* const*p = counter_names; *p != nullptr; ++p)
+    for (char const* const* p = counter_names; *p != nullptr; ++p)
     {
         // split counter type into counter path elements
         hpx::performance_counters::counter_path_elements path;
@@ -127,8 +126,7 @@ void test_all_locality_thread_counters(char const* const* counter_names,
         }
 
         std::string name;
-        HPX_TEST_EQ(
-            hpx::performance_counters::get_counter_name(path, name),
+        HPX_TEST_EQ(hpx::performance_counters::get_counter_name(path, name),
             hpx::performance_counters::status_valid_data);
 
         std::cout << name << '\n';
@@ -141,7 +139,7 @@ void test_all_locality_thread_counters(char const* const* counter_names,
         }
         catch (...)
         {
-            HPX_TEST(false);        // should never happen
+            HPX_TEST(false);    // should never happen
         }
     }
 }
@@ -203,13 +201,13 @@ void test_all_counters_locality(std::size_t locality_id)
             locality_id, std::size_t(-1), core);
     }
 
-//     // locality/thread (same as locality/pool#default/threads)
-//     test_all_locality_thread_counters(locality_id, std::size_t(-1));
-//
-//     for (std::size_t core = 0; core != cores; ++core)
-//     {
-//         test_all_locality_thread_counters(locality_id, core);
-//     }
+    //     // locality/thread (same as locality/pool#default/threads)
+    //     test_all_locality_thread_counters(locality_id, std::size_t(-1));
+    //
+    //     for (std::size_t core = 0; core != cores; ++core)
+    //     {
+    //         test_all_locality_thread_counters(locality_id, core);
+    //     }
 
     // locality/total
     test_all_locality_counters(locality_id);
diff --git a/tests/unit/performance_counter/counter_raw_values.cpp b/libs/performance_counters/tests/unit/counter_raw_values.cpp
similarity index 93%
rename from tests/unit/performance_counter/counter_raw_values.cpp
rename to libs/performance_counters/tests/unit/counter_raw_values.cpp
index adb3440b3b..e647a8a31a 100644
--- a/tests/unit/performance_counter/counter_raw_values.cpp
+++ b/libs/performance_counters/tests/unit/counter_raw_values.cpp
@@ -39,8 +39,7 @@ void register_counter_type()
         // function providing counter data
         &get_values,
         // description text
-        "returns an array of linearly increasing counter values"
-    );
+        "returns an array of linearly increasing counter values");
 }
 
 int hpx_main(int argc, char* argv[])
@@ -54,7 +53,7 @@ int hpx_main(int argc, char* argv[])
 
         auto values = c.get_counter_values_array(hpx::launch::sync, false);
 
-        HPX_TEST(values.count_ == static_cast<std::uint64_t>(i + 1));
+        HPX_TEST_EQ(values.count_, static_cast<std::uint64_t>(i + 1));
 
         std::vector<std::int64_t> expected(10);
         std::iota(expected.begin(), expected.end(), i);
@@ -74,11 +73,8 @@ int main(int argc, char* argv[])
     hpx::register_startup_function(&register_counter_type);
 
     // Initialize and run HPX.
-    std::vector<std::string> const cfg = {
-        "hpx.os_threads=1"
-    };
+    std::vector<std::string> const cfg = {"hpx.os_threads=1"};
     HPX_TEST_EQ(hpx::init(argc, argv, cfg), 0);
 
     return hpx::util::report_errors();
 }
-
diff --git a/tests/unit/performance_counter/path_elements.cpp b/libs/performance_counters/tests/unit/path_elements.cpp
similarity index 87%
rename from tests/unit/performance_counter/path_elements.cpp
rename to libs/performance_counters/tests/unit/path_elements.cpp
index cc2ebcfaf2..27aaa7f54a 100644
--- a/tests/unit/performance_counter/path_elements.cpp
+++ b/libs/performance_counters/tests/unit/path_elements.cpp
@@ -5,15 +5,14 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/hpx_init.hpp>
-#include <hpx/include/util.hpp>
 #include <hpx/include/performance_counters.hpp>
+#include <hpx/include/util.hpp>
 #include <hpx/testing.hpp>
 
 #include <string>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace test
-{
+namespace test {
     ///////////////////////////////////////////////////////////////////////////
     struct data_good
     {
@@ -22,6 +21,7 @@ namespace test
         hpx::performance_counters::counter_path_elements path_;
     };
 
+    // clang-format off
     data_good data[] =
     {
         {   "/objectname{parentinstancename#2/instancename#1}/countername",
@@ -389,6 +389,7 @@ namespace test
         },
         {   "", "", hpx::performance_counters::counter_path_elements() }
     };
+    // clang-format on
 
     void good()
     {
@@ -398,72 +399,79 @@ namespace test
             using namespace hpx::performance_counters;
 
             std::string fullname;
-            HPX_TEST(status_valid_data == get_counter_name(t->path_, fullname, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(fullname == t->fullname_);
+            HPX_TEST_EQ(
+                status_valid_data, get_counter_name(t->path_, fullname, ec));
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(fullname, t->fullname_);
 
             std::string type_name;
             HPX_TEST(status_valid_data ==
                 get_counter_type_name(t->path_, type_name, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(type_name == t->typename_);
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(type_name, t->typename_);
 
             counter_path_elements p;
 
             HPX_TEST(status_valid_data ==
                 get_counter_path_elements(t->fullname_, p, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(p.objectname_ == t->path_.objectname_);
-            HPX_TEST(p.parentinstancename_ == t->path_.parentinstancename_);
-            HPX_TEST(p.instancename_ == t->path_.instancename_);
-            HPX_TEST(p.subinstancename_ == t->path_.subinstancename_);
-            HPX_TEST(p.instanceindex_ == t->path_.instanceindex_);
-            HPX_TEST(p.subinstanceindex_ == t->path_.subinstanceindex_);
-            HPX_TEST(p.countername_ == t->path_.countername_);
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(p.objectname_, t->path_.objectname_);
+            HPX_TEST_EQ(p.parentinstancename_, t->path_.parentinstancename_);
+            HPX_TEST_EQ(p.instancename_, t->path_.instancename_);
+            HPX_TEST_EQ(p.subinstancename_, t->path_.subinstancename_);
+            HPX_TEST_EQ(p.instanceindex_, t->path_.instanceindex_);
+            HPX_TEST_EQ(p.subinstanceindex_, t->path_.subinstanceindex_);
+            HPX_TEST_EQ(p.countername_, t->path_.countername_);
 
             fullname.erase();
-            HPX_TEST(status_valid_data == get_counter_name(p, fullname, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(fullname == t->fullname_);
+            HPX_TEST_EQ(status_valid_data, get_counter_name(p, fullname, ec));
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(fullname, t->fullname_);
 
             counter_type_path_elements tp1, tp2;
 
             HPX_TEST(status_valid_data ==
                 get_counter_type_path_elements(t->fullname_, tp1, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(tp1.objectname_ == t->path_.objectname_);
-            HPX_TEST(tp1.countername_ == t->path_.countername_);
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(tp1.objectname_, t->path_.objectname_);
+            HPX_TEST_EQ(tp1.countername_, t->path_.countername_);
 
             type_name.erase();
-            HPX_TEST(status_valid_data == get_counter_type_name(tp1, type_name, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(type_name == t->typename_);
+            HPX_TEST_EQ(
+                status_valid_data, get_counter_type_name(tp1, type_name, ec));
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(type_name, t->typename_);
 
             type_name.erase();
             HPX_TEST(status_valid_data ==
                 get_full_counter_type_name(tp1, type_name, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            if (t->path_.parameters_.empty()) {
-                HPX_TEST(type_name == t->typename_);
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            if (t->path_.parameters_.empty())
+            {
+                HPX_TEST_EQ(type_name, t->typename_);
             }
-            else {
-                HPX_TEST(type_name == t->typename_ + '@' + t->path_.parameters_);
+            else
+            {
+                HPX_TEST_EQ(
+                    type_name, t->typename_ + '@' + t->path_.parameters_);
             }
 
             HPX_TEST(status_valid_data ==
                 get_counter_type_path_elements(t->typename_, tp2, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(tp2.objectname_ == t->path_.objectname_);
-            HPX_TEST(tp2.countername_ == t->path_.countername_);
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(tp2.objectname_, t->path_.objectname_);
+            HPX_TEST_EQ(tp2.countername_, t->path_.countername_);
 
             type_name.erase();
-            HPX_TEST(status_valid_data == get_counter_type_name(tp2, type_name, ec));
-            HPX_TEST(ec.value() == hpx::success);
-            HPX_TEST(type_name == t->typename_);
+            HPX_TEST_EQ(
+                status_valid_data, get_counter_type_name(tp2, type_name, ec));
+            HPX_TEST_EQ(ec.value(), hpx::success);
+            HPX_TEST_EQ(type_name, t->typename_);
         }
     }
 
     ///////////////////////////////////////////////////////////////////////////
+    // clang-format off
     char const* const data_bad[] =
     {
         "/{parentinstancename/instancename#1}/countername",
@@ -480,6 +488,7 @@ namespace test
         "/objectname{parentinstancename/instancename#1}/",
         nullptr
     };
+    // clang-format on
 
     void bad()
     {
@@ -491,7 +500,8 @@ namespace test
         for (char const* t = data_bad[0]; nullptr != t; t = data_bad[++i])
         {
             hpx::error_code ec;
-            HPX_TEST_EQ(status_invalid_data, get_counter_path_elements(t, p, ec));
+            HPX_TEST_EQ(
+                status_invalid_data, get_counter_path_elements(t, p, ec));
             HPX_TEST_EQ(ec.value(), hpx::bad_parameter);
         }
 
@@ -501,18 +511,20 @@ namespace test
         {
             hpx::error_code ec;
             bool caught_exception = false;
-            try {
+            try
+            {
                 get_counter_path_elements(t, p);
                 HPX_TEST(false);
             }
-            catch (hpx::exception const& e) {
+            catch (hpx::exception const& e)
+            {
                 HPX_TEST_EQ(e.get_error(), hpx::bad_parameter);
                 caught_exception = true;
             }
             HPX_TEST(caught_exception);
         }
     }
-}
+}    // namespace test
 
 int hpx_main(hpx::program_options::variables_map& vm)
 {
@@ -528,6 +540,6 @@ int hpx_main(hpx::program_options::variables_map& vm)
 ///////////////////////////////////////////////////////////////////////////////
 int main(int argc, char* argv[])
 {
-    return hpx::init(HPX_APPLICATION_STRING, argc, argv);   // Initialize and run HPX.
+    return hpx::init(
+        HPX_APPLICATION_STRING, argc, argv);    // Initialize and run HPX.
 }
-
diff --git a/tests/unit/performance_counter/reinit_counters.cpp b/libs/performance_counters/tests/unit/reinit_counters.cpp
similarity index 88%
rename from tests/unit/performance_counter/reinit_counters.cpp
rename to libs/performance_counters/tests/unit/reinit_counters.cpp
index 93ccea1d1e..4f3a9c5528 100644
--- a/tests/unit/performance_counter/reinit_counters.cpp
+++ b/libs/performance_counters/tests/unit/reinit_counters.cpp
@@ -76,11 +76,12 @@ hpx::naming::gid_type test_counter_creator(
 {
     hpx::performance_counters::counter_path_elements paths;
     get_counter_path_elements(info.fullname_, paths, ec);
-    if (ec) return hpx::naming::invalid_gid;
+    if (ec)
+        return hpx::naming::invalid_gid;
 
-    if (paths.parentinstance_is_basename_) {
-        HPX_THROWS_IF(ec, hpx::bad_parameter,
-            "test_counter_creator",
+    if (paths.parentinstance_is_basename_)
+    {
+        HPX_THROWS_IF(ec, hpx::bad_parameter, "test_counter_creator",
             "invalid counter instance parent name: " +
                 paths.parentinstancename_);
         return hpx::naming::invalid_gid;
@@ -92,15 +93,18 @@ hpx::naming::gid_type test_counter_creator(
         // make sure parent instance name is set properly
         hpx::performance_counters::counter_info complemented_info = info;
         complement_counter_info(complemented_info, info, ec);
-        if (ec) return hpx::naming::invalid_gid;
+        if (ec)
+            return hpx::naming::invalid_gid;
 
         // create the counter as requested
         hpx::naming::gid_type id;
-        try {
+        try
+        {
             id = hpx::components::server::construct<test_counter_type>(
                 complemented_info);
         }
-        catch (hpx::exception const& e) {
+        catch (hpx::exception const& e)
+        {
             if (&ec == &hpx::throws)
                 throw;
             ec = make_error_code(e.get_error(), e.what());
@@ -112,8 +116,7 @@ hpx::naming::gid_type test_counter_creator(
         return id;
     }
 
-    HPX_THROWS_IF(ec, hpx::bad_parameter,
-        "test_counter_creator",
+    HPX_THROWS_IF(ec, hpx::bad_parameter, "test_counter_creator",
         "invalid counter instance name: " + paths.instancename_);
     return hpx::naming::invalid_gid;
 }
@@ -125,7 +128,7 @@ void register_counter_type()
     hpx::performance_counters::install_counter_type("/test/reinit-values",
         hpx::performance_counters::counter_raw_values,
         "returns an array of linearly increasing counter values, supports "
-            "reinit",
+        "reinit",
         &test_counter_creator,
         &hpx::performance_counters::locality_counter_discoverer,
         HPX_PERFORMANCE_COUNTER_V1);
@@ -134,7 +137,7 @@ void register_counter_type()
 ///////////////////////////////////////////////////////////////////////////////
 int hpx_main(hpx::program_options::variables_map& vm)
 {
-    unsigned int seed = (unsigned int)std::time(nullptr);
+    unsigned int seed = (unsigned int) std::time(nullptr);
     if (vm.count("seed"))
         seed = vm["seed"].as<unsigned int>();
 
@@ -169,17 +172,13 @@ int main(int argc, char* argv[])
     options_description desc_commandline(
         "Usage: " HPX_APPLICATION_STRING " [options]");
 
-    desc_commandline.add_options()
-        ("seed,s", value<unsigned int>(),
-        "the random number generator seed to use for this run")
-        ;
+    desc_commandline.add_options()("seed,s", value<unsigned int>(),
+        "the random number generator seed to use for this run");
 
     hpx::register_startup_function(&register_counter_type);
 
     // Initialize and run HPX.
-    std::vector<std::string> const cfg = {
-        "hpx.os_threads=1"
-    };
+    std::vector<std::string> const cfg = {"hpx.os_threads=1"};
     HPX_TEST_EQ(hpx::init(desc_commandline, argc, argv, cfg), 0);
 
     return hpx::util::report_errors();
diff --git a/libs/plugin/CMakeLists.txt b/libs/plugin/CMakeLists.txt
index d8514602f0..ddfc53cfe8 100644
--- a/libs/plugin/CMakeLists.txt
+++ b/libs/plugin/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/plugin/README.rst b/libs/plugin/README.rst
index 5c7e26ba4a..e81514e078 100644
--- a/libs/plugin/README.rst
+++ b/libs/plugin/README.rst
@@ -12,4 +12,4 @@ plugin
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/plugin/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/plugin/docs/index.html>`__.
diff --git a/libs/plugin/include/hpx/plugin/abstract_factory.hpp b/libs/plugin/include/hpx/plugin/abstract_factory.hpp
index 065ca914f2..606cb4785b 100644
--- a/libs/plugin/include/hpx/plugin/abstract_factory.hpp
+++ b/libs/plugin/include/hpx/plugin/abstract_factory.hpp
@@ -8,8 +8,8 @@
 #define HPX_ABSTRACT_FACTORY_VP_2004_08_25
 
 #include <hpx/plugin/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/plugin/virtual_constructor.hpp>
+#include <hpx/type_support/pack.hpp>
 
 namespace hpx { namespace util { namespace plugin {
 
@@ -30,7 +30,7 @@ namespace hpx { namespace util { namespace plugin {
         */
         template <typename BasePlugin, typename Base, typename... Parameters>
         struct abstract_factory_item<BasePlugin, Base,
-            hpx::util::detail::pack<Parameters...>> : public Base
+            hpx::util::pack<Parameters...>> : public Base
         {
             using Base::create;
             virtual BasePlugin* create(
diff --git a/libs/plugin/include/hpx/plugin/concrete_factory.hpp b/libs/plugin/include/hpx/plugin/concrete_factory.hpp
index c253cec757..2144eb19e8 100644
--- a/libs/plugin/include/hpx/plugin/concrete_factory.hpp
+++ b/libs/plugin/include/hpx/plugin/concrete_factory.hpp
@@ -8,9 +8,9 @@
 #define HPX_CONCRETE_FACTORY_VP_2004_08_25
 
 #include <hpx/plugin/config.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/plugin/abstract_factory.hpp>
 #include <hpx/plugin/plugin_wrapper.hpp>
+#include <hpx/type_support/pack.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace util { namespace plugin {
@@ -24,7 +24,7 @@ namespace hpx { namespace util { namespace plugin {
         template <typename BasePlugin, typename Concrete, typename Base,
             typename... Parameters>
         struct concrete_factory_item<BasePlugin, Concrete, Base,
-            hpx::util::detail::pack<Parameters...>> : public Base
+            hpx::util::pack<Parameters...>> : public Base
         {
             BasePlugin* create(dll_handle dll, Parameters... parameters)
             {
diff --git a/libs/plugin/include/hpx/plugin/config.hpp b/libs/plugin/include/hpx/plugin/config.hpp
index 493e19eb9e..d1ecf3c5a6 100644
--- a/libs/plugin/include/hpx/plugin/config.hpp
+++ b/libs/plugin/include/hpx/plugin/config.hpp
@@ -14,7 +14,7 @@
 ////////////////////////////////////////////////////////////////////////////////
 // Older implementations of std::shared_ptr do not support binding function
 // pointers (see http//wg21.link/lwg3018)
-#if defined(HPX_HAVE_CXX11_SHARED_PTR_LWG3018)
+#if defined(HPX_HAVE_CXX11_STD_SHARED_PTR_LWG3018)
 
 #include <memory>
 
diff --git a/libs/plugin/include/hpx/plugin/plugin_factory.hpp b/libs/plugin/include/hpx/plugin/plugin_factory.hpp
index c349149eae..0a328c202f 100644
--- a/libs/plugin/include/hpx/plugin/plugin_factory.hpp
+++ b/libs/plugin/include/hpx/plugin/plugin_factory.hpp
@@ -190,7 +190,7 @@ namespace hpx { namespace util { namespace plugin {
 
         template <typename BasePlugin, typename Base, typename... Parameters>
         struct plugin_factory_item<BasePlugin, Base,
-            hpx::util::detail::pack<Parameters...>> : public Base
+            hpx::util::pack<Parameters...>> : public Base
         {
             plugin_factory_item(dll& d, std::string const& basename)
               : Base(d, basename)
@@ -251,7 +251,7 @@ namespace hpx { namespace util { namespace plugin {
 
         template <typename BasePlugin, typename Base, typename... Parameters>
         struct static_plugin_factory_item<BasePlugin, Base,
-            hpx::util::detail::pack<Parameters...>> : public Base
+            hpx::util::pack<Parameters...>> : public Base
         {
             static_plugin_factory_item(get_plugins_list_type const& f)
               : Base(f)
diff --git a/libs/plugin/include/hpx/plugin/virtual_constructor.hpp b/libs/plugin/include/hpx/plugin/virtual_constructor.hpp
index 6261348c57..66837ae6ff 100644
--- a/libs/plugin/include/hpx/plugin/virtual_constructor.hpp
+++ b/libs/plugin/include/hpx/plugin/virtual_constructor.hpp
@@ -10,7 +10,7 @@
 
 #include <hpx/plugin/config.hpp>
 #include <hpx/datastructures/any.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <map>
 #include <memory>
@@ -29,7 +29,7 @@ namespace hpx { namespace util { namespace plugin {
     template <typename BasePlugin>
     struct virtual_constructor
     {
-        using type = hpx::util::detail::pack<>;
+        using type = hpx::util::pack<>;
     };
 
 }}}    // namespace hpx::util::plugin
diff --git a/libs/prefix/CMakeLists.txt b/libs/prefix/CMakeLists.txt
new file mode 100644
index 0000000000..b7c774a4e6
--- /dev/null
+++ b/libs/prefix/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(prefix_headers
+  hpx/prefix/find_prefix.hpp
+)
+
+set(prefix_compat_headers
+  hpx/util/find_prefix.hpp
+)
+
+set(prefix_sources
+  find_prefix.cpp
+)
+
+include(HPX_AddModule)
+add_hpx_module(prefix
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${prefix_sources}
+  HEADERS ${prefix_headers}
+  COMPAT_HEADERS ${prefix_compat_headers}
+  DEPENDENCIES
+    hpx_assertion
+    hpx_config
+    hpx_errors
+    hpx_filesystem
+    hpx_plugin
+    hpx_string_util
+    hpx_type_support
+  CMAKE_SUBDIRS
+)
diff --git a/libs/prefix/README.rst b/libs/prefix/README.rst
new file mode 100644
index 0000000000..b248898895
--- /dev/null
+++ b/libs/prefix/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+======
+prefix
+======
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/prefix/docs/index.html>`__.
diff --git a/libs/prefix/docs/index.rst b/libs/prefix/docs/index.rst
new file mode 100644
index 0000000000..20809c6067
--- /dev/null
+++ b/libs/prefix/docs/index.rst
@@ -0,0 +1,13 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_prefix:
+
+======
+prefix
+======
+
diff --git a/hpx/util/find_prefix.hpp b/libs/prefix/include/hpx/prefix/find_prefix.hpp
similarity index 62%
rename from hpx/util/find_prefix.hpp
rename to libs/prefix/include/hpx/prefix/find_prefix.hpp
index 036cc7d199..c9903d742c 100644
--- a/hpx/util/find_prefix.hpp
+++ b/libs/prefix/include/hpx/prefix/find_prefix.hpp
@@ -14,49 +14,45 @@
 
 #include <string>
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     // set and query the prefix as configured at compile time
-    HPX_EXPORT void set_hpx_prefix(const char * prefix);
+    HPX_EXPORT void set_hpx_prefix(const char* prefix);
     HPX_EXPORT char const* hpx_prefix();
 
     // return the installation path of the specified module
     HPX_EXPORT std::string find_prefix(std::string const& library = "hpx");
 
     // return a list of paths delimited by HPX_INI_PATH_DELIMITER
-    HPX_EXPORT std::string find_prefixes(std::string const& suffix,
-        std::string const& library = "hpx");
+    HPX_EXPORT std::string find_prefixes(
+        std::string const& suffix, std::string const& library = "hpx");
 
     // return the full path of the current executable
     HPX_EXPORT std::string get_executable_filename(char const* argv0 = nullptr);
     HPX_EXPORT std::string get_executable_prefix(char const* argv0 = nullptr);
-}}
+}}    // namespace hpx::util
 
 // The HPX runtime needs to know where to look for the HPX ini files if no ini
 // path is specified by the user (default in $HPX_LOCATION/share/hpx-1.0.0/ini).
 // Also, the default component path is set within the same prefix
 
-#define HPX_BASE_DIR_NAME             "hpx-"                                  \
-        HPX_PP_STRINGIZE(HPX_VERSION_MAJOR) "."                               \
-        HPX_PP_STRINGIZE(HPX_VERSION_MINOR) "."                               \
-        HPX_PP_STRINGIZE(HPX_VERSION_SUBMINOR)                                \
-    /**/
+// clang-format off
+#define HPX_BASE_DIR_NAME                                                      \
+    "hpx-"                                                                     \
+    HPX_PP_STRINGIZE(HPX_VERSION_MAJOR) "."                                    \
+    HPX_PP_STRINGIZE(HPX_VERSION_MINOR) "."                                    \
+    HPX_PP_STRINGIZE(HPX_VERSION_SUBMINOR) /**/
+// clang-format on
 
 #if !defined(HPX_DEFAULT_INI_PATH)
-#define HPX_DEFAULT_INI_PATH                                                  \
-        hpx::util::find_prefixes("/share/" HPX_BASE_DIR_NAME "/ini")          \
-    /**/
+#define HPX_DEFAULT_INI_PATH                                                   \
+    hpx::util::find_prefixes("/share/" HPX_BASE_DIR_NAME "/ini") /**/
 #endif
 #if !defined(HPX_DEFAULT_INI_FILE)
-#define HPX_DEFAULT_INI_FILE                                                  \
-        hpx::util::find_prefixes("/share/" HPX_BASE_DIR_NAME "/hpx.ini")      \
-    /**/
+#define HPX_DEFAULT_INI_FILE                                                   \
+    hpx::util::find_prefixes("/share/" HPX_BASE_DIR_NAME "/hpx.ini") /**/
 #endif
 #if !defined(HPX_DEFAULT_COMPONENT_PATH)
-#define HPX_DEFAULT_COMPONENT_PATH                                            \
-        hpx::util::find_prefixes("/hpx")                                      \
-    /**/
+#define HPX_DEFAULT_COMPONENT_PATH hpx::util::find_prefixes("/hpx") /**/
 #endif
 
-#endif // HPX_09DFB7AE_8265_4667_AA02_65BF8C0B1DFD
-
+#endif    // HPX_09DFB7AE_8265_4667_AA02_65BF8C0B1DFD
diff --git a/libs/prefix/include_compatibility/hpx/util/find_prefix.hpp b/libs/prefix/include_compatibility/hpx/util/find_prefix.hpp
new file mode 100644
index 0000000000..d40b30b509
--- /dev/null
+++ b/libs/prefix/include_compatibility/hpx/util/find_prefix.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/prefix/find_prefix.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/find_prefix.hpp is deprecated, \
+    please include hpx/prefix/find_prefix.hpp instead")
+#else
+#warning "The header hpx/util/find_prefix.hpp is deprecated, \
+    please include hpx/prefix/find_prefix.hpp instead"
+#endif
+#endif
diff --git a/src/util/find_prefix.cpp b/libs/prefix/src/find_prefix.cpp
similarity index 78%
rename from src/util/find_prefix.cpp
rename to libs/prefix/src/find_prefix.cpp
index 986549f248..f1045dc6e9 100644
--- a/src/util/find_prefix.cpp
+++ b/libs/prefix/src/find_prefix.cpp
@@ -12,38 +12,37 @@
 #include <hpx/errors.hpp>
 #include <hpx/filesystem.hpp>
 #include <hpx/plugin.hpp>
+#include <hpx/prefix/find_prefix.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
 #include <hpx/type_support/unused.hpp>
-#include <hpx/util/find_prefix.hpp>
 
 #if defined(HPX_WINDOWS)
-#  include <windows.h>
+#include <windows.h>
 #elif defined(__linux) || defined(linux) || defined(__linux__)
-#  include <unistd.h>
-#  include <sys/stat.h>
-#  include <linux/limits.h>
-#  include <vector>
+#include <linux/limits.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <vector>
 #elif __APPLE__
-#  include <mach-o/dyld.h>
+#include <mach-o/dyld.h>
 #elif defined(__FreeBSD__)
-#  include <sys/types.h>
-#  include <sys/sysctl.h>
-#  include <algorithm>
-#  include <iterator>
-#  include <vector>
+#include <algorithm>
+#include <iterator>
+#include <sys/sysctl.h>
+#include <sys/types.h>
+#include <vector>
 #endif
 
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/classification.hpp>
 #include <boost/tokenizer.hpp>
 
 #include <cstdint>
 #include <string>
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     static const char* prefix_ = nullptr;
 
-    void set_hpx_prefix(const char * prefix)
+    void set_hpx_prefix(const char* prefix)
     {
         if (prefix_ == nullptr)
             prefix_ = prefix;
@@ -51,19 +50,20 @@ namespace hpx { namespace util
 
     char const* hpx_prefix()
     {
-        HPX_ASSERT(nullptr != prefix_);
         return prefix_;
     }
 
     std::string find_prefix(std::string const& library)
     {
 #if !defined(__ANDROID__) && !defined(ANDROID) && !defined(__MIC)
-        try {
+        try
+        {
             error_code ec(hpx::throwmode::lightweight);
             hpx::util::plugin::dll dll(HPX_MAKE_DLL_STRING(library));
 
             dll.load_library(ec);
-            if (ec) return hpx_prefix();
+            if (ec)
+                return hpx_prefix();
 
             using hpx::filesystem::path;
 
@@ -75,21 +75,23 @@ namespace hpx { namespace util
 
             return prefix;
         }
-        catch (std::logic_error const&) {
-            ;   // just ignore loader problems
+        catch (std::logic_error const&)
+        {
+            ;    // just ignore loader problems
         }
 #endif
         return hpx_prefix();
     }
 
-    std::string find_prefixes(std::string const& suffix, std::string const& library)
+    std::string find_prefixes(
+        std::string const& suffix, std::string const& library)
     {
         std::string prefixes = find_prefix(library);
-        typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
+        typedef boost::tokenizer<boost::char_separator<char>> tokenizer;
         boost::char_separator<char> sep(HPX_INI_PATH_DELIMITER);
         tokenizer tokens(prefixes, sep);
         std::string result;
-        for(tokenizer::iterator it = tokens.begin(); it != tokens.end(); ++it)
+        for (tokenizer::iterator it = tokens.begin(); it != tokens.end(); ++it)
         {
             if (it != tokens.begin())
                 result += HPX_INI_PATH_DELIMITER;
@@ -130,7 +132,7 @@ namespace hpx { namespace util
 #if defined(HPX_WINDOWS)
         HPX_UNUSED(argv0);
 
-        char exe_path[MAX_PATH + 1] = { '\0' };
+        char exe_path[MAX_PATH + 1] = {'\0'};
         if (!GetModuleFileNameA(nullptr, exe_path, sizeof(exe_path)))
         {
             HPX_THROW_EXCEPTION(hpx::dynamic_link_failure,
@@ -181,9 +183,9 @@ namespace hpx { namespace util
             {
                 std::vector<std::string> path_dirs;
 
-                boost::algorithm::split(path_dirs, epath,
-                    boost::algorithm::is_any_of(":"),
-                    boost::algorithm::token_compress_on);
+                hpx::string_util::split(path_dirs, epath,
+                    hpx::string_util::is_any_of(":"),
+                    hpx::string_util::token_compress_mode::on);
 
                 for (std::uint64_t i = 0; i < path_dirs.size(); ++i)
                 {
@@ -200,17 +202,17 @@ namespace hpx { namespace util
                     // NOTE: If someone was using an HPX application that was
                     // seteuid'd to root, this may fail.
                     if (0 == ::stat(r.c_str(), &s))
-                        if ((s.st_uid == ::geteuid()) && (s.st_mode & S_IXUSR)
-                         && (s.st_gid == ::getegid()) && (s.st_mode & S_IXGRP)
-                                                      && (s.st_mode & S_IXOTH))
+                        if ((s.st_uid == ::geteuid()) &&
+                            (s.st_mode & S_IXUSR) &&
+                            (s.st_gid == ::getegid()) &&
+                            (s.st_mode & S_IXGRP) && (s.st_mode & S_IXOTH))
                             return r;
                 }
             }
         }
 
         HPX_THROW_EXCEPTION(hpx::dynamic_link_failure,
-            "get_executable_filename",
-            "unable to find executable filename");
+            "get_executable_filename", "unable to find executable filename");
 
 #elif defined(__APPLE__)
         HPX_UNUSED(argv0);
@@ -224,13 +226,13 @@ namespace hpx { namespace util
                 "get_executable_filename",
                 "unable to find executable filename");
         }
-        exe_path[len-1] = '\0';
+        exe_path[len - 1] = '\0';
         r = exe_path;
 
 #elif defined(__FreeBSD__)
         HPX_UNUSED(argv0);
 
-        int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
+        int mib[] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1};
         size_t cb = 0;
         sysctl(mib, 4, nullptr, &cb, nullptr, 0);
         if (cb)
@@ -241,10 +243,9 @@ namespace hpx { namespace util
         }
 
 #else
-#  error Unsupported platform
+#error Unsupported platform
 #endif
 
         return r;
     }
-}}
-
+}}    // namespace hpx::util
diff --git a/libs/preprocessor/CMakeLists.txt b/libs/preprocessor/CMakeLists.txt
index c32570bcdf..cab1ff5680 100644
--- a/libs/preprocessor/CMakeLists.txt
+++ b/libs/preprocessor/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/preprocessor/README.rst b/libs/preprocessor/README.rst
index a791ee4969..84cc40bf82 100644
--- a/libs/preprocessor/README.rst
+++ b/libs/preprocessor/README.rst
@@ -18,4 +18,4 @@ This library contains useful preprocessor macros:
 * ``HPX_PP_STRIP_PARENS``: Strips parenthesis from a token
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/pp/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/pp/docs/index.html>`__.
diff --git a/libs/program_options/CMakeLists.txt b/libs/program_options/CMakeLists.txt
index c5f106d27d..b62f79c354 100644
--- a/libs/program_options/CMakeLists.txt
+++ b/libs/program_options/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -57,6 +57,7 @@ add_hpx_module(program_options
     hpx_assertion
     hpx_config
     hpx_datastructures
+    hpx_format
     hpx_iterator_support
     ${__boost_program_options}
   CMAKE_SUBDIRS examples tests
diff --git a/libs/program_options/README.rst b/libs/program_options/README.rst
index e0c248d5c7..7fdea71555 100644
--- a/libs/program_options/README.rst
+++ b/libs/program_options/README.rst
@@ -12,4 +12,4 @@ program_options
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/program_options/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/program_options/docs/index.html>`__.
diff --git a/libs/program_options/examples/config_file_types.cpp b/libs/program_options/examples/config_file_types.cpp
index c63f30dfde..f3234e38d2 100644
--- a/libs/program_options/examples/config_file_types.cpp
+++ b/libs/program_options/examples/config_file_types.cpp
@@ -19,7 +19,7 @@
 namespace po = hpx::program_options;
 using namespace std;
 
-const double FLOAT_SEPERATION = 0.00000000001;
+const double FLOAT_SEPARATION = 0.00000000001;
 
 template <typename Double1, typename Double2>
 bool check_float(Double1 test, Double2 expected)
@@ -27,9 +27,9 @@ bool check_float(Double1 test, Double2 expected)
     double test_d = double(test);
     double expected_d = double(expected);
 
-    double seperation = expected_d * (1. + FLOAT_SEPERATION) / expected_d;
-    if ((test_d < expected_d + seperation) &&
-        (test_d > expected_d - seperation))
+    double separation = expected_d * (1. + FLOAT_SEPARATION) / expected_d;
+    if ((test_d < expected_d + separation) &&
+        (test_d > expected_d - separation))
     {
         return true;
     }
diff --git a/libs/program_options/examples/options_hierarchy.cpp b/libs/program_options/examples/options_hierarchy.cpp
index a9817585a9..859cf28f72 100644
--- a/libs/program_options/examples/options_hierarchy.cpp
+++ b/libs/program_options/examples/options_hierarchy.cpp
@@ -54,16 +54,16 @@ struct NetworkOpts
     unsigned short port;
 };
 
-class OptionsHeirarchy
+class OptionsHierarchy
 {
 public:
     // The constructor sets up all the various options that will be parsed
-    OptionsHeirarchy()
+    OptionsHierarchy()
     {
         SetOptions();
     }
 
-    // Parse options runs through the heirarchy doing all the parsing
+    // Parse options runs through the hierarchy doing all the parsing
     void ParseOptions(int argc, char* argv[])
     {
         ParseCommandLine(argc, argv);
@@ -253,7 +253,7 @@ private:
     void ParseEnvironment()
     {
         store(po::parse_environment(common_options,
-                  std::bind(&OptionsHeirarchy::EnvironmentMapper, this,
+                  std::bind(&OptionsHierarchy::EnvironmentMapper, this,
                       std::placeholders::_1)),
             results);
         notify(results);
@@ -317,7 +317,7 @@ private:
 
 void get_env_options() {}
 
-void PrintOptions(OptionsHeirarchy options)
+void PrintOptions(OptionsHierarchy options)
 {
     auto path = options.Path();
     if (path.length())
@@ -358,7 +358,7 @@ void PrintOptions(OptionsHeirarchy options)
 
 int main(int ac, char* av[])
 {
-    OptionsHeirarchy options;
+    OptionsHierarchy options;
     try
     {
         options.ParseOptions(ac, av);
@@ -549,8 +549,8 @@ However, if the --verboseity flag is also set, it will override the env
 variable. This illustrates an important example, the way program_options works,
 is that a parser will not override a value that has previously been set by
 another parser. Thus the env parser doesn't override the command line parser.
-(We will see this again in config files.) Default values are seperate from this
-heirarcy, they only apply if no parser has set the value and it is being read.
+(We will see this again in config files.) Default values are separate from this
+hierarchy, they only apply if no parser has set the value and it is being read.
 
     > set EXAMPLE_VERBOSE=DEBUG
     > example.exe --verbosity=WARN
@@ -699,7 +699,7 @@ Results in a combination of all three config files:
     Network Address: 5.6.7.8
     Network Port: 3000
 
-Incidently the boolean run-gui option could have been set a number of ways
+Incidentally the boolean run-gui option could have been set a number of ways
 that all result in the C++ boolean value of true:
 
     run-gui=true
diff --git a/libs/program_options/examples/regex.cpp b/libs/program_options/examples/regex.cpp
index 4392a506cc..12d8152ecb 100644
--- a/libs/program_options/examples/regex.cpp
+++ b/libs/program_options/examples/regex.cpp
@@ -23,14 +23,13 @@
 #include <hpx/datastructures/any.hpp>
 #include <hpx/hpx_main.hpp>
 #include <hpx/program_options.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <iostream>
 #include <regex>
 #include <string>
 #include <vector>
 
-#include <boost/lexical_cast.hpp>
-
 using namespace hpx::program_options;
 using namespace std;
 
@@ -73,7 +72,7 @@ void validate(
     smatch match;
     if (regex_match(s, match, r))
     {
-        v = any(magic_number(boost::lexical_cast<int>(match[1])));
+        v = any(magic_number(hpx::util::from_string<int>(match[1])));
     }
     else
     {
diff --git a/libs/program_options/include/hpx/program_options/detail/value_semantic.hpp b/libs/program_options/include/hpx/program_options/detail/value_semantic.hpp
index 96a8bade0b..80a1b959c4 100644
--- a/libs/program_options/include/hpx/program_options/detail/value_semantic.hpp
+++ b/libs/program_options/include/hpx/program_options/detail/value_semantic.hpp
@@ -39,8 +39,7 @@ namespace hpx { namespace program_options {
 #include <hpx/datastructures/any.hpp>
 #include <hpx/datastructures/optional.hpp>
 #include <hpx/program_options/errors.hpp>
-
-#include <boost/lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <string>
@@ -135,9 +134,9 @@ namespace hpx { namespace program_options {
         std::basic_string<Char> s(validators::get_single_string(xs));
         try
         {
-            v = hpx::util::any_nonser(boost::lexical_cast<T>(s));
+            v = hpx::util::any_nonser(hpx::util::from_string<T>(s));
         }
-        catch (const boost::bad_lexical_cast&)
+        catch (const hpx::util::bad_lexical_cast&)
         {
             throw invalid_option_value(s);
         }
@@ -182,7 +181,7 @@ namespace hpx { namespace program_options {
                 validate(a, cv, (T*) nullptr, 0);
                 tv->push_back(hpx::util::any_cast<T>(a));
             }
-            catch (const boost::bad_lexical_cast& /*e*/)
+            catch (const hpx::util::bad_lexical_cast& /*e*/)
             {
                 throw invalid_option_value(s[i]);
             }
diff --git a/libs/program_options/include/hpx/program_options/parsers.hpp b/libs/program_options/include/hpx/program_options/parsers.hpp
index 6f777f906a..a4f4b4bbfb 100644
--- a/libs/program_options/include/hpx/program_options/parsers.hpp
+++ b/libs/program_options/include/hpx/program_options/parsers.hpp
@@ -280,18 +280,18 @@ namespace hpx { namespace program_options {
 
     /** Splits a given string to a collection of single strings which
         can be passed to command_line_parser. The second parameter is
-        used to specify a collection of possible seperator chars used
-        for splitting. The seperator is defaulted to space " ".
+        used to specify a collection of possible separator chars used
+        for splitting. The separator is defaulted to space " ".
         Splitting is done in a unix style way, with respect to quotes '"'
         and escape characters '\'
     */
     HPX_EXPORT std::vector<std::string> split_unix(const std::string& cmdline,
-        const std::string& seperator = " \t", const std::string& quote = "'\"",
+        const std::string& separator = " \t", const std::string& quote = "'\"",
         const std::string& escape = "\\");
 
     /** @overload */
     HPX_EXPORT std::vector<std::wstring> split_unix(const std::wstring& cmdline,
-        const std::wstring& seperator = L" \t",
+        const std::wstring& separator = L" \t",
         const std::wstring& quote = L"'\"", const std::wstring& escape = L"\\");
 
 #ifdef HPX_WINDOWS
diff --git a/libs/program_options/include/hpx/program_options/value_semantic.hpp b/libs/program_options/include/hpx/program_options/value_semantic.hpp
index 8aa7db7a7b..9c25b570df 100644
--- a/libs/program_options/include/hpx/program_options/value_semantic.hpp
+++ b/libs/program_options/include/hpx/program_options/value_semantic.hpp
@@ -50,8 +50,7 @@ namespace hpx { namespace program_options {
 
 #include <hpx/datastructures/any.hpp>
 #include <hpx/program_options/errors.hpp>
-
-#include <boost/lexical_cast.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include <functional>
 #include <limits>
@@ -251,7 +250,7 @@ namespace hpx { namespace program_options {
         typed_value* default_value(const T& v)
         {
             m_default_value = hpx::util::any_nonser(v);
-            m_default_value_as_text = boost::lexical_cast<std::string>(v);
+            m_default_value_as_text = hpx::util::to_string(v);
             return this;
         }
 
@@ -275,7 +274,7 @@ namespace hpx { namespace program_options {
         typed_value* implicit_value(const T& v)
         {
             m_implicit_value = hpx::util::any_nonser(v);
-            m_implicit_value_as_text = boost::lexical_cast<std::string>(v);
+            m_implicit_value_as_text = hpx::util::to_string(v);
             return this;
         }
 
diff --git a/libs/program_options/src/options_description.cpp b/libs/program_options/src/options_description.cpp
index a55e31a1fd..d7244d6af9 100644
--- a/libs/program_options/src/options_description.cpp
+++ b/libs/program_options/src/options_description.cpp
@@ -14,7 +14,6 @@
 // should move that to a separate headers.
 #include <hpx/program_options/parsers.hpp>
 
-#include <boost/lexical_cast.hpp>
 #include <boost/tokenizer.hpp>
 
 #include <climits>
diff --git a/libs/program_options/src/split.cpp b/libs/program_options/src/split.cpp
index 98f2388c23..8af273c087 100644
--- a/libs/program_options/src/split.cpp
+++ b/libs/program_options/src/split.cpp
@@ -19,7 +19,7 @@ namespace hpx { namespace program_options { namespace detail {
     template <class Char>
     std::vector<std::basic_string<Char>> split_unix(
         const std::basic_string<Char>& cmdline,
-        const std::basic_string<Char>& seperator,
+        const std::basic_string<Char>& separator,
         const std::basic_string<Char>& quote,
         const std::basic_string<Char>& escape)
     {
@@ -28,7 +28,7 @@ namespace hpx { namespace program_options { namespace detail {
             std::basic_string<Char>>;
 
         tokenizerT tok(cmdline.begin(), cmdline.end(),
-            boost::escaped_list_separator<Char>(escape, seperator, quote));
+            boost::escaped_list_separator<Char>(escape, separator, quote));
 
         std::vector<std::basic_string<Char>> result;
         for (typename tokenizerT::iterator cur_token(tok.begin()),
@@ -48,17 +48,17 @@ namespace hpx { namespace program_options {
     // Take a command line string and splits in into tokens, according
     // to the given collection of separators chars.
     HPX_EXPORT std::vector<std::string> split_unix(const std::string& cmdline,
-        const std::string& seperator, const std::string& quote,
+        const std::string& separator, const std::string& quote,
         const std::string& escape)
     {
-        return detail::split_unix<char>(cmdline, seperator, quote, escape);
+        return detail::split_unix<char>(cmdline, separator, quote, escape);
     }
 
     HPX_EXPORT std::vector<std::wstring> split_unix(const std::wstring& cmdline,
-        const std::wstring& seperator, const std::wstring& quote,
+        const std::wstring& separator, const std::wstring& quote,
         const std::wstring& escape)
     {
-        return detail::split_unix<wchar_t>(cmdline, seperator, quote, escape);
+        return detail::split_unix<wchar_t>(cmdline, separator, quote, escape);
     }
 
 }}    // namespace hpx::program_options
diff --git a/libs/program_options/src/variables_map.cpp b/libs/program_options/src/variables_map.cpp
index eea6ea4583..ab1ed12273 100644
--- a/libs/program_options/src/variables_map.cpp
+++ b/libs/program_options/src/variables_map.cpp
@@ -35,7 +35,7 @@ namespace hpx { namespace program_options {
         HPX_ASSERT(options.description);
         const options_description& desc = *options.description;
 
-        // We need to access map's operator[], not the overriden version
+        // We need to access map's operator[], not the overridden version
         // variables_map. Ehmm.. messy.
         std::map<std::string, variable_value>& m = xm;
 
diff --git a/libs/program_options/tests/regressions/commandline_options_1437.cpp b/libs/program_options/tests/regressions/commandline_options_1437.cpp
index e290c66911..6689f41500 100644
--- a/libs/program_options/tests/regressions/commandline_options_1437.cpp
+++ b/libs/program_options/tests/regressions/commandline_options_1437.cpp
@@ -15,7 +15,7 @@ bool invoked_main = false;
 int my_hpx_main(int argc, char** argv)
 {
     // all HPX command line arguments should have been stripped here
-    HPX_TEST(argc == 1);
+    HPX_TEST_EQ(argc, 1);
 
     invoked_main = true;
     return hpx::finalize();
@@ -23,7 +23,7 @@ int my_hpx_main(int argc, char** argv)
 
 int main(int argc, char** argv)
 {
-    HPX_TEST(argc > 1);
+    HPX_TEST_LT(1, argc);
 
     HPX_TEST_EQ(hpx::init(&my_hpx_main, "testapp", argc, argv), 0);
     HPX_TEST(invoked_main);
diff --git a/libs/program_options/tests/unit/boost_program_options.cpp b/libs/program_options/tests/unit/boost_program_options.cpp
index 89ebf29919..cbd6dac732 100644
--- a/libs/program_options/tests/unit/boost_program_options.cpp
+++ b/libs/program_options/tests/unit/boost_program_options.cpp
@@ -7,7 +7,7 @@
 // Test for compatibility with Boost.ProgramOptions
 // hpxinspect:nodeprecatedinclude:boost/program_options.hpp
 
-// We use boost::program_options here, so surpress the deprecation warning.
+// We use boost::program_options here, so suppress the deprecation warning.
 #if defined(__clang__)
 #pragma clang diagnostic ignored "-Wdeprecated-declarations"
 #elif defined(__GNUC__)
diff --git a/libs/program_options/tests/unit/cmdline.cpp b/libs/program_options/tests/unit/cmdline.cpp
index d22577762d..1c1003746e 100644
--- a/libs/program_options/tests/unit/cmdline.cpp
+++ b/libs/program_options/tests/unit/cmdline.cpp
@@ -16,6 +16,7 @@
 #include <hpx/program_options/options_description.hpp>
 #include <hpx/program_options/value_semantic.hpp>
 
+#include <cstddef>
 #include <iostream>
 #include <sstream>
 #include <utility>
@@ -55,7 +56,7 @@ int translate_syntax_error_kind(invalid_command_line_syntax::kind_t k)
     b = table;
     e = table + sizeof(table) / sizeof(table[0]);
     i = std::find(b, e, k);
-    HPX_TEST(i != e);
+    HPX_TEST_NEQ(i, e);
     return int(std::distance(b, i)) + 3;
 }
 
@@ -434,9 +435,9 @@ void test_additional_parser()
 #if !defined(HPX_PROGRAM_OPTIONS_HAVE_BOOST_PROGRAM_OPTIONS_COMPATIBILITY) ||  \
     (defined(BOOST_VERSION) && BOOST_VERSION >= 106800)
     // the long_names() API function was introduced in Boost V1.68
-    HPX_TEST(result.size() == 3);
+    HPX_TEST_EQ(result.size(), std::size_t(3));
 #else
-    HPX_TEST(result.size() == 2);
+    HPX_TEST_EQ(result.size(), std::size_t(2));
 #endif
     HPX_TEST_EQ(result[0].string_key, "response-file");
     HPX_TEST_EQ(result[0].value[0], "config");
@@ -494,7 +495,7 @@ void test_style_parser()
 
     vector<option> result = cmd.run();
 
-    HPX_TEST(result.size() == 2);
+    HPX_TEST_EQ(result.size(), std::size_t(2));
     HPX_TEST_EQ(result[0].string_key, "foo");
     HPX_TEST_EQ(result[0].value[0], "1");
     HPX_TEST_EQ(result[1].string_key, "bar");
@@ -503,7 +504,7 @@ void test_style_parser()
 
 void test_unregistered()
 {
-    // Check unregisted option when no options are registed at all.
+    // Check unregistered option when no options are registered at all.
     options_description desc;
 
     vector<string> input;
@@ -518,7 +519,7 @@ void test_unregistered()
     cmd.allow_unregistered();
 
     vector<option> result = cmd.run();
-    HPX_TEST(result.size() == 5);
+    HPX_TEST_EQ(result.size(), std::size_t(5));
     // --foo=1
     HPX_TEST_EQ(result[0].string_key, "foo");
     HPX_TEST_EQ(result[0].unregistered, true);
@@ -530,7 +531,7 @@ void test_unregistered()
     // '1' is considered a positional option, not a value to
     // --bar
     HPX_TEST(result[2].string_key.empty());
-    HPX_TEST(result[2].position_key == 0);
+    HPX_TEST_EQ(result[2].position_key, 0);
     HPX_TEST_EQ(result[2].unregistered, false);
     HPX_TEST_EQ(result[2].value[0], "1");
     // -b
@@ -542,7 +543,7 @@ void test_unregistered()
     HPX_TEST_EQ(result[4].unregistered, true);
     HPX_TEST_EQ(result[4].value[0], "iz");
 
-    // Check sticky short options together with unregisted options.
+    // Check sticky short options together with unregistered options.
 
     desc.add_options()("help,h", "")("magic,m", value<string>(), "");
 
@@ -556,7 +557,7 @@ void test_unregistered()
 
     result = cmd2.run();
 
-    HPX_TEST(result.size() == 3);
+    HPX_TEST_EQ(result.size(), std::size_t(3));
     HPX_TEST_EQ(result[0].string_key, "help");
     HPX_TEST_EQ(result[0].unregistered, false);
     HPX_TEST(result[0].value.empty());
diff --git a/libs/program_options/tests/unit/optional.cpp b/libs/program_options/tests/unit/optional.cpp
index 3c056a5ec5..03cb8969d9 100644
--- a/libs/program_options/tests/unit/optional.cpp
+++ b/libs/program_options/tests/unit/optional.cpp
@@ -50,10 +50,10 @@ void test_optional()
     po::notify(vm);
 
     HPX_TEST(!!foo);
-    HPX_TEST(*foo == 12);
+    HPX_TEST_EQ(*foo, 12);
 
     HPX_TEST(!!bar);
-    HPX_TEST(*bar == 1);
+    HPX_TEST_EQ(*bar, 1);
 
     HPX_TEST(!baz);
 #endif
diff --git a/libs/program_options/tests/unit/parsers.cpp b/libs/program_options/tests/unit/parsers.cpp
index cea615631b..eba42798c5 100644
--- a/libs/program_options/tests/unit/parsers.cpp
+++ b/libs/program_options/tests/unit/parsers.cpp
@@ -16,6 +16,7 @@
 #include <hpx/program_options/value_semantic.hpp>
 #include <hpx/program_options/variables_map.hpp>
 
+#include <cstddef>
 #include <cstdlib>    // for putenv
 #include <fstream>
 #include <functional>
@@ -43,9 +44,9 @@ pair<string, vector<vector<string>>> msp(const string& s1, const string& s2)
 
 void check_value(const option& option, const char* name, const char* value)
 {
-    HPX_TEST(option.string_key == name);
-    HPX_TEST(option.value.size() == 1);
-    HPX_TEST(option.value.front() == value);
+    HPX_TEST_EQ(option.string_key, name);
+    HPX_TEST_EQ(option.value.size(), std::size_t(1));
+    HPX_TEST_EQ(option.value.front(), value);
 }
 
 vector<string> sv(const char* array[], unsigned size)
@@ -132,7 +133,7 @@ namespace command_line {
                 .options;
         HPX_TEST_EQ(a5.size(), 3u);
         check_value(a5[0], "-p", "7");
-        HPX_TEST(a5[1].value.size() == 3);
+        HPX_TEST_EQ(a5[1].value.size(), std::size_t(3));
         HPX_TEST_EQ(a5[1].string_key, "-o");
         HPX_TEST_EQ(a5[1].value[0], "1");
         HPX_TEST_EQ(a5[1].value[1], "2");
@@ -160,7 +161,7 @@ namespace command_line {
         check_value(parsed_options[0], "foo", "one");
         check_value(parsed_options[1], "bar", "two");
         HPX_TEST_EQ(parsed_options[2].string_key, "foo");
-        HPX_TEST(parsed_options[2].value.size() == 2);
+        HPX_TEST_EQ(parsed_options[2].value.size(), std::size_t(2));
         HPX_TEST_EQ(parsed_options[2].value[0], "three");
         HPX_TEST_EQ(parsed_options[2].value[1], "four");
         check_value(parsed_options[3], "fizbaz", "five");
@@ -178,7 +179,7 @@ namespace command_line {
         check_value(parsed_options[0], "foo", "one");
         check_value(parsed_options[1], "bar", "two");
         HPX_TEST_EQ(parsed_options[2].string_key, "foo");
-        HPX_TEST(parsed_options[2].value.size() == 2);
+        HPX_TEST_EQ(parsed_options[2].value.size(), std::size_t(2));
         HPX_TEST_EQ(parsed_options[2].value[0], "three");
         HPX_TEST_EQ(parsed_options[2].value[1], "four");
         check_value(parsed_options[3], "fizbaz", "five");
@@ -207,12 +208,12 @@ namespace command_line {
                 .run()
                 .options;
         HPX_TEST_EQ(a6.size(), 2u);
-        HPX_TEST(a6[0].value.size() == 2);
+        HPX_TEST_EQ(a6[0].value.size(), std::size_t(2));
         HPX_TEST_EQ(a6[0].string_key, "multitoken");
         HPX_TEST_EQ(a6[0].value[0], "token1");
         HPX_TEST_EQ(a6[0].value[1], "token2");
         HPX_TEST_EQ(a6[1].string_key, "file");
-        HPX_TEST(a6[1].value.size() == 1);
+        HPX_TEST_EQ(a6[1].value.size(), std::size_t(1));
         HPX_TEST_EQ(a6[1].value[0], "some_file");
 #endif
     }
@@ -252,7 +253,7 @@ void test_config_file(const char* config_file)
 
     stringstream ss(content1);
     vector<option> a1 = parse_config_file(ss, desc).options;
-    HPX_TEST(a1.size() == 7);
+    HPX_TEST_EQ(a1.size(), std::size_t(7));
     check_value(a1[0], "gv1", "0");
     check_value(a1[1], "empty_value", "");
     check_value(a1[2], "plug3", "7");
@@ -263,7 +264,7 @@ void test_config_file(const char* config_file)
 
     // same test, but now options come from file
     vector<option> a2 = parse_config_file<char>(config_file, desc).options;
-    HPX_TEST(a2.size() == 7);
+    HPX_TEST_EQ(a2.size(), std::size_t(7));
     check_value(a2[0], "gv1", "0");
     check_value(a2[1], "empty_value", "");
     check_value(a2[2], "plug3", "7");
@@ -287,10 +288,10 @@ void test_environment()
 #endif
     parsed_options p = parse_environment(desc, "PO_TEST_");
 
-    HPX_TEST(p.options.size() == 1);
-    HPX_TEST(p.options[0].string_key == "foo");
-    HPX_TEST(p.options[0].value.size() == 1);
-    HPX_TEST(p.options[0].value[0] == "1");
+    HPX_TEST_EQ(p.options.size(), std::size_t(1));
+    HPX_TEST_EQ(p.options[0].string_key, "foo");
+    HPX_TEST_EQ(p.options[0].value.size(), std::size_t(1));
+    HPX_TEST_EQ(p.options[0].value[0], "1");
 
     //TODO: since 'bar' does not allow a value, it cannot appear in environment,
     // which already has a value.
@@ -309,20 +310,20 @@ void test_unregistered()
                             .run()
                             .options;
 
-    HPX_TEST(a1.size() == 3);
-    HPX_TEST(a1[0].string_key == "foo");
-    HPX_TEST(a1[0].unregistered == true);
-    HPX_TEST(a1[0].value.size() == 1);
-    HPX_TEST(a1[0].value[0] == "12");
-    HPX_TEST(a1[1].string_key == "bar");
-    HPX_TEST(a1[1].unregistered == true);
-    HPX_TEST(a1[2].string_key == "");
-    HPX_TEST(a1[2].unregistered == false);
+    HPX_TEST_EQ(a1.size(), std::size_t(3));
+    HPX_TEST_EQ(a1[0].string_key, "foo");
+    HPX_TEST_EQ(a1[0].unregistered, true);
+    HPX_TEST_EQ(a1[0].value.size(), std::size_t(1));
+    HPX_TEST_EQ(a1[0].value[0], "12");
+    HPX_TEST_EQ(a1[1].string_key, "bar");
+    HPX_TEST_EQ(a1[1].unregistered, true);
+    HPX_TEST_EQ(a1[2].string_key, "");
+    HPX_TEST_EQ(a1[2].unregistered, false);
 
     vector<string> a2 = collect_unrecognized(a1, include_positional);
-    HPX_TEST(a2[0] == "--foo=12");
-    HPX_TEST(a2[1] == "--bar");
-    HPX_TEST(a2[2] == "1");
+    HPX_TEST_EQ(a2[0], "--foo=12");
+    HPX_TEST_EQ(a2[1], "--bar");
+    HPX_TEST_EQ(a2[2], "1");
 
     // Test that storing unregistered options has no effect
     variables_map vm;
@@ -339,7 +340,7 @@ void test_unregistered()
 
     stringstream ss(content1);
     vector<option> a3 = parse_config_file(ss, desc, true).options;
-    HPX_TEST(a3.size() == 2);
+    HPX_TEST_EQ(a3.size(), std::size_t(2));
     check_value(a3[0], "gv1", "0");
     check_value(a3[1], "m1.v1", "1");
 }
diff --git a/libs/program_options/tests/unit/positional_options.cpp b/libs/program_options/tests/unit/positional_options.cpp
index 3b17e2f532..6c364d2a27 100644
--- a/libs/program_options/tests/unit/positional_options.cpp
+++ b/libs/program_options/tests/unit/positional_options.cpp
@@ -15,6 +15,7 @@
 #include <hpx/program_options/positional_options.hpp>
 #include <hpx/program_options/value_semantic.hpp>
 
+#include <cstddef>
 #include <limits>
 #include <vector>
 
@@ -72,7 +73,7 @@ void test_parsing()
     parsed_options parsed =
         command_line_parser(args).options(desc).positional(p).run();
 
-    HPX_TEST(parsed.options.size() == 5);
+    HPX_TEST_EQ(parsed.options.size(), std::size_t(5));
     HPX_TEST_EQ(parsed.options[1].string_key, "input-file");
     HPX_TEST_EQ(parsed.options[1].value[0], "file1");
     HPX_TEST_EQ(parsed.options[3].string_key, "input-file");
diff --git a/libs/program_options/tests/unit/split.cpp b/libs/program_options/tests/unit/split.cpp
index 2133e1423e..ab4eca95b6 100644
--- a/libs/program_options/tests/unit/split.cpp
+++ b/libs/program_options/tests/unit/split.cpp
@@ -14,6 +14,7 @@
 #include <hpx/program_options/value_semantic.hpp>
 #include <hpx/program_options/variables_map.hpp>
 
+#include <cstddef>
 #include <string>
 #include <vector>
 
@@ -22,7 +23,7 @@ using namespace std;
 
 void check_value(const string& option, const string& value)
 {
-    HPX_TEST(option == value);
+    HPX_TEST_EQ(option, value);
 }
 
 void split_whitespace(const options_description& description)
@@ -32,7 +33,7 @@ void split_whitespace(const options_description& description)
 
     vector<string> tokens = split_unix(cmdline, " \t\n\r");
 
-    HPX_TEST(tokens.size() == 7);
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
 
     check_value(tokens[0], "prg");
     check_value(tokens[1], "--input");
@@ -54,7 +55,7 @@ void split_equalsign(const options_description& description)
 
     vector<string> tokens = split_unix(cmdline, "= ");
 
-    HPX_TEST(tokens.size() == 7);
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
     check_value(tokens[0], "prg");
     check_value(tokens[1], "--input");
     check_value(tokens[2], "input.txt");
@@ -74,7 +75,7 @@ void split_semi(const options_description& description)
 
     vector<string> tokens = split_unix(cmdline, "; ");
 
-    HPX_TEST(tokens.size() == 7);
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
     check_value(tokens[0], "prg");
     check_value(tokens[1], "--input");
     check_value(tokens[2], "input.txt");
@@ -95,7 +96,7 @@ void split_quotes(const options_description& description)
 
     vector<string> tokens = split_unix(cmdline, " ");
 
-    HPX_TEST(tokens.size() == 7);
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
     check_value(tokens[0], "prg");
     check_value(tokens[1], "--input");
     check_value(tokens[2], "input.txt input.txt");
@@ -116,7 +117,7 @@ void split_escape(const options_description& description)
 
     vector<string> tokens = split_unix(cmdline, " ");
 
-    HPX_TEST(tokens.size() == 7);
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
     check_value(tokens[0], "prg");
     check_value(tokens[1], "--input");
     check_value(tokens[2], "\"input.txt\"");
@@ -137,7 +138,7 @@ void split_single_quote(const options_description& description)
 
     vector<string> tokens = split_unix(cmdline, " ", "'");
 
-    HPX_TEST(tokens.size() == 7);
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
     check_value(tokens[0], "prg");
     check_value(tokens[1], "--input");
     check_value(tokens[2], "input.txt input.txt");
@@ -158,7 +159,7 @@ void split_defaults(const options_description& description)
 
     vector<string> tokens = split_unix(cmdline);
 
-    HPX_TEST(tokens.size() == 7);
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
     check_value(tokens[0], "prg");
     check_value(tokens[1], "--input");
     check_value(tokens[2], "input file.txt");
diff --git a/libs/program_options/tests/unit/unicode.cpp b/libs/program_options/tests/unit/unicode.cpp
index eafa95bca3..7b8014482f 100644
--- a/libs/program_options/tests/unit/unicode.cpp
+++ b/libs/program_options/tests/unit/unicode.cpp
@@ -14,6 +14,7 @@
 #include <hpx/program_options/value_semantic.hpp>
 #include <hpx/program_options/variables_map.hpp>
 
+#include <cstddef>
 #include <locale>
 #include <sstream>
 #include <string>
@@ -39,7 +40,7 @@ void test_unicode_to_unicode()
     store(parsed, vm);
 
     HPX_TEST(vm["foo"].as<wstring>() == L"\x044F");
-    HPX_TEST(parsed.options[0].original_tokens.size() == 1);
+    HPX_TEST_EQ(parsed.options[0].original_tokens.size(), std::size_t(1));
     HPX_TEST(parsed.options[0].original_tokens[0] == L"--foo=\x044F");
 }
 
@@ -62,7 +63,7 @@ void test_unicode_to_native()
     variables_map vm;
     store(wcommand_line_parser(args).options(desc).run(), vm);
 
-    HPX_TEST(vm["foo"].as<string>() == "\xD1\x8F");
+    HPX_TEST_EQ(vm["foo"].as<string>(), "\xD1\x8F");
 }
 
 void test_native_to_unicode()
@@ -94,8 +95,8 @@ vector<wstring> sv(const wchar_t* array[], unsigned size)
 
 void check_value(const woption& option, const char* name, const wchar_t* value)
 {
-    HPX_TEST(option.string_key == name);
-    HPX_TEST(option.value.size() == 1);
+    HPX_TEST_EQ(option.string_key, name);
+    HPX_TEST_EQ(option.value.size(), std::size_t(1));
     HPX_TEST(option.value.front() == value);
 }
 
@@ -117,7 +118,7 @@ void test_command_line()
     vector<woption> a4 =
         wcommand_line_parser(cmdline4).options(desc).run().options;
 
-    HPX_TEST(a4.size() == 5);
+    HPX_TEST_EQ(a4.size(), std::size_t(5));
 
     check_value(a4[0], "foo", L"1\u0FF52");
     check_value(a4[1], "foo", L"4");
@@ -144,7 +145,7 @@ void test_config_file()
     variables_map vm;
     store(parse_config_file(stream, desc), vm);
 
-    HPX_TEST(vm["foo"].as<string>() == "\xD1\x8F");
+    HPX_TEST_EQ(vm["foo"].as<string>(), "\xD1\x8F");
 }
 
 int main(int, char*[])
diff --git a/libs/program_options/tests/unit/variable_map.cpp b/libs/program_options/tests/unit/variable_map.cpp
index d3543b7d56..2ad34b0424 100644
--- a/libs/program_options/tests/unit/variable_map.cpp
+++ b/libs/program_options/tests/unit/variable_map.cpp
@@ -15,6 +15,7 @@
 #include <hpx/program_options/value_semantic.hpp>
 #include <hpx/program_options/variables_map.hpp>
 
+#include <cstddef>
 #include <sstream>
 #include <string>
 #include <vector>
@@ -51,12 +52,12 @@ void test_variable_map()
     variables_map vm;
     store(a3, vm);
     notify(vm);
-    HPX_TEST(vm.size() == 4);
-    HPX_TEST(vm["foo"].as<string>() == "'12'");
-    HPX_TEST(vm["bar"].as<string>() == "11");
-    HPX_TEST(vm.count("biz") == 1);
-    HPX_TEST(vm["biz"].as<string>() == "3");
-    HPX_TEST(vm["output"].as<string>() == "foo");
+    HPX_TEST_EQ(vm.size(), std::size_t(4));
+    HPX_TEST_EQ(vm["foo"].as<string>(), "'12'");
+    HPX_TEST_EQ(vm["bar"].as<string>(), "11");
+    HPX_TEST_EQ(vm.count("biz"), std::size_t(1));
+    HPX_TEST_EQ(vm["biz"].as<string>(), "3");
+    HPX_TEST_EQ(vm["output"].as<string>(), "foo");
 
     int i;
     // clang-format off
@@ -75,11 +76,11 @@ void test_variable_map()
     variables_map vm2;
     store(a4, vm2);
     notify(vm2);
-    HPX_TEST(vm2.size() == 3);
-    HPX_TEST(vm2["zee"].as<bool>() == true);
-    HPX_TEST(vm2["zak"].as<int>() == 13);
-    HPX_TEST(vm2["opt"].as<bool>() == false);
-    HPX_TEST(i == 13);
+    HPX_TEST_EQ(vm2.size(), std::size_t(3));
+    HPX_TEST_EQ(vm2["zee"].as<bool>(), true);
+    HPX_TEST_EQ(vm2["zak"].as<int>(), 13);
+    HPX_TEST_EQ(vm2["opt"].as<bool>(), false);
+    HPX_TEST_EQ(i, 13);
 
     options_description desc2;
     // clang-format off
@@ -98,10 +99,10 @@ void test_variable_map()
     variables_map vm3;
     store(a5, vm3);
     notify(vm3);
-    HPX_TEST(vm3.size() == 3);
-    HPX_TEST(vm3["vee"].as<string>() == "42");
-    HPX_TEST(vm3["voo"].as<string>() == "1");
-    HPX_TEST(vm3["iii"].as<int>() == 123);
+    HPX_TEST_EQ(vm3.size(), std::size_t(3));
+    HPX_TEST_EQ(vm3["vee"].as<string>(), "42");
+    HPX_TEST_EQ(vm3["voo"].as<string>(), "1");
+    HPX_TEST_EQ(vm3["iii"].as<int>(), 123);
 
     options_description desc3;
     // clang-format off
@@ -123,10 +124,10 @@ void test_variable_map()
     variables_map vm4;
     store(a6, vm4);
     notify(vm4);
-    HPX_TEST(vm4.size() == 4);
-    HPX_TEST(vm4["imp"].as<int>() == 1);
-    HPX_TEST(vm4["iim"].as<int>() == 201);
-    HPX_TEST(vm4["mmp"].as<int>() == 123);
+    HPX_TEST_EQ(vm4.size(), std::size_t(4));
+    HPX_TEST_EQ(vm4["imp"].as<int>(), 1);
+    HPX_TEST_EQ(vm4["iim"].as<int>(), 201);
+    HPX_TEST_EQ(vm4["mmp"].as<int>(), 123);
 }
 
 int stored_value;
@@ -164,8 +165,8 @@ void test_semantic_values()
     variables_map vm;
     store(parsed, vm);
     notify(vm);
-    HPX_TEST(vm.count("biz") == 1);
-    HPX_TEST(vm.count("baz") == 1);
+    HPX_TEST_EQ(vm.count("biz"), std::size_t(1));
+    HPX_TEST_EQ(vm.count("baz"), std::size_t(1));
     const vector<string> av = vm["biz"].as<vector<string>>();
     const vector<string> av2 = vm["baz"].as<vector<string>>();
     string exp1[] = {"a", "b x"};
@@ -178,7 +179,7 @@ void test_semantic_values()
     variables_map vm2;
     store(parsed, vm2);
     notify(vm2);
-    HPX_TEST(vm2.count("int") == 1);
+    HPX_TEST_EQ(vm2.count("int"), std::size_t(1));
     HPX_TEST(vm2["int"].as<vector<int>>() == vector<int>(1, 13));
     HPX_TEST_EQ(stored_value, 13);
 
@@ -226,30 +227,30 @@ void test_priority()
     variables_map vm;
     store(p1, vm);
 
-    HPX_TEST(vm.count("first") == 1);
-    HPX_TEST(vm["first"].as<vector<int>>().size() == 2);
+    HPX_TEST_EQ(vm.count("first"), std::size_t(1));
+    HPX_TEST_EQ(vm["first"].as<vector<int>>().size(), std::size_t(2));
     HPX_TEST_EQ(vm["first"].as<vector<int>>()[0], 1);
     HPX_TEST_EQ(vm["first"].as<vector<int>>()[1], 3);
 
-    HPX_TEST(vm.count("second") == 1);
-    HPX_TEST(vm["second"].as<vector<int>>().size() == 1);
+    HPX_TEST_EQ(vm.count("second"), std::size_t(1));
+    HPX_TEST_EQ(vm["second"].as<vector<int>>().size(), std::size_t(1));
     HPX_TEST_EQ(vm["second"].as<vector<int>>()[0], 1);
 
     store(p2, vm);
 
     // Value should not change.
-    HPX_TEST(vm.count("first") == 1);
-    HPX_TEST(vm["first"].as<vector<int>>().size() == 2);
+    HPX_TEST_EQ(vm.count("first"), std::size_t(1));
+    HPX_TEST_EQ(vm["first"].as<vector<int>>().size(), std::size_t(2));
     HPX_TEST_EQ(vm["first"].as<vector<int>>()[0], 1);
     HPX_TEST_EQ(vm["first"].as<vector<int>>()[1], 3);
 
     // Value should change to 7
-    HPX_TEST(vm.count("second") == 1);
-    HPX_TEST(vm["second"].as<vector<int>>().size() == 1);
+    HPX_TEST_EQ(vm.count("second"), std::size_t(1));
+    HPX_TEST_EQ(vm["second"].as<vector<int>>().size(), std::size_t(1));
     HPX_TEST_EQ(vm["second"].as<vector<int>>()[0], 7);
 
-    HPX_TEST(vm.count("include") == 1);
-    HPX_TEST(vm["include"].as<vector<int>>().size() == 2);
+    HPX_TEST_EQ(vm.count("include"), std::size_t(1));
+    HPX_TEST_EQ(vm["include"].as<vector<int>>().size(), std::size_t(2));
     HPX_TEST_EQ(vm["include"].as<vector<int>>()[0], 1);
     HPX_TEST_EQ(vm["include"].as<vector<int>>()[1], 7);
 }
@@ -286,8 +287,8 @@ void test_multiple_assignments_with_different_option_description()
     store(p2, vm);
     store(p3, vm);
 
-    HPX_TEST(vm.count("help") == 1);
-    HPX_TEST(vm.count("includes") == 1);
+    HPX_TEST_EQ(vm.count("help"), std::size_t(1));
+    HPX_TEST_EQ(vm.count("includes"), std::size_t(1));
     HPX_TEST_EQ(vm["includes"].as<vector<string>>()[0], "a");
     HPX_TEST_EQ(vm["includes"].as<vector<string>>()[1], "b");
 }
diff --git a/libs/resiliency/CMakeLists.txt b/libs/resiliency/CMakeLists.txt
index 5a66d31cc4..a1bff9b4a0 100644
--- a/libs/resiliency/CMakeLists.txt
+++ b/libs/resiliency/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/resiliency/README.rst b/libs/resiliency/README.rst
index 8b767a9ff3..cc2f625b2b 100644
--- a/libs/resiliency/README.rst
+++ b/libs/resiliency/README.rst
@@ -12,7 +12,7 @@ Resiliency
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/resiliency/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/resiliency/docs/index.html>`__.
 
 Copyright (c) 2019 National Technology & Engineering Solutions of Sandia,
 LLC (NTESS). Under the terms of the Contract DE-NA0003525 with NTESS, the
diff --git a/libs/resiliency/include/hpx/resiliency/async_replay.hpp b/libs/resiliency/include/hpx/resiliency/async_replay.hpp
index 1943b424a2..9ce54cf224 100644
--- a/libs/resiliency/include/hpx/resiliency/async_replay.hpp
+++ b/libs/resiliency/include/hpx/resiliency/async_replay.hpp
@@ -15,8 +15,8 @@
 
 #include <hpx/async.hpp>
 #include <hpx/dataflow.hpp>
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/lcos/future.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <exception>
@@ -82,8 +82,7 @@ namespace hpx { namespace resiliency {
             }
 
             template <std::size_t... Is>
-            hpx::future<Result> invoke(
-                hpx::util::detail::pack_c<std::size_t, Is...>)
+            hpx::future<Result> invoke(hpx::util::index_pack<Is...>)
             {
                 return hpx::async(f_, std::get<Is>(t_)...);
             }
@@ -91,15 +90,14 @@ namespace hpx { namespace resiliency {
             hpx::future<Result> call(std::size_t n)
             {
                 // launch given function asynchronously
-                hpx::future<Result> f =
-                    invoke(hpx::util::detail::make_index_pack<
-                        std::tuple_size<Tuple>::value>{});
+                hpx::future<Result> f = invoke(hpx::util::make_index_pack<
+                    std::tuple_size<Tuple>::value>{});
 
                 // attach a continuation that will relaunch the task, if
                 // necessary
                 auto this_ = this->shared_from_this();
                 return f.then(hpx::launch::sync,
-                    [HPX_CAPTURE_MOVE(this_), n](hpx::future<Result>&& f) {
+                    [this_ = std::move(this_), n](hpx::future<Result>&& f) {
                         if (f.has_exception())
                         {
                             // rethrow abort_replay_exception, if caught
diff --git a/libs/resiliency/include/hpx/resiliency/async_replicate.hpp b/libs/resiliency/include/hpx/resiliency/async_replicate.hpp
index 7f5bd19abf..38a7d51808 100644
--- a/libs/resiliency/include/hpx/resiliency/async_replicate.hpp
+++ b/libs/resiliency/include/hpx/resiliency/async_replicate.hpp
@@ -100,8 +100,8 @@ namespace hpx { namespace resiliency {
         // that passes the predicate, properly handle exceptions
         return hpx::dataflow(
             hpx::launch::sync,    // do not schedule new thread for the lambda
-            [HPX_CAPTURE_FORWARD(pred), HPX_CAPTURE_FORWARD(vote), n](
-                std::vector<hpx::future<result_type>>&& results) mutable
+            [pred = std::forward<Pred>(pred), vote = std::forward<Vote>(vote),
+                n](std::vector<hpx::future<result_type>>&& results) mutable
             -> result_type {
                 // Store all valid results
                 std::vector<result_type> valid_results;
diff --git a/libs/resiliency/tests/performance/replay/1d_stencil.cpp b/libs/resiliency/tests/performance/replay/1d_stencil.cpp
index 0a95e43506..7397158113 100644
--- a/libs/resiliency/tests/performance/replay/1d_stencil.cpp
+++ b/libs/resiliency/tests/performance/replay/1d_stencil.cpp
@@ -54,7 +54,7 @@ public:
         for (std::size_t k = 0; k != subdomain_width + 1; ++k)
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
     }
 
     partition_data(partition_data&& other)
@@ -241,7 +241,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: 0" << std::endl;
 
diff --git a/libs/resiliency/tests/performance/replay/1d_stencil_checksum.cpp b/libs/resiliency/tests/performance/replay/1d_stencil_checksum.cpp
index 804f836878..55c23da2f2 100644
--- a/libs/resiliency/tests/performance/replay/1d_stencil_checksum.cpp
+++ b/libs/resiliency/tests/performance/replay/1d_stencil_checksum.cpp
@@ -72,7 +72,7 @@ public:
         {
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
             checksum_ += data_[k];
         }
     }
@@ -336,7 +336,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: " << counter << std::endl;
 
diff --git a/libs/resiliency/tests/performance/replay/1d_stencil_replay.cpp b/libs/resiliency/tests/performance/replay/1d_stencil_replay.cpp
index fcd85cc27d..fb855bb9f6 100644
--- a/libs/resiliency/tests/performance/replay/1d_stencil_replay.cpp
+++ b/libs/resiliency/tests/performance/replay/1d_stencil_replay.cpp
@@ -66,7 +66,7 @@ public:
         {
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
         }
     }
 
@@ -284,7 +284,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: " << counter << std::endl;
 
diff --git a/libs/resiliency/tests/performance/replay/dataflow_replay.cpp b/libs/resiliency/tests/performance/replay/dataflow_replay.cpp
index c2cf4296cb..bf480abab5 100644
--- a/libs/resiliency/tests/performance/replay/dataflow_replay.cpp
+++ b/libs/resiliency/tests/performance/replay/dataflow_replay.cpp
@@ -70,7 +70,7 @@ public:
         {
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
             checksum_ += data_[k];
         }
     }
@@ -326,7 +326,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: " << counter << std::endl;
 
diff --git a/libs/resiliency/tests/performance/replay/dataflow_replay_validate.cpp b/libs/resiliency/tests/performance/replay/dataflow_replay_validate.cpp
index 23f900fcc4..8a3fee08cb 100644
--- a/libs/resiliency/tests/performance/replay/dataflow_replay_validate.cpp
+++ b/libs/resiliency/tests/performance/replay/dataflow_replay_validate.cpp
@@ -71,7 +71,7 @@ public:
         {
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
             checksum_ += data_[k];
         }
     }
@@ -327,7 +327,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: " << counter << std::endl;
 
diff --git a/libs/resiliency/tests/performance/replay/pure_dataflow.cpp b/libs/resiliency/tests/performance/replay/pure_dataflow.cpp
index 185a2a1b01..a1669c0ce0 100644
--- a/libs/resiliency/tests/performance/replay/pure_dataflow.cpp
+++ b/libs/resiliency/tests/performance/replay/pure_dataflow.cpp
@@ -55,7 +55,7 @@ public:
         for (std::size_t k = 0; k != subdomain_width + 1; ++k)
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
     }
 
     partition_data(partition_data&& other)
@@ -250,7 +250,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: 0" << std::endl;
 
diff --git a/libs/resiliency/tests/performance/replicate/1d_stencil_replicate.cpp b/libs/resiliency/tests/performance/replicate/1d_stencil_replicate.cpp
index 8451ce7e22..8ebcbf9bf9 100644
--- a/libs/resiliency/tests/performance/replicate/1d_stencil_replicate.cpp
+++ b/libs/resiliency/tests/performance/replicate/1d_stencil_replicate.cpp
@@ -67,7 +67,7 @@ public:
         {
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
         }
     }
 
@@ -285,7 +285,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: " << counter << std::endl;
 
diff --git a/libs/resiliency/tests/performance/replicate/1d_stencil_replicate_checksum.cpp b/libs/resiliency/tests/performance/replicate/1d_stencil_replicate_checksum.cpp
index cac60c3bd9..f4bb1efb6a 100644
--- a/libs/resiliency/tests/performance/replicate/1d_stencil_replicate_checksum.cpp
+++ b/libs/resiliency/tests/performance/replicate/1d_stencil_replicate_checksum.cpp
@@ -71,7 +71,7 @@ public:
         {
             data_[k] = std::sin(2 * pi *
                 ((0.0 + subdomain_width * subdomain_index + k) /
-                    (subdomain_width * subdomains)));
+                    static_cast<double>(subdomain_width * subdomains)));
             checksum_ += data_[k];
         }
     }
@@ -335,7 +335,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     std::cout << "Time elapsed: "
-              << (hpx::util::high_resolution_clock::now() - t) / 1e9
+              << static_cast<double>(
+                     hpx::util::high_resolution_clock::now() - t) /
+            1e9
               << std::endl;
     std::cout << "Errors occurred: " << counter << std::endl;
 
diff --git a/libs/resource_partitioner/CMakeLists.txt b/libs/resource_partitioner/CMakeLists.txt
index 0e43e8a64f..3c74ef7400 100644
--- a/libs/resource_partitioner/CMakeLists.txt
+++ b/libs/resource_partitioner/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -41,17 +41,22 @@ add_hpx_module(resource_partitioner
     hpx_allocator_support
     hpx_assertion
     hpx_cache
+    hpx_command_line_handling
     hpx_concurrency
     hpx_coroutines
     hpx_errors
     hpx_execution
+    hpx_format
     hpx_functional
     hpx_hardware
     hpx_memory
     hpx_plugin
     hpx_program_options
+    hpx_runtime_configuration
     hpx_serialization
     hpx_synchronization
+    hpx_thread_pools
+    hpx_threading_base
     hpx_topology
   CMAKE_SUBDIRS examples tests
 )
diff --git a/libs/resource_partitioner/README.rst b/libs/resource_partitioner/README.rst
index d974111032..3b1154eb19 100644
--- a/libs/resource_partitioner/README.rst
+++ b/libs/resource_partitioner/README.rst
@@ -13,4 +13,4 @@ resource_partitioner
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/resource_partitioner/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/resource_partitioner/docs/index.html>`__.
diff --git a/libs/resource_partitioner/examples/CMakeLists.txt b/libs/resource_partitioner/examples/CMakeLists.txt
index da3a8f1535..74238ae262 100644
--- a/libs/resource_partitioner/examples/CMakeLists.txt
+++ b/libs/resource_partitioner/examples/CMakeLists.txt
@@ -22,21 +22,16 @@ set(example_programs
 
 if(HPX_WITH_MAX_CPU_COUNT AND HPX_WITH_SHARED_PRIORITY_SCHEDULER)
   set(example_programs ${example_programs}
+    async_customization
     oversubscribing_resource_partitioner
     simple_resource_partitioner
   )
 
-  if (HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION)
+  # Intel compilers have trouble compiling this example
+  if(NOT ${CMAKE_CXX_COMPILER_ID} STREQUAL "Intel")
     set(example_programs ${example_programs}
-      async_customization
+      guided_pool_test
     )
-
-    # Intel compilers have trouble compiling this example
-    if(NOT ${CMAKE_CXX_COMPILER_ID} STREQUAL "Intel")
-      set(example_programs ${example_programs}
-        guided_pool_test
-      )
-    endif()
   endif()
 endif()
 
@@ -65,6 +60,7 @@ foreach(example_program ${example_programs})
 
   # add example executable
   add_hpx_executable(${example_program}
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${example_program}_FLAGS}
                      FOLDER "Examples/ResourcePartitioner")
diff --git a/libs/resource_partitioner/examples/async_customization.cpp b/libs/resource_partitioner/examples/async_customization.cpp
index ca7dff0bd9..3dff3de428 100644
--- a/libs/resource_partitioner/examples/async_customization.cpp
+++ b/libs/resource_partitioner/examples/async_customization.cpp
@@ -16,7 +16,7 @@
 #include <hpx/async.hpp>
 
 // we should not need these
-#include <hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool_impl.hpp>
 
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/debugging/demangle_helper.hpp>
@@ -56,7 +56,7 @@ struct test_async_executor
 
     template <typename... Futures>
     struct is_tuple_of_futures<util::tuple<Futures...>>
-      : util::detail::all_of<
+      : util::all_of<
             traits::is_future<typename std::remove_reference<Futures>::type>...>
     {
     };
@@ -393,9 +393,9 @@ int test(const std::string& message, Executor& exec)
                     auto tup = f.get();
                     auto cmplx =
                         std::complex<double>(double(util::get<0>(tup).get()),
-                            util::get<1>(tup).get());
-                    auto cmplxe =
-                        std::complex<double>(double(testval4), testval5);
+                            double(util::get<1>(tup).get()));
+                    auto cmplxe = std::complex<double>(
+                        double(testval4), double(testval5));
                     std::cout << "expected " << cmplxe << " got " << cmplx
                               << std::endl;
                     HPX_TEST_EQ(cmplx, cmplxe);
diff --git a/libs/resource_partitioner/examples/guided_pool_test.cpp b/libs/resource_partitioner/examples/guided_pool_test.cpp
index 07a495917d..781b6eecc0 100644
--- a/libs/resource_partitioner/examples/guided_pool_test.cpp
+++ b/libs/resource_partitioner/examples/guided_pool_test.cpp
@@ -7,13 +7,13 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 //
+#include <hpx/execution/executors.hpp>
 #include <hpx/parallel/algorithms/for_loop.hpp>
-#include <hpx/parallel/executors.hpp>
 //
 #include <hpx/resource_partitioner/partitioner.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp>
 #include <hpx/runtime/threads/executors/guided_pool_executor.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool_impl.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 //
 #include <hpx/include/iostreams.hpp>
@@ -304,5 +304,5 @@ int main(int argc, char* argv[])
 
     std::cout << "[main] resources added to thread_pools \n";
 
-    return hpx::init();
+    return hpx::init(rp);
 }
diff --git a/libs/resource_partitioner/examples/oversubscribing_resource_partitioner.cpp b/libs/resource_partitioner/examples/oversubscribing_resource_partitioner.cpp
index 7ab9b1db0f..33b7becdd6 100644
--- a/libs/resource_partitioner/examples/oversubscribing_resource_partitioner.cpp
+++ b/libs/resource_partitioner/examples/oversubscribing_resource_partitioner.cpp
@@ -7,12 +7,12 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 //
+#include <hpx/execution/execution.hpp>
 #include <hpx/parallel/algorithms/for_loop.hpp>
-#include <hpx/parallel/execution.hpp>
 //
 #include <hpx/resource_partitioner/partitioner.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool_impl.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 //
 #include <hpx/include/iostreams.hpp>
diff --git a/libs/resource_partitioner/examples/simple_resource_partitioner.cpp b/libs/resource_partitioner/examples/simple_resource_partitioner.cpp
index f615ea5dd3..3e1dcc6245 100644
--- a/libs/resource_partitioner/examples/simple_resource_partitioner.cpp
+++ b/libs/resource_partitioner/examples/simple_resource_partitioner.cpp
@@ -8,12 +8,12 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 //
+#include <hpx/execution/execution.hpp>
 #include <hpx/parallel/algorithms/for_loop.hpp>
-#include <hpx/parallel/execution.hpp>
 //
 #include <hpx/resource_partitioner/partitioner.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool_impl.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 //
 #include <hpx/include/iostreams.hpp>
@@ -337,5 +337,5 @@ int main(int argc, char* argv[])
         std::cout << "[main] resources added to thread_pools \n";
     }
 
-    return hpx::init();
+    return hpx::init(rp);
 }
diff --git a/libs/resource_partitioner/examples/simplest_resource_partitioner_1.cpp b/libs/resource_partitioner/examples/simplest_resource_partitioner_1.cpp
index b2bdbcf8ba..23e87d0c16 100644
--- a/libs/resource_partitioner/examples/simplest_resource_partitioner_1.cpp
+++ b/libs/resource_partitioner/examples/simplest_resource_partitioner_1.cpp
@@ -19,6 +19,6 @@ int hpx_main(int argc, char* argv[])
 int main(int argc, char** argv)
 {
     hpx::resource::partitioner rp(argc, argv);
-    hpx::init();
+    hpx::init(rp);
 }
 //body]
diff --git a/libs/resource_partitioner/examples/simplest_resource_partitioner_2.cpp b/libs/resource_partitioner/examples/simplest_resource_partitioner_2.cpp
index 0d439cf9bc..1740ca7c3c 100644
--- a/libs/resource_partitioner/examples/simplest_resource_partitioner_2.cpp
+++ b/libs/resource_partitioner/examples/simplest_resource_partitioner_2.cpp
@@ -44,6 +44,6 @@ int main(int argc, char* argv[])
         }
     }
 
-    hpx::init();
+    hpx::init(rp);
 }
 //body]
diff --git a/libs/resource_partitioner/include/hpx/resource_partitioner/detail/create_partitioner.hpp b/libs/resource_partitioner/include/hpx/resource_partitioner/detail/create_partitioner.hpp
index 883c86b960..df83dfafde 100644
--- a/libs/resource_partitioner/include/hpx/resource_partitioner/detail/create_partitioner.hpp
+++ b/libs/resource_partitioner/include/hpx/resource_partitioner/detail/create_partitioner.hpp
@@ -10,9 +10,9 @@
 #include <hpx/config.hpp>
 #include <hpx/functional/bind_back.hpp>
 #include <hpx/functional/function.hpp>
+#include <hpx/prefix/find_prefix.hpp>
 #include <hpx/resource_partitioner/partitioner_fwd.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
-#include <hpx/util/find_prefix.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 
 #include <hpx/program_options.hpp>
 
diff --git a/libs/resource_partitioner/include/hpx/resource_partitioner/detail/partitioner.hpp b/libs/resource_partitioner/include/hpx/resource_partitioner/detail/partitioner.hpp
index 052a69cbe6..8cc4b9df52 100644
--- a/libs/resource_partitioner/include/hpx/resource_partitioner/detail/partitioner.hpp
+++ b/libs/resource_partitioner/include/hpx/resource_partitioner/detail/partitioner.hpp
@@ -10,15 +10,15 @@
 #include <hpx/config.hpp>
 #include <hpx/affinity/affinity_data.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/program_options.hpp>
 #include <hpx/resource_partitioner/partitioner.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/synchronization/spinlock.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util/command_line_handling.hpp>
 
 #include <atomic>
 #include <cstddef>
diff --git a/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner.hpp b/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner.hpp
index 7adaebca19..6126b0bbbe 100644
--- a/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner.hpp
+++ b/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner.hpp
@@ -8,11 +8,12 @@
 #define HPX_RESOURCE_PARTITIONER_AUG_10_2017_1005AM
 
 #include <hpx/config.hpp>
+#include <hpx/command_line_handling.hpp>
 #include <hpx/functional/function.hpp>
 #include <hpx/resource_partitioner/detail/create_partitioner.hpp>
 #include <hpx/resource_partitioner/partitioner_fwd.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
 
 #include <hpx/program_options.hpp>
 
@@ -25,7 +26,7 @@ namespace hpx { namespace resource {
     ///////////////////////////////////////////////////////////////////////////
     class pu
     {
-        HPX_CONSTEXPR static const std::size_t invalid_pu_id = std::size_t(-1);
+        static constexpr const std::size_t invalid_pu_id = std::size_t(-1);
 
     public:
         explicit pu(std::size_t id = invalid_pu_id, core* core = nullptr,
@@ -65,8 +66,7 @@ namespace hpx { namespace resource {
 
     class core
     {
-        HPX_CONSTEXPR static const std::size_t invalid_core_id =
-            std::size_t(-1);
+        static constexpr const std::size_t invalid_core_id = std::size_t(-1);
 
     public:
         explicit core(
@@ -99,7 +99,7 @@ namespace hpx { namespace resource {
 
     class numa_domain
     {
-        HPX_CONSTEXPR static const std::size_t invalid_numa_domain_id =
+        static constexpr const std::size_t invalid_numa_domain_id =
             std::size_t(-1);
 
     public:
@@ -272,6 +272,16 @@ namespace hpx { namespace resource {
         // return the topology object managed by the internal partitioner
         HPX_EXPORT hpx::threads::topology const& get_topology() const;
 
+        // access the command line options
+        HPX_EXPORT util::command_line_handling& get_command_line_switches();
+
+        // Does initialization of all resources and internal data of the
+        // resource partitioner called in hpx_init
+        HPX_EXPORT void configure_pools();
+
+        // Return the initialization result for this resource_partitioner
+        HPX_EXPORT int parse_result() const;
+
     private:
         detail::partitioner& partitioner_;
     };
diff --git a/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner_fwd.hpp b/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner_fwd.hpp
index 203aeb1987..991080a1a7 100644
--- a/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner_fwd.hpp
+++ b/libs/resource_partitioner/include/hpx/resource_partitioner/partitioner_fwd.hpp
@@ -9,9 +9,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/functional/function.hpp>
-#include <hpx/runtime/threads/detail/network_background_callback.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/network_background_callback.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 
 #include <cstddef>
 #include <memory>
diff --git a/libs/resource_partitioner/src/detail_partitioner.cpp b/libs/resource_partitioner/src/detail_partitioner.cpp
index 3f94c08fb9..ad89343f40 100644
--- a/libs/resource_partitioner/src/detail_partitioner.cpp
+++ b/libs/resource_partitioner/src/detail_partitioner.cpp
@@ -6,18 +6,19 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/format.hpp>
 #include <hpx/functional/function.hpp>
 #include <hpx/resource_partitioner/detail/partitioner.hpp>
 #include <hpx/resource_partitioner/partitioner.hpp>
 #include <hpx/runtime/config_entry.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/topology/topology.hpp>
 #include <hpx/type_support/static.hpp>
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -235,7 +236,7 @@ namespace hpx { namespace resource { namespace detail {
         if (!default_scheduler_mode_str.empty())
         {
             default_scheduler_mode_ = threads::policies::scheduler_mode(
-                hpx::util::safe_lexical_cast<std::size_t>(
+                hpx::util::from_string<std::size_t>(
                     default_scheduler_mode_str));
             HPX_ASSERT_MSG(
                 (default_scheduler_mode_ &
@@ -896,7 +897,7 @@ namespace hpx { namespace resource { namespace detail {
         get_affinity_description(cfg_, affinity_description);
 
         pus_needed_ = affinity_data_.init(cfg_.num_threads_,
-            hpx::util::safe_lexical_cast<std::size_t>(
+            hpx::util::from_string<std::size_t>(
                 get_config_entry("hpx.cores", 0), 0),
             get_pu_offset(cfg_), get_pu_step(cfg_),
             static_cast<std::size_t>(cfg_.rtcfg_.get_first_used_core()),
diff --git a/libs/resource_partitioner/src/partitioner.cpp b/libs/resource_partitioner/src/partitioner.cpp
index 5f7c668c15..52b9819d28 100644
--- a/libs/resource_partitioner/src/partitioner.cpp
+++ b/libs/resource_partitioner/src/partitioner.cpp
@@ -257,4 +257,22 @@ namespace hpx { namespace resource {
         return partitioner_.threads_needed();
     }
 
+    util::command_line_handling& partitioner::get_command_line_switches()
+    {
+        return partitioner_.get_command_line_switches();
+    }
+
+    // Does initialization of all resources and internal data of the
+    // resource partitioner called in hpx_init
+    void partitioner::configure_pools()
+    {
+        partitioner_.configure_pools();
+    }
+
+    // Return the initialization result for this resource_partitioner
+    int partitioner::parse_result() const
+    {
+        return partitioner_.parse_result();
+    }
+
 }}    // namespace hpx::resource
diff --git a/libs/resource_partitioner/tests/regressions/CMakeLists.txt b/libs/resource_partitioner/tests/regressions/CMakeLists.txt
index 85718aa846..c2ff676dd9 100644
--- a/libs/resource_partitioner/tests/regressions/CMakeLists.txt
+++ b/libs/resource_partitioner/tests/regressions/CMakeLists.txt
@@ -4,3 +4,26 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+set(tests
+    help_exit_4317_1
+    help_exit_4317_2
+)
+
+foreach(test ${tests})
+  set(sources
+      ${test}.cpp)
+
+  source_group("Source Files" FILES ${sources})
+
+  # add example executable
+  add_hpx_executable(${test}_test
+                     SOURCES ${sources}
+                     ${${test}_FLAGS}
+                     EXCLUDE_FROM_ALL
+                     HPX_PREFIX ${HPX_BUILD_PREFIX}
+                     FOLDER "Tests/Regressions/Modules/ResourcePartitioner/")
+
+  add_hpx_regression_test("modules.resource_partitioner" ${test} ${${test}_PARAMETERS})
+
+endforeach()
+
diff --git a/libs/resource_partitioner/tests/regressions/help_exit_4317_1.cpp b/libs/resource_partitioner/tests/regressions/help_exit_4317_1.cpp
new file mode 100644
index 0000000000..1680a70b24
--- /dev/null
+++ b/libs/resource_partitioner/tests/regressions/help_exit_4317_1.cpp
@@ -0,0 +1,34 @@
+//  Copyright (c) 2020 albestro
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/hpx.hpp>
+#include <hpx/hpx_init.hpp>
+#include <hpx/testing.hpp>
+
+#include <atomic>
+#include <string>
+#include <vector>
+
+std::atomic<bool> main_executed(false);
+
+int hpx_main()
+{
+    main_executed = true;
+    return hpx::finalize();
+}
+
+int main(int argc, char** argv)
+{
+    std::vector<std::string> cfg = {"--hpx:help"};
+
+    hpx::resource::partitioner rp(argc, argv, cfg);
+
+    HPX_TEST_EQ(hpx::init(rp), 0);
+
+    HPX_TEST(!main_executed);
+
+    return hpx::util::report_errors();
+}
diff --git a/libs/resource_partitioner/tests/regressions/help_exit_4317_2.cpp b/libs/resource_partitioner/tests/regressions/help_exit_4317_2.cpp
new file mode 100644
index 0000000000..a8fc32a114
--- /dev/null
+++ b/libs/resource_partitioner/tests/regressions/help_exit_4317_2.cpp
@@ -0,0 +1,32 @@
+//  Copyright (c) 2020 albestro
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/hpx.hpp>
+#include <hpx/hpx_init.hpp>
+#include <hpx/testing.hpp>
+
+#include <atomic>
+#include <string>
+#include <vector>
+
+std::atomic<bool> main_executed(false);
+
+int hpx_main()
+{
+    main_executed = true;
+    return hpx::finalize();
+}
+
+int main(int argc, char** argv)
+{
+    std::vector<std::string> cfg = {"--hpx:help"};
+
+    HPX_TEST_EQ(hpx::init(argc, argv, cfg), 0);
+
+    HPX_TEST(!main_executed);
+
+    return hpx::util::report_errors();
+}
diff --git a/libs/resource_partitioner/tests/unit/CMakeLists.txt b/libs/resource_partitioner/tests/unit/CMakeLists.txt
index d70bf2e60e..48961e9224 100644
--- a/libs/resource_partitioner/tests/unit/CMakeLists.txt
+++ b/libs/resource_partitioner/tests/unit/CMakeLists.txt
@@ -22,6 +22,7 @@ foreach(test ${tests})
 
   # add example executable
   add_hpx_executable(${test}_test
+                     INTERNAL_FLAGS
                      SOURCES ${sources}
                      ${${test}_FLAGS}
                      EXCLUDE_FROM_ALL
diff --git a/libs/resource_partitioner/tests/unit/named_pool_executor.cpp b/libs/resource_partitioner/tests/unit/named_pool_executor.cpp
index c6a80c745d..786c00e117 100644
--- a/libs/resource_partitioner/tests/unit/named_pool_executor.cpp
+++ b/libs/resource_partitioner/tests/unit/named_pool_executor.cpp
@@ -144,6 +144,6 @@ int main(int argc, char* argv[])
     }
 
     // now run the test
-    HPX_TEST_EQ(hpx::init(), 0);
+    HPX_TEST_EQ(hpx::init(rp), 0);
     return hpx::util::report_errors();
 }
diff --git a/libs/resource_partitioner/tests/unit/resource_partitioner_info.cpp b/libs/resource_partitioner/tests/unit/resource_partitioner_info.cpp
index fd43c08e99..50426d3d43 100644
--- a/libs/resource_partitioner/tests/unit/resource_partitioner_info.cpp
+++ b/libs/resource_partitioner/tests/unit/resource_partitioner_info.cpp
@@ -51,6 +51,6 @@ int main(int argc, char* argv[])
     hpx::resource::partitioner rp(argc, argv, std::move(cfg));
 
     // now run the test
-    HPX_TEST_EQ(hpx::init(), 0);
+    HPX_TEST_EQ(hpx::init(rp), 0);
     return hpx::util::report_errors();
 }
diff --git a/libs/resource_partitioner/tests/unit/used_pus.cpp b/libs/resource_partitioner/tests/unit/used_pus.cpp
index adafd7e74d..17007b6d7b 100644
--- a/libs/resource_partitioner/tests/unit/used_pus.cpp
+++ b/libs/resource_partitioner/tests/unit/used_pus.cpp
@@ -42,6 +42,6 @@ int main(int argc, char* argv[])
     hpx::resource::partitioner rp(argc, argv, std::move(cfg));
 
     // now run the test
-    HPX_TEST_EQ(hpx::init(), 0);
+    HPX_TEST_EQ(hpx::init(rp), 0);
     return hpx::util::report_errors();
 }
diff --git a/libs/runtime_configuration/CMakeLists.txt b/libs/runtime_configuration/CMakeLists.txt
new file mode 100644
index 0000000000..f42780075f
--- /dev/null
+++ b/libs/runtime_configuration/CMakeLists.txt
@@ -0,0 +1,60 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(runtime_configuration_headers
+  hpx/runtime_configuration/agas_service_mode.hpp
+  hpx/runtime_configuration/component_registry_base.hpp
+  hpx/runtime_configuration/ini.hpp
+  hpx/runtime_configuration/plugin_registry_base.hpp
+  hpx/runtime_configuration/runtime_configuration.hpp
+  hpx/runtime_configuration/runtime_mode.hpp
+  hpx/runtime_configuration/static_factory_data.hpp
+)
+
+set(runtime_configuration_compat_headers
+  hpx/util/ini.hpp
+  hpx/util/runtime_configuration.hpp
+  hpx/plugins/plugin_registry_base.hpp
+  hpx/runtime/components/component_registry_base.hpp
+  hpx/runtime/components/static_factory_data.hpp
+  hpx/runtime/runtime_mode.hpp
+)
+
+set(runtime_configuration_sources
+  ini.cpp
+  init_ini_data.cpp
+  runtime_configuration.cpp
+  runtime_mode.cpp
+)
+
+include(HPX_AddModule)
+add_hpx_module(runtime_configuration
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${runtime_configuration_sources}
+  HEADERS ${runtime_configuration_headers}
+  COMPAT_HEADERS ${runtime_configuration_compat_headers}
+  DEPENDENCIES
+    hpx_assertion
+    hpx_concurrency
+    hpx_config
+    hpx_coroutines
+    hpx_errors
+    hpx_functional
+    hpx_plugin
+    hpx_prefix
+    hpx_serialization
+    hpx_string_util
+    hpx_thread_support
+    hpx_version
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/runtime_configuration/README.rst b/libs/runtime_configuration/README.rst
new file mode 100644
index 0000000000..15509cd0c4
--- /dev/null
+++ b/libs/runtime_configuration/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+=====================
+runtime_configuration
+=====================
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/runtime_configuration/docs/index.html>`__.
diff --git a/libs/runtime_configuration/docs/index.rst b/libs/runtime_configuration/docs/index.rst
new file mode 100644
index 0000000000..7ccc67b391
--- /dev/null
+++ b/libs/runtime_configuration/docs/index.rst
@@ -0,0 +1,13 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_runtime_configuration:
+
+=====================
+runtime_configuration
+=====================
+
diff --git a/libs/runtime_configuration/examples/CMakeLists.txt b/libs/runtime_configuration/examples/CMakeLists.txt
new file mode 100644
index 0000000000..4f8e1bd25a
--- /dev/null
+++ b/libs/runtime_configuration/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.runtime_configuration)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.runtime_configuration)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_RUNTIME_CONFIGURATION_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.runtime_configuration)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.runtime_configuration)
+  endif()
+endif()
diff --git a/libs/runtime_configuration/include/hpx/runtime_configuration/agas_service_mode.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/agas_service_mode.hpp
new file mode 100644
index 0000000000..764de7bb4d
--- /dev/null
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/agas_service_mode.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2007-2014 Hartmut Kaiser
+//  Copyright (c) 2011      Bryce Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_RUNTIME_CONFIGURATION_AGAS_SERVICE_MODE_HPP
+#define HPX_RUNTIME_CONFIGURATION_AGAS_SERVICE_MODE_HPP
+
+namespace hpx { namespace agas {
+    enum service_mode
+    {
+        service_mode_invalid = -1,
+        service_mode_bootstrap = 0,
+        service_mode_hosted = 1
+    };
+}}    // namespace hpx::agas
+
+#endif /*HPX_RUNTIME_CONFIGURATION_AGAS_SERVICE_MODE_HPP*/
diff --git a/hpx/runtime/components/component_registry_base.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/component_registry_base.hpp
similarity index 88%
rename from hpx/runtime/components/component_registry_base.hpp
rename to libs/runtime_configuration/include/hpx/runtime_configuration/component_registry_base.hpp
index 0650aeec1f..ce26d7db8b 100644
--- a/hpx/runtime/components/component_registry_base.hpp
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/component_registry_base.hpp
@@ -9,14 +9,13 @@
 
 #include <hpx/config.hpp>
 #include <hpx/plugin.hpp>
-#include <hpx/runtime/components/static_factory_data.hpp>
+#include <hpx/runtime_configuration/static_factory_data.hpp>
 
 #include <string>
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace components
-{
+namespace hpx { namespace components {
     ///////////////////////////////////////////////////////////////////////////
     /// The \a component_registry_base has to be used as a base class for all
     /// component registries.
@@ -50,32 +49,32 @@ namespace hpx { namespace components
         ///         on any error.
         virtual void register_component_type() = 0;
     };
-}}
+}}    // namespace hpx::components
 
 ///////////////////////////////////////////////////////////////////////////////
 /// This macro is used to register the given component factory with
 /// Hpx.Plugin. This macro has to be used for each of the components.
-#define HPX_REGISTER_COMPONENT_REGISTRY(RegistryType, componentname)          \
-    HPX_PLUGIN_EXPORT(HPX_PLUGIN_COMPONENT_PREFIX,                            \
-        hpx::components::component_registry_base, RegistryType,               \
-        componentname, registry)                                              \
+#define HPX_REGISTER_COMPONENT_REGISTRY(RegistryType, componentname)           \
+    HPX_PLUGIN_EXPORT(HPX_PLUGIN_COMPONENT_PREFIX,                             \
+        hpx::components::component_registry_base, RegistryType, componentname, \
+        registry)                                                              \
 /**/
-#define HPX_REGISTER_COMPONENT_REGISTRY_DYNAMIC(RegistryType, componentname)  \
-    HPX_PLUGIN_EXPORT_DYNAMIC(HPX_PLUGIN_COMPONENT_PREFIX,                    \
-        hpx::components::component_registry_base, RegistryType,               \
-        componentname, registry)                                              \
+#define HPX_REGISTER_COMPONENT_REGISTRY_DYNAMIC(RegistryType, componentname)   \
+    HPX_PLUGIN_EXPORT_DYNAMIC(HPX_PLUGIN_COMPONENT_PREFIX,                     \
+        hpx::components::component_registry_base, RegistryType, componentname, \
+        registry)                                                              \
 /**/
 
 ///////////////////////////////////////////////////////////////////////////////
 #if !defined(HPX_APPLICATION_NAME)
 /// This macro is used to define the required Hpx.Plugin entry points. This
 /// macro has to be used in exactly one compilation unit of a component module.
-#define HPX_REGISTER_REGISTRY_MODULE()                                        \
-    HPX_PLUGIN_EXPORT_LIST(HPX_PLUGIN_COMPONENT_PREFIX, registry);            \
-    HPX_INIT_REGISTRY_MODULE_STATIC(HPX_PLUGIN_COMPONENT_PREFIX, registry)    \
+#define HPX_REGISTER_REGISTRY_MODULE()                                         \
+    HPX_PLUGIN_EXPORT_LIST(HPX_PLUGIN_COMPONENT_PREFIX, registry);             \
+    HPX_INIT_REGISTRY_MODULE_STATIC(HPX_PLUGIN_COMPONENT_PREFIX, registry)     \
 /**/
-#define HPX_REGISTER_REGISTRY_MODULE_DYNAMIC()                                \
-    HPX_PLUGIN_EXPORT_LIST_DYNAMIC(HPX_PLUGIN_COMPONENT_PREFIX, registry)     \
+#define HPX_REGISTER_REGISTRY_MODULE_DYNAMIC()                                 \
+    HPX_PLUGIN_EXPORT_LIST_DYNAMIC(HPX_PLUGIN_COMPONENT_PREFIX, registry)      \
 /**/
 #else
 // in executables (when HPX_APPLICATION_NAME is defined) this needs to expand
@@ -85,4 +84,3 @@ namespace hpx { namespace components
 #endif
 
 #endif
-
diff --git a/hpx/util/ini.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/ini.hpp
similarity index 69%
rename from hpx/util/ini.hpp
rename to libs/runtime_configuration/include/hpx/runtime_configuration/ini.hpp
index d5d126785a..0e50da28d0 100644
--- a/hpx/util/ini.hpp
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/ini.hpp
@@ -10,25 +10,22 @@
 #define HPX_UTIL_SECTION_SEP_17_2008_022PM
 
 #include <hpx/config.hpp>
-#include <hpx/util_fwd.hpp> // this needs to go first
-
-#include <hpx/synchronization/spinlock.hpp>
+#include <hpx/concurrency/spinlock.hpp>
+#include <hpx/functional.hpp>
 #include <hpx/serialization/serialization_fwd.hpp>
-#include <hpx/functional/function.hpp>
-
-#include <boost/lexical_cast.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include <iostream>
 #include <map>
 #include <mutex>
 #include <string>
-#include <vector>
 #include <utility>
+#include <vector>
 
 // suppress warnings about dependent classes not being exported from the dll
 #if defined(HPX_MSVC_WARNING_PRAGMA)
 #pragma warning(push)
-#pragma warning(disable: 4091 4251 4231 4275 4660)
+#pragma warning(disable : 4091 4251 4231 4275 4660)
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -36,23 +33,25 @@
 #define HPX_SECTION_VERSION 0x10
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
     class HPX_EXPORT section
     {
     public:
-        typedef util::function_nonser<
-                void(std::string const&, std::string const&)
-            > entry_changed_func;
+        typedef util::function_nonser<void(
+            std::string const&, std::string const&)>
+            entry_changed_func;
         typedef std::pair<std::string, entry_changed_func> entry_type;
         typedef std::map<std::string, entry_type> entry_map;
         typedef std::map<std::string, section> section_map;
 
     private:
-        section *this_() { return this; }
+        section* this_()
+        {
+            return this;
+        }
 
-        typedef lcos::local::spinlock mutex_type;
+        using mutex_type = util::spinlock;
 
         section* root_;
         entry_map entries_;
@@ -74,35 +73,37 @@ namespace hpx { namespace util
         HPX_SERIALIZATION_SPLIT_MEMBER()
 
     protected:
-        void line_msg(std::string msg, std::string const& file,
-            int lnum = 0, std::string const& line = "");
+        void line_msg(std::string msg, std::string const& file, int lnum = 0,
+            std::string const& line = "");
 
         section& clone_from(section const& rhs, section* root = nullptr);
 
     private:
         void add_section(std::unique_lock<mutex_type>& l,
             std::string const& sec_name, section& sec, section* root = nullptr);
-        bool has_section(std::unique_lock<mutex_type>& l,
-            std::string const& sec_name) const;
+        bool has_section(
+            std::unique_lock<mutex_type>& l, std::string const& sec_name) const;
 
-        section* get_section (std::unique_lock<mutex_type>& l,
-            std::string const& sec_name);
-        section const* get_section (std::unique_lock<mutex_type>& l,
-            std::string const& sec_name) const;
+        section* get_section(
+            std::unique_lock<mutex_type>& l, std::string const& sec_name);
+        section const* get_section(
+            std::unique_lock<mutex_type>& l, std::string const& sec_name) const;
 
         ///////////////////////////////////////////////////////////////////////////
-        section* add_section_if_new(std::unique_lock<mutex_type>& l,
-            std::string const& sec_name);
-
-        void add_entry(std::unique_lock<mutex_type>& l, std::string const& fullkey,
-            std::string const& key, std::string val);
-        void add_entry(std::unique_lock<mutex_type>& l, std::string const& fullkey,
-            std::string const& key, entry_type const& val);
-
-        bool has_entry(std::unique_lock<mutex_type>& l,
-            std::string const& key) const;
-        std::string get_entry(std::unique_lock<mutex_type>& l,
-            std::string const& key) const;
+        section* add_section_if_new(
+            std::unique_lock<mutex_type>& l, std::string const& sec_name);
+
+        void add_entry(std::unique_lock<mutex_type>& l,
+            std::string const& fullkey, std::string const& key,
+            std::string val);
+        void add_entry(std::unique_lock<mutex_type>& l,
+            std::string const& fullkey, std::string const& key,
+            entry_type const& val);
+
+        bool has_entry(
+            std::unique_lock<mutex_type>& l, std::string const& key) const;
+        std::string get_entry(
+            std::unique_lock<mutex_type>& l, std::string const& key) const;
         std::string get_entry(std::unique_lock<mutex_type>& l,
             std::string const& key, std::string const& dflt) const;
 
@@ -121,9 +122,9 @@ namespace hpx { namespace util
             std::vector<std::string> const& lines, bool verify_existing = true,
             bool weed_out_comments = true, bool replace_existing = true);
 
-        void parse(std::string const& sourcename,
-            std::string const& line, bool verify_existing = true,
-            bool weed_out_comments = true, bool replace_existing = true)
+        void parse(std::string const& sourcename, std::string const& line,
+            bool verify_existing = true, bool weed_out_comments = true,
+            bool replace_existing = true)
         {
             std::vector<std::string> lines;
             lines.push_back(line);
@@ -136,8 +137,8 @@ namespace hpx { namespace util
         void merge(section& second);
         void dump(int ind = 0, std::ostream& strm = std::cout) const;
 
-        void add_section(std::string const& sec_name, section& sec,
-            section* root = nullptr)
+        void add_section(
+            std::string const& sec_name, section& sec, section* root = nullptr)
         {
             std::unique_lock<mutex_type> l(mtx_);
             add_section(l, sec_name, sec, root);
@@ -155,20 +156,26 @@ namespace hpx { namespace util
             return has_section(l, sec_name);
         }
 
-        section* get_section (std::string const& sec_name)
+        section* get_section(std::string const& sec_name)
         {
             std::unique_lock<mutex_type> l(mtx_);
             return get_section(l, sec_name);
         }
 
-        section const* get_section (std::string const& sec_name) const
+        section const* get_section(std::string const& sec_name) const
         {
             std::unique_lock<mutex_type> l(mtx_);
             return get_section(l, sec_name);
         }
 
-        section_map& get_sections() { return sections_; }
-        section_map const& get_sections() const { return sections_; }
+        section_map& get_sections()
+        {
+            return sections_;
+        }
+        section_map const& get_sections() const
+        {
+            return sections_;
+        }
 
         void add_entry(std::string const& key, entry_type const& val)
         {
@@ -194,7 +201,8 @@ namespace hpx { namespace util
             return get_entry(l, key);
         }
 
-        std::string get_entry(std::string const& key, std::string const& dflt) const
+        std::string get_entry(
+            std::string const& key, std::string const& dflt) const
         {
             std::unique_lock<mutex_type> l(mtx_);
             return get_entry(l, key, dflt);
@@ -204,20 +212,24 @@ namespace hpx { namespace util
         std::string get_entry(std::string const& key, T dflt) const
         {
             std::unique_lock<mutex_type> l(mtx_);
-            return get_entry(l, key, boost::lexical_cast<std::string>(dflt));
+            return get_entry(l, key, hpx::util::to_string(dflt));
         }
 
-        void add_notification_callback(std::string const& key,
-            entry_changed_func const& callback)
+        void add_notification_callback(
+            std::string const& key, entry_changed_func const& callback)
         {
             std::unique_lock<mutex_type> l(mtx_);
             add_notification_callback(l, key, callback);
         }
 
-        entry_map const& get_entries() const { return entries_; }
+        entry_map const& get_entries() const
+        {
+            return entries_;
+        }
 
     private:
-        std::string expand(std::unique_lock<mutex_type>& l, std::string in) const;
+        std::string expand(
+            std::unique_lock<mutex_type>& l, std::string in) const;
 
         void expand(std::unique_lock<mutex_type>& l, std::string&,
             std::string::size_type) const;
@@ -252,15 +264,26 @@ namespace hpx { namespace util
         void set_root(section* r, bool recursive = false)
         {
             root_ = r;
-            if (recursive) {
+            if (recursive)
+            {
                 section_map::iterator send = sections_.end();
-                for (section_map::iterator si = sections_.begin(); si != send; ++si)
+                for (section_map::iterator si = sections_.begin(); si != send;
+                     ++si)
                     si->second.set_root(r, true);
             }
         }
-        section* get_root() const { return root_; }
-        std::string get_name() const { return name_; }
-        std::string get_parent_name() const { return parent_name_; }
+        section* get_root() const
+        {
+            return root_;
+        }
+        std::string get_name() const
+        {
+            return name_;
+        }
+        std::string get_parent_name() const
+        {
+            return parent_name_;
+        }
         std::string get_full_name() const
         {
             if (!parent_name_.empty())
@@ -268,10 +291,12 @@ namespace hpx { namespace util
             return name_;
         }
 
-        void set_name(std::string const& name) { name_ = name; }
+        void set_name(std::string const& name)
+        {
+            name_ = name;
+        }
     };
 
-}} // namespace hpx::util
+}}    // namespace hpx::util
 
 #endif
-
diff --git a/hpx/util/init_ini_data.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/init_ini_data.hpp
similarity index 78%
rename from hpx/util/init_ini_data.hpp
rename to libs/runtime_configuration/include/hpx/runtime_configuration/init_ini_data.hpp
index 50ddf96671..592b92689c 100644
--- a/hpx/util/init_ini_data.hpp
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/init_ini_data.hpp
@@ -5,14 +5,14 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#if!defined(HPX_INIT_INI_DATA_SEP_26_2008_0344PM)
+#if !defined(HPX_INIT_INI_DATA_SEP_26_2008_0344PM)
 #define HPX_INIT_INI_DATA_SEP_26_2008_0344PM
 
 #include <hpx/filesystem.hpp>
 #include <hpx/plugin.hpp>
-#include <hpx/plugins/plugin_registry_base.hpp>
-#include <hpx/runtime/components/component_registry_base.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/component_registry_base.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
 
 #include <map>
 #include <memory>
@@ -20,12 +20,11 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
-    bool handle_ini_file (section& ini, std::string const& loc);
-    bool handle_ini_file_env (section& ini, char const* env_var,
-        char const* file_suffix = nullptr);
+    bool handle_ini_file(section& ini, std::string const& loc);
+    bool handle_ini_file_env(
+        section& ini, char const* env_var, char const* file_suffix = nullptr);
 
     ///////////////////////////////////////////////////////////////////////////
     // read system and user specified ini files
@@ -48,12 +47,11 @@ namespace hpx { namespace util
     ///////////////////////////////////////////////////////////////////////////
     // iterate over all shared libraries in the given directory and construct
     // default ini settings assuming all of those are components
-    std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+    std::vector<std::shared_ptr<plugins::plugin_registry_base>>
     init_ini_data_default(std::string const& libs, section& ini,
         std::map<std::string, filesystem::path>& basenames,
         std::map<std::string, hpx::util::plugin::dll>& modules);
 
-}}
+}}    // namespace hpx::util
 
 #endif
-
diff --git a/hpx/plugins/plugin_registry_base.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/plugin_registry_base.hpp
similarity index 88%
rename from hpx/plugins/plugin_registry_base.hpp
rename to libs/runtime_configuration/include/hpx/runtime_configuration/plugin_registry_base.hpp
index 240433ef9b..9e52e7547e 100644
--- a/hpx/plugins/plugin_registry_base.hpp
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/plugin_registry_base.hpp
@@ -15,8 +15,7 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace plugins
-{
+namespace hpx { namespace plugins {
     ///////////////////////////////////////////////////////////////////////////
     /// The \a plugin_registry_base has to be used as a base class for all
     /// plugin registries.
@@ -37,29 +36,29 @@ namespace hpx { namespace plugins
         ///         implemented in this module.
         virtual bool get_plugin_info(std::vector<std::string>& fillini) = 0;
 
-        virtual void init(int * /*argc*/, char *** /*argv*/, util::command_line_handling&)
+        virtual void init(
+            int* /*argc*/, char*** /*argv*/, util::command_line_handling&)
         {
         }
     };
-}}
+}}    // namespace hpx::plugins
 
 ///////////////////////////////////////////////////////////////////////////////
 /// This macro is used to register the given component factory with
 /// Hpx.Plugin. This macro has to be used for each of the components.
-#define HPX_REGISTER_PLUGIN_BASE_REGISTRY(PluginType, name)                   \
-    HPX_PLUGIN_EXPORT(HPX_PLUGIN_PLUGIN_PREFIX,                               \
-        hpx::plugins::plugin_registry_base, PluginType, name, plugin)         \
+#define HPX_REGISTER_PLUGIN_BASE_REGISTRY(PluginType, name)                    \
+    HPX_PLUGIN_EXPORT(HPX_PLUGIN_PLUGIN_PREFIX,                                \
+        hpx::plugins::plugin_registry_base, PluginType, name, plugin)          \
 /**/
 
 /// This macro is used to define the required Hpx.Plugin entry points. This
 /// macro has to be used in exactly one compilation unit of a component module.
-#define HPX_REGISTER_PLUGIN_REGISTRY_MODULE()                                 \
-    HPX_PLUGIN_EXPORT_LIST(HPX_PLUGIN_PLUGIN_PREFIX, plugin)                  \
-/**/
+#define HPX_REGISTER_PLUGIN_REGISTRY_MODULE()                                  \
+    HPX_PLUGIN_EXPORT_LIST(HPX_PLUGIN_PLUGIN_PREFIX, plugin)                   \
+    /**/
 
-#define HPX_REGISTER_PLUGIN_REGISTRY_MODULE_DYNAMIC()                         \
-    HPX_PLUGIN_EXPORT_LIST_DYNAMIC(HPX_PLUGIN_PLUGIN_PREFIX, plugin)          \
-/**/
+#define HPX_REGISTER_PLUGIN_REGISTRY_MODULE_DYNAMIC()                          \
+    HPX_PLUGIN_EXPORT_LIST_DYNAMIC(HPX_PLUGIN_PLUGIN_PREFIX, plugin)           \
+    /**/
 
 #endif
-
diff --git a/hpx/util/runtime_configuration.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/runtime_configuration.hpp
similarity index 85%
rename from hpx/util/runtime_configuration.hpp
rename to libs/runtime_configuration/include/hpx/runtime_configuration/runtime_configuration.hpp
index 595ada84bb..ea30a95d5c 100644
--- a/hpx/util/runtime_configuration.hpp
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/runtime_configuration.hpp
@@ -9,14 +9,14 @@
 #define HPX_UTIL_RUNTIME_CONFIGURATION_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/filesystem.hpp>
 #include <hpx/plugin.hpp>
-#include <hpx/plugins/plugin_registry_base.hpp>
-#include <hpx/runtime/agas_fwd.hpp>
-#include <hpx/runtime/components/static_factory_data.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
-#include <hpx/coroutines/thread_enums.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/agas_service_mode.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
+#include <hpx/runtime_configuration/static_factory_data.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -27,8 +27,7 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
     // The runtime_configuration class is a wrapper for the runtime
     // configuration data allowing to extract configuration information in a
@@ -50,11 +49,12 @@ namespace hpx { namespace util
         // any explicit command line options
         void reconfigure(std::vector<std::string> const& ini_defs);
 
-        std::vector<std::shared_ptr<plugins::plugin_registry_base> >
-            load_modules();
+        std::vector<std::shared_ptr<plugins::plugin_registry_base>>
+        load_modules();
 
-        void load_components_static(std::vector<
-            components::static_factory_load_data_type> const& static_modules);
+        void load_components_static(
+            std::vector<components::static_factory_load_data_type> const&
+                static_modules);
 
         // Returns the AGAS mode of this locality, returns either hosted (for
         // localities connecting to a remote AGAS server) or bootstrap for the
@@ -87,8 +87,8 @@ namespace hpx { namespace util
 
         // Load application specific configuration and merge it with the
         // default configuration loaded from hpx.ini
-        bool load_application_configuration(char const* filename,
-            error_code& ec = throws);
+        bool load_application_configuration(
+            char const* filename, error_code& ec = throws);
 
         // Can be set to true if we want to use the ITT notify tools API.
         bool get_itt_notify_mode() const;
@@ -104,6 +104,11 @@ namespace hpx { namespace util
         bool enable_spinlock_deadlock_detection() const;
         std::size_t get_spinlock_deadlock_detection_limit() const;
 
+#if defined(__linux) || defined(linux) || defined(__linux__) ||                \
+    defined(__FreeBSD__)
+        bool use_stack_guard_pages() const;
+#endif
+
         // Returns the number of OS threads this locality is running.
         std::size_t get_os_thread_count() const;
 
@@ -117,19 +122,20 @@ namespace hpx { namespace util
         }
 
         // Will return the requested stack size to use for an HPX-threads.
-        std::ptrdiff_t get_stack_size(threads::thread_stacksize stacksize) const;
+        std::ptrdiff_t get_stack_size(
+            threads::thread_stacksize stacksize) const;
 
         // Return the configured sizes of any of the know thread pools
         std::size_t get_thread_pool_size(char const* poolname) const;
 
-        // Return the endianess to be used for out-serialization
+        // Return the endianness to be used for out-serialization
         std::string get_endian_out() const;
 
         // Return maximally allowed message sizes
         std::uint64_t get_max_inbound_message_size() const;
         std::uint64_t get_max_outbound_message_size() const;
 
-        std::map<std::string, hpx::util::plugin::dll> & modules()
+        std::map<std::string, hpx::util::plugin::dll>& modules()
         {
             return modules_;
         }
@@ -143,13 +149,10 @@ namespace hpx { namespace util
         std::ptrdiff_t init_large_stack_size() const;
         std::ptrdiff_t init_huge_stack_size() const;
 
-#if defined(__linux) || defined(linux) || defined(__linux__) || defined(__FreeBSD__)
-        bool init_use_stack_guard_pages() const;
-#endif
-
         void pre_initialize_ini();
         void post_initialize_ini(std::string& hpx_ini_file,
             std::vector<std::string> const& cmdline_ini_defs);
+        void pre_initialize_logging_ini();
 
         void reconfigure();
 
@@ -164,8 +167,7 @@ namespace hpx { namespace util
         void load_component_path(
             std::vector<std::shared_ptr<plugins::plugin_registry_base>>&
                 plugin_registries,
-            std::string const& path,
-            std::set<std::string>& component_paths,
+            std::string const& path, std::set<std::string>& component_paths,
             std::map<std::string, filesystem::path>& basenames);
 
     public:
@@ -184,6 +186,6 @@ namespace hpx { namespace util
 
         std::map<std::string, hpx::util::plugin::dll> modules_;
     };
-}}
+}}    // namespace hpx::util
 
 #endif /*HPX_UTIL_RUNTIME_CONFIGURATION_HPP*/
diff --git a/hpx/runtime/runtime_mode.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/runtime_mode.hpp
similarity index 68%
rename from hpx/runtime/runtime_mode.hpp
rename to libs/runtime_configuration/include/hpx/runtime_configuration/runtime_mode.hpp
index 2ca67c9a4b..ed543c56ec 100644
--- a/hpx/runtime/runtime_mode.hpp
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/runtime_mode.hpp
@@ -14,19 +14,18 @@
 
 #include <string>
 
-namespace hpx
-{
+namespace hpx {
     /// A HPX runtime can be executed in two different modes: console mode
     /// and worker mode.
     enum runtime_mode
     {
         runtime_mode_invalid = -1,
-        runtime_mode_console = 0,   ///< The runtime is the console locality
-        runtime_mode_worker = 1,    ///< The runtime is a worker locality
-        runtime_mode_connect = 2,   ///< The runtime is a worker locality
-                                    ///< connecting late
-        runtime_mode_default = 3,   ///< The runtime mode will be determined
-                                    ///< based on the command line arguments
+        runtime_mode_console = 0,    ///< The runtime is the console locality
+        runtime_mode_worker = 1,     ///< The runtime is a worker locality
+        runtime_mode_connect = 2,    ///< The runtime is a worker locality
+                                     ///< connecting late
+        runtime_mode_default = 3,    ///< The runtime mode will be determined
+                                     ///< based on the command line arguments
         runtime_mode_last
     };
 
@@ -42,7 +41,8 @@ namespace hpx
     /// representing the name.
     ///
     /// \param mode this represents the runtime mode
-    HPX_API_EXPORT runtime_mode get_runtime_mode_from_name(std::string const& mode);
-}
+    HPX_API_EXPORT runtime_mode get_runtime_mode_from_name(
+        std::string const& mode);
+}    // namespace hpx
 
 #endif /*HPX_RUNTIME_RUNTIME_MODE_HPP*/
diff --git a/hpx/runtime/components/static_factory_data.hpp b/libs/runtime_configuration/include/hpx/runtime_configuration/static_factory_data.hpp
similarity index 79%
rename from hpx/runtime/components/static_factory_data.hpp
rename to libs/runtime_configuration/include/hpx/runtime_configuration/static_factory_data.hpp
index 2aa5d3f34a..8986423bca 100644
--- a/hpx/runtime/components/static_factory_data.hpp
+++ b/libs/runtime_configuration/include/hpx/runtime_configuration/static_factory_data.hpp
@@ -11,27 +11,28 @@
 
 #include <hpx/config.hpp>
 #include <hpx/datastructures/any.hpp>
+#include <hpx/plugin.hpp>
 #include <hpx/preprocessor/cat.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-#include <hpx/plugin.hpp>
 
 #include <map>
 #include <string>
 
-namespace hpx { namespace components
-{
+namespace hpx { namespace components {
     ///////////////////////////////////////////////////////////////////////////
     struct static_factory_load_data_type
     {
-        char const* name;     // component name
+        char const* name;    // component name
         hpx::util::plugin::get_plugins_list_type get_factory;
     };
 
     HPX_EXPORT void init_registry_module(static_factory_load_data_type const&);
     HPX_EXPORT void init_registry_factory(static_factory_load_data_type const&);
-    HPX_EXPORT void init_registry_commandline(static_factory_load_data_type const&);
-    HPX_EXPORT void init_registry_startup_shutdown(static_factory_load_data_type const&);
-}}
+    HPX_EXPORT void init_registry_commandline(
+        static_factory_load_data_type const&);
+    HPX_EXPORT void init_registry_startup_shutdown(
+        static_factory_load_data_type const&);
+}}    // namespace hpx::components
 
 ///////////////////////////////////////////////////////////////////////////////
 #define HPX_DECLARE_FACTORY_STATIC(name, base)                                 \
@@ -39,76 +40,74 @@ namespace hpx { namespace components
         hpx::util::any_nonser>* HPX_PLUGIN_API HPX_PLUGIN_LIST_NAME(name,      \
         base)() /**/
 
-#define HPX_DEFINE_FACTORY_STATIC(module, name, base)                         \
-    {                                                                         \
-        HPX_PP_STRINGIZE(module),                                             \
-        HPX_PLUGIN_LIST_NAME(name, base)                                      \
-    }                                                                         \
+#define HPX_DEFINE_FACTORY_STATIC(module, name, base)                          \
+    {                                                                          \
+        HPX_PP_STRINGIZE(module), HPX_PLUGIN_LIST_NAME(name, base)             \
+    }                                                                          \
 /**/
 
 ///////////////////////////////////////////////////////////////////////////////
-#define HPX_INIT_REGISTRY_MODULE_STATIC(name, base)                           \
-    HPX_DECLARE_FACTORY_STATIC(name, base);                                   \
-    namespace {                                                               \
-        struct HPX_PP_CAT(init_registry_module_static_, name)                 \
-        {                                                                     \
-            HPX_PP_CAT(init_registry_module_static_, name)()                  \
-            {                                                                 \
-                hpx::components::static_factory_load_data_type data =         \
-                    HPX_DEFINE_FACTORY_STATIC(HPX_COMPONENT_NAME, name, base);\
-                hpx::components::init_registry_module(data);                  \
-            }                                                                 \
-        } HPX_PP_CAT(module_data_, __LINE__);                                 \
-    }                                                                         \
+#define HPX_INIT_REGISTRY_MODULE_STATIC(name, base)                            \
+    HPX_DECLARE_FACTORY_STATIC(name, base);                                    \
+    namespace {                                                                \
+        struct HPX_PP_CAT(init_registry_module_static_, name)                  \
+        {                                                                      \
+            HPX_PP_CAT(init_registry_module_static_, name)()                   \
+            {                                                                  \
+                hpx::components::static_factory_load_data_type data =          \
+                    HPX_DEFINE_FACTORY_STATIC(HPX_COMPONENT_NAME, name, base); \
+                hpx::components::init_registry_module(data);                   \
+            }                                                                  \
+        } HPX_PP_CAT(module_data_, __LINE__);                                  \
+    }                                                                          \
     /**/
 
 ///////////////////////////////////////////////////////////////////////////////
-#define HPX_INIT_REGISTRY_FACTORY_STATIC(name, componentname, base)           \
-    HPX_DECLARE_FACTORY_STATIC(name, base);                                   \
-    namespace {                                                               \
-        struct HPX_PP_CAT(init_registry_factory_static_, componentname)       \
-        {                                                                     \
-            HPX_PP_CAT(init_registry_factory_static_, componentname)()        \
-            {                                                                 \
-                hpx::components::static_factory_load_data_type data =         \
-                    HPX_DEFINE_FACTORY_STATIC(componentname, name, base);     \
-                hpx::components::init_registry_factory(data);                 \
-            }                                                                 \
-        } HPX_PP_CAT(componentname, HPX_PP_CAT(_factory_data_, __LINE__));    \
-    }                                                                         \
+#define HPX_INIT_REGISTRY_FACTORY_STATIC(name, componentname, base)            \
+    HPX_DECLARE_FACTORY_STATIC(name, base);                                    \
+    namespace {                                                                \
+        struct HPX_PP_CAT(init_registry_factory_static_, componentname)        \
+        {                                                                      \
+            HPX_PP_CAT(init_registry_factory_static_, componentname)()         \
+            {                                                                  \
+                hpx::components::static_factory_load_data_type data =          \
+                    HPX_DEFINE_FACTORY_STATIC(componentname, name, base);      \
+                hpx::components::init_registry_factory(data);                  \
+            }                                                                  \
+        } HPX_PP_CAT(componentname, HPX_PP_CAT(_factory_data_, __LINE__));     \
+    }                                                                          \
     /**/
 
 ///////////////////////////////////////////////////////////////////////////////
-#define HPX_INIT_REGISTRY_COMMANDLINE_STATIC(name, base)                      \
-    HPX_DECLARE_FACTORY_STATIC(name, base);                                   \
-    namespace {                                                               \
-        struct HPX_PP_CAT(init_registry_module_commandline_, name)            \
-        {                                                                     \
-            HPX_PP_CAT(init_registry_module_commandline_, name)()             \
-            {                                                                 \
-                hpx::components::static_factory_load_data_type data =         \
-                    HPX_DEFINE_FACTORY_STATIC(HPX_COMPONENT_NAME, name, base);\
-                hpx::components::init_registry_commandline(data);             \
-            }                                                                 \
-        } HPX_PP_CAT(module_commandline_data_, __LINE__);                     \
-    }                                                                         \
+#define HPX_INIT_REGISTRY_COMMANDLINE_STATIC(name, base)                       \
+    HPX_DECLARE_FACTORY_STATIC(name, base);                                    \
+    namespace {                                                                \
+        struct HPX_PP_CAT(init_registry_module_commandline_, name)             \
+        {                                                                      \
+            HPX_PP_CAT(init_registry_module_commandline_, name)()              \
+            {                                                                  \
+                hpx::components::static_factory_load_data_type data =          \
+                    HPX_DEFINE_FACTORY_STATIC(HPX_COMPONENT_NAME, name, base); \
+                hpx::components::init_registry_commandline(data);              \
+            }                                                                  \
+        } HPX_PP_CAT(module_commandline_data_, __LINE__);                      \
+    }                                                                          \
     /**/
 
 ///////////////////////////////////////////////////////////////////////////////
-#define HPX_INIT_REGISTRY_STARTUP_SHUTDOWN_STATIC(name, base)                 \
-    HPX_DECLARE_FACTORY_STATIC(name, base);                                   \
-    namespace {                                                               \
-        struct HPX_PP_CAT(init_registry_module_startup_shutdown_, name)       \
-        {                                                                     \
-            HPX_PP_CAT(init_registry_module_startup_shutdown_, name)()        \
-            {                                                                 \
-                hpx::components::static_factory_load_data_type data =         \
-                    HPX_DEFINE_FACTORY_STATIC(HPX_COMPONENT_NAME, name, base);\
-                hpx::components::init_registry_startup_shutdown(data);        \
-            }                                                                 \
-        } HPX_PP_CAT(module_startup_shutdown_data_, __LINE__);                \
-    }                                                                         \
+#define HPX_INIT_REGISTRY_STARTUP_SHUTDOWN_STATIC(name, base)                  \
+    HPX_DECLARE_FACTORY_STATIC(name, base);                                    \
+    namespace {                                                                \
+        struct HPX_PP_CAT(init_registry_module_startup_shutdown_, name)        \
+        {                                                                      \
+            HPX_PP_CAT(init_registry_module_startup_shutdown_, name)()         \
+            {                                                                  \
+                hpx::components::static_factory_load_data_type data =          \
+                    HPX_DEFINE_FACTORY_STATIC(HPX_COMPONENT_NAME, name, base); \
+                hpx::components::init_registry_startup_shutdown(data);         \
+            }                                                                  \
+        } HPX_PP_CAT(module_startup_shutdown_data_, __LINE__);                 \
+    }                                                                          \
     /**/
 
 #endif
-
diff --git a/libs/runtime_configuration/include_compatibility/hpx/plugins/plugin_registry_base.hpp b/libs/runtime_configuration/include_compatibility/hpx/plugins/plugin_registry_base.hpp
new file mode 100644
index 0000000000..74a2ee6805
--- /dev/null
+++ b/libs/runtime_configuration/include_compatibility/hpx/plugins/plugin_registry_base.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime_configuration/plugin_registry_base.hpp is deprecated, \
+    please include hpx/runtime_configuration/plugin_registry_base.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime_configuration/plugin_registry_base.hpp is deprecated, \
+    please include hpx/runtime_configuration/plugin_registry_base.hpp instead"
+#endif
+#endif
diff --git a/libs/runtime_configuration/include_compatibility/hpx/runtime/components/component_registry_base.hpp b/libs/runtime_configuration/include_compatibility/hpx/runtime/components/component_registry_base.hpp
new file mode 100644
index 0000000000..7db08e3620
--- /dev/null
+++ b/libs/runtime_configuration/include_compatibility/hpx/runtime/components/component_registry_base.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/runtime_configuration/component_registry_base.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime_configuration/component_registry_base.hpp is deprecated, \
+    please include hpx/runtime_configuration/component_registry_base.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime_configuration/component_registry_base.hpp is deprecated, \
+    please include hpx/runtime_configuration/component_registry_base.hpp instead"
+#endif
+#endif
diff --git a/libs/runtime_configuration/include_compatibility/hpx/runtime/components/static_factory_data.hpp b/libs/runtime_configuration/include_compatibility/hpx/runtime/components/static_factory_data.hpp
new file mode 100644
index 0000000000..e3df6d69d9
--- /dev/null
+++ b/libs/runtime_configuration/include_compatibility/hpx/runtime/components/static_factory_data.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/runtime_configuration/static_factory_data.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime_configuration/static_factory_data.hpp is deprecated, \
+    please include hpx/runtime_configuration/static_factory_data.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime_configuration/static_factory_data.hpp is deprecated, \
+    please include hpx/runtime_configuration/static_factory_data.hpp instead"
+#endif
+#endif
diff --git a/libs/runtime_configuration/include_compatibility/hpx/runtime/runtime_mode.hpp b/libs/runtime_configuration/include_compatibility/hpx/runtime/runtime_mode.hpp
new file mode 100644
index 0000000000..7da84c8dc5
--- /dev/null
+++ b/libs/runtime_configuration/include_compatibility/hpx/runtime/runtime_mode.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime_configuration/runtime_mode.hpp is deprecated, \
+    please include hpx/runtime_configuration/runtime_mode.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime_configuration/runtime_mode.hpp is deprecated, \
+    please include hpx/runtime_configuration/runtime_mode.hpp instead"
+#endif
+#endif
diff --git a/libs/runtime_configuration/include_compatibility/hpx/util/ini.hpp b/libs/runtime_configuration/include_compatibility/hpx/util/ini.hpp
new file mode 100644
index 0000000000..c6809e248e
--- /dev/null
+++ b/libs/runtime_configuration/include_compatibility/hpx/util/ini.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/ini.hpp is deprecated, \
+    please include hpx/runtime_configuration/ini.hpp instead")
+#else
+#warning "The header hpx/util/ini.hpp is deprecated, \
+    please include hpx/runtime_configuration/ini.hpp instead"
+#endif
+#endif
diff --git a/libs/runtime_configuration/include_compatibility/hpx/util/init_ini_data.hpp b/libs/runtime_configuration/include_compatibility/hpx/util/init_ini_data.hpp
new file mode 100644
index 0000000000..05e14ca0e2
--- /dev/null
+++ b/libs/runtime_configuration/include_compatibility/hpx/util/init_ini_data.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/runtime_configuration/init_ini_data.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime_configuration/init_ini_data.hpp is deprecated, \
+    please include hpx/runtime_configuration/init_ini_data.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime_configuration/init_ini_data.hpp is deprecated, \
+    please include hpx/runtime_configuration/init_ini_data.hpp instead"
+#endif
+#endif
diff --git a/libs/runtime_configuration/include_compatibility/hpx/util/runtime_configuration.hpp b/libs/runtime_configuration/include_compatibility/hpx/util/runtime_configuration.hpp
new file mode 100644
index 0000000000..33bb6c7794
--- /dev/null
+++ b/libs/runtime_configuration/include_compatibility/hpx/util/runtime_configuration.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/config/defines.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+
+#if defined(HPX_RUNTIME_CONFIGURATION_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/util/runtime_configuration.hpp is deprecated, \
+    please include hpx/runtime_configuration/runtime_configuration.hpp instead")
+#else
+#warning "The header hpx/util/runtime_configuration.hpp is deprecated, \
+    please include hpx/runtime_configuration/runtime_configuration.hpp instead"
+#endif
+#endif
diff --git a/libs/runtime_configuration/src/ini.cpp b/libs/runtime_configuration/src/ini.cpp
new file mode 100644
index 0000000000..93f5734136
--- /dev/null
+++ b/libs/runtime_configuration/src/ini.cpp
@@ -0,0 +1,1022 @@
+//  Copyright (c) 2005-2007 Andre Merzky
+//  Copyright (c) 2005-2018 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+
+// System Header Files
+#include <cerrno>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+
+#include <fstream>
+#include <iostream>
+#include <list>
+#include <mutex>
+#include <regex>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include <hpx/assertion.hpp>
+#include <hpx/errors.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/serialization/map.hpp>
+#include <hpx/serialization/serialize.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/thread_support/unlock_guard.hpp>
+
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#elif !defined(HPX_WINDOWS)
+extern char** environ;
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace hpx { namespace util {
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // example ini line: line # comment
+    const char pattern_comment[] = "^([^#]*)(#.*)$";
+    ///////////////////////////////////////////////////////////////////////////////
+
+    namespace detail {
+        ///////////////////////////////////////////////////////////////////////////
+        inline std::string trim_whitespace(std::string const& s)
+        {
+            typedef std::string::size_type size_type;
+
+            size_type first = s.find_first_not_of(" \t\r\n");
+            if (std::string::npos == first)
+                return (std::string());
+
+            size_type last = s.find_last_not_of(" \t\r\n");
+            return s.substr(first, last - first + 1);
+        }
+    }    // namespace detail
+
+    ///////////////////////////////////////////////////////////////////////////////
+    section::section()
+      : root_(this_())
+    {
+    }
+
+    section::section(std::string const& filename, section* root)
+      : root_(nullptr != root ? root : this_())
+      , name_(filename)
+    {
+        read(filename);
+    }
+
+    section::section(const section& in)
+      : root_(this_())
+      , name_(in.get_name())
+      , parent_name_(in.get_parent_name())
+    {
+        entry_map const& e = in.get_entries();
+        entry_map::const_iterator end = e.end();
+        for (entry_map::const_iterator i = e.begin(); i != end; ++i)
+            add_entry(i->first, i->second);
+
+        section_map s = in.get_sections();
+        section_map::iterator send = s.end();
+        for (section_map::iterator si = s.begin(); si != send; ++si)
+            add_section(si->first, si->second, get_root());
+    }
+
+    section& section::operator=(section const& rhs)
+    {
+        if (this != &rhs)
+        {
+            std::unique_lock<mutex_type> l(mtx_);
+
+            root_ = this;
+            parent_name_ = rhs.get_parent_name();
+            name_ = rhs.get_name();
+
+            entry_map const& e = rhs.get_entries();
+            entry_map::const_iterator end = e.end();
+            for (entry_map::const_iterator i = e.begin(); i != end; ++i)
+                add_entry(l, i->first, i->first, i->second);
+
+            section_map s = rhs.get_sections();
+            section_map::iterator send = s.end();
+            for (section_map::iterator si = s.begin(); si != send; ++si)
+                add_section(l, si->first, si->second, get_root());
+        }
+        return *this;
+    }
+
+    section& section::clone_from(section const& rhs, section* root)
+    {
+        if (this != &rhs)
+        {
+            std::unique_lock<mutex_type> l(mtx_);
+
+            root_ = root ? root : this;
+            parent_name_ = rhs.get_parent_name();
+            name_ = rhs.get_name();
+
+            entry_map const& e = rhs.get_entries();
+            entry_map::const_iterator end = e.end();
+            for (entry_map::const_iterator i = e.begin(); i != end; ++i)
+                add_entry(l, i->first, i->first, i->second);
+
+            section_map s = rhs.get_sections();
+            section_map::iterator send = s.end();
+            for (section_map::iterator si = s.begin(); si != send; ++si)
+                add_section(l, si->first, si->second, get_root());
+        }
+        return *this;
+    }
+
+    void section::read(std::string const& filename)
+    {
+#if defined(__AIX__) && defined(__GNUC__)
+        // NEVER ask why... seems to be some weird stdlib initialization problem
+        // If you don't call getline() here the while(getline...) loop below will
+        // crash with a bad_cast exception. Stupid AIX...
+        std::string l1;
+        std::ifstream i1;
+        i1.open(filename.c_str(), std::ios::in);
+        std::getline(i1, l1);
+        i1.close();
+#endif
+
+        // build ini - open file and parse each line
+        std::ifstream input(filename.c_str(), std::ios::in);
+        if (!input.is_open())
+            line_msg("Cannot open file: ", filename);
+
+        // read file
+        std::string line;
+        std::vector<std::string> lines;
+        while (std::getline(input, line))
+            lines.push_back(line);
+
+        // parse file
+        parse(filename, lines, false);
+    }
+
+    bool force_entry(std::string& str)
+    {
+        std::string::size_type p = str.find_last_of('!');
+        if (p != std::string::npos &&
+            str.find_first_not_of(" \t", p + 1) == std::string::npos)
+        {
+            str = str.substr(0, p);    // remove forcing modifier ('!')
+            return true;
+        }
+        return false;
+    }
+
+    // parse file
+    void section::parse(std::string const& sourcename,
+        std::vector<std::string> const& lines, bool verify_existing,
+        bool weed_out_comments, bool replace_existing)
+    {
+        int linenum = 0;
+        section* current = this;
+
+        std::regex regex_comment(pattern_comment, std::regex_constants::icase);
+
+        std::vector<std::string>::const_iterator end = lines.end();
+        for (std::vector<std::string>::const_iterator it = lines.begin();
+             it != end; ++it)
+        {
+            ++linenum;
+
+            // remove trailing new lines and white spaces
+            std::string line(detail::trim_whitespace(*it));
+
+            // skip if empty line
+            if (line.empty())
+                continue;
+
+            // weed out comments
+            if (weed_out_comments)
+            {
+                std::smatch what_comment;
+                if (std::regex_match(line, what_comment, regex_comment))
+                {
+                    HPX_ASSERT(3 == what_comment.size());
+
+                    line = detail::trim_whitespace(what_comment[1]);
+                    if (line.empty())
+                        continue;
+                }
+            }
+            // no comments anymore: line is either section, key=val,
+            // or garbage/empty
+
+            // Check if we have a section.
+            // Example: [sec.ssec]
+            if (line.front() == '[' && line.back() == ']')
+            {
+                current = this;    // start adding sections at the root
+
+                // got the section name. It might be hierarchical, so split it up, and
+                // for each elem, check if we have it.  If not, create it, and add
+                std::string sec_name(line.substr(1, line.size() - 2));
+                std::string::size_type pos = 0;
+                for (std::string::size_type pos1 = sec_name.find_first_of('.');
+                     std::string::npos != pos1;
+                     pos1 = sec_name.find_first_of('.', pos = pos1 + 1))
+                {
+                    current = current->add_section_if_new(
+                        sec_name.substr(pos, pos1 - pos));
+                }
+
+                current = current->add_section_if_new(sec_name.substr(pos));
+                continue;
+            }
+
+            // Check if we have a key=val entry...
+            std::string::size_type assign_pos = line.find('=');
+            if (assign_pos != std::string::npos)
+            {
+                std::string sec_key =
+                    detail::trim_whitespace(line.substr(0, assign_pos));
+                std::string value = detail::trim_whitespace(
+                    line.substr(assign_pos + 1, line.size() - assign_pos - 1));
+
+                section* s = current;    // save the section we're in
+                current = this;          // start adding sections at the root
+
+                std::string::size_type pos = 0;
+                // Check if we have a qualified key name
+                // Example: hpx.commandline.allow_unknown
+                for (std::string::size_type dot_pos =
+                         sec_key.find_first_of('.');
+                     std::string::npos != dot_pos;
+                     dot_pos = sec_key.find_first_of('.', pos = dot_pos + 1))
+                {
+                    current = current->add_section_if_new(
+                        sec_key.substr(pos, dot_pos - pos));
+                }
+                // if we don't have section qualifiers, restor current...
+                if (current == this)
+                {
+                    current = s;
+                }
+
+                std::string key = sec_key.substr(pos);
+
+                // add key/val to this section
+                std::unique_lock<mutex_type> l(current->mtx_);
+
+                if (!force_entry(key) && verify_existing &&
+                    !current->has_entry(l, key))
+                {
+                    line_msg("Attempt to initialize unknown entry: ",
+                        sourcename, linenum, line);
+                }
+
+                if (replace_existing || !current->has_entry(l, key))
+                {
+                    current->add_entry(l, key, key, value);
+                }
+
+                // restore the old section
+                current = s;
+            }
+            else
+            {
+                // Hmm, is not a section, is not an entry, is not empty - must be
+                // an error!
+                line_msg("Cannot parse line at: ", sourcename, linenum, line);
+            }
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    void section::add_section(std::unique_lock<mutex_type>& l,
+        std::string const& sec_name, section& sec, section* root)
+    {
+        // setting name and root
+        sec.name_ = sec_name;
+        sec.parent_name_ = get_full_name();
+
+        section& newsec = sections_[sec_name];
+        newsec.clone_from(sec, (nullptr != root) ? root : get_root());
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    section* section::add_section_if_new(
+        std::unique_lock<mutex_type>& l, std::string const& sec_name)
+    {
+        // do we know this one?
+        if (!has_section(l, sec_name))
+        {
+            // no - add it!
+            section sec;
+            add_section(l, sec_name, sec, get_root());
+        }
+
+        return get_section(l, sec_name);
+    }
+
+    bool section::has_section(
+        std::unique_lock<mutex_type>& l, std::string const& sec_name) const
+    {
+        std::string::size_type i = sec_name.find('.');
+        if (i != std::string::npos)
+        {
+            std::string cor_sec_name = sec_name.substr(0, i);
+
+            section_map::const_iterator it = sections_.find(cor_sec_name);
+            if (it != sections_.end())
+            {
+                std::string sub_sec_name = sec_name.substr(i + 1);
+                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                return (*it).second.has_section(sub_sec_name);
+            }
+            return false;
+        }
+        return sections_.find(sec_name) != sections_.end();
+    }
+
+    section* section::get_section(
+        std::unique_lock<mutex_type>& l, std::string const& sec_name)
+    {
+        std::string::size_type i = sec_name.find('.');
+        if (i != std::string::npos)
+        {
+            std::string cor_sec_name = sec_name.substr(0, i);
+            section_map::iterator it = sections_.find(cor_sec_name);
+            if (it != sections_.end())
+            {
+                std::string sub_sec_name = sec_name.substr(i + 1);
+                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                return (*it).second.get_section(sub_sec_name);
+            }
+
+            std::string name(get_name());
+            if (name.empty())
+                name = "<root>";
+
+            HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
+                "No such section (" + sec_name + ") in section: " + name);
+            return nullptr;
+        }
+
+        section_map::iterator it = sections_.find(sec_name);
+        if (it != sections_.end())
+            return &((*it).second);
+
+        HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
+            "No such section (" + sec_name + ") in section: " + get_name());
+        return nullptr;
+    }
+
+    section const* section::get_section(
+        std::unique_lock<mutex_type>& l, std::string const& sec_name) const
+    {
+        std::string::size_type i = sec_name.find('.');
+        if (i != std::string::npos)
+        {
+            std::string cor_sec_name = sec_name.substr(0, i);
+            section_map::const_iterator it = sections_.find(cor_sec_name);
+            if (it != sections_.end())
+            {
+                std::string sub_sec_name = sec_name.substr(i + 1);
+                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                return (*it).second.get_section(sub_sec_name);
+            }
+
+            std::string name(get_name());
+            if (name.empty())
+                name = "<root>";
+
+            HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
+                "No such section (" + sec_name + ") in section: " + name);
+            return nullptr;
+        }
+
+        section_map::const_iterator it = sections_.find(sec_name);
+        if (it != sections_.end())
+            return &((*it).second);
+
+        HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
+            "No such section (" + sec_name + ") in section: " + get_name());
+        return nullptr;
+    }
+
+    void section::add_entry(std::unique_lock<mutex_type>& l,
+        std::string const& fullkey, std::string const& key, std::string val)
+    {
+        // first expand the full property name in the value (avoids infinite recursion)
+        expand_only(
+            l, val, std::string::size_type(-1), get_full_name() + "." + key);
+
+        std::string::size_type i = key.find_last_of('.');
+        if (i != std::string::npos)
+        {
+            section* current = root_;
+
+            // make sure all sections in key exist
+            std::string sec_name = key.substr(0, i);
+
+            std::string::size_type pos = 0;
+            for (std::string::size_type pos1 = sec_name.find_first_of('.');
+                 std::string::npos != pos1;
+                 pos1 = sec_name.find_first_of('.', pos = pos1 + 1))
+            {
+                current = current->add_section_if_new(
+                    l, sec_name.substr(pos, pos1 - pos));
+            }
+
+            current = current->add_section_if_new(l, sec_name.substr(pos));
+
+            // now add this entry to the section
+            current->add_entry(l, fullkey, key.substr(i + 1), val);
+        }
+        else
+        {
+            entry_map::iterator it = entries_.find(key);
+            if (it != entries_.end())
+            {
+                auto& e = it->second;
+                e.first = std::move(val);
+                if (!e.second.empty())
+                {
+                    std::string value = e.first;
+                    entry_changed_func f = e.second;
+
+                    hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                    f(fullkey, value);
+                }
+            }
+            else
+            {
+                // just add this entry to the section
+                entries_[key] = entry_type(val, entry_changed_func());
+            }
+        }
+    }
+
+    void section::add_entry(std::unique_lock<mutex_type>& l,
+        std::string const& fullkey, std::string const& key,
+        entry_type const& val)
+    {
+        std::string::size_type i = key.find_last_of('.');
+        if (i != std::string::npos)
+        {
+            section* current = root_;
+
+            // make sure all sections in key exist
+            std::string sec_name = key.substr(0, i);
+
+            std::string::size_type pos = 0;
+            for (std::string::size_type pos1 = sec_name.find_first_of('.');
+                 std::string::npos != pos1;
+                 pos1 = sec_name.find_first_of('.', pos = pos1 + 1))
+            {
+                current = current->add_section_if_new(
+                    l, sec_name.substr(pos, pos1 - pos));
+            }
+
+            current = current->add_section_if_new(l, sec_name.substr(pos));
+
+            // now add this entry to the section
+            current->add_entry(l, fullkey, key.substr(i + 1), val);
+        }
+        else
+        {
+            entry_map::iterator it = entries_.find(key);
+            if (it != entries_.end())
+            {
+                it->second = val;
+                if (!it->second.second.empty())
+                {
+                    std::string value = it->second.first;
+                    entry_changed_func f = it->second.second;
+
+                    hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                    f(fullkey, value);
+                }
+            }
+            else
+            {
+                // just add this entry to the section
+                std::pair<entry_map::iterator, bool> p =
+                    entries_.insert(entry_map::value_type(key, val));
+                HPX_ASSERT(p.second);
+
+                if (!p.first->second.second.empty())
+                {
+                    std::string key = p.first->first;
+                    std::string value = p.first->second.first;
+                    entry_changed_func f = p.first->second.second;
+
+                    hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                    f(key, value);
+                }
+            }
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    template <typename F1, typename F2>
+    class compose_callback_impl
+    {
+    public:
+        template <typename A1, typename A2>
+        compose_callback_impl(A1&& f1, A2&& f2)
+          : f1_(std::forward<A1>(f1))
+          , f2_(std::forward<A2>(f2))
+        {
+        }
+
+        void operator()(std::string const& k, std::string const& v) const
+        {
+            f1_(k, v);
+            f2_(k, v);
+        }
+
+    private:
+        F1 f1_;
+        F2 f2_;
+    };
+
+    template <typename F1, typename F2>
+    static HPX_FORCEINLINE
+        util::function_nonser<void(std::string const&, std::string const&)>
+        compose_callback(F1&& f1, F2&& f2)
+    {
+        if (!f1)
+            return std::forward<F2>(f2);
+        else if (!f2)
+            return std::forward<F1>(f1);
+
+        // otherwise create a combined callback
+        typedef compose_callback_impl<typename util::decay<F1>::type,
+            typename util::decay<F2>::type>
+            result_type;
+        return result_type(std::forward<F1>(f1), std::forward<F2>(f2));
+    }
+
+    void section::add_notification_callback(std::unique_lock<mutex_type>& l,
+        std::string const& key, entry_changed_func const& callback)
+    {
+        std::string::size_type i = key.find_last_of('.');
+        if (i != std::string::npos)
+        {
+            section* current = root_;
+
+            // make sure all sections in key exist
+            std::string sec_name = key.substr(0, i);
+
+            std::string::size_type pos = 0;
+            for (std::string::size_type pos1 = sec_name.find_first_of('.');
+                 std::string::npos != pos1;
+                 pos1 = sec_name.find_first_of('.', pos = pos1 + 1))
+            {
+                current = current->add_section_if_new(
+                    l, sec_name.substr(pos, pos1 - pos));
+            }
+
+            current = current->add_section_if_new(l, sec_name.substr(pos));
+
+            // now add this entry to the section
+            current->add_notification_callback(l, key.substr(i + 1), callback);
+        }
+        else
+        {
+            // just add this entry to the section
+            entry_map::iterator it = entries_.find(key);
+            if (it != entries_.end())
+            {
+                it->second.second =
+                    compose_callback(callback, it->second.second);
+            }
+            else
+            {
+                entries_[key] = entry_type("", callback);
+            }
+        }
+    }
+
+    bool section::has_entry(
+        std::unique_lock<mutex_type>& l, std::string const& key) const
+    {
+        std::string::size_type i = key.find('.');
+        if (i != std::string::npos)
+        {
+            std::string sub_sec = key.substr(0, i);
+            std::string sub_key = key.substr(i + 1, key.size() - i);
+            if (has_section(l, sub_sec))
+            {
+                section_map::const_iterator cit = sections_.find(sub_sec);
+                HPX_ASSERT(cit != sections_.end());
+                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                return (*cit).second.has_entry(sub_key);
+            }
+            return false;
+        }
+        return entries_.find(key) != entries_.end();
+    }
+
+    std::string section::get_entry(
+        std::unique_lock<mutex_type>& l, std::string const& key) const
+    {
+        std::string::size_type i = key.find('.');
+        if (i != std::string::npos)
+        {
+            std::string sub_sec = key.substr(0, i);
+            std::string sub_key = key.substr(i + 1, key.size() - i);
+            if (has_section(l, sub_sec))
+            {
+                section_map::const_iterator cit = sections_.find(sub_sec);
+                HPX_ASSERT(cit != sections_.end());
+                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
+                return (*cit).second.get_entry(sub_key);
+            }
+
+            HPX_THROW_EXCEPTION(bad_parameter, "section::get_entry",
+                "No such key (" + key + ") in section: " + get_name());
+            return "";
+        }
+
+        if (entries_.find(key) != entries_.end())
+        {
+            entry_map::const_iterator cit = entries_.find(key);
+            HPX_ASSERT(cit != entries_.end());
+            return expand(l, (*cit).second.first);
+        }
+
+        HPX_THROW_EXCEPTION(bad_parameter, "section::get_entry",
+            "No such section (" + key + ") in section: " + get_name());
+        return "";
+    }
+
+    std::string section::get_entry(std::unique_lock<mutex_type>& l,
+        std::string const& key, std::string const& default_val) const
+    {
+        typedef std::vector<std::string> string_vector;
+
+        string_vector split_key;
+        hpx::string_util::split(
+            split_key, key, hpx::string_util::is_any_of("."));
+
+        std::string sk = split_key.back();
+        split_key.pop_back();
+
+        section const* cur_section = this;
+        for (string_vector::const_iterator iter = split_key.begin(),
+                                           end = split_key.end();
+             iter != end; ++iter)
+        {
+            section_map::const_iterator next =
+                cur_section->sections_.find(*iter);
+            if (cur_section->sections_.end() == next)
+                return expand(l, default_val);
+            cur_section = &next->second;
+        }
+
+        entry_map::const_iterator entry = cur_section->entries_.find(sk);
+        if (cur_section->entries_.end() == entry)
+            return expand(l, default_val);
+
+        return expand(l, entry->second.first);
+    }
+
+    inline void indent(int ind, std::ostream& strm)
+    {
+        for (int i = 0; i < ind; ++i)
+            strm << "  ";
+    }
+
+    void section::dump(int ind, std::ostream& strm) const
+    {
+        std::unique_lock<mutex_type> l(mtx_);
+
+        bool header = false;
+        if (0 == ind)
+            header = true;
+
+        ++ind;
+        if (header)
+        {
+            if (get_root() == this)
+            {
+                strm << "============================\n";
+            }
+            else
+            {
+                strm << "============================[\n"
+                     << get_name() << "\n"
+                     << "]\n";
+            }
+        }
+
+        entry_map::const_iterator eend = entries_.end();
+        for (entry_map::const_iterator i = entries_.begin(); i != eend; ++i)
+        {
+            indent(ind, strm);
+
+            const std::string expansion = expand(l, i->second.first);
+
+            // Check if the expanded entry is different from the actual entry.
+            if (expansion != i->second.first)
+                // If the expansion is different from the real entry, then print
+                // it out.
+                strm << "'" << i->first << "' : '" << i->second.first
+                     << "' -> '" << expansion << "'\n";
+            else
+                strm << "'" << i->first << "' : '" << i->second.first << "'\n";
+        }
+
+        section_map::const_iterator send = sections_.end();
+        for (section_map::const_iterator i = sections_.begin(); i != send; ++i)
+        {
+            indent(ind, strm);
+            strm << "[" << i->first << "]\n";
+            (*i).second.dump(ind, strm);
+        }
+
+        if (header)
+            strm << "============================\n";
+
+        strm << std::flush;
+    }
+
+    void section::merge(std::string const& filename)
+    {
+        section tmp(filename, root_);
+        merge(tmp);
+    }
+
+    void section::merge(section& second)
+    {
+        std::unique_lock<mutex_type> l(mtx_);
+
+        // merge entries: keep own entries, and add other entries
+        entry_map const& s_entries = second.get_entries();
+        entry_map::const_iterator end = s_entries.end();
+        for (entry_map::const_iterator i = s_entries.begin(); i != end; ++i)
+            entries_[i->first] = i->second;
+
+        // merge subsection known in first section
+        section_map::iterator send = sections_.end();
+        for (section_map::iterator i = sections_.begin(); i != send; ++i)
+        {
+            // is there something to merge with?
+            if (second.has_section(l, i->first))
+                i->second.merge(second.sections_[i->first]);
+        }
+
+        // merge subsection known in second section
+        section_map s = second.get_sections();
+        section_map::iterator secend = s.end();
+        for (section_map::iterator i = s.begin(); i != secend; ++i)
+        {
+            // if THIS knows the section, we already merged it above
+            if (!has_section(l, i->first))
+            {
+                // it is not known here, so we can't merge, but have to add it.
+                add_section(l, i->first, i->second, get_root());
+            }
+        }
+    }
+
+    /////////////////////////////////////////////////////////////////////////////////
+    void section::line_msg(std::string msg, std::string const& file, int lnum,
+        std::string const& line)
+    {
+        msg += " " + file;
+        if (lnum > 0)
+            msg += ": line " + std::to_string(lnum);
+        if (!line.empty())
+            msg += " (offending entry: " + line + ")";
+
+        HPX_THROW_EXCEPTION(no_success, "section::line_msg", msg);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // find the matching closing brace starting from 'begin', escaped braces will
+    // be un-escaped
+    inline std::string::size_type find_next(char const* ch, std::string& value,
+        std::string::size_type begin = static_cast<std::string::size_type>(-1))
+    {
+        std::string::size_type end = value.find_first_of(ch, begin + 1);
+        while (end != std::string::npos)
+        {
+            if (end != 0 && value[end - 1] != '\\')
+                break;
+            value.replace(end - 1, 2, ch);
+            end = value.find_first_of(ch, end);
+        }
+        return end;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    void section::expand(std::unique_lock<mutex_type>& l, std::string& value,
+        std::string::size_type begin) const
+    {
+        std::string::size_type p = value.find_first_of('$', begin + 1);
+        while (p != std::string::npos && value.size() - 1 != p)
+        {
+            if ('[' == value[p + 1])
+                expand_bracket(l, value, p);
+            else if ('{' == value[p + 1])
+                expand_brace(l, value, p);
+            p = value.find_first_of('$', p + 1);
+        }
+    }
+
+    void section::expand_bracket(std::unique_lock<mutex_type>& l,
+        std::string& value, std::string::size_type begin) const
+    {
+        // expand all keys embedded inside this key
+        expand(l, value, begin);
+
+        // now expand the key itself
+        std::string::size_type end = find_next("]", value, begin + 1);
+        if (end != std::string::npos)
+        {
+            std::string to_expand = value.substr(begin + 2, end - begin - 2);
+            std::string::size_type colon = find_next(":", to_expand);
+            if (colon == std::string::npos)
+            {
+                value.replace(begin, end - begin + 1,
+                    root_->get_entry(l, to_expand, std::string("")));
+            }
+            else
+            {
+                value.replace(begin, end - begin + 1,
+                    root_->get_entry(l, to_expand.substr(0, colon),
+                        to_expand.substr(colon + 1)));
+            }
+        }
+    }
+
+    void section::expand_brace(std::unique_lock<mutex_type>& l,
+        std::string& value, std::string::size_type begin) const
+    {
+        // expand all keys embedded inside this key
+        expand(l, value, begin);
+
+        // now expand the key itself
+        std::string::size_type end = find_next("}", value, begin + 1);
+        if (end != std::string::npos)
+        {
+            std::string to_expand = value.substr(begin + 2, end - begin - 2);
+            std::string::size_type colon = find_next(":", to_expand);
+            if (colon == std::string::npos)
+            {
+                char* env = getenv(to_expand.c_str());
+                value.replace(
+                    begin, end - begin + 1, nullptr != env ? env : "");
+            }
+            else
+            {
+                char* env = getenv(to_expand.substr(0, colon).c_str());
+                value.replace(begin, end - begin + 1,
+                    nullptr != env ? std::string(env) :
+                                     to_expand.substr(colon + 1));
+            }
+        }
+    }
+
+    std::string section::expand(
+        std::unique_lock<mutex_type>& l, std::string value) const
+    {
+        expand(l, value, std::string::size_type(-1));
+        return value;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    void section::expand_only(std::unique_lock<mutex_type>& l,
+        std::string& value, std::string::size_type begin,
+        std::string const& expand_this) const
+    {
+        std::string::size_type p = value.find_first_of('$', begin + 1);
+        while (p != std::string::npos && value.size() - 1 != p)
+        {
+            if ('[' == value[p + 1])
+                expand_bracket_only(l, value, p, expand_this);
+            else if ('{' == value[p + 1])
+                expand_brace_only(l, value, p, expand_this);
+            p = value.find_first_of('$', p + 1);
+        }
+    }
+
+    void section::expand_bracket_only(std::unique_lock<mutex_type>& l,
+        std::string& value, std::string::size_type begin,
+        std::string const& expand_this) const
+    {
+        // expand all keys embedded inside this key
+        expand_only(l, value, begin, expand_this);
+
+        // now expand the key itself
+        std::string::size_type end = find_next("]", value, begin + 1);
+        if (end != std::string::npos)
+        {
+            std::string to_expand = value.substr(begin + 2, end - begin - 2);
+            std::string::size_type colon = find_next(":", to_expand);
+            if (colon == std::string::npos)
+            {
+                if (to_expand == expand_this)
+                {
+                    value.replace(begin, end - begin + 1,
+                        root_->get_entry(l, to_expand, std::string("")));
+                }
+            }
+            else if (to_expand.substr(0, colon) == expand_this)
+            {
+                value.replace(begin, end - begin + 1,
+                    root_->get_entry(l, to_expand.substr(0, colon),
+                        to_expand.substr(colon + 1)));
+            }
+        }
+    }
+
+    void section::expand_brace_only(std::unique_lock<mutex_type>& l,
+        std::string& value, std::string::size_type begin,
+        std::string const& expand_this) const
+    {
+        // expand all keys embedded inside this key
+        expand_only(l, value, begin, expand_this);
+
+        // now expand the key itself
+        std::string::size_type end = find_next("}", value, begin + 1);
+        if (end != std::string::npos)
+        {
+            std::string to_expand = value.substr(begin + 2, end - begin - 2);
+            std::string::size_type colon = find_next(":", to_expand);
+            if (colon == std::string::npos)
+            {
+                char* env = getenv(to_expand.c_str());
+                value.replace(
+                    begin, end - begin + 1, nullptr != env ? env : "");
+            }
+            else
+            {
+                char* env = getenv(to_expand.substr(0, colon).c_str());
+                value.replace(begin, end - begin + 1,
+                    nullptr != env ? std::string(env) :
+                                     to_expand.substr(colon + 1));
+            }
+        }
+    }
+
+    std::string section::expand_only(std::unique_lock<mutex_type>& l,
+        std::string value, std::string const& expand_this) const
+    {
+        expand_only(l, value, std::string::size_type(-1), expand_this);
+        return value;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // explicit instantiation for the correct archive types
+    HPX_EXPORT void serialize(serialization::output_archive& ar,
+        section::entry_type const& data, unsigned int version)
+    {
+        ar << data.first;
+        // do not handle callback function
+    }
+
+    HPX_EXPORT void serialize(serialization::input_archive& ar,
+        section::entry_type& data, unsigned int version)
+    {
+        ar >> data.first;
+        // do not handle callback function
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////
+    template <typename Archive>
+    void section::save(Archive& ar, const unsigned int version) const
+    {
+        ar << name_;
+        ar << parent_name_;
+        ar << entries_;
+        ar << sections_;
+    }
+
+    template <typename Archive>
+    void section::load(Archive& ar, const unsigned int version)
+    {
+        ar >> name_;
+        ar >> parent_name_;
+        ar >> entries_;
+        ar >> sections_;
+
+        set_root(this, true);    // make this the current root
+    }
+
+    // explicit instantiation for the correct archive types
+    template HPX_EXPORT void section::save(
+        serialization::output_archive&, const unsigned int version) const;
+
+    template HPX_EXPORT void section::load(
+        serialization::input_archive&, const unsigned int version);
+
+}}    // namespace hpx::util
diff --git a/src/util/init_ini_data.cpp b/libs/runtime_configuration/src/init_ini_data.cpp
similarity index 72%
rename from src/util/init_ini_data.cpp
rename to libs/runtime_configuration/src/init_ini_data.cpp
index 2fd1022540..5bf0b24b21 100644
--- a/src/util/init_ini_data.cpp
+++ b/libs/runtime_configuration/src/init_ini_data.cpp
@@ -11,12 +11,12 @@
 #include <hpx/filesystem.hpp>
 #include <hpx/logging.hpp>
 #include <hpx/plugin.hpp>
-#include <hpx/plugins/plugin_registry_base.hpp>
-#include <hpx/runtime/components/component_registry_base.hpp>
+#include <hpx/prefix/find_prefix.hpp>
 #include <hpx/runtime/startup_function.hpp>
-#include <hpx/util/find_prefix.hpp>
-#include <hpx/util/ini.hpp>
-#include <hpx/util/init_ini_data.hpp>
+#include <hpx/runtime_configuration/component_registry_base.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/runtime_configuration/init_ini_data.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
 #include <hpx/version.hpp>
 
 #include <boost/assign/std/vector.hpp>
@@ -26,45 +26,48 @@
 #include <iostream>
 #include <map>
 #include <memory>
+#include <random>
 #include <string>
 #include <utility>
 #include <vector>
-#include <random>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
-    bool handle_ini_file (section& ini, std::string const& loc)
+    bool handle_ini_file(section& ini, std::string const& loc)
     {
-        try {
+        try
+        {
             namespace fs = filesystem;
             fs::error_code ec;
             if (!fs::exists(loc, ec) || ec)
-                return false;       // avoid exception on missing file
-            ini.read (loc);
+                return false;    // avoid exception on missing file
+            ini.read(loc);
         }
-        catch (hpx::exception const& /*e*/) {
+        catch (hpx::exception const& /*e*/)
+        {
             return false;
         }
         return true;
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    bool handle_ini_file_env (section& ini, char const* env_var,
-        char const* file_suffix)
+    bool handle_ini_file_env(
+        section& ini, char const* env_var, char const* file_suffix)
     {
         char const* env = getenv(env_var);
-        if (nullptr != env) {
+        if (nullptr != env)
+        {
             namespace fs = filesystem;
 
-            fs::path inipath (env);
+            fs::path inipath(env);
             if (nullptr != file_suffix)
                 inipath /= fs::path(file_suffix);
 
-            if (handle_ini_file(ini, inipath.string())) {
-                LBT_(info) << "loaded configuration (${" << env_var << "}): "
-                           << inipath.string();
+            if (handle_ini_file(ini, inipath.string()))
+            {
+                LBT_(info) << "loaded configuration (${" << env_var
+                           << "}): " << inipath.string();
                 return true;
             }
         }
@@ -76,18 +79,19 @@ namespace hpx { namespace util
     //
     // returns true if at least one alternative location has been read
     // successfully
-    bool init_ini_data_base (section& ini, std::string& hpx_ini_file)
+    bool init_ini_data_base(section& ini, std::string& hpx_ini_file)
     {
         namespace fs = filesystem;
 
         // fall back: use compile time prefix
         std::string ini_paths(ini.get_entry("hpx.master_ini_path"));
-        std::string ini_paths_suffixes(ini.get_entry("hpx.master_ini_path_suffixes"));
+        std::string ini_paths_suffixes(
+            ini.get_entry("hpx.master_ini_path_suffixes"));
 
         // split off the separate paths from the given path list
-        typedef boost::tokenizer<boost::char_separator<char> > tokenizer_type;
+        typedef boost::tokenizer<boost::char_separator<char>> tokenizer_type;
 
-        boost::char_separator<char> sep (HPX_INI_PATH_DELIMITER);
+        boost::char_separator<char> sep(HPX_INI_PATH_DELIMITER);
         tokenizer_type tok_paths(ini_paths, sep);
         tokenizer_type::iterator end_paths = tok_paths.end();
         tokenizer_type tok_suffixes(ini_paths_suffixes, sep);
@@ -115,22 +119,25 @@ namespace hpx { namespace util
         // look in the current directory first
         std::string cwd = fs::current_path().string() + "/.hpx.ini";
         {
-            bool result2 = handle_ini_file (ini, cwd);
-            if (result2) {
+            bool result2 = handle_ini_file(ini, cwd);
+            if (result2)
+            {
                 LBT_(info) << "loaded configuration: " << cwd;
             }
             result = result2 || result;
         }
 
         // look for master ini in the HPX_INI environment
-        result = handle_ini_file_env (ini, "HPX_INI") || result;
+        result = handle_ini_file_env(ini, "HPX_INI") || result;
 
         // afterwards in the standard locations
-#if !defined(HPX_WINDOWS)   // /etc/hpx.ini doesn't make sense for Windows
+#if !defined(HPX_WINDOWS)    // /etc/hpx.ini doesn't make sense for Windows
         {
             bool result2 = handle_ini_file(ini, "/etc/hpx.ini");
-            if (result2) {
-                LBT_(info) << "loaded configuration: " << "/etc/hpx.ini";
+            if (result2)
+            {
+                LBT_(info) << "loaded configuration: "
+                           << "/etc/hpx.ini";
             }
             result = result2 || result;
         }
@@ -139,19 +146,24 @@ namespace hpx { namespace util
         result = handle_ini_file_env(ini, "HOME", "/.hpx.ini") || result;
         result = handle_ini_file_env(ini, "PWD", "/.hpx.ini") || result;
 
-        if (!hpx_ini_file.empty()) {
+        if (!hpx_ini_file.empty())
+        {
             namespace fs = filesystem;
             fs::error_code ec;
-            if (!fs::exists(hpx_ini_file, ec) || ec) {
-                std::cerr << "hpx::init: command line warning: file specified using "
-                             "--hpx::config does not exist ("
+            if (!fs::exists(hpx_ini_file, ec) || ec)
+            {
+                std::cerr
+                    << "hpx::init: command line warning: file specified using "
+                       "--hpx::config does not exist ("
                     << hpx_ini_file << ")." << std::endl;
                 hpx_ini_file.clear();
                 result = false;
             }
-            else {
+            else
+            {
                 bool result2 = handle_ini_file(ini, hpx_ini_file);
-                if (result2) {
+                if (result2)
+                {
                     LBT_(info) << "loaded configuration: " << hpx_ini_file;
                 }
                 return result || result2;
@@ -167,26 +179,28 @@ namespace hpx { namespace util
         namespace fs = filesystem;
 
         // now merge all information into one global structure
-        std::string ini_path(ini.get_entry("hpx.ini_path", HPX_DEFAULT_INI_PATH));
-        std::vector <std::string> ini_paths;
+        std::string ini_path(
+            ini.get_entry("hpx.ini_path", HPX_DEFAULT_INI_PATH));
+        std::vector<std::string> ini_paths;
 
         // split off the separate paths from the given path list
-        typedef boost::tokenizer<boost::char_separator<char> > tokenizer_type;
+        typedef boost::tokenizer<boost::char_separator<char>> tokenizer_type;
 
-        boost::char_separator<char> sep (HPX_INI_PATH_DELIMITER);
+        boost::char_separator<char> sep(HPX_INI_PATH_DELIMITER);
         tokenizer_type tok(ini_path, sep);
         tokenizer_type::iterator end = tok.end();
-        for (tokenizer_type::iterator it = tok.begin (); it != end; ++it)
-            ini_paths.push_back (*it);
+        for (tokenizer_type::iterator it = tok.begin(); it != end; ++it)
+            ini_paths.push_back(*it);
 
         // have all path elements, now find ini files in there...
         std::vector<std::string>::iterator ini_end = ini_paths.end();
         for (std::vector<std::string>::iterator it = ini_paths.begin();
              it != ini_end; ++it)
         {
-            try {
+            try
+            {
                 fs::directory_iterator nodir;
-                fs::path this_path (*it);
+                fs::path this_path(*it);
 
                 fs::error_code ec;
                 if (!fs::exists(this_path, ec) || ec)
@@ -198,16 +212,20 @@ namespace hpx { namespace util
                         continue;
 
                     // read and merge the ini file into the main ini hierarchy
-                    try {
-                        ini.merge ((*dir).path().string());
-                        LBT_(info) << "loaded configuration: " << (*dir).path().string();
+                    try
+                    {
+                        ini.merge((*dir).path().string());
+                        LBT_(info) << "loaded configuration: "
+                                   << (*dir).path().string();
                     }
-                    catch (hpx::exception const& /*e*/) {
+                    catch (hpx::exception const& /*e*/)
+                    {
                         ;
                     }
                 }
             }
-            catch (fs::filesystem_error const& /*e*/) {
+            catch (fs::filesystem_error const& /*e*/)
+            {
                 ;
             }
         }
@@ -221,24 +239,28 @@ namespace hpx { namespace util
         hpx::util::plugin::get_plugins_list_type get_factory, error_code& ec)
     {
         hpx::util::plugin::static_plugin_factory<
-            components::component_registry_base> pf(get_factory);
-        std::vector<std::shared_ptr<components::component_registry_base>> registries;
+            components::component_registry_base>
+            pf(get_factory);
+        std::vector<std::shared_ptr<components::component_registry_base>>
+            registries;
 
         // retrieve the names of all known registries
         std::vector<std::string> names;
         pf.get_names(names, ec);
-        if (ec) return registries;
+        if (ec)
+            return registries;
 
         std::vector<std::string> ini_data;
-        if (names.empty()) {
+        if (names.empty())
+        {
             // This HPX module does not export any factories, but
             // might export startup/shutdown functions. Create some
             // default configuration data.
             using namespace boost::assign;
 #if defined(HPX_DEBUG)
             // demangle the name in debug mode
-            if (name[name.size()-1] == 'd')
-                name.resize(name.size()-1);
+            if (name[name.size() - 1] == 'd')
+                name.resize(name.size() - 1);
 #endif
             ini_data += std::string("[hpx.components.") + name + "]";
             ini_data += "name = " + name;
@@ -246,7 +268,8 @@ namespace hpx { namespace util
             ini_data += "enabled = 1";
             ini_data += "static = 1";
         }
-        else {
+        else
+        {
             registries.reserve(names.size());
             // ask all registries
             for (std::string const& s : names)
@@ -254,7 +277,8 @@ namespace hpx { namespace util
                 // create the component registry object
                 std::shared_ptr<components::component_registry_base> registry(
                     pf.create(s, ec));
-                if (ec) continue;
+                if (ec)
+                    continue;
 
                 registry->get_component_info(ini_data, "", true);
                 registries.push_back(registry);
@@ -276,18 +300,20 @@ namespace hpx { namespace util
         // retrieve the names of all known registries
         std::vector<std::string> names;
         pf.get_names(names, ec);
-        if (ec) return;
+        if (ec)
+            return;
 
         std::vector<std::string> ini_data;
-        if (names.empty()) {
+        if (names.empty())
+        {
             // This HPX module does not export any factories, but
             // might export startup/shutdown functions. Create some
             // default configuration data.
             using namespace boost::assign;
 #if defined(HPX_DEBUG)
             // demangle the name in debug mode
-            if (name[name.size()-1] == 'd')
-                name.resize(name.size()-1);
+            if (name[name.size() - 1] == 'd')
+                name.resize(name.size() - 1);
 #endif
             ini_data += std::string("[hpx.components.") + name + "]";
             ini_data += "name = " + name;
@@ -295,20 +321,20 @@ namespace hpx { namespace util
             ini_data += "no_factory = 1";
             ini_data += "enabled = 1";
         }
-        else {
+        else
+        {
             // ask all registries
             for (std::string const& s : names)
             {
                 // create the component registry object
-                std::shared_ptr<components::component_registry_base>
-                    registry (pf.create(s, ec));
-                if (ec) return;
+                std::shared_ptr<components::component_registry_base> registry(
+                    pf.create(s, ec));
+                if (ec)
+                    return;
 
                 registry->get_component_info(ini_data, curr);
-                hpx::register_startup_function([registry]()
-                {
-                    registry->register_component_type();
-                });
+                hpx::register_startup_function(
+                    [registry]() { registry->register_component_type(); });
             }
         }
 
@@ -318,31 +344,34 @@ namespace hpx { namespace util
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+    std::vector<std::shared_ptr<plugins::plugin_registry_base>>
     load_plugin_factory(hpx::util::plugin::dll& d, util::section& ini,
         std::string const& curr, std::string const& name, error_code& ec)
     {
-        typedef std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+        typedef std::vector<std::shared_ptr<plugins::plugin_registry_base>>
             plugin_list_type;
 
         plugin_list_type plugin_registries;
-        hpx::util::plugin::plugin_factory<plugins::plugin_registry_base>
-            pf(d, "plugin");
+        hpx::util::plugin::plugin_factory<plugins::plugin_registry_base> pf(
+            d, "plugin");
 
         // retrieve the names of all known registries
         std::vector<std::string> names;
-        pf.get_names(names, ec);      // throws on error
-        if (ec) return plugin_registries;
+        pf.get_names(names, ec);    // throws on error
+        if (ec)
+            return plugin_registries;
 
         std::vector<std::string> ini_data;
-        if (!names.empty()) {
+        if (!names.empty())
+        {
             // ask all registries
             for (std::string const& s : names)
             {
                 // create the plugin registry object
-                std::shared_ptr<plugins::plugin_registry_base>
-                    registry(pf.create(s, ec));
-                if (ec) continue;
+                std::shared_ptr<plugins::plugin_registry_base> registry(
+                    pf.create(s, ec));
+                if (ec)
+                    continue;
 
                 registry->get_plugin_info(ini_data);
                 plugin_registries.push_back(registry);
@@ -355,8 +384,7 @@ namespace hpx { namespace util
         return plugin_registries;
     }
 
-    namespace detail
-    {
+    namespace detail {
         inline bool cmppath_less(
             std::pair<filesystem::path, std::string> const& lhs,
             std::pair<filesystem::path, std::string> const& rhs)
@@ -370,36 +398,38 @@ namespace hpx { namespace util
         {
             return lhs.first == rhs.first;
         }
-    }
+    }    // namespace detail
 
     ///////////////////////////////////////////////////////////////////////////
-    std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+    std::vector<std::shared_ptr<plugins::plugin_registry_base>>
     init_ini_data_default(std::string const& libs, util::section& ini,
         std::map<std::string, filesystem::path>& basenames,
         std::map<std::string, hpx::util::plugin::dll>& modules)
     {
         namespace fs = filesystem;
 
-        typedef std::vector<std::pair<fs::path, std::string> >::iterator
+        typedef std::vector<std::pair<fs::path, std::string>>::iterator
             iterator_type;
 
-        typedef std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+        typedef std::vector<std::shared_ptr<plugins::plugin_registry_base>>
             plugin_list_type;
 
         plugin_list_type plugin_registries;
 
         // list of modules to load
-        std::vector<std::pair<fs::path, std::string> > libdata;
-        try {
+        std::vector<std::pair<fs::path, std::string>> libdata;
+        try
+        {
             fs::directory_iterator nodir;
             fs::path libs_path(libs);
 
             fs::error_code ec;
             if (!fs::exists(libs_path, ec) || ec)
-                return plugin_registries;     // given directory doesn't exist
+                return plugin_registries;    // given directory doesn't exist
 
             // retrieve/create section [hpx.components]
-            if (!ini.has_section("hpx.components")) {
+            if (!ini.has_section("hpx.components"))
+            {
                 util::section* hpx_sec = ini.get_section("hpx");
                 HPX_ASSERT(nullptr != hpx_sec);
 
@@ -423,11 +453,12 @@ namespace hpx { namespace util
                 if (0 == name.find("lib"))
                     name = name.substr(3);
 #endif
-#if defined(__APPLE__) // shared library version is added berfore extension
+#if defined(__APPLE__)    // shared library version is added berfore extension
                 const std::string version = hpx::full_version_as_string();
                 std::string::size_type i = name.find(version);
                 if (i != std::string::npos)
-                    name.erase(i - 1, version.length() + 1); // - 1 for one more dot
+                    name.erase(
+                        i - 1, version.length() + 1);    // - 1 for one more dot
 #endif
                 // ensure base directory, remove symlinks, etc.
                 fs::error_code fsec;
@@ -442,17 +473,21 @@ namespace hpx { namespace util
                 std::pair<std::map<std::string, fs::path>::iterator, bool> p =
                     basenames.insert(std::make_pair(basename, canonical_curr));
 
-                if (p.second) {
+                if (p.second)
+                {
                     libdata.push_back(std::make_pair(canonical_curr, name));
                 }
-                else {
-                    LRT_(warning) << "skipping module " << basename
-                        << " (" << canonical_curr.string() << ")"
-                        << ": ignored because of: " << (*p.first).second.string();
+                else
+                {
+                    LRT_(warning) << "skipping module " << basename << " ("
+                                  << canonical_curr.string() << ")"
+                                  << ": ignored because of: "
+                                  << (*p.first).second.string();
                 }
             }
         }
-        catch (fs::filesystem_error const& e) {
+        catch (fs::filesystem_error const& e)
+        {
             LRT_(info) << "caught filesystem error: " << e.what();
         }
 
@@ -461,14 +496,9 @@ namespace hpx { namespace util
             return plugin_registries;
 
         // make sure each node loads libraries in a different order
-#if defined(HPX_HAVE_CXX11_STD_SHUFFLE)
         std::random_device random_device;
         std::mt19937 generator(random_device());
         std::shuffle(libdata.begin(), libdata.end(), std::move(generator));
-#else
-        std::srand(static_cast<unsigned>(std::time(nullptr)));
-        std::random_shuffle(libdata.begin(), libdata.end());
-#endif
 
         typedef std::pair<fs::path, std::string> libdata_type;
         for (libdata_type const& p : libdata)
@@ -479,10 +509,10 @@ namespace hpx { namespace util
             error_code ec(lightweight);
             hpx::util::plugin::dll d(p.first.string(), p.second);
             d.load_library(ec);
-            if (ec) {
-                LRT_(info)
-                    << "skipping (load_library failed): " << p.first.string()
-                    << ": " << get_error_what(ec);
+            if (ec)
+            {
+                LRT_(info) << "skipping (load_library failed): "
+                           << p.first.string() << ": " << get_error_what(ec);
                 continue;
             }
 
@@ -491,14 +521,14 @@ namespace hpx { namespace util
             // get the component factory
             std::string curr_fullname(p.first.parent_path().string());
             load_component_factory(d, ini, curr_fullname, p.second, ec);
-            if (ec) {
-                LRT_(info)
-                    << "skipping (load_component_factory failed): "
-                    << p.first.string()
-                    << ": " << get_error_what(ec);
-                ec = error_code(lightweight);   // reinit ec
+            if (ec)
+            {
+                LRT_(info) << "skipping (load_component_factory failed): "
+                           << p.first.string() << ": " << get_error_what(ec);
+                ec = error_code(lightweight);    // reinit ec
             }
-            else {
+            else
+            {
                 LRT_(debug)
                     << "load_component_factory succeeded: " << p.first.string();
                 must_keep_loaded = true;
@@ -508,13 +538,13 @@ namespace hpx { namespace util
             plugin_list_type tmp_regs =
                 load_plugin_factory(d, ini, curr_fullname, p.second, ec);
 
-            if (ec) {
-                LRT_(info)
-                    << "skipping (load_plugin_factory failed): "
-                    << p.first.string()
-                    << ": " << get_error_what(ec);
+            if (ec)
+            {
+                LRT_(info) << "skipping (load_plugin_factory failed): "
+                           << p.first.string() << ": " << get_error_what(ec);
             }
-            else {
+            else
+            {
                 LRT_(debug)
                     << "load_plugin_factory succeeded: " << p.first.string();
 
@@ -524,10 +554,11 @@ namespace hpx { namespace util
             }
 
             // store loaded library for future use
-            if (must_keep_loaded) {
+            if (must_keep_loaded)
+            {
                 modules.insert(std::make_pair(p.second, std::move(d)));
             }
         }
         return plugin_registries;
     }
-}}
+}}    // namespace hpx::util
diff --git a/src/util/runtime_configuration.cpp b/libs/runtime_configuration/src/runtime_configuration.cpp
similarity index 70%
rename from src/util/runtime_configuration.cpp
rename to libs/runtime_configuration/src/runtime_configuration.cpp
index a8fa2b9ffb..e64ee210ef 100644
--- a/src/util/runtime_configuration.cpp
+++ b/libs/runtime_configuration/src/runtime_configuration.cpp
@@ -1,25 +1,23 @@
-//  Copyright (c) 2005-2017 Hartmut Kaiser
+//  Copyright (c) 2005-2020 Hartmut Kaiser
 //  Copyright (c)      2011 Bryce Adelstein-Lelbach
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#include <hpx/util/runtime_configuration.hpp>
-
-// TODO: move parcel ports into plugins
 #include <hpx/assertion.hpp>
-#include <hpx/basic_execution/register_locks.hpp>
 #include <hpx/concurrency/itt_notify.hpp>
 #include <hpx/filesystem.hpp>
+#include <hpx/prefix/find_prefix.hpp>
 #include <hpx/preprocessor/expand.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-#include <hpx/runtime/parcelset/parcelhandler.hpp>
-#include <hpx/util/find_prefix.hpp>
-#include <hpx/util/init_ini_data.hpp>
-#include <hpx/util/init_logging.hpp>
-#include <hpx/util/register_locks_globally.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/runtime_configuration/agas_service_mode.hpp>
+#include <hpx/runtime_configuration/component_registry_base.hpp>
+#include <hpx/runtime_configuration/init_ini_data.hpp>
+#include <hpx/runtime_configuration/plugin_registry_base.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
+#include <hpx/util/get_entry_as.hpp>
 #include <hpx/version.hpp>
 
 #include <boost/predef/other/endian.h>
@@ -43,74 +41,38 @@
 #include <vector>
 
 #if defined(HPX_WINDOWS)
-#  include <process.h>
+#include <process.h>
 #elif defined(HPX_HAVE_UNISTD_H)
-#  include <unistd.h>
+#include <unistd.h>
 #endif
 
 #if (defined(__linux) || defined(linux) || defined(__linux__))
+#include <arpa/inet.h>
 #include <ifaddrs.h>
 #include <netinet/in.h>
-#include <arpa/inet.h>
 #include <sys/types.h>
 #endif
 
 #if !defined(HPX_WINDOWS)
-#  if defined(HPX_DEBUG)
-#    define HPX_DLL_STRING  "libhpxd" HPX_SHARED_LIB_EXTENSION
-#  else
-#    define HPX_DLL_STRING  "libhpx" HPX_SHARED_LIB_EXTENSION
-#  endif
+#if defined(HPX_DEBUG)
+#define HPX_DLL_STRING "libhpxd" HPX_SHARED_LIB_EXTENSION
+#else
+#define HPX_DLL_STRING "libhpx" HPX_SHARED_LIB_EXTENSION
+#endif
 #elif defined(HPX_DEBUG)
-#  define HPX_DLL_STRING   "hpxd" HPX_SHARED_LIB_EXTENSION
+#define HPX_DLL_STRING "hpxd" HPX_SHARED_LIB_EXTENSION
 #else
-#  define HPX_DLL_STRING   "hpx" HPX_SHARED_LIB_EXTENSION
+#define HPX_DLL_STRING "hpx" HPX_SHARED_LIB_EXTENSION
 #endif
 
 #include <limits>
 
 ///////////////////////////////////////////////////////////////////////////////
-#if defined(__linux) || defined(linux) || defined(__linux__)\
-         || defined(__FreeBSD__) || defined(__APPLE__)
-namespace hpx { namespace threads { namespace coroutines { namespace detail
-{
-    namespace posix
-    {
-        ///////////////////////////////////////////////////////////////////////
-        // this global (urghhh) variable is used to control whether guard pages
-        // will be used or not
-        HPX_EXPORT bool use_guard_pages = true;
-    }
-}}}}
-#endif
+namespace hpx { namespace parcelset {
+    std::vector<std::string> load_runtime_configuration();
+}}    // namespace hpx::parcelset
 
-namespace hpx { namespace threads { namespace policies
-{
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    ///////////////////////////////////////////////////////////////////////////
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    HPX_EXPORT bool minimal_deadlock_detection = true;
-#endif
-}}}
-
-#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-namespace hpx { namespace util { namespace detail
-{
-    ///////////////////////////////////////////////////////////////////////////
-    // We globally control whether to do minimal deadlock detection in
-    // spin-locks using this global bool variable. It will be set once by the
-    // runtime configuration startup code
-    bool spinlock_break_on_deadlock = false;
-    std::size_t spinlock_deadlock_detection_limit =
-        HPX_SPINLOCK_DEADLOCK_DETECTION_LIMIT;
-}}}
-#endif
-
-///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     // pre-initialize entries with compile time based values
     void runtime_configuration::pre_initialize_ini()
     {
@@ -118,6 +80,7 @@ namespace hpx { namespace util
             return;
 
         std::vector<std::string> lines = {
+            // clang-format off
             // create an empty application section
             "[application]",
 
@@ -209,8 +172,8 @@ namespace hpx { namespace util
 #endif
             "default_scheduler_mode = ${HPX_DEFAULT_SCHEDULER_MODE}",
 
-            /// If HPX_HAVE_ATTACH_DEBUGGER_ON_TEST_FAILURE is set,
-            /// then apply the test-failure value as default.
+        /// If HPX_HAVE_ATTACH_DEBUGGER_ON_TEST_FAILURE is set,
+        /// then apply the test-failure value as default.
 #if defined(HPX_HAVE_ATTACH_DEBUGGER_ON_TEST_FAILURE)
             "attach_debugger = ${HPX_ATTACH_DEBUGGER:test-failure}",
 #else
@@ -241,7 +204,8 @@ namespace hpx { namespace util
                 HPX_PP_EXPAND(HPX_LARGE_STACK_SIZE)) "}",
             "huge_size = ${HPX_HUGE_STACK_SIZE:" HPX_PP_STRINGIZE(
                 HPX_PP_EXPAND(HPX_HUGE_STACK_SIZE)) "}",
-#if defined(__linux) || defined(linux) || defined(__linux__) || defined(__FreeBSD__)
+#if defined(__linux) || defined(linux) || defined(__linux__) ||                \
+    defined(__FreeBSD__)
             "use_guard_pages = ${HPX_USE_GUARD_PAGES:1}",
 #endif
 
@@ -363,11 +327,12 @@ namespace hpx { namespace util
             "name = hpx",
             "path = $[hpx.location]/bin/" HPX_DLL_STRING,
             "enabled = 1"
+            // clang-format on
         };
 
 #if defined(HPX_HAVE_NETWORKING)
         std::vector<std::string> lines_pp =
-            hpx::parcelset::parcelhandler::load_runtime_configuration();
+            hpx::parcelset::load_runtime_configuration();
 
         lines.insert(lines.end(), lines_pp.begin(), lines_pp.end());
 #endif
@@ -378,32 +343,171 @@ namespace hpx { namespace util
         need_to_call_pre_initialize = false;
     }
 
-    void runtime_configuration::post_initialize_ini(
-        std::string& hpx_ini_file_,
+    void runtime_configuration::post_initialize_ini(std::string& hpx_ini_file_,
         std::vector<std::string> const& cmdline_ini_defs_)
     {
         util::init_ini_data_base(*this, hpx_ini_file_);
         need_to_call_pre_initialize = true;
 
         // let the command line override the config file.
-        if (!cmdline_ini_defs_.empty()) {
+        if (!cmdline_ini_defs_.empty())
+        {
             // do not weed out comments
-            this->parse("<command line definitions>", cmdline_ini_defs_,
-                true, false);
+            this->parse(
+                "<command line definitions>", cmdline_ini_defs_, true, false);
             need_to_call_pre_initialize = true;
         }
     }
 
+    void runtime_configuration::pre_initialize_logging_ini()
+    {
+        std::vector<std::string> lines = {
+        // clang-format off
+#if defined(HPX_HAVE_LOGGING)
+#define HPX_TIMEFORMAT "$hh:$mm.$ss.$mili"
+            // general logging
+            "[hpx.logging]",
+            "level = ${HPX_LOGLEVEL:0}",
+            "destination = ${HPX_LOGDESTINATION:console}",
+            "format = ${HPX_LOGFORMAT:"
+                "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
+                "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
+                HPX_TIMEFORMAT ") [%idx%]|\\n}",
+
+            // general console logging
+            "[hpx.logging.console]",
+            "level = ${HPX_LOGLEVEL:$[hpx.logging.level]}",
+#if defined(ANDROID) || defined(__ANDROID__)
+            "destination = ${HPX_CONSOLE_LOGDESTINATION:android_log}",
+#else
+            "destination = ${HPX_CONSOLE_LOGDESTINATION:"
+                "file(hpx.$[system.pid].log)}",
+#endif
+            "format = ${HPX_CONSOLE_LOGFORMAT:|}",
+
+            // logging related to timing
+            "[hpx.logging.timing]",
+            "level = ${HPX_TIMING_LOGLEVEL:-1}",
+            "destination = ${HPX_TIMING_LOGDESTINATION:console}",
+            "format = ${HPX_TIMING_LOGFORMAT:"
+                "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
+                "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
+                HPX_TIMEFORMAT ") [%idx%] [TIM] |\\n}",
+
+            // console logging related to timing
+            "[hpx.logging.console.timing]",
+            "level = ${HPX_TIMING_LOGLEVEL:$[hpx.logging.timing.level]}",
+#if defined(ANDROID) || defined(__ANDROID__)
+            "destination = ${HPX_CONSOLE_TIMING_LOGDESTINATION:android_log}",
+#else
+            "destination = ${HPX_CONSOLE_TIMING_LOGDESTINATION:"
+                "file(hpx.timing.$[system.pid].log)}",
+#endif
+            "format = ${HPX_CONSOLE_TIMING_LOGFORMAT:|}",
+
+            // logging related to AGAS
+            "[hpx.logging.agas]",
+            "level = ${HPX_AGAS_LOGLEVEL:-1}",
+            "destination = ${HPX_AGAS_LOGDESTINATION:"
+                "file(hpx.agas.$[system.pid].log)}",
+            "format = ${HPX_AGAS_LOGFORMAT:"
+                "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
+                "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
+                    HPX_TIMEFORMAT ") [%idx%][AGAS] |\\n}",
+
+            // console logging related to AGAS
+            "[hpx.logging.console.agas]",
+            "level = ${HPX_AGAS_LOGLEVEL:$[hpx.logging.agas.level]}",
+#if defined(ANDROID) || defined(__ANDROID__)
+            "destination = ${HPX_CONSOLE_AGAS_LOGDESTINATION:android_log}",
+#else
+            "destination = ${HPX_CONSOLE_AGAS_LOGDESTINATION:"
+                "file(hpx.agas.$[system.pid].log)}",
+#endif
+            "format = ${HPX_CONSOLE_AGAS_LOGFORMAT:|}",
+
+            // logging related to the parcel transport
+            "[hpx.logging.parcel]",
+            "level = ${HPX_PARCEL_LOGLEVEL:-1}",
+            "destination = ${HPX_PARCEL_LOGDESTINATION:"
+                "file(hpx.parcel.$[system.pid].log)}",
+            "format = ${HPX_PARCEL_LOGFORMAT:"
+                "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
+                "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
+                HPX_TIMEFORMAT ") [%idx%][  PT] |\\n}",
+
+            // console logging related to the parcel transport
+            "[hpx.logging.console.parcel]",
+            "level = ${HPX_PARCEL_LOGLEVEL:$[hpx.logging.parcel.level]}",
+#if defined(ANDROID) || defined(__ANDROID__)
+            "destination = ${HPX_CONSOLE_PARCEL_LOGDESTINATION:android_log}",
+#else
+            "destination = ${HPX_CONSOLE_PARCEL_LOGDESTINATION:"
+                "file(hpx.parcel.$[system.pid].log)}",
+#endif
+            "format = ${HPX_CONSOLE_PARCEL_LOGFORMAT:|}",
+
+            // logging related to applications
+            "[hpx.logging.application]",
+            "level = ${HPX_APP_LOGLEVEL:-1}",
+            "destination = ${HPX_APP_LOGDESTINATION:console}",
+            "format = ${HPX_APP_LOGFORMAT:"
+                "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
+                "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
+                HPX_TIMEFORMAT ") [%idx%] [APP] |\\n}",
+
+            // console logging related to applications
+            "[hpx.logging.console.application]",
+            "level = ${HPX_APP_LOGLEVEL:$[hpx.logging.application.level]}",
+#if defined(ANDROID) || defined(__ANDROID__)
+            "destination = ${HPX_CONSOLE_APP_LOGDESTINATION:android_log}",
+#else
+            "destination = ${HPX_CONSOLE_APP_LOGDESTINATION:"
+                "file(hpx.application.$[system.pid].log)}",
+#endif
+            "format = ${HPX_CONSOLE_APP_LOGFORMAT:|}",
+
+            // logging of debug channel
+            "[hpx.logging.debuglog]",
+            "level = ${HPX_DEB_LOGLEVEL:-1}",
+            "destination = ${HPX_DEB_LOGDESTINATION:console}",
+            "format = ${HPX_DEB_LOGFORMAT:"
+                "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
+                "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
+                HPX_TIMEFORMAT ") [%idx%] [DEB] |\\n}",
+
+            "[hpx.logging.console.debuglog]",
+            "level = ${HPX_DEB_LOGLEVEL:$[hpx.logging.debuglog.level]}",
+#if defined(ANDROID) || defined(__ANDROID__)
+            "destination = ${HPX_CONSOLE_DEB_LOGDESTINATION:android_log}",
+#else
+            "destination = ${HPX_CONSOLE_DEB_LOGDESTINATION:"
+                "file(hpx.debuglog.$[system.pid].log)}",
+#endif
+            "format = ${HPX_CONSOLE_DEB_LOGFORMAT:|}"
+
+#undef HPX_TIMEFORMAT
+#endif
+            // clang-format on
+        };
+
+        // don't overload user overrides
+        this->parse("<static logging defaults>", lines, false, false);
+    }
+
     ///////////////////////////////////////////////////////////////////////////
     // load information about statically known components
-    void runtime_configuration::load_components_static(std::vector<
-        components::static_factory_load_data_type> const& static_modules)
+    void runtime_configuration::load_components_static(
+        std::vector<components::static_factory_load_data_type> const&
+            static_modules)
     {
-        std::vector<std::shared_ptr<components::component_registry_base>> registries;
-        for (components::static_factory_load_data_type const& d : static_modules)
+        std::vector<std::shared_ptr<components::component_registry_base>>
+            registries;
+        for (components::static_factory_load_data_type const& d :
+            static_modules)
         {
-            auto new_registries =
-                util::load_component_factory_static(*this, d.name, d.get_factory);
+            auto new_registries = util::load_component_factory_static(
+                *this, d.name, d.get_factory);
             registries.reserve(registries.size() + new_registries.size());
             std::copy(new_registries.begin(), new_registries.end(),
                 std::back_inserter(registries));
@@ -424,7 +528,7 @@ namespace hpx { namespace util
 
         // invoke last reconfigure
         reconfigure();
-        for (auto& registry: registries)
+        for (auto& registry : registries)
         {
             registry->register_component_type();
         }
@@ -435,8 +539,7 @@ namespace hpx { namespace util
     void runtime_configuration::load_component_path(
         std::vector<std::shared_ptr<plugins::plugin_registry_base>>&
             plugin_registries,
-        std::string const& path,
-        std::set<std::string>& component_paths,
+        std::string const& path, std::set<std::string>& component_paths,
         std::map<std::string, filesystem::path>& basenames)
     {
         namespace fs = filesystem;
@@ -459,12 +562,11 @@ namespace hpx { namespace util
             if (p.second)
             {
                 // have all path elements, now find ini files in there...
-                fs::path this_path (*p.first);
+                fs::path this_path(*p.first);
                 if (fs::exists(this_path, fsec) && !fsec)
                 {
-                    plugin_list_type tmp_regs =
-                        util::init_ini_data_default(this_path.string(),
-                            *this, basenames, modules_);
+                    plugin_list_type tmp_regs = util::init_ini_data_default(
+                        this_path.string(), *this, basenames, modules_);
 
                     std::copy(tmp_regs.begin(), tmp_regs.end(),
                         std::back_inserter(plugin_registries));
@@ -487,9 +589,9 @@ namespace hpx { namespace util
         // installation location, this allows to install simple components
         // without the need to install an ini file
         // split of the separate paths from the given path list
-        typedef boost::tokenizer<boost::char_separator<char> > tokenizer_type;
+        typedef boost::tokenizer<boost::char_separator<char>> tokenizer_type;
 
-        boost::char_separator<char> sep (HPX_INI_PATH_DELIMITER);
+        boost::char_separator<char> sep(HPX_INI_PATH_DELIMITER);
         tokenizer_type tok_path(component_base_paths, sep);
         tokenizer_type tok_suffixes(component_path_suffixes, sep);
         tokenizer_type::iterator end_path = tok_path.end();
@@ -502,7 +604,7 @@ namespace hpx { namespace util
             if (tok_suffixes.begin() != tok_suffixes.end())
             {
                 for (tokenizer_type::iterator jt = tok_suffixes.begin();
-                    jt != end_suffixes; ++jt)
+                     jt != end_suffixes; ++jt)
                 {
                     std::string p = path;
                     p += *jt;
@@ -519,10 +621,10 @@ namespace hpx { namespace util
     }
 
     // load information about dynamically discovered plugins
-    std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+    std::vector<std::shared_ptr<plugins::plugin_registry_base>>
     runtime_configuration::load_modules()
     {
-        typedef std::vector<std::shared_ptr<plugins::plugin_registry_base> >
+        typedef std::vector<std::shared_ptr<plugins::plugin_registry_base>>
             plugin_list_type;
 
         // protect against duplicate paths
@@ -568,16 +670,17 @@ namespace hpx { namespace util
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    runtime_configuration::runtime_configuration(char const* argv0_, runtime_mode mode)
-      : mode_(mode),
-        num_localities(0),
-        small_stacksize(HPX_SMALL_STACK_SIZE),
-        medium_stacksize(HPX_MEDIUM_STACK_SIZE),
-        large_stacksize(HPX_LARGE_STACK_SIZE),
-        huge_stacksize(HPX_HUGE_STACK_SIZE),
-        need_to_call_pre_initialize(true)
+    runtime_configuration::runtime_configuration(
+        char const* argv0_, runtime_mode mode)
+      : mode_(mode)
+      , num_localities(0)
+      , small_stacksize(HPX_SMALL_STACK_SIZE)
+      , medium_stacksize(HPX_MEDIUM_STACK_SIZE)
+      , large_stacksize(HPX_LARGE_STACK_SIZE)
+      , huge_stacksize(HPX_HUGE_STACK_SIZE)
+      , need_to_call_pre_initialize(true)
 #if defined(__linux) || defined(linux) || defined(__linux__)
-        , argv0(argv0_)
+      , argv0(argv0_)
 #endif
     {
         pre_initialize_ini();
@@ -593,34 +696,10 @@ namespace hpx { namespace util
         large_stacksize = init_large_stack_size();
         HPX_ASSERT(init_huge_stack_size() <= HPX_HUGE_STACK_SIZE);
         huge_stacksize = init_huge_stack_size();
-
-#if defined(__linux) || defined(linux) || defined(__linux__) || defined(__FreeBSD__)
-        threads::coroutines::detail::posix::use_guard_pages =
-            init_use_stack_guard_pages();
-#endif
-#ifdef HPX_HAVE_VERIFY_LOCKS
-        if (enable_lock_detection())
-            util::enable_lock_detection();
-#endif
-#ifdef HPX_HAVE_VERIFY_LOCKS_GLOBALLY
-        if (enable_global_lock_detection())
-            util::enable_global_lock_detection();
-#endif
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-        threads::policies::minimal_deadlock_detection =
-            enable_minimal_deadlock_detection();
-#endif
-#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-        util::detail::spinlock_break_on_deadlock =
-            enable_spinlock_deadlock_detection();
-        util::detail::spinlock_deadlock_detection_limit =
-            get_spinlock_deadlock_detection_limit();
-#endif
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    void runtime_configuration::reconfigure(
-        std::string const& hpx_ini_file_)
+    void runtime_configuration::reconfigure(std::string const& hpx_ini_file_)
     {
         hpx_ini_file = hpx_ini_file_;
         reconfigure();
@@ -636,12 +715,7 @@ namespace hpx { namespace util
     void runtime_configuration::reconfigure()
     {
         pre_initialize_ini();
-
-        std::vector<std::string> const& prefill =
-            util::detail::get_logging_data();
-        if (!prefill.empty())
-            this->parse("<static prefill defaults>", prefill, false, false);
-
+        pre_initialize_logging_ini();
         post_initialize_ini(hpx_ini_file, cmdline_ini_defs);
 
         // set global config options
@@ -654,40 +728,17 @@ namespace hpx { namespace util
         medium_stacksize = init_medium_stack_size();
         large_stacksize = init_large_stack_size();
         huge_stacksize = init_huge_stack_size();
-
-#if defined(__linux) || defined(linux) || defined(__linux__) || defined(__FreeBSD__)
-        threads::coroutines::detail::posix::use_guard_pages =
-            init_use_stack_guard_pages();
-#endif
-#ifdef HPX_HAVE_VERIFY_LOCKS
-        if (enable_lock_detection())
-            util::enable_lock_detection();
-#endif
-#ifdef HPX_HAVE_VERIFY_LOCKS_GLOBALLY
-        if (enable_global_lock_detection())
-            util::enable_global_lock_detection();
-#endif
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-        threads::policies::minimal_deadlock_detection =
-            enable_minimal_deadlock_detection();
-#endif
-#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-        util::detail::spinlock_break_on_deadlock =
-            enable_spinlock_deadlock_detection();
-        util::detail::spinlock_deadlock_detection_limit =
-            get_spinlock_deadlock_detection_limit();
-#endif
     }
 
     std::size_t runtime_configuration::get_ipc_data_buffer_cache_size() const
     {
         if (has_section("hpx.parcel"))
         {
-            util::section const * sec = get_section("hpx.parcel.ipc");
-            if(nullptr != sec)
+            util::section const* sec = get_section("hpx.parcel.ipc");
+            if (nullptr != sec)
             {
-                return hpx::util::get_entry_as<std::size_t>(
-                    *sec, "data_buffer_cache_size",
+                return hpx::util::get_entry_as<std::size_t>(*sec,
+                    "data_buffer_cache_size",
                     HPX_PARCEL_IPC_DATA_BUFFER_CACHE_SIZE);
             }
         }
@@ -708,7 +759,8 @@ namespace hpx { namespace util
                     return agas::service_mode_hosted;
                 else if (m == "bootstrap")
                     return agas::service_mode_bootstrap;
-                else {
+                else
+                {
                     // REVIEW: exception type is overused
                     HPX_THROW_EXCEPTION(bad_parameter,
                         "runtime_configuration::get_agas_service_mode",
@@ -721,10 +773,13 @@ namespace hpx { namespace util
 
     std::uint32_t runtime_configuration::get_num_localities() const
     {
-        if (num_localities == 0) {
-            if (has_section("hpx")) {
+        if (num_localities == 0)
+        {
+            if (has_section("hpx"))
+            {
                 util::section const* sec = get_section("hpx");
-                if (nullptr != sec) {
+                if (nullptr != sec)
+                {
                     num_localities = hpx::util::get_entry_as<std::uint32_t>(
                         *sec, "localities", 1);
                 }
@@ -735,17 +790,19 @@ namespace hpx { namespace util
         return num_localities;
     }
 
-    void runtime_configuration::set_num_localities(std::uint32_t num_localities_)
+    void runtime_configuration::set_num_localities(
+        std::uint32_t num_localities_)
     {
         // this function should not be called on the AGAS server
         HPX_ASSERT(agas::service_mode_bootstrap != get_agas_service_mode());
         num_localities = num_localities_;
 
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section* sec = get_section("hpx");
-            if (nullptr != sec) {
-                sec->add_entry("localities",
-                    std::to_string(num_localities));
+            if (nullptr != sec)
+            {
+                sec->add_entry("localities", std::to_string(num_localities));
             }
         }
     }
@@ -761,7 +818,7 @@ namespace hpx { namespace util
             {
                 // get the number of initial localities
                 if (hpx::util::get_entry_as<std::uint32_t>(
-                      *sec, "localities", 1) > 1)
+                        *sec, "localities", 1) > 1)
                 {
                     return true;
                 }
@@ -795,9 +852,11 @@ namespace hpx { namespace util
 
     std::uint32_t runtime_configuration::get_first_used_core() const
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<std::uint32_t>(
                     *sec, "first_used_core", 0);
             }
@@ -808,39 +867,46 @@ namespace hpx { namespace util
     void runtime_configuration::set_first_used_core(
         std::uint32_t first_used_core)
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section* sec = get_section("hpx");
-            if (nullptr != sec) {
-                sec->add_entry("first_used_core",
-                    std::to_string(first_used_core));
+            if (nullptr != sec)
+            {
+                sec->add_entry(
+                    "first_used_core", std::to_string(first_used_core));
             }
         }
     }
 
-    std::size_t runtime_configuration::get_agas_local_cache_size(std::size_t dflt) const
+    std::size_t runtime_configuration::get_agas_local_cache_size(
+        std::size_t dflt) const
     {
         std::size_t cache_size = dflt;
 
-        if (has_section("hpx.agas")) {
+        if (has_section("hpx.agas"))
+        {
             util::section const* sec = get_section("hpx.agas");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 cache_size = hpx::util::get_entry_as<std::size_t>(
                     *sec, "local_cache_size", cache_size);
             }
         }
 
         if (cache_size != std::size_t(~0x0ul) && cache_size < 16ul)
-            cache_size = 16;      // limit lower bound
+            cache_size = 16;    // limit lower bound
         return cache_size;
     }
 
     bool runtime_configuration::get_agas_caching_mode() const
     {
-        if (has_section("hpx.agas")) {
+        if (has_section("hpx.agas"))
+        {
             util::section const* sec = get_section("hpx.agas");
-            if (nullptr != sec) {
-                return hpx::util::get_entry_as<int>(
-                    *sec, "use_caching", "1") != 0;
+            if (nullptr != sec)
+            {
+                return hpx::util::get_entry_as<int>(*sec, "use_caching", 1) !=
+                    0;
             }
         }
         return false;
@@ -848,24 +914,28 @@ namespace hpx { namespace util
 
     bool runtime_configuration::get_agas_range_caching_mode() const
     {
-        if (has_section("hpx.agas")) {
+        if (has_section("hpx.agas"))
+        {
             util::section const* sec = get_section("hpx.agas");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<int>(
-                    *sec, "use_range_caching", "1") != 0;
+                           *sec, "use_range_caching", 1) != 0;
             }
         }
         return false;
     }
 
-    std::size_t
-    runtime_configuration::get_agas_max_pending_refcnt_requests() const
+    std::size_t runtime_configuration::get_agas_max_pending_refcnt_requests()
+        const
     {
-        if (has_section("hpx.agas")) {
+        if (has_section("hpx.agas"))
+        {
             util::section const* sec = get_section("hpx.agas");
-            if (nullptr != sec) {
-                return hpx::util::get_entry_as<std::size_t>(
-                    *sec, "max_pending_refcnt_requests",
+            if (nullptr != sec)
+            {
+                return hpx::util::get_entry_as<std::size_t>(*sec,
+                    "max_pending_refcnt_requests",
                     HPX_INITIAL_AGAS_MAX_PENDING_REFCNT_REQUESTS);
             }
         }
@@ -875,11 +945,13 @@ namespace hpx { namespace util
     bool runtime_configuration::get_itt_notify_mode() const
     {
 #if HPX_HAVE_ITTNOTIFY != 0
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<int>(
-                    *sec, "use_itt_notify", "0") != 0;
+                           *sec, "use_itt_notify", 0) != 0;
             }
         }
 #endif
@@ -890,11 +962,13 @@ namespace hpx { namespace util
     bool runtime_configuration::enable_lock_detection() const
     {
 #ifdef HPX_HAVE_VERIFY_LOCKS
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<int>(
-                    *sec, "lock_detection", "0") != 0;
+                           *sec, "lock_detection", 0) != 0;
             }
         }
 #endif
@@ -905,11 +979,13 @@ namespace hpx { namespace util
     bool runtime_configuration::enable_global_lock_detection() const
     {
 #ifdef HPX_HAVE_VERIFY_LOCKS_GLOBALLY
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<int>(
-                    *sec, "global_lock_detection", "0") != 0;
+                           *sec, "global_lock_detection", 0) != 0;
             }
         }
 #endif
@@ -920,15 +996,17 @@ namespace hpx { namespace util
     bool runtime_configuration::enable_minimal_deadlock_detection() const
     {
 #ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
 #ifdef HPX_DEBUG
                 return hpx::util::get_entry_as<int>(
-                    *sec, "minimal_deadlock_detection", "1") != 0;
+                           *sec, "minimal_deadlock_detection", 1) != 0;
 #else
                 return hpx::util::get_entry_as<int>(
-                    *sec, "minimal_deadlock_detection", "0") != 0;
+                           *sec, "minimal_deadlock_detection", 0) != 0;
 #endif
             }
         }
@@ -948,15 +1026,17 @@ namespace hpx { namespace util
     bool runtime_configuration::enable_spinlock_deadlock_detection() const
     {
 #ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
 #ifdef HPX_DEBUG
                 return hpx::util::get_entry_as<int>(
-                    *sec, "spinlock_deadlock_detection", "1") != 0;
+                           *sec, "spinlock_deadlock_detection", 1) != 0;
 #else
                 return hpx::util::get_entry_as<int>(
-                    *sec, "spinlock_deadlock_detection", "0") != 0;
+                           *sec, "spinlock_deadlock_detection", 0) != 0;
 #endif
             }
         }
@@ -973,16 +1053,18 @@ namespace hpx { namespace util
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    std::size_t runtime_configuration::get_spinlock_deadlock_detection_limit() const
+    std::size_t runtime_configuration::get_spinlock_deadlock_detection_limit()
+        const
     {
 #ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<std::size_t>(*sec,
                     "spinlock_deadlock_detection_limit",
-                    HPX_PP_STRINGIZE(
-                        HPX_PP_EXPAND(HPX_SPINLOCK_DEADLOCK_DETECTION_LIMIT)));
+                    HPX_SPINLOCK_DEADLOCK_DETECTION_LIMIT);
             }
         }
         return HPX_SPINLOCK_DEADLOCK_DETECTION_LIMIT;
@@ -993,9 +1075,11 @@ namespace hpx { namespace util
 
     std::size_t runtime_configuration::get_os_thread_count() const
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<std::size_t>(
                     *sec, "os_threads", 1);
             }
@@ -1005,9 +1089,11 @@ namespace hpx { namespace util
 
     std::string runtime_configuration::get_cmd_line() const
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return sec->get_entry("cmd_line", "");
             }
         }
@@ -1015,24 +1101,29 @@ namespace hpx { namespace util
     }
 
     // Return the configured sizes of any of the know thread pools
-    std::size_t runtime_configuration::get_thread_pool_size(char const* poolname) const
+    std::size_t runtime_configuration::get_thread_pool_size(
+        char const* poolname) const
     {
-        if (has_section("hpx.threadpools")) {
+        if (has_section("hpx.threadpools"))
+        {
             util::section const* sec = get_section("hpx.threadpools");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<std::size_t>(
-                    *sec, std::string(poolname) + "_size", "2");
+                    *sec, std::string(poolname) + "_size", 2);
             }
         }
-        return 2;     // the default size for all pools is 2
+        return 2;    // the default size for all pools is 2
     }
 
-    // Return the endianess to be used for out-serialization
+    // Return the endianness to be used for out-serialization
     std::string runtime_configuration::get_endian_out() const
     {
-        if (has_section("hpx.parcel")) {
+        if (has_section("hpx.parcel"))
+        {
             util::section const* sec = get_section("hpx.parcel");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
 #if BOOST_ENDIAN_BIG_BYTE
                 return sec->get_entry("endian_out", "big");
 #else
@@ -1048,13 +1139,14 @@ namespace hpx { namespace util
     }
 
     // Will return the stack size to use for all HPX-threads.
-    std::ptrdiff_t runtime_configuration::init_stack_size(
-        char const* entryname, char const* defaultvaluestr,
-        std::ptrdiff_t defaultvalue) const
+    std::ptrdiff_t runtime_configuration::init_stack_size(char const* entryname,
+        char const* defaultvaluestr, std::ptrdiff_t defaultvalue) const
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx.stacks");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 std::string entry = sec->get_entry(entryname, defaultvaluestr);
                 std::ptrdiff_t val = defaultvalue;
 
@@ -1067,14 +1159,17 @@ namespace hpx { namespace util
         return defaultvalue;
     }
 
-#if defined(__linux) || defined(linux) || defined(__linux__) || defined(__FreeBSD__)
-    bool runtime_configuration::init_use_stack_guard_pages() const
+#if defined(__linux) || defined(linux) || defined(__linux__) ||                \
+    defined(__FreeBSD__)
+    bool runtime_configuration::use_stack_guard_pages() const
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx.stacks");
-            if (nullptr != sec) {
+            if (nullptr != sec)
+            {
                 return hpx::util::get_entry_as<int>(
-                    *sec, "use_guard_pages", "1") != 0;
+                           *sec, "use_guard_pages", 1) != 0;
             }
         }
         return true;    // default is true
@@ -1109,12 +1204,13 @@ namespace hpx { namespace util
     // Return maximally allowed message size
     std::uint64_t runtime_configuration::get_max_inbound_message_size() const
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx.parcel");
-            if (nullptr != sec) {
-                std::uint64_t maxsize =
-                    hpx::util::get_entry_as<std::uint64_t>(
-                        *sec, "max_message_size", HPX_PARCEL_MAX_MESSAGE_SIZE);
+            if (nullptr != sec)
+            {
+                std::uint64_t maxsize = hpx::util::get_entry_as<std::uint64_t>(
+                    *sec, "max_message_size", HPX_PARCEL_MAX_MESSAGE_SIZE);
                 if (maxsize > 0)
                     return maxsize;
             }
@@ -1124,13 +1220,14 @@ namespace hpx { namespace util
 
     std::uint64_t runtime_configuration::get_max_outbound_message_size() const
     {
-        if (has_section("hpx")) {
+        if (has_section("hpx"))
+        {
             util::section const* sec = get_section("hpx.parcel");
-            if (nullptr != sec) {
-                std::uint64_t maxsize =
-                    hpx::util::get_entry_as<std::uint64_t>(
-                        *sec, "max_outbound_message_size",
-                        HPX_PARCEL_MAX_OUTBOUND_MESSAGE_SIZE);
+            if (nullptr != sec)
+            {
+                std::uint64_t maxsize = hpx::util::get_entry_as<std::uint64_t>(
+                    *sec, "max_outbound_message_size",
+                    HPX_PARCEL_MAX_OUTBOUND_MESSAGE_SIZE);
                 if (maxsize > 0)
                     return maxsize;
             }
@@ -1142,13 +1239,15 @@ namespace hpx { namespace util
     bool runtime_configuration::load_application_configuration(
         char const* filename, error_code& ec)
     {
-        try {
+        try
+        {
             section appcfg(filename);
             section applroot;
             applroot.add_section("application", appcfg);
             this->section::merge(applroot);
         }
-        catch (hpx::exception const& e) {
+        catch (hpx::exception const& e)
+        {
             // file doesn't exist or is ill-formed
             if (&ec == &throws)
                 throw;
@@ -1162,7 +1261,8 @@ namespace hpx { namespace util
     std::ptrdiff_t runtime_configuration::get_stack_size(
         threads::thread_stacksize stacksize) const
     {
-        switch (stacksize) {
+        switch (stacksize)
+        {
         case threads::thread_stacksize_medium:
             return medium_stacksize;
 
@@ -1181,5 +1281,4 @@ namespace hpx { namespace util
         }
         return small_stacksize;
     }
-}}
-
+}}    // namespace hpx::util
diff --git a/libs/runtime_configuration/src/runtime_mode.cpp b/libs/runtime_configuration/src/runtime_mode.cpp
new file mode 100644
index 0000000000..6bd65c4722
--- /dev/null
+++ b/libs/runtime_configuration/src/runtime_mode.cpp
@@ -0,0 +1,43 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2012 Bryce Adelstein-Lelbach
+//  Copyright (c) 2012-2017 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#include <hpx/config.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
+
+#include <cstddef>
+#include <string>
+
+namespace hpx {
+    namespace strings {
+        char const* const runtime_mode_names[] = {
+            "invalid",    // -1
+            "console",    // 0
+            "worker",     // 1
+            "connect",    // 2
+            "default",    // 3
+        };
+    }
+
+    char const* get_runtime_mode_name(runtime_mode state)
+    {
+        if (state < runtime_mode_invalid || state >= runtime_mode_last)
+            return "invalid (value out of bounds)";
+        return strings::runtime_mode_names[state + 1];
+    }
+
+    runtime_mode get_runtime_mode_from_name(std::string const& mode)
+    {
+        for (std::size_t i = 0; i < runtime_mode_last; ++i)
+        {
+            if (mode == strings::runtime_mode_names[i])
+                return static_cast<runtime_mode>(i - 1);
+        }
+        return runtime_mode_invalid;
+    }
+}    // namespace hpx
diff --git a/libs/runtime_configuration/tests/CMakeLists.txt b/libs/runtime_configuration/tests/CMakeLists.txt
new file mode 100644
index 0000000000..41755a69d2
--- /dev/null
+++ b/libs/runtime_configuration/tests/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_RUNTIME_CONFIGURATION_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_RUNTIME_CONFIGURATION_WITH_TESTS)
+  if (HPX_WITH_TESTS_UNIT)
+    add_hpx_pseudo_target(tests.unit.modules.runtime_configuration)
+    add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.runtime_configuration)
+    add_subdirectory(unit)
+  endif()
+
+  if (HPX_WITH_TESTS_REGRESSIONS)
+    add_hpx_pseudo_target(tests.regressions.modules.runtime_configuration)
+    add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.runtime_configuration)
+    add_subdirectory(regressions)
+  endif()
+
+  if (HPX_WITH_TESTS_BENCHMARKS)
+    add_hpx_pseudo_target(tests.performance.modules.runtime_configuration)
+    add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.runtime_configuration)
+    add_subdirectory(performance)
+  endif()
+
+  if (HPX_WITH_TESTS_HEADERS)
+    add_hpx_header_tests(
+      modules.runtime_configuration
+      HEADERS ${runtime_configuration_headers}
+      HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+      DEPENDENCIES hpx_runtime_configuration)
+  endif()
+endif()
diff --git a/libs/runtime_configuration/tests/performance/CMakeLists.txt b/libs/runtime_configuration/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/runtime_configuration/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/runtime_configuration/tests/regressions/CMakeLists.txt b/libs/runtime_configuration/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/runtime_configuration/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/runtime_configuration/tests/unit/CMakeLists.txt b/libs/runtime_configuration/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/runtime_configuration/tests/unit/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/schedulers/CMakeLists.txt b/libs/schedulers/CMakeLists.txt
new file mode 100644
index 0000000000..1307e82418
--- /dev/null
+++ b/libs/schedulers/CMakeLists.txt
@@ -0,0 +1,49 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(schedulers_headers
+  hpx/schedulers/deadlock_detection.hpp
+  hpx/schedulers/local_priority_queue_scheduler.hpp
+  hpx/schedulers/local_queue_scheduler.hpp
+  hpx/schedulers/lockfree_queue_backends.hpp
+  hpx/schedulers/maintain_queue_wait_times.hpp
+  hpx/schedulers/queue_helpers.hpp
+  hpx/schedulers/shared_priority_queue_scheduler.hpp
+  hpx/schedulers/static_priority_queue_scheduler.hpp
+  hpx/schedulers/static_queue_scheduler.hpp
+  hpx/schedulers/thread_queue.hpp
+  hpx/schedulers/thread_queue_mc.hpp
+  hpx/schedulers.hpp)
+
+set(schedulers_compat_headers
+  hpx/runtime/threads/policies/deadlock_detection.hpp
+  hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp
+  hpx/runtime/threads/policies/local_queue_scheduler.hpp
+  hpx/runtime/threads/policies/lockfree_queue_backends.hpp
+  hpx/runtime/threads/policies/maintain_queue_wait_times.hpp
+  hpx/runtime/threads/policies/queue_helpers.hpp
+  hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp
+  hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp
+  hpx/runtime/threads/policies/static_queue_scheduler.hpp
+  hpx/runtime/threads/policies/thread_queue.hpp
+  hpx/runtime/threads/policies/thread_queue_mc.hpp
+  hpx/runtime/threads/policies/schedulers.hpp)
+
+include(HPX_AddModule)
+add_hpx_module(schedulers
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN OFF
+  HEADERS ${schedulers_headers}
+  COMPAT_HEADERS ${schedulers_compat_headers}
+  DEPENDENCIES hpx_threading_base
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/schedulers/README.rst b/libs/schedulers/README.rst
new file mode 100644
index 0000000000..25b3d9f54a
--- /dev/null
+++ b/libs/schedulers/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+==========
+schedulers
+==========
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/schedulers/docs/index.html>`__.
diff --git a/libs/schedulers/docs/index.rst b/libs/schedulers/docs/index.rst
new file mode 100644
index 0000000000..b6969eff07
--- /dev/null
+++ b/libs/schedulers/docs/index.rst
@@ -0,0 +1,18 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_schedulers:
+
+==========
+schedulers
+==========
+
+TODO: High-level description of the library.
+
+See the :ref:`API reference <libs_schedulers_api>` of this module for more
+details.
+
diff --git a/libs/schedulers/examples/CMakeLists.txt b/libs/schedulers/examples/CMakeLists.txt
new file mode 100644
index 0000000000..a661f6694d
--- /dev/null
+++ b/libs/schedulers/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.schedulers)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.schedulers)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_SCHEDULERS_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.schedulers)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.schedulers)
+  endif()
+endif()
diff --git a/hpx/runtime/threads/policies/schedulers.hpp b/libs/schedulers/include/hpx/schedulers.hpp
similarity index 62%
rename from hpx/runtime/threads/policies/schedulers.hpp
rename to libs/schedulers/include/hpx/schedulers.hpp
index 771f3f4441..260951ee01 100644
--- a/hpx/runtime/threads/policies/schedulers.hpp
+++ b/libs/schedulers/include/hpx/schedulers.hpp
@@ -10,16 +10,16 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_LOCAL_SCHEDULER)
-#include <hpx/runtime/threads/policies/local_queue_scheduler.hpp>
+#include <hpx/schedulers/local_queue_scheduler.hpp>
 #endif
 #if defined(HPX_HAVE_STATIC_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_queue_scheduler.hpp>
+#include <hpx/schedulers/static_queue_scheduler.hpp>
 #endif
-#include <hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/local_priority_queue_scheduler.hpp>
 #if defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/static_priority_queue_scheduler.hpp>
 #endif
 #if defined(HPX_HAVE_SHARED_PRIORITY_SCHEDULER)
-#include <hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/shared_priority_queue_scheduler.hpp>
 #endif
 #endif
diff --git a/libs/schedulers/include/hpx/schedulers/deadlock_detection.hpp b/libs/schedulers/include/hpx/schedulers/deadlock_detection.hpp
new file mode 100644
index 0000000000..30ffe5072d
--- /dev/null
+++ b/libs/schedulers/include/hpx/schedulers/deadlock_detection.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2005-2017 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Adelstein-Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_RUNTIME_THREADS_POLICIES_DEADLOCK_DETECTION_HPP
+#define HPX_RUNTIME_THREADS_POLICIES_DEADLOCK_DETECTION_HPP
+
+#include <hpx/config.hpp>
+
+namespace hpx { namespace threads { namespace policies {
+#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
+    HPX_EXPORT void set_minimal_deadlock_detection_enabled(bool enabled);
+    HPX_EXPORT bool get_minimal_deadlock_detection_enabled();
+#endif
+}}}    // namespace hpx::threads::policies
+
+#endif
diff --git a/hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp b/libs/schedulers/include/hpx/schedulers/local_priority_queue_scheduler.hpp
similarity index 97%
rename from hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp
rename to libs/schedulers/include/hpx/schedulers/local_priority_queue_scheduler.hpp
index c633d28704..882adcf744 100644
--- a/hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp
+++ b/libs/schedulers/include/hpx/schedulers/local_priority_queue_scheduler.hpp
@@ -10,18 +10,19 @@
 #define HPX_THREADMANAGER_SCHEDULING_LOCAL_PRIORITY_QUEUE_MAR_15_2011_0926AM
 
 #include <hpx/config.hpp>
+#include <hpx/affinity/affinity_data.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/concurrency/cache_line_data.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/functional.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/affinity/affinity_data.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/policies/thread_queue.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/schedulers/thread_queue.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util_fwd.hpp>
 
 #include <atomic>
 #include <cmath>
@@ -40,14 +41,6 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads { namespace policies {
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    ///////////////////////////////////////////////////////////////////////////
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    extern bool minimal_deadlock_detection;
-#endif
-
     ///////////////////////////////////////////////////////////////////////////
 #if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
     using default_local_priority_queue_scheduler_terminated_queue =
@@ -157,7 +150,7 @@ namespace hpx { namespace threads { namespace policies {
             }
         }
 
-        virtual ~local_priority_queue_scheduler()
+        ~local_priority_queue_scheduler() override
         {
             for (std::size_t i = 0; i != num_queues_; ++i)
             {
@@ -734,12 +727,10 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         /// Destroy the passed thread as it has been terminated
-        void destroy_thread(
-            threads::thread_data* thrd, std::int64_t& busy_count) override
+        void destroy_thread(threads::thread_data* thrd) override
         {
             HPX_ASSERT(thrd->get_scheduler_base() == this);
-            thrd->get_queue<thread_queue_type>().destroy_thread(
-                thrd, busy_count);
+            thrd->get_queue<thread_queue_type>().destroy_thread(thrd);
         }
 
         ///////////////////////////////////////////////////////////////////////
@@ -832,8 +823,7 @@ namespace hpx { namespace threads { namespace policies {
                 case thread_priority_unknown:
                 {
                     HPX_THROW_EXCEPTION(bad_parameter,
-                        "local_priority_queue_scheduler::get_thread_"
-                        "count",
+                        "local_priority_queue_scheduler::get_thread_count",
                         "unknown thread priority value "
                         "(thread_priority_unknown)");
                     return 0;
@@ -1098,7 +1088,8 @@ namespace hpx { namespace threads { namespace policies {
 
 #ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
             // no new work is available, are we deadlocked?
-            if (HPX_UNLIKELY(minimal_deadlock_detection && LHPX_ENABLED(error)))
+            if (HPX_UNLIKELY(get_minimal_deadlock_detection_enabled() &&
+                    LHPX_ENABLED(error)))
             {
                 bool suspended_only = true;
 
@@ -1247,7 +1238,8 @@ namespace hpx { namespace threads { namespace policies {
             });
 
             // check for the rest and if we are NUMA aware
-            if (has_work_stealing_numa() && any(first_mask & pu_mask))
+            if (has_scheduler_mode(policies::enable_stealing_numa) &&
+                any(first_mask & pu_mask))
             {
                 iterate([&](std::size_t other_num_thread) {
                     return !any(numa_mask & numa_masks[other_num_thread]);
@@ -1284,7 +1276,7 @@ namespace hpx { namespace threads { namespace policies {
 
         void reset_thread_distribution() override
         {
-            curr_queue_.store(0);
+            curr_queue_.store(0, std::memory_order_release);
         }
 
     protected:
diff --git a/hpx/runtime/threads/policies/local_queue_scheduler.hpp b/libs/schedulers/include/hpx/schedulers/local_queue_scheduler.hpp
similarity index 96%
rename from hpx/runtime/threads/policies/local_queue_scheduler.hpp
rename to libs/schedulers/include/hpx/schedulers/local_queue_scheduler.hpp
index 80a0b939e1..1f801111d9 100644
--- a/hpx/runtime/threads/policies/local_queue_scheduler.hpp
+++ b/libs/schedulers/include/hpx/schedulers/local_queue_scheduler.hpp
@@ -11,17 +11,18 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_LOCAL_SCHEDULER)
+#include <hpx/affinity/affinity_data.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/functional.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/affinity/affinity_data.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/policies/thread_queue.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/schedulers/thread_queue.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util_fwd.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -39,14 +40,6 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads { namespace policies {
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    ///////////////////////////////////////////////////////////////////////////
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    extern bool minimal_deadlock_detection;
-#endif
-
     ///////////////////////////////////////////////////////////////////////////
 #if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
     using default_local_queue_scheduler_terminated_queue = lockfree_lifo;
@@ -356,7 +349,8 @@ namespace hpx { namespace threads { namespace policies {
                 return false;
             }
 
-            bool numa_stealing = has_work_stealing_numa();
+            bool numa_stealing =
+                has_scheduler_mode(policies::enable_stealing_numa);
             if (!numa_stealing)
             {
                 // steal work items: first try to steal from other cores in
@@ -523,12 +517,10 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         /// Destroy the passed thread as it has been terminated
-        void destroy_thread(
-            threads::thread_data* thrd, std::int64_t& busy_count) override
+        void destroy_thread(threads::thread_data* thrd) override
         {
             HPX_ASSERT(thrd->get_scheduler_base() == this);
-            thrd->get_queue<thread_queue_type>().destroy_thread(
-                thrd, busy_count);
+            thrd->get_queue<thread_queue_type>().destroy_thread(thrd);
         }
 
         ///////////////////////////////////////////////////////////////////////
@@ -708,7 +700,8 @@ namespace hpx { namespace threads { namespace policies {
                 return true;
             }
 
-            bool numa_stealing_ = has_work_stealing_numa();
+            bool numa_stealing_ =
+                has_scheduler_mode(policies::enable_stealing_numa);
             // limited or no stealing across domains
             if (!numa_stealing_)
             {
@@ -809,7 +802,8 @@ namespace hpx { namespace threads { namespace policies {
 
 #ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
             // no new work is available, are we deadlocked?
-            if (HPX_UNLIKELY(minimal_deadlock_detection && LHPX_ENABLED(error)))
+            if (HPX_UNLIKELY(get_minimal_deadlock_detection_enabled() &&
+                    LHPX_ENABLED(error)))
             {
                 bool suspended_only = true;
 
@@ -882,7 +876,8 @@ namespace hpx { namespace threads { namespace policies {
             else
                 first_mask = core_mask;
 
-            bool numa_stealing = has_work_stealing_numa();
+            bool numa_stealing =
+                has_scheduler_mode(policies::enable_stealing_numa);
             if (numa_stealing && any(first_mask & core_mask))
             {
 #if !defined(HPX_NATIVE_MIC)    // we know that the MIC has one NUMA domain only
diff --git a/libs/schedulers/include/hpx/schedulers/lockfree_queue_backends.hpp b/libs/schedulers/include/hpx/schedulers/lockfree_queue_backends.hpp
new file mode 100644
index 0000000000..4f73b72e4b
--- /dev/null
+++ b/libs/schedulers/include/hpx/schedulers/lockfree_queue_backends.hpp
@@ -0,0 +1,301 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2012 Bryce Adelstein-Lelbach
+//  Copyright (c) 2019 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#if !defined(HPX_FB3518C8_4493_450E_A823_A9F8A3185B2D)
+#define HPX_FB3518C8_4493_450E_A823_A9F8A3185B2D
+
+#include <hpx/config.hpp>
+
+#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
+#include <hpx/concurrency/deque.hpp>
+#else
+#include <boost/lockfree/queue.hpp>
+#endif
+
+// Does not rely on CXX11_STD_ATOMIC_128BIT
+#include <hpx/concurrency/concurrentqueue.hpp>
+
+#include <cstddef>
+#include <cstdint>
+#include <utility>
+
+namespace hpx { namespace threads { namespace policies {
+
+    struct lockfree_fifo;
+
+    ///////////////////////////////////////////////////////////////////////////////
+    // FIFO
+    template <typename T>
+    struct lockfree_fifo_backend
+    {
+#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
+        using container_type = boost::lockfree::deque<T>;
+#else
+        using container_type = boost::lockfree::queue<T>;
+#endif
+
+        using value_type = T;
+        using reference = T&;
+        using const_reference = T const&;
+        using size_type = std::uint64_t;
+
+        lockfree_fifo_backend(
+            size_type initial_size = 0, size_type num_thread = size_type(-1))
+          : queue_(std::size_t(initial_size))
+        {
+        }
+
+        bool push(const_reference val, bool /*other_end*/ = false)
+        {
+#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
+            return queue_.push_left(val);
+#else
+            return queue_.push(val);
+#endif
+        }
+
+        bool pop(reference val, bool steal = true)
+        {
+#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
+            return queue_.pop_right(val);
+#else
+            return queue_.pop(val);
+#endif
+        }
+
+        bool empty()
+        {
+            return queue_.empty();
+        }
+
+    private:
+        container_type queue_;
+    };
+
+    struct lockfree_fifo
+    {
+        template <typename T>
+        struct apply
+        {
+            using type = lockfree_fifo_backend<T>;
+        };
+    };
+
+    ////////////////////////////////////////////////////////////////////////////
+    // MoodyCamel FIFO
+    template <typename T>
+    struct moodycamel_fifo_backend
+    {
+        using container_type = moodycamel::ConcurrentQueue<T>;
+
+        using value_type = T;
+        using reference = T&;
+        using const_reference = T const&;
+        using rval_reference = T&&;
+        using size_type = std::uint64_t;
+
+        moodycamel_fifo_backend(
+            size_type initial_size = 0, size_type num_thread = size_type(-1))
+          : queue_(std::size_t(initial_size))
+        {
+        }
+
+        bool push(rval_reference val, bool /*other_end*/ = false)
+        {
+            return queue_.enqueue(std::move(val));
+        }
+
+        bool push(const_reference val, bool /*other_end*/ = false)
+        {
+            return queue_.enqueue(val);
+        }
+
+        bool pop(reference val, bool steal = true)
+        {
+            return queue_.try_dequeue(val);
+        }
+
+        bool empty()
+        {
+            return (queue_.size_approx() == 0);
+        }
+
+    private:
+        container_type queue_;
+    };
+
+    struct concurrentqueue_fifo
+    {
+        template <typename T>
+        struct apply
+        {
+            using type = moodycamel_fifo_backend<T>;
+        };
+    };
+
+// LIFO
+#if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
+            struct lockfree_lifo;
+
+            template <typename T>
+            struct lockfree_lifo_backend
+            {
+                using container_type = boost::lockfree::deque<T>;
+
+                using value_type = T;
+                using reference = T&;
+                using const_reference = T const&;
+                using size_type = std::uint64_t;
+
+                lockfree_lifo_backend(size_type initial_size = 0,
+                    size_type num_thread = size_type(-1))
+                  : queue_(std::size_t(initial_size))
+                {
+                }
+
+                bool push(const_reference val, bool other_end = false)
+                {
+                    if (other_end)
+                        return queue_.push_right(val);
+                    return queue_.push_left(val);
+                }
+
+                bool pop(reference val, bool steal = true)
+                {
+                    return queue_.pop_left(val);
+                }
+
+                bool empty()
+                {
+                    return queue_.empty();
+                }
+
+            private:
+                container_type queue_;
+            };
+
+            struct lockfree_lifo
+            {
+                template <typename T>
+                struct apply
+                {
+                    using type = lockfree_lifo_backend<T>;
+                };
+            };
+
+#if defined(HPX_HAVE_ABP_SCHEDULER)
+            ////////////////////////////////////////////////////////////////////////////
+            // FIFO + stealing at opposite end.
+            struct lockfree_abp_fifo;
+            struct lockfree_abp_lifo;
+
+            template <typename T>
+            struct lockfree_abp_fifo_backend
+            {
+                using container_type = boost::lockfree::deque<T>;
+
+                using value_type = T;
+                using reference = T&;
+                using const_reference = T const&;
+                using size_type = std::uint64_t;
+
+                lockfree_abp_fifo_backend(size_type initial_size = 0,
+                    size_type num_thread = size_type(-1))
+                  : queue_(std::size_t(initial_size))
+                {
+                }
+
+                bool push(const_reference val, bool /*other_end*/ = false)
+                {
+                    return queue_.push_left(val);
+                }
+
+                bool pop(reference val, bool steal = true)
+                {
+                    if (steal)
+                        return queue_.pop_left(val);
+                    return queue_.pop_right(val);
+                }
+
+                bool empty()
+                {
+                    return queue_.empty();
+                }
+
+            private:
+                container_type queue_;
+            };
+
+            struct lockfree_abp_fifo
+            {
+                template <typename T>
+                struct apply
+                {
+                    using type = lockfree_abp_fifo_backend<T>;
+                };
+            };
+
+            ////////////////////////////////////////////////////////////////////////////
+            // LIFO + stealing at opposite end.
+            // E.g. ABP (Arora, Blumofe and Plaxton) queuing
+            // http://dl.acm.org/citation.cfm?id=277678
+            template <typename T>
+            struct lockfree_abp_lifo_backend
+            {
+                using container_type = boost::lockfree::deque<T>;
+
+                using value_type = T;
+                using reference = T&;
+                using const_reference = T const&;
+                using size_type = std::uint64_t;
+
+                lockfree_abp_lifo_backend(size_type initial_size = 0,
+                    size_type num_thread = size_type(-1))
+                  : queue_(std::size_t(initial_size))
+                {
+                }
+
+                bool push(const_reference val, bool other_end = false)
+                {
+                    if (other_end)
+                        return queue_.push_right(val);
+                    return queue_.push_left(val);
+                }
+
+                bool pop(reference val, bool steal = true)
+                {
+                    if (steal)
+                        return queue_.pop_right(val);
+                    return queue_.pop_left(val);
+                }
+
+                bool empty()
+                {
+                    return queue_.empty();
+                }
+
+            private:
+                container_type queue_;
+            };
+
+            struct lockfree_abp_lifo
+            {
+                template <typename T>
+                struct apply
+                {
+                    using type = lockfree_abp_lifo_backend<T>;
+                };
+            };
+
+#endif    // HPX_HAVE_ABP_SCHEDULER
+#endif    // HPX_HAVE_CXX11_STD_ATOMIC_128BIT
+
+}}}    // namespace hpx::threads::policies
+
+#endif    // HPX_FB3518C8_4493_450E_A823_A9F8A3185B2D
diff --git a/libs/schedulers/include/hpx/schedulers/maintain_queue_wait_times.hpp b/libs/schedulers/include/hpx/schedulers/maintain_queue_wait_times.hpp
new file mode 100644
index 0000000000..41e9e42e9c
--- /dev/null
+++ b/libs/schedulers/include/hpx/schedulers/maintain_queue_wait_times.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2005-2017 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Adelstein-Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_RUNTIME_THREADS_POLICIES_MAINTAIN_QUEUE_WAIT_TIMES_HPP
+#define HPX_RUNTIME_THREADS_POLICIES_MAINTAIN_QUEUE_WAIT_TIMES_HPP
+
+#include <hpx/config.hpp>
+
+namespace hpx { namespace threads { namespace policies {
+#ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
+    HPX_EXPORT void set_maintain_queue_wait_times_enabled(bool enabled);
+    HPX_EXPORT bool get_maintain_queue_wait_times_enabled();
+#endif
+}}}    // namespace hpx::threads::policies
+
+#endif
diff --git a/hpx/runtime/threads/policies/queue_helpers.hpp b/libs/schedulers/include/hpx/schedulers/queue_helpers.hpp
similarity index 92%
rename from hpx/runtime/threads/policies/queue_helpers.hpp
rename to libs/schedulers/include/hpx/schedulers/queue_helpers.hpp
index 89c98298cc..cd090d44bb 100644
--- a/hpx/runtime/threads/policies/queue_helpers.hpp
+++ b/libs/schedulers/include/hpx/schedulers/queue_helpers.hpp
@@ -13,8 +13,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/type_support/unused.hpp>
 
 #include <cmath>
@@ -26,14 +27,6 @@
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads { namespace policies {
 
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    ///////////////////////////////////////////////////////////////////////////
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    extern bool minimal_deadlock_detection;
-#endif
-
     ///////////////////////////////////////////////////////////////////////////////
     namespace detail {
         ///////////////////////////////////////////////////////////////////////////
@@ -53,7 +46,7 @@ namespace hpx { namespace threads { namespace policies {
             HPX_UNUSED(running);    //-V601
             return false;
 #else
-            if (!minimal_deadlock_detection)
+            if (!get_minimal_deadlock_detection_enabled())
                 return false;
 
             // attempt to output possibly deadlocked threads occasionally only
diff --git a/hpx/runtime/threads/policies/queue_holder_numa.hpp b/libs/schedulers/include/hpx/schedulers/queue_holder_numa.hpp
similarity index 87%
rename from hpx/runtime/threads/policies/queue_holder_numa.hpp
rename to libs/schedulers/include/hpx/schedulers/queue_holder_numa.hpp
index 553cab95c6..7efb93e6bc 100644
--- a/hpx/runtime/threads/policies/queue_holder_numa.hpp
+++ b/libs/schedulers/include/hpx/schedulers/queue_holder_numa.hpp
@@ -8,15 +8,16 @@
 #define HPX_THREADMANAGER_SCHEDULING_QUEUE_HELPER
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_mc.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/schedulers/thread_queue_mc.hpp>
+#include <hpx/threading_base/print.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 //
 #include <hpx/logging.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
 #include <hpx/type_support/unused.hpp>
 //
-#include <hpx/runtime/threads/policies/queue_holder_thread.hpp>
+#include <hpx/schedulers/queue_holder_thread.hpp>
 //
 #include <cmath>
 #include <cstddef>
@@ -76,7 +77,7 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         // ----------------------------------------------------------------
-        void init(std::uint16_t domain, std::uint16_t queues)
+        void init(std::size_t domain, std::size_t queues)
         {
             num_queues_ = queues;
             domain_ = domain;
@@ -91,18 +92,18 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         // ----------------------------------------------------------------
-        inline ThreadQueue* thread_queue(std::uint16_t id) const
+        inline ThreadQueue* thread_queue(std::size_t id) const
         {
             return queues_[id];
         }
 
         // ----------------------------------------------------------------
-        inline bool get_next_thread_HP(std::uint16_t qidx,
+        inline bool get_next_thread_HP(std::size_t qidx,
             threads::thread_data*& thrd, bool stealing, bool core_stealing)
         {
             // loop over queues and take one task,
-            std::uint16_t q = qidx;
-            for (std::uint16_t i = 0; i < num_queues_;
+            std::size_t q = qidx;
+            for (std::size_t i = 0; i < num_queues_;
                  ++i, q = fast_mod((qidx + i), num_queues_))
             {
                 if (queues_[q]->get_next_thread_HP(
@@ -127,13 +128,13 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         // ----------------------------------------------------------------
-        inline bool get_next_thread(std::uint16_t qidx,
+        inline bool get_next_thread(std::size_t qidx,
             threads::thread_data*& thrd, bool stealing, bool core_stealing)
         {
             // loop over queues and take one task,
             // starting with the requested queue
-            std::uint16_t q = qidx;
-            for (std::uint16_t i = 0; i < num_queues_;
+            std::size_t q = qidx;
+            for (std::size_t i = 0; i < num_queues_;
                  ++i, q = fast_mod((qidx + i), num_queues_))
             {
                 // if we got a thread, return it, only allow stealing if i>0
@@ -155,12 +156,12 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         // ----------------------------------------------------------------
-        bool add_new_HP(ThreadQueue* receiver, std::uint16_t qidx,
+        bool add_new_HP(ThreadQueue* receiver, std::size_t qidx,
             std::size_t& added, bool stealing, bool allow_stealing)
         {
             // loop over queues and take one task,
-            std::uint16_t q = qidx;
-            for (std::uint16_t i = 0; i < num_queues_;
+            std::size_t q = qidx;
+            for (std::size_t i = 0; i < num_queues_;
                  ++i, q = fast_mod((qidx + i), num_queues_))
             {
                 std::size_t added =
@@ -186,12 +187,12 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         // ----------------------------------------------------------------
-        bool add_new(ThreadQueue* receiver, std::uint16_t qidx,
+        bool add_new(ThreadQueue* receiver, std::size_t qidx,
             std::size_t& added, bool stealing, bool allow_stealing)
         {
             // loop over queues and take one task,
-            std::uint16_t q = qidx;
-            for (std::uint16_t i = 0; i < num_queues_;
+            std::size_t q = qidx;
+            for (std::size_t i = 0; i < num_queues_;
                  ++i, q = fast_mod((qidx + i), num_queues_))
             {
                 std::size_t added =
@@ -256,8 +257,8 @@ namespace hpx { namespace threads { namespace policies {
         // ----------------------------------------------------------------
         // ----------------------------------------------------------------
         // ----------------------------------------------------------------
-        std::uint16_t num_queues_;
-        std::uint16_t domain_;
+        std::size_t num_queues_;
+        std::size_t domain_;
         std::vector<ThreadQueue*> queues_;
 
     public:
@@ -301,17 +302,6 @@ namespace hpx { namespace threads { namespace policies {
         void on_stop_thread(std::size_t num_thread) {}
         void on_error(std::size_t num_thread, std::exception_ptr const& e) {}
     };
-
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    // ------------------------------------------------------------////
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    extern bool minimal_deadlock_detection;
-#endif
-
-    // ------------------------------------------------------------////////
-
 }}}    // namespace hpx::threads::policies
 
 #endif    // HPX_F0153C92_99B1_4F31_8FA9_4208DB2F26CE
diff --git a/hpx/runtime/threads/policies/queue_holder_thread.hpp b/libs/schedulers/include/hpx/schedulers/queue_holder_thread.hpp
similarity index 95%
rename from hpx/runtime/threads/policies/queue_holder_thread.hpp
rename to libs/schedulers/include/hpx/schedulers/queue_holder_thread.hpp
index 1b372e9ae7..d410325f84 100644
--- a/hpx/runtime/threads/policies/queue_holder_thread.hpp
+++ b/libs/schedulers/include/hpx/schedulers/queue_holder_thread.hpp
@@ -9,12 +9,14 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/datastructures/tuple.hpp>
 #include <hpx/debugging/print.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_data_stackful.hpp>
-#include <hpx/runtime/threads/thread_data_stackless.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/threading_base/print.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_data_stackful.hpp>
+#include <hpx/threading_base/thread_data_stackless.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/type_support/unused.hpp>
 
 #include <cmath>
@@ -55,8 +57,8 @@ namespace hpx { namespace threads { namespace policies {
     // apply the modulo operator only when needed
     // (i.e. when the input is greater than the ceiling)
     // NB: the numbers must be positive
-    HPX_FORCEINLINE int fast_mod(
-        const unsigned int input, const unsigned int ceil)
+    HPX_FORCEINLINE std::size_t fast_mod(
+        std::size_t const input, std::size_t const ceil)
     {
         return input >= ceil ? input % ceil : input;
     }
@@ -87,11 +89,11 @@ namespace hpx { namespace threads { namespace policies {
         QueueType* const lp_queue_;
 
         // these are the domain and local thread queue ids for the container
-        const std::uint16_t domain_index_;
-        const std::uint16_t queue_index_;
-        const std::uint16_t thread_num_;
+        const std::size_t domain_index_;
+        const std::size_t queue_index_;
+        const std::size_t thread_num_;
         // a mask that hold a bit per queue to indicate ownership of the queue
-        const std::uint16_t owner_mask_;
+        const std::size_t owner_mask_;
 
         // we must use OS mutexes here because we cannot suspend an HPX
         // thread whilst processing the Queues for that thread, this code
@@ -114,16 +116,17 @@ namespace hpx { namespace threads { namespace policies {
         thread_heap_type thread_heap_nostack_;
 
         // number of terminated threads to discard
-        const int min_delete_count_;
-        const int max_delete_count_;
+        int const min_delete_count_;
+        int const max_delete_count_;
 
         // number of terminated threads to collect before cleaning them up
-        const int max_terminated_threads_;
+        int const max_terminated_threads_;
 
         // these ought to be atomic, but if we get a race and assign a thread
         // to queue N instead of N+1 it doesn't really matter
 
-        mutable util::cache_line_data<std::tuple<int, int>> rollover_counters_;
+        mutable util::cache_line_data<std::tuple<std::size_t, std::size_t>>
+            rollover_counters_;
 
         // ----------------------------------------------------------------
         // ----------------------------------------------------------------
@@ -199,8 +202,8 @@ namespace hpx { namespace threads { namespace policies {
         // ----------------------------------------------------------------
         // ----------------------------------------------------------------
         queue_holder_thread(QueueType* bp_queue, QueueType* hp_queue,
-            QueueType* np_queue, QueueType* lp_queue, std::uint16_t domain,
-            std::uint16_t queue, std::uint16_t thread_num, std::uint16_t owner,
+            QueueType* np_queue, QueueType* lp_queue, std::size_t domain,
+            std::size_t queue, std::size_t thread_num, std::size_t owner,
             const thread_queue_init_parameters& init)
           : bp_queue_(bp_queue)
           , hp_queue_(hp_queue)
@@ -290,7 +293,7 @@ namespace hpx { namespace threads { namespace policies {
         // ------------------------------------------------------------
         // return the next round robin thread index across all workers
         // using a batching of N per worker before incrementing
-        inline unsigned int worker_next(const unsigned int workers) const
+        inline std::size_t worker_next(std::size_t const workers) const
         {
             tq_deb.debug(debug::str<>("worker_next"), "Rollover counter ",
                 debug::dec<4>(std::get<0>(rollover_counters_.data_)),
@@ -314,7 +317,7 @@ namespace hpx { namespace threads { namespace policies {
                 tq_deb.debug(debug::str<>("schedule_thread"),
                     queue_data_print(this),
                     debug::threadinfo<threads::thread_data*>(thrd),
-                    "queing thread_priority_bound");
+                    "queueing thread_priority_bound");
                 bp_queue_->schedule_work(thrd, other_end);
             }
             else if (hp_queue_ &&
@@ -325,7 +328,7 @@ namespace hpx { namespace threads { namespace policies {
                 tq_deb.debug(debug::str<>("schedule_thread"),
                     queue_data_print(this),
                     debug::threadinfo<threads::thread_data*>(thrd),
-                    "queing thread_priority_high");
+                    "queueing thread_priority_high");
                 hp_queue_->schedule_work(thrd, other_end);
             }
             else if (lp_queue_ && (priority == thread_priority_low))
@@ -333,7 +336,7 @@ namespace hpx { namespace threads { namespace policies {
                 tq_deb.debug(debug::str<>("schedule_thread"),
                     queue_data_print(this),
                     debug::threadinfo<threads::thread_data*>(thrd),
-                    "queing thread_priority_low");
+                    "queueing thread_priority_low");
                 lp_queue_->schedule_work(thrd, other_end);
             }
             else
@@ -341,7 +344,7 @@ namespace hpx { namespace threads { namespace policies {
                 tq_deb.debug(debug::str<>("schedule_thread"),
                     queue_data_print(this),
                     debug::threadinfo<threads::thread_data*>(thrd),
-                    "queing thread_priority_normal");
+                    "queueing thread_priority_normal");
                 np_queue_->schedule_work(thrd, other_end);
             }
         }
@@ -411,7 +414,7 @@ namespace hpx { namespace threads { namespace policies {
 
         // ----------------------------------------------------------------
         void create_thread(thread_init_data& data, thread_id_type* tid,
-            thread_state_enum state, bool run_now, std::uint16_t thread_num,
+            thread_state_enum state, bool run_now, std::size_t thread_num,
             error_code& ec)
         {
             if (thread_num != thread_num_)
@@ -697,7 +700,7 @@ namespace hpx { namespace threads { namespace policies {
             std::int64_t add_count, thread_holder_type* addfrom, bool stealing)
         {
             std::size_t added;
-            if (owns_bp_queue() && !stealing)
+            if (owns_bp_queue())
             {
                 added =
                     bp_queue_->add_new(add_count, addfrom->bp_queue_, stealing);
@@ -899,7 +902,7 @@ namespace hpx { namespace threads { namespace policies {
         // ------------------------------------------------------------
         /// Destroy the passed thread as it has been terminated
         void destroy_thread(
-            threads::thread_data* thrd, std::uint16_t thread_num, bool xthread)
+            threads::thread_data* thrd, std::size_t thread_num, bool xthread)
         {
             // the thread must be destroyed by the same queue holder that created it
             HPX_ASSERT(&thrd->get_queue<queue_holder_thread>() == this);
@@ -1025,17 +1028,6 @@ namespace hpx { namespace threads { namespace policies {
     template <typename QueueType>
     util::internal_allocator<threads::thread_data>
         queue_holder_thread<QueueType>::thread_alloc_;
-
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    // ------------------------------------------------------------
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    extern bool minimal_deadlock_detection;
-#endif
-
-    // ------------------------------------------------------------
-
 }}}    // namespace hpx::threads::policies
 
 #endif
diff --git a/hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp b/libs/schedulers/include/hpx/schedulers/shared_priority_queue_scheduler.hpp
similarity index 87%
rename from hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp
rename to libs/schedulers/include/hpx/schedulers/shared_priority_queue_scheduler.hpp
index 9c8770ec88..eac2ce916b 100644
--- a/hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp
+++ b/libs/schedulers/include/hpx/schedulers/shared_priority_queue_scheduler.hpp
@@ -13,19 +13,20 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/debugging/print.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/runtime/threads/detail/thread_num_tss.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/queue_holder_numa.hpp>
-#include <hpx/runtime/threads/policies/queue_holder_thread.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_mc.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/functional.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/schedulers/queue_holder_numa.hpp>
+#include <hpx/schedulers/queue_holder_thread.hpp>
+#include <hpx/schedulers/thread_queue_mc.hpp>
+#include <hpx/threading_base/print.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util/yield_while.hpp>
-#include <hpx/util_fwd.hpp>
 
 #include <array>
 #include <cstddef>
@@ -223,7 +224,7 @@ namespace hpx { namespace threads { namespace policies {
                 // ------------------------------------------------------------
                 // access thread local storage to determine correct thread
                 // and pool identification
-                inline int local_thread_number()
+                inline std::size_t local_thread_number()
                 {
                     using namespace hpx::threads::detail;
                     const auto& tns = get_thread_pool_tss();
@@ -241,8 +242,8 @@ namespace hpx { namespace threads { namespace policies {
                         1, debug::str<>("Cleanup"), "Global version");
                     spq_deb.timed(cleanup);
 
-                    int local_num = local_thread_number();
-                    if (local_num < 0)
+                    std::size_t local_num = local_thread_number();
+                    if (local_num == std::size_t(-1))
                     {
                         // clang-format off
                         using namespace hpx::threads::detail;
@@ -267,7 +268,7 @@ namespace hpx { namespace threads { namespace policies {
                         "thread_num", debug::dec<3>(local_num));
 
                     return numa_holder_[domain_num]
-                        .thread_queue(static_cast<std::uint16_t>(q_index))
+                        .thread_queue(static_cast<std::size_t>(q_index))
                         ->cleanup_terminated(local_num, delete_all);
                 }
 
@@ -275,8 +276,8 @@ namespace hpx { namespace threads { namespace policies {
                 bool cleanup_terminated(
                     std::size_t thread_num, bool delete_all) override
                 {
-                    int local_num = local_thread_number();
-                    HPX_ASSERT(local_num >= 0 && local_num < int(num_workers_));
+                    std::size_t local_num = local_thread_number();
+                    HPX_ASSERT(local_num < num_workers_);
 
                     //            spq_deb.timed(debug::str<>("clean_terminated")
                     //                          , "thread version", delete_all);
@@ -290,7 +291,7 @@ namespace hpx { namespace threads { namespace policies {
 
                     // cleanup the queues assigned to this thread
                     return numa_holder_[domain_num]
-                        .thread_queue(static_cast<std::uint16_t>(q_index))
+                        .thread_queue(static_cast<std::size_t>(q_index))
                         ->cleanup_terminated(local_num, delete_all);
                 }
 
@@ -304,7 +305,7 @@ namespace hpx { namespace threads { namespace policies {
                     // safety check that task was created by this thread/scheduler
                     HPX_ASSERT(data.scheduler_base == this);
 
-                    int local_num = local_thread_number();
+                    std::size_t local_num = local_thread_number();
 
                     std::size_t thread_num = local_num;
                     std::size_t domain_num;
@@ -339,7 +340,7 @@ namespace hpx { namespace threads { namespace policies {
                             // pool - we can schedule on any thread available
                             thread_num =
                                 numa_holder_[0].thread_queue(0)->worker_next(
-                                    static_cast<unsigned int>(num_workers_));
+                                    static_cast<std::size_t>(num_workers_));
                         }
                         else if (!round_robin_) /* thread parent */
                         {
@@ -363,13 +364,13 @@ namespace hpx { namespace threads { namespace policies {
                                 parent_pool_->get_pool_name(),
                                 typename thread_holder_type::queue_data_print(
                                     numa_holder_[domain_num].thread_queue(
-                                        static_cast<std::uint16_t>(q_index))));
+                                        static_cast<std::size_t>(q_index))));
                             thread_num =
                                 numa_holder_[domain_num]
                                     .thread_queue(
-                                        static_cast<std::uint16_t>(q_index))
-                                    ->worker_next(static_cast<unsigned int>(
-                                        num_workers_));
+                                        static_cast<std::size_t>(q_index))
+                                    ->worker_next(
+                                        static_cast<std::size_t>(num_workers_));
                         }
                         thread_num = select_active_pu(l, thread_num);
                         // cppcheck-suppress redundantAssignment
@@ -396,9 +397,8 @@ namespace hpx { namespace threads { namespace policies {
                         // Create thread on requested NUMA domain
                         debug::set(msg, "HINT_NUMA  ");
                         // TODO: This case does not handle suspended PUs.
-                        domain_num = fast_mod(
-                            static_cast<unsigned int>(data.schedulehint.hint),
-                            static_cast<unsigned int>(num_domains_));
+                        domain_num =
+                            fast_mod(data.schedulehint.hint, num_domains_);
                         // if the thread creating the new task is on the domain
                         // assigned to the new task - try to reuse the core as well
                         thread_num = local_num;
@@ -427,7 +427,7 @@ namespace hpx { namespace threads { namespace policies {
                     }
                     // we do not allow threads created on other queues to 'run now'
                     // as this caues cross-thread allocations and map accesses
-                    if (local_num != static_cast<int>(thread_num))
+                    if (local_num != thread_num)
                     {
                         run_now = false;
                         spq_deb.debug(debug::str<>("create_thread"), "pool",
@@ -449,19 +449,19 @@ namespace hpx { namespace threads { namespace policies {
                             debug::threadinfo<thread_init_data>(data));
                     }
                     numa_holder_[domain_num]
-                        .thread_queue(static_cast<std::uint16_t>(q_index))
+                        .thread_queue(static_cast<std::size_t>(q_index))
                         ->create_thread(
                             data, thrd, initial_state, run_now, local_num, ec);
                 }
 
                 template <typename T>
-                bool steal_by_function(std::uint16_t domain,
-                    std::uint16_t q_index, bool steal_numa, bool steal_core,
+                bool steal_by_function(std::size_t domain, std::size_t q_index,
+                    bool steal_numa, bool steal_core,
                     thread_holder_type* origin, T& var, const char* prefix,
-                    std::function<bool(std::uint16_t, std::uint16_t,
+                    std::function<bool(std::size_t, std::size_t,
                         thread_holder_type*, T&, bool, bool)>
                         operation_HP,
-                    std::function<bool(std::uint16_t, std::uint16_t,
+                    std::function<bool(std::size_t, std::size_t,
                         thread_holder_type*, T&, bool, bool)>
                         operation)
                 {
@@ -487,14 +487,11 @@ namespace hpx { namespace threads { namespace policies {
                     // High priority tasks first
                     else if (steal_hp_first_)
                     {
-                        for (std::uint16_t d = 0; d < num_domains_; ++d)
+                        for (std::size_t d = 0; d < num_domains_; ++d)
                         {
-                            std::uint16_t dom =
-                                fast_mod(static_cast<unsigned int>(domain + d),
-                                    static_cast<unsigned int>(num_domains_));
-                            q_index =
-                                fast_mod(static_cast<unsigned int>(q_index),
-                                    static_cast<unsigned int>(q_counts_[dom]));
+                            std::size_t dom =
+                                fast_mod(domain + d, num_domains_);
+                            q_index = fast_mod(q_index, q_counts_[dom]);
                             result = operation_HP(
                                 dom, q_index, origin, var, (d > 0), true);
                             if (result)
@@ -510,14 +507,11 @@ namespace hpx { namespace threads { namespace policies {
                             if (!steal_numa)
                                 break;
                         }
-                        for (std::uint16_t d = 0; d < num_domains_; ++d)
+                        for (std::size_t d = 0; d < num_domains_; ++d)
                         {
-                            std::uint16_t dom =
-                                fast_mod(static_cast<unsigned int>(domain + d),
-                                    static_cast<unsigned int>(num_domains_));
-                            q_index =
-                                fast_mod(static_cast<unsigned int>(q_index),
-                                    static_cast<unsigned int>(q_counts_[dom]));
+                            std::size_t dom =
+                                fast_mod(domain + d, num_domains_);
+                            q_index = fast_mod(q_index, q_counts_[dom]);
                             result = operation(
                                 dom, q_index, origin, var, (d > 0), true);
                             if (result)
@@ -576,14 +570,11 @@ namespace hpx { namespace threads { namespace policies {
                         else
                         {
                             // try other numa domains BP/HP
-                            for (std::uint16_t d = 1; d < num_domains_; ++d)
+                            for (std::size_t d = 1; d < num_domains_; ++d)
                             {
-                                std::uint16_t dom = fast_mod(
-                                    static_cast<unsigned int>(domain + d),
-                                    static_cast<unsigned int>(num_domains_));
-                                q_index = fast_mod(
-                                    static_cast<unsigned int>(q_index),
-                                    static_cast<unsigned int>(q_counts_[dom]));
+                                std::size_t dom =
+                                    fast_mod(domain + d, num_domains_);
+                                q_index = fast_mod(q_index, q_counts_[dom]);
                                 result = operation_HP(
                                     dom, q_index, origin, var, true, true);
                                 if (result)
@@ -597,14 +588,11 @@ namespace hpx { namespace threads { namespace policies {
                                 }
                             }
                             // try other numa domains NP/LP
-                            for (std::uint16_t d = 1; d < num_domains_; ++d)
+                            for (std::size_t d = 1; d < num_domains_; ++d)
                             {
-                                std::uint16_t dom = fast_mod(
-                                    static_cast<unsigned int>(domain + d),
-                                    static_cast<unsigned int>(num_domains_));
-                                q_index = fast_mod(
-                                    static_cast<unsigned int>(q_index),
-                                    static_cast<unsigned int>(q_counts_[dom]));
+                                std::size_t dom =
+                                    fast_mod(domain + d, num_domains_);
+                                q_index = fast_mod(q_index, q_counts_[dom]);
                                 result = operation(
                                     dom, q_index, origin, var, true, true);
                                 if (result)
@@ -627,9 +615,8 @@ namespace hpx { namespace threads { namespace policies {
                     bool running, threads::thread_data*& thrd,
                     bool enable_stealing) override
                 {
-                    int this_thread = local_thread_number();
-                    HPX_ASSERT(
-                        this_thread >= 0 && this_thread < int(num_workers_));
+                    std::size_t this_thread = local_thread_number();
+                    HPX_ASSERT(this_thread < num_workers_);
 
                     // just cleanup the thread we were called by rather than all threads
                     static auto getnext =
@@ -638,7 +625,7 @@ namespace hpx { namespace threads { namespace policies {
                     spq_deb.timed(getnext, debug::dec<>(thread_num));
 
                     auto get_next_thread_function_HP =
-                        [&](std::uint16_t domain, std::uint16_t q_index,
+                        [&](std::size_t domain, std::size_t q_index,
                             thread_holder_type* receiver,
                             threads::thread_data*& thrd, bool stealing,
                             bool allow_stealing) {
@@ -647,7 +634,7 @@ namespace hpx { namespace threads { namespace policies {
                         };
 
                     auto get_next_thread_function =
-                        [&](std::uint16_t domain, std::uint16_t q_index,
+                        [&](std::size_t domain, std::size_t q_index,
                             thread_holder_type* receiver,
                             threads::thread_data*& thrd, bool stealing,
                             bool allow_stealing) {
@@ -655,11 +642,11 @@ namespace hpx { namespace threads { namespace policies {
                                 q_index, thrd, stealing, allow_stealing);
                         };
 
-                    std::uint16_t domain = d_lookup_[this_thread];
-                    std::uint16_t q_index = q_lookup_[this_thread];
+                    std::size_t domain = d_lookup_[this_thread];
+                    std::size_t q_index = q_lookup_[this_thread];
 
                     // first try a high priority task, allow stealing
-                    // if stealingo og HP tasks in on, this wil be fine
+                    // if stealing of HP tasks in on, this will be fine
                     // but send a null function for normal tasks
                     bool result = steal_by_function<threads::thread_data*>(
                         domain, q_index, numa_stealing_, core_stealing_,
@@ -686,9 +673,8 @@ namespace hpx { namespace threads { namespace policies {
                     bool running, std::int64_t& idle_loop_count,
                     bool /*enable_stealing*/, std::size_t& added) override
                 {
-                    int this_thread = local_thread_number();
-                    HPX_ASSERT(
-                        this_thread >= 0 && this_thread < int(num_workers_));
+                    std::size_t this_thread = local_thread_number();
+                    HPX_ASSERT(this_thread < num_workers_);
 
                     // just cleanup the thread we were called by rather than all threads
                     static auto w_or_add_n =
@@ -697,7 +683,7 @@ namespace hpx { namespace threads { namespace policies {
                     added = 0;
 
                     auto add_new_function_HP =
-                        [&](std::uint16_t domain, std::uint16_t q_index,
+                        [&](std::size_t domain, std::size_t q_index,
                             thread_holder_type* receiver, std::size_t& added,
                             bool stealing, bool allow_stealing) {
                             return numa_holder_[domain].add_new_HP(receiver,
@@ -705,15 +691,15 @@ namespace hpx { namespace threads { namespace policies {
                         };
 
                     auto add_new_function =
-                        [&](std::uint16_t domain, std::uint16_t q_index,
+                        [&](std::size_t domain, std::size_t q_index,
                             thread_holder_type* receiver, std::size_t& added,
                             bool stealing, bool allow_stealing) {
                             return numa_holder_[domain].add_new(receiver,
                                 q_index, added, stealing, allow_stealing);
                         };
 
-                    std::uint16_t domain = d_lookup_[this_thread];
-                    std::uint16_t q_index = q_lookup_[this_thread];
+                    std::size_t domain = d_lookup_[this_thread];
+                    std::size_t q_index = q_lookup_[this_thread];
                     //
                     thread_holder_type* receiver =
                         numa_holder_[domain].queues_[q_index];
@@ -742,7 +728,7 @@ namespace hpx { namespace threads { namespace policies {
                 {
                     HPX_ASSERT(thrd->get_scheduler_base() == this);
 
-                    int local_num = local_thread_number();
+                    std::size_t local_num = local_thread_number();
                     std::size_t thread_num = local_num;
                     std::size_t domain_num = 0;
                     std::size_t q_index = std::size_t(-1);
@@ -766,7 +752,7 @@ namespace hpx { namespace threads { namespace policies {
                             // pool - we can schedule on any thread available
                             thread_num =
                                 numa_holder_[0].thread_queue(0)->worker_next(
-                                    static_cast<unsigned int>(num_workers_));
+                                    num_workers_);
                             q_index = 0;
                             // clang-format off
                             using namespace hpx::threads::detail;
@@ -795,12 +781,9 @@ namespace hpx { namespace threads { namespace policies {
                         {
                             domain_num = d_lookup_[thread_num];
                             q_index = q_lookup_[thread_num];
-                            thread_num =
-                                numa_holder_[domain_num]
-                                    .thread_queue(
-                                        static_cast<std::uint16_t>(q_index))
-                                    ->worker_next(static_cast<unsigned int>(
-                                        num_workers_));
+                            thread_num = numa_holder_[domain_num]
+                                             .thread_queue(q_index)
+                                             ->worker_next(num_workers_);
                             spq_deb.debug(debug::str<>("schedule_thread"),
                                 "assign_work_round_robin", "thread_num",
                                 thread_num,
@@ -828,9 +811,7 @@ namespace hpx { namespace threads { namespace policies {
                         // Create thread on requested NUMA domain
                         debug::set(msg, "HINT_NUMA  ");
                         // TODO: This case does not handle suspended PUs.
-                        domain_num = fast_mod(
-                            static_cast<unsigned int>(schedulehint.mode),
-                            static_cast<unsigned int>(num_domains_));
+                        domain_num = fast_mod(schedulehint.mode, num_domains_);
                         // if the thread creating the new task is on the domain
                         // assigned to the new task - try to reuse the core as well
                         if (d_lookup_[thread_num] == domain_num)
@@ -857,7 +838,7 @@ namespace hpx { namespace threads { namespace policies {
                         debug::dec<2>(domain_num), "Q", debug::dec<3>(q_index));
 
                     numa_holder_[domain_num]
-                        .thread_queue(static_cast<std::uint16_t>(q_index))
+                        .thread_queue(q_index)
                         ->schedule_thread(thrd, priority, false);
                 }
 
@@ -876,8 +857,7 @@ namespace hpx { namespace threads { namespace policies {
                 //---------------------------------------------------------------------
                 // Destroy the passed thread - as it has been terminated
                 //---------------------------------------------------------------------
-                void destroy_thread(threads::thread_data* thrd,
-                    std::int64_t& busy_count) override
+                void destroy_thread(threads::thread_data* thrd) override
                 {
                     HPX_ASSERT(thrd->get_scheduler_base() == this);
                     auto d1 = thrd->get_queue<
@@ -887,9 +867,8 @@ namespace hpx { namespace threads { namespace policies {
                                       queue_holder_thread<thread_queue_type>>()
                                   .queue_index_;
 
-                    int this_thread = local_thread_number();
-                    HPX_ASSERT(
-                        this_thread >= 0 && this_thread < int(num_workers_));
+                    std::size_t this_thread = local_thread_number();
+                    HPX_ASSERT(this_thread < num_workers_);
 
                     auto d2 = d_lookup_[this_thread];
                     auto q2 = q_lookup_[this_thread];
@@ -924,8 +903,7 @@ namespace hpx { namespace threads { namespace policies {
                         std::size_t domain_num = d_lookup_[thread_num];
                         std::size_t q_index = q_lookup_[thread_num];
                         count += numa_holder_[domain_num]
-                                     .thread_queue(
-                                         static_cast<std::uint16_t>(q_index))
+                                     .thread_queue(q_index)
                                      ->get_queue_length();
                     }
                     else
@@ -952,7 +930,7 @@ namespace hpx { namespace threads { namespace policies {
                         std::size_t domain_num = d_lookup_[thread_num];
                         std::size_t q_index = q_lookup_[thread_num];
                         return numa_holder_[domain_num]
-                            .thread_queue(static_cast<std::uint16_t>(q_index))
+                            .thread_queue(q_index)
                             ->get_thread_count(state, priority);
                     }
                     else
@@ -1004,7 +982,7 @@ namespace hpx { namespace threads { namespace policies {
 
                         // used to make sure thread ids are valid for this scheduler
                         pool_index_ =
-                            std::uint16_t(parent_pool_->get_pool_index());
+                            std::size_t(parent_pool_->get_pool_index());
 
                         // For each worker thread, count which numa domain each
                         // belongs to and build lists of useful indexes/refs
@@ -1025,13 +1003,12 @@ namespace hpx { namespace threads { namespace policies {
                             std::size_t domain =
                                 topo.get_numa_node_number(pu_num);
 #if defined(SHARED_PRIORITY_SCHEDULER_DEBUG_NUMA)
-                            if (local_id >= (num_workers_ + 1) / 2)
+                            if (pu_num > (num_workers_ / 2))
                             {
-                                domain += 1;
+                                domain++;
                             }
 #endif
-                            d_lookup_[local_id] =
-                                static_cast<std::uint16_t>(domain);
+                            d_lookup_[local_id] = domain;
 
                             // each time a _new_ domain is added increment the offset
                             domain_map.insert({domain, domain_map.size()});
@@ -1046,7 +1023,7 @@ namespace hpx { namespace threads { namespace policies {
                         for (std::size_t local_id = 0; local_id < num_workers_;
                              ++local_id)
                         {
-                            d_lookup_[local_id] = static_cast<std::uint16_t>(
+                            d_lookup_[local_id] = static_cast<std::size_t>(
                                 domain_map[d_lookup_[local_id]]);
 
                             // increment the count for the domain
@@ -1113,9 +1090,8 @@ namespace hpx { namespace threads { namespace policies {
 
                     // store local thread number and pool index in thread local storage
                     hpx::threads::detail::set_thread_pool_tss(
-                        {std::uint16_t(local_thread),
-                            std::uint16_t(
-                                parent_pool_->get_pool_id().index())});
+                        {std::size_t(local_thread),
+                            std::size_t(parent_pool_->get_pool_id().index())});
 
                     // one thread holder per core (shared by PUs)
                     thread_holder_type* thread_holder = nullptr;
@@ -1146,7 +1122,7 @@ namespace hpx { namespace threads { namespace policies {
                             if (numa_holder_[domain].size() == 0)
                             {
                                 numa_holder_[domain].init(
-                                    static_cast<std::uint16_t>(domain),
+                                    static_cast<std::size_t>(domain),
                                     q_counts_[domain]);
                             }
                         }
@@ -1154,7 +1130,7 @@ namespace hpx { namespace threads { namespace policies {
                         if (local_thread == local_id)
                         {
                             q_lookup_[local_thread] =
-                                static_cast<std::uint16_t>(index);
+                                static_cast<std::size_t>(index);
 
                             // bound queues are never shared
                             bp_queue =
@@ -1175,12 +1151,11 @@ namespace hpx { namespace threads { namespace policies {
                                 {
                                     // share the queue with our next lowest neighbor
                                     HPX_ASSERT(index != 0);
-                                    hp_queue =
-                                        numa_holder_[domain]
-                                            .thread_queue(
-                                                static_cast<std::uint16_t>(
-                                                    index - 1))
-                                            ->hp_queue_;
+                                    hp_queue = numa_holder_[domain]
+                                                   .thread_queue(
+                                                       static_cast<std::size_t>(
+                                                           index - 1))
+                                                   ->hp_queue_;
                                 }
                             }
                             // Normal priority
@@ -1195,11 +1170,11 @@ namespace hpx { namespace threads { namespace policies {
                             {
                                 // share the queue with our next lowest neighbor
                                 HPX_ASSERT(index != 0);
-                                np_queue = numa_holder_[domain]
-                                               .thread_queue(
-                                                   static_cast<std::uint16_t>(
-                                                       index - 1))
-                                               ->np_queue_;
+                                np_queue =
+                                    numa_holder_[domain]
+                                        .thread_queue(
+                                            static_cast<std::size_t>(index - 1))
+                                        ->np_queue_;
                             }
                             // Low priority
                             if (cores_per_queue_.low_priority > 0)
@@ -1216,12 +1191,11 @@ namespace hpx { namespace threads { namespace policies {
                                 {
                                     // share the queue with our next lowest neighbor
                                     HPX_ASSERT(index != 0);
-                                    lp_queue =
-                                        numa_holder_[domain]
-                                            .thread_queue(
-                                                static_cast<std::uint16_t>(
-                                                    index - 1))
-                                            ->lp_queue_;
+                                    lp_queue = numa_holder_[domain]
+                                                   .thread_queue(
+                                                       static_cast<std::size_t>(
+                                                           index - 1))
+                                                   ->lp_queue_;
                                 }
                             }
 
@@ -1233,10 +1207,10 @@ namespace hpx { namespace threads { namespace policies {
                             thread_holder =
                                 new queue_holder_thread<thread_queue_type>(
                                     bp_queue, hp_queue, np_queue, lp_queue,
-                                    static_cast<std::uint16_t>(domain),
-                                    static_cast<std::uint16_t>(index),
-                                    static_cast<std::uint16_t>(local_id),
-                                    static_cast<std::uint16_t>(owner_mask),
+                                    static_cast<std::size_t>(domain),
+                                    static_cast<std::size_t>(index),
+                                    static_cast<std::size_t>(local_id),
+                                    static_cast<std::size_t>(owner_mask),
                                     queue_parameters_);
 
                             numa_holder_[domain].queues_[numa_id] =
@@ -1353,22 +1327,22 @@ namespace hpx { namespace threads { namespace policies {
                 typedef queue_holder_numa<thread_queue_type> numa_queues;
 
                 // for each numa domain, the number of queues available
-                std::array<std::uint16_t, HPX_HAVE_MAX_NUMA_DOMAIN_COUNT>
+                std::array<std::size_t, HPX_HAVE_MAX_NUMA_DOMAIN_COUNT>
                     q_counts_;
                 // index of first queue on each nume domain
-                std::array<std::uint16_t, HPX_HAVE_MAX_NUMA_DOMAIN_COUNT>
+                std::array<std::size_t, HPX_HAVE_MAX_NUMA_DOMAIN_COUNT>
                     q_offset_;
                 // one item per numa domain of a container for queues on that domain
                 std::array<numa_queues, HPX_HAVE_MAX_NUMA_DOMAIN_COUNT>
                     numa_holder_;
 
                 // lookups for local thread_num into arrays
-                std::array<std::uint16_t, HPX_HAVE_MAX_CPU_COUNT>
+                std::array<std::size_t, HPX_HAVE_MAX_CPU_COUNT>
                     d_lookup_;    // numa domain
-                std::array<std::uint16_t, HPX_HAVE_MAX_CPU_COUNT>
+                std::array<std::size_t, HPX_HAVE_MAX_CPU_COUNT>
                     q_lookup_;    // queue on domain
 #ifdef SHARED_PRIORITY_SCHEDULER_LINUX
-                std::array<std::uint16_t, HPX_HAVE_MAX_CPU_COUNT>
+                std::array<std::size_t, HPX_HAVE_MAX_CPU_COUNT>
                     schedcpu_;    // cpu_id
 #endif
 
@@ -1406,7 +1380,7 @@ namespace hpx { namespace threads { namespace policies {
                 volatile bool debug_init_;
                 volatile std::size_t thread_init_counter_;
                 // used in thread pool checks
-                std::uint16_t pool_index_;
+                std::size_t pool_index_;
             };
 }}}    // namespace hpx::threads::policies
 #endif
diff --git a/hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp b/libs/schedulers/include/hpx/schedulers/static_priority_queue_scheduler.hpp
similarity index 83%
rename from hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp
rename to libs/schedulers/include/hpx/schedulers/static_priority_queue_scheduler.hpp
index ec01439f50..8704bf37bd 100644
--- a/hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp
+++ b/libs/schedulers/include/hpx/schedulers/static_priority_queue_scheduler.hpp
@@ -13,20 +13,18 @@
 
 #if defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
 #include <hpx/assertion.hpp>
-#include <hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads_fwd.hpp>
+#include <hpx/schedulers/local_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
 
-#include <mutex>
 #include <cstddef>
 #include <cstdint>
+#include <mutex>
 #include <string>
 
 #include <hpx/config/warnings_prefix.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace threads { namespace policies
-{
+namespace hpx { namespace threads { namespace policies {
     ///////////////////////////////////////////////////////////////////////////
 #if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
     using default_static_priority_queue_scheduler_terminated_queue =
@@ -51,10 +49,8 @@ namespace hpx { namespace threads { namespace policies
         typename TerminatedQueuing =
             default_static_priority_queue_scheduler_terminated_queue>
     class HPX_EXPORT static_priority_queue_scheduler
-      : public local_priority_queue_scheduler<Mutex,
-            PendingQueuing,
-            StagedQueuing,
-            TerminatedQueuing>
+      : public local_priority_queue_scheduler<Mutex, PendingQueuing,
+            StagedQueuing, TerminatedQueuing>
     {
     public:
         using base_type = local_priority_queue_scheduler<Mutex, PendingQueuing,
@@ -63,13 +59,12 @@ namespace hpx { namespace threads { namespace policies
         using init_parameter_type = typename base_type::init_parameter_type;
 
         static_priority_queue_scheduler(init_parameter_type const& init,
-                bool deferred_initialization = true)
+            bool deferred_initialization = true)
           : base_type(init, deferred_initialization)
         {
             // disable thread stealing to begin with
-            this->remove_scheduler_mode(
-                scheduler_mode(policies::enable_stealing |
-                               policies::enable_stealing_numa));
+            this->remove_scheduler_mode(scheduler_mode(
+                policies::enable_stealing | policies::enable_stealing_numa));
         }
 
         void set_scheduler_mode(scheduler_mode mode) override
@@ -85,10 +80,9 @@ namespace hpx { namespace threads { namespace policies
             return "static_priority_queue_scheduler";
         }
     };
-}}}
+}}}    // namespace hpx::threads::policies
 
 #include <hpx/config/warnings_suffix.hpp>
 
 #endif
 #endif
-
diff --git a/hpx/runtime/threads/policies/static_queue_scheduler.hpp b/libs/schedulers/include/hpx/schedulers/static_queue_scheduler.hpp
similarity index 79%
rename from hpx/runtime/threads/policies/static_queue_scheduler.hpp
rename to libs/schedulers/include/hpx/schedulers/static_queue_scheduler.hpp
index b3d2e5767d..c5ca510b03 100644
--- a/hpx/runtime/threads/policies/static_queue_scheduler.hpp
+++ b/libs/schedulers/include/hpx/schedulers/static_queue_scheduler.hpp
@@ -12,18 +12,18 @@
 
 #if defined(HPX_HAVE_STATIC_SCHEDULER)
 #include <hpx/assertion.hpp>
-#include <hpx/runtime/threads/policies/local_queue_scheduler.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/thread_queue.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/topology/topology.hpp>
-#include <hpx/runtime/threads_fwd.hpp>
 #include <hpx/logging.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+#include <hpx/schedulers/local_queue_scheduler.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/schedulers/thread_queue.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/topology/topology.hpp>
 
-#include <mutex>
 #include <cstddef>
 #include <cstdint>
 #include <memory>
+#include <mutex>
 #include <string>
 #include <vector>
 
@@ -32,16 +32,7 @@
 // TODO: add branch prediction and function heat
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace threads { namespace policies
-{
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    ///////////////////////////////////////////////////////////////////////////
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    extern bool minimal_deadlock_detection;
-#endif
-
+namespace hpx { namespace threads { namespace policies {
     ///////////////////////////////////////////////////////////////////////////
 #if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
     using default_static_queue_scheduler_terminated_queue = lockfree_lifo;
@@ -63,15 +54,16 @@ namespace hpx { namespace threads { namespace policies
             TerminatedQueuing>
     {
     public:
-        typedef local_queue_scheduler<
-            Mutex, PendingQueuing, StagedQueuing, TerminatedQueuing
-        > base_type;
+        typedef local_queue_scheduler<Mutex, PendingQueuing, StagedQueuing,
+            TerminatedQueuing>
+            base_type;
 
         static_queue_scheduler(
-                typename base_type::init_parameter_type const& init,
-                bool deferred_initialization = true)
+            typename base_type::init_parameter_type const& init,
+            bool deferred_initialization = true)
           : base_type(init, deferred_initialization)
-        {}
+        {
+        }
 
         static std::string get_scheduler_name()
         {
@@ -125,7 +117,8 @@ namespace hpx { namespace threads { namespace policies
             result =
                 this->queues_[num_thread]->wait_or_add_new(running, added) &&
                 result;
-            if (0 != added) return result;
+            if (0 != added)
+                return result;
 
             // Check if we have been disabled
             if (!running)
@@ -135,7 +128,8 @@ namespace hpx { namespace threads { namespace policies
 
 #ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
             // no new work is available, are we deadlocked?
-            if (HPX_UNLIKELY(minimal_deadlock_detection && LHPX_ENABLED(error)))
+            if (HPX_UNLIKELY(get_minimal_deadlock_detection_enabled() &&
+                    LHPX_ENABLED(error)))
             {
                 bool suspended_only = true;
 
@@ -146,8 +140,9 @@ namespace hpx { namespace threads { namespace policies
                         i, idle_loop_count, running);
                 }
 
-                if (HPX_UNLIKELY(suspended_only)) {
-                    LTM_(error) //-V128
+                if (HPX_UNLIKELY(suspended_only))
+                {
+                    LTM_(error)    //-V128
                         << "queue(" << num_thread << "): "
                         << "no new work available, are we deadlocked?";
                 }
@@ -157,10 +152,9 @@ namespace hpx { namespace threads { namespace policies
             return result;
         }
     };
-}}}
+}}}    // namespace hpx::threads::policies
 
 #include <hpx/config/warnings_suffix.hpp>
 
 #endif
 #endif
-
diff --git a/hpx/runtime/threads/policies/thread_queue.hpp b/libs/schedulers/include/hpx/schedulers/thread_queue.hpp
similarity index 90%
rename from hpx/runtime/threads/policies/thread_queue.hpp
rename to libs/schedulers/include/hpx/schedulers/thread_queue.hpp
index ca1ce4de8c..10a1540fb4 100644
--- a/hpx/runtime/threads/policies/thread_queue.hpp
+++ b/libs/schedulers/include/hpx/schedulers/thread_queue.hpp
@@ -16,13 +16,15 @@
 #include <hpx/errors.hpp>
 #include <hpx/format.hpp>
 #include <hpx/functional/function.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/queue_helpers.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_data_stackful.hpp>
-#include <hpx/runtime/threads/thread_data_stackless.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/schedulers/maintain_queue_wait_times.hpp>
+#include <hpx/schedulers/queue_helpers.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_data_stackful.hpp>
+#include <hpx/threading_base/thread_data_stackless.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
 #include <hpx/util/get_and_reset_value.hpp>
 
@@ -30,8 +32,6 @@
 #include <hpx/util/tick_counter.hpp>
 #endif
 
-#include <boost/lexical_cast.hpp>
-
 #include <atomic>
 #include <cstddef>
 #include <cstdint>
@@ -48,21 +48,6 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads { namespace policies {
-#ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-    ///////////////////////////////////////////////////////////////////////////
-    // We control whether to collect queue wait times using this global bool.
-    // It will be set by any of the related performance counters. Once set it
-    // stays set, thus no race conditions will occur.
-    extern HPX_EXPORT bool maintain_queue_wait_times;
-#endif
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-    ///////////////////////////////////////////////////////////////////////////
-    // We globally control whether to do minimal deadlock detection using this
-    // global bool variable. It will be set once by the runtime configuration
-    // startup code
-    extern bool minimal_deadlock_detection;
-#endif
-
     ///////////////////////////////////////////////////////////////////////////
     // // Queue back-end interface:
     //
@@ -219,7 +204,7 @@ namespace hpx { namespace threads { namespace policies {
             while (add_count-- && addfrom->new_tasks_.pop(task, steal))
             {
 #ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-                if (maintain_queue_wait_times)
+                if (get_maintain_queue_wait_times_enabled())
                 {
                     addfrom->new_tasks_wait_ +=
                         util::high_resolution_clock::now() -
@@ -314,12 +299,12 @@ namespace hpx { namespace threads { namespace policies {
                 }
                 else if (work_items_.empty())
                 {
-                    add_count =
-                        parameters_
-                            .min_add_new_count_;    // add this number of threads
+                    // add this number of threads
+                    add_count = parameters_.min_add_new_count_;
+
+                    // increase max_thread_count
                     parameters_.max_thread_count_ +=
-                        parameters_
-                            .min_add_new_count_;    // increase max_thread_count //-V101
+                        parameters_.min_add_new_count_;    //-V101
                 }
                 else
                 {
@@ -376,7 +361,7 @@ namespace hpx { namespace threads { namespace policies {
             util::tick_counter tc(cleanup_terminated_time_);
 #endif
 
-            if (terminated_items_count_ == 0)
+            if (terminated_items_count_.load(std::memory_order_acquire) == 0)
                 return true;
 
             if (delete_all)
@@ -418,27 +403,28 @@ namespace hpx { namespace threads { namespace policies {
                     thread_id_type tid(todelete);
                     --terminated_items_count_;
 
-                    thread_map_type::iterator it = thread_map_.find(tid);
-
                     // this thread has to be in this map
-                    HPX_ASSERT(it != thread_map_.end());
-
-                    recycle_thread(*it);
+                    HPX_ASSERT(thread_map_.find(tid) != thread_map_.end());
 
-                    thread_map_.erase(it);
+                    bool deleted = thread_map_.erase(tid) != 0;
+                    HPX_ASSERT(deleted);
+                    HPX_UNUSED(deleted);
                     --thread_map_count_;
+
                     HPX_ASSERT(thread_map_count_ >= 0);
 
+                    recycle_thread(tid);
+
                     --delete_count;
                 }
             }
-            return terminated_items_count_ == 0;
+            return terminated_items_count_.load(std::memory_order_acquire) == 0;
         }
 
     public:
         bool cleanup_terminated(bool delete_all = false)
         {
-            if (terminated_items_count_ == 0)
+            if (terminated_items_count_.load(std::memory_order_acquire) == 0)
                 return true;
 
             if (delete_all)
@@ -534,20 +520,23 @@ namespace hpx { namespace threads { namespace policies {
 
         ///////////////////////////////////////////////////////////////////////
         // This returns the current length of the queues (work items and new items)
-        std::int64_t get_queue_length() const
+        std::int64_t get_queue_length(
+            std::memory_order order = std::memory_order_acquire) const
         {
-            return work_items_count_.data_ + new_tasks_count_.data_;
+            return work_items_count_.data_.load(order) +
+                new_tasks_count_.data_.load(order);
         }
 
         // This returns the current length of the pending queue
-        std::int64_t get_pending_queue_length() const
+        std::int64_t get_pending_queue_length(
+            std::memory_order order = std::memory_order_acquire) const
         {
-            return work_items_count_.data_;
+            return work_items_count_.data_.load(order);
         }
 
         // This returns the current length of the staged queue
         std::int64_t get_staged_queue_length(
-            std::memory_order order = std::memory_order_seq_cst) const
+            std::memory_order order = std::memory_order_acquire) const
         {
             return new_tasks_count_.data_.load(order);
         }
@@ -631,30 +620,12 @@ namespace hpx { namespace threads { namespace policies {
             stolen_to_staged_.fetch_add(num, std::memory_order_relaxed);
         }
 #else
-        HPX_CXX14_CONSTEXPR void increment_num_pending_misses(
-            std::size_t num = 1)
-        {
-        }
-        HPX_CXX14_CONSTEXPR void increment_num_pending_accesses(
-            std::size_t num = 1)
-        {
-        }
-        HPX_CXX14_CONSTEXPR void increment_num_stolen_from_pending(
-            std::size_t num = 1)
-        {
-        }
-        HPX_CXX14_CONSTEXPR void increment_num_stolen_from_staged(
-            std::size_t num = 1)
-        {
-        }
-        HPX_CXX14_CONSTEXPR void increment_num_stolen_to_pending(
-            std::size_t num = 1)
-        {
-        }
-        HPX_CXX14_CONSTEXPR void increment_num_stolen_to_staged(
-            std::size_t num = 1)
-        {
-        }
+        constexpr void increment_num_pending_misses(std::size_t num = 1) {}
+        constexpr void increment_num_pending_accesses(std::size_t num = 1) {}
+        constexpr void increment_num_stolen_from_pending(std::size_t num = 1) {}
+        constexpr void increment_num_stolen_from_staged(std::size_t num = 1) {}
+        constexpr void increment_num_stolen_to_pending(std::size_t num = 1) {}
+        constexpr void increment_num_stolen_to_staged(std::size_t num = 1) {}
 #endif
 
         ///////////////////////////////////////////////////////////////////////
@@ -699,9 +670,11 @@ namespace hpx { namespace threads { namespace policies {
                         &get_thread_id_data(thrd)->get_queue<thread_queue>() ==
                         this);
 
-                    // push the new thread in the pending queue thread
+                    // push the new thread in the pending thread queue
                     if (initial_state == pending)
+                    {
                         schedule_thread(get_thread_id_data(thrd));
+                    }
 
                     // return the thread_id of the newly created thread
                     if (id)
@@ -738,7 +711,7 @@ namespace hpx { namespace threads { namespace policies {
                 --src->work_items_count_.data_;
 
 #ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-                if (maintain_queue_wait_times)
+                if (get_maintain_queue_wait_times_enabled())
                 {
                     std::uint64_t now = util::high_resolution_clock::now();
                     src->work_items_wait_ += now - util::get<1>(*trd);
@@ -760,7 +733,7 @@ namespace hpx { namespace threads { namespace policies {
             while (src->new_tasks_.pop(task))
             {
 #ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-                if (maintain_queue_wait_times)
+                if (get_maintain_queue_wait_times_enabled())
                 {
                     std::int64_t now = util::high_resolution_clock::now();
                     src->new_tasks_wait_ += now - util::get<2>(*task);
@@ -807,7 +780,7 @@ namespace hpx { namespace threads { namespace policies {
             {
                 --work_items_count_.data_;
 
-                if (maintain_queue_wait_times)
+                if (get_maintain_queue_wait_times_enabled())
                 {
                     work_items_wait_ += util::high_resolution_clock::now() -
                         util::get<1>(*tdesc);
@@ -843,10 +816,10 @@ namespace hpx { namespace threads { namespace policies {
         }
 
         /// Destroy the passed thread as it has been terminated
-        void destroy_thread(
-            threads::thread_data* thrd, std::int64_t& busy_count)
+        void destroy_thread(threads::thread_data* thrd)
         {
             HPX_ASSERT(&thrd->get_queue<thread_queue>() == this);
+
             terminated_items_.push(thrd);
 
             std::int64_t count = ++terminated_items_count_;
@@ -1055,7 +1028,7 @@ namespace hpx { namespace threads { namespace policies {
 #ifndef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
             return false;
 #else
-            if (minimal_deadlock_detection)
+            if (get_minimal_deadlock_detection_enabled())
             {
                 std::lock_guard<mutex_type> lk(mtx_);
                 return detail::dump_suspended_threads(
@@ -1076,30 +1049,30 @@ namespace hpx { namespace threads { namespace policies {
         mutable mutex_type mtx_;    // mutex protecting the members
 
         thread_map_type thread_map_;    // mapping of thread id's to HPX-threads
-        std::atomic<std::int64_t>
-            thread_map_count_;    // overall count of work items
+
+        // overall count of work items
+        std::atomic<std::int64_t> thread_map_count_;
 
         work_items_type work_items_;    // list of active work items
 
 #ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-        std::atomic<std::int64_t>
-            work_items_wait_;    // overall wait time of work items
-        std::atomic<std::int64_t>
-            work_items_wait_count_;    // overall number of
-                                       // work items in queue
+        // overall wait time of work items
+        std::atomic<std::int64_t> work_items_wait_;
+        // overall number of work items in queue
+        std::atomic<std::int64_t> work_items_wait_count_;
 #endif
-        terminated_items_type
-            terminated_items_;    // list of terminated threads
-        std::atomic<std::int64_t>
-            terminated_items_count_;    // count of terminated items
+        // list of terminated threads
+        terminated_items_type terminated_items_;
+        // count of terminated items
+        std::atomic<std::int64_t> terminated_items_count_;
 
         task_items_type new_tasks_;    // list of new tasks to run
 
 #ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-        std::atomic<std::int64_t>
-            new_tasks_wait_;    // overall wait time of new tasks
-        std::atomic<std::int64_t>
-            new_tasks_wait_count_;    // overall number tasks waited
+        // overall wait time of new tasks
+        std::atomic<std::int64_t> new_tasks_wait_;
+        // overall number tasks waited
+        std::atomic<std::int64_t> new_tasks_wait_count_;
 #endif
 
         thread_heap_type thread_heap_small_;
diff --git a/hpx/runtime/threads/policies/thread_queue_mc.hpp b/libs/schedulers/include/hpx/schedulers/thread_queue_mc.hpp
similarity index 96%
rename from hpx/runtime/threads/policies/thread_queue_mc.hpp
rename to libs/schedulers/include/hpx/schedulers/thread_queue_mc.hpp
index 86d695f608..482a0f476e 100644
--- a/hpx/runtime/threads/policies/thread_queue_mc.hpp
+++ b/libs/schedulers/include/hpx/schedulers/thread_queue_mc.hpp
@@ -14,12 +14,14 @@
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/function.hpp>
-#include <hpx/runtime/threads/policies/lockfree_queue_backends.hpp>
-#include <hpx/runtime/threads/policies/queue_holder_thread.hpp>
-#include <hpx/runtime/threads/policies/thread_queue.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+#include <hpx/schedulers/maintain_queue_wait_times.hpp>
+#include <hpx/schedulers/queue_holder_thread.hpp>
+#include <hpx/schedulers/thread_queue.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
 #include <hpx/topology/topology.hpp>
 #include <hpx/util/get_and_reset_value.hpp>
@@ -28,8 +30,6 @@
 #include <hpx/util/tick_counter.hpp>
 #endif
 
-#include <boost/lexical_cast.hpp>
-
 #include <atomic>
 #include <cstddef>
 #include <cstdint>
@@ -196,7 +196,6 @@ namespace hpx { namespace threads { namespace policies {
             return 0;
         }
 
-        // ----------------------------------------------------------------
         // create a new thread and schedule it if the initial state is equal to
         // pending
         void create_thread(thread_init_data& data, thread_id_type* id,
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/deadlock_detection.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/deadlock_detection.hpp
new file mode 100644
index 0000000000..341a17a09d
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/deadlock_detection.hpp
@@ -0,0 +1,22 @@
+//  Copyright (c) 2019 ETH Zurich
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/deadlock_detection.hpp \
+    is deprecated, please include \
+    hpx/schedulers/deadlock_detection.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/policies/deadlock_detection.hpp \
+    is deprecated, please include \
+    hpx/schedulers/deadlock_detection.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp
new file mode 100644
index 0000000000..6af9d1a2bd
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/local_priority_queue_scheduler.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp \
+    is deprecated, please include \
+    hpx/schedulers/local_priority_queue_scheduler.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp \
+    is deprecated, please include \
+    hpx/schedulers/local_priority_queue_scheduler.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/local_queue_scheduler.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/local_queue_scheduler.hpp
new file mode 100644
index 0000000000..cd94ae23aa
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/local_queue_scheduler.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/local_queue_scheduler.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/local_queue_scheduler.hpp is deprecated, \
+    please include hpx/schedulers/local_queue_scheduler.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/local_queue_scheduler.hpp is deprecated, \
+    please include hpx/schedulers/local_queue_scheduler.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/lockfree_queue_backends.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/lockfree_queue_backends.hpp
new file mode 100644
index 0000000000..38c7821916
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/lockfree_queue_backends.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/lockfree_queue_backends.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/lockfree_queue_backends.hpp is deprecated, \
+    please include hpx/schedulers/lockfree_queue_backends.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/lockfree_queue_backends.hpp is deprecated, \
+    please include hpx/schedulers/lockfree_queue_backends.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/maintain_queue_wait_times.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/maintain_queue_wait_times.hpp
new file mode 100644
index 0000000000..129759b58b
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/maintain_queue_wait_times.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 ETH Zurich
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/maintain_queue_wait_times.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/maintain_queue_wait_times.hpp \
+    is deprecated, please include \
+    hpx/schedulers/maintain_queue_wait_times.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/maintain_queue_wait_times.hpp \
+    is deprecated, please include \
+    hpx/schedulers/maintain_queue_wait_times.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/queue_helpers.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/queue_helpers.hpp
new file mode 100644
index 0000000000..57ec038079
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/queue_helpers.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/queue_helpers.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/queue_helpers.hpp is deprecated, \
+    please include hpx/schedulers/queue_helpers.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/queue_helpers.hpp is deprecated, \
+    please include hpx/schedulers/queue_helpers.hpp instead"
+#endif
+#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/named_write_fwd.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/schedulers.hpp
similarity index 50%
rename from libs/logging/include_compatibility/hpx/util/logging/format/named_write_fwd.hpp
rename to libs/schedulers/include_compatibility/hpx/runtime/threads/policies/schedulers.hpp
index 2c8e363dd6..6c4586295b 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/named_write_fwd.hpp
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/schedulers.hpp
@@ -1,21 +1,21 @@
-//  Copyright (c) 2019 Mikael Simberg
+//  Copyright (c) 2019 Ste||ar Group
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/named_write_fwd.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers.hpp>
 
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
-    "The header hpx/util/logging/format/named_write_fwd.hpp is deprecated, \
-    please include hpx/logging/format/named_write_fwd.hpp instead")
+    "The header hpx/runtime/threads/policies/schedulers.hpp is deprecated, \
+    please include hpx/schedulers.hpp instead")
 #else
 #warning                                                                       \
-    "The header hpx/util/logging/format/named_write_fwd.hpp is deprecated, \
-    please include hpx/logging/format/named_write_fwd.hpp instead"
+    "The header hpx/runtime/threads/policies/schedulers.hpp is deprecated, \
+    please include hpx/schedulers.hpp instead"
 #endif
 #endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp
new file mode 100644
index 0000000000..b1523e97ad
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/shared_priority_queue_scheduler.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp \
+    is deprecated, please include \
+    hpx/schedulers/shared_priority_queue_scheduler.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp \
+    is deprecated, please include \
+    hpx/schedulers/shared_priority_queue_scheduler.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp
new file mode 100644
index 0000000000..bb4a1362c1
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/static_priority_queue_scheduler.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp \
+    is deprecated, please include \
+    hpx/schedulers/static_priority_queue_scheduler.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp \
+    is deprecated, please include \
+    hpx/schedulers/static_priority_queue_scheduler.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/static_queue_scheduler.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/static_queue_scheduler.hpp
new file mode 100644
index 0000000000..0aba279c2a
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/static_queue_scheduler.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/static_queue_scheduler.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/static_queue_scheduler.hpp is deprecated, \
+    please include hpx/schedulers/static_queue_scheduler.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/static_queue_scheduler.hpp is deprecated, \
+    please include hpx/schedulers/static_queue_scheduler.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/thread_queue.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/thread_queue.hpp
new file mode 100644
index 0000000000..289d717def
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/thread_queue.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/thread_queue.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/thread_queue.hpp is deprecated, \
+    please include hpx/schedulers/thread_queue.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/thread_queue.hpp is deprecated, \
+    please include hpx/schedulers/thread_queue.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/thread_queue_mc.hpp b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/thread_queue_mc.hpp
new file mode 100644
index 0000000000..8bdf4cbe85
--- /dev/null
+++ b/libs/schedulers/include_compatibility/hpx/runtime/threads/policies/thread_queue_mc.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 Ste||ar Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/config/defines.hpp>
+#include <hpx/schedulers/thread_queue_mc.hpp>
+
+#if defined(HPX_SCHEDULERS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/thread_queue_mc.hpp is deprecated, \
+    please include hpx/schedulers/thread_queue_mc.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/thread_queue_mc.hpp is deprecated, \
+    please include hpx/schedulers/thread_queue_mc.hpp instead"
+#endif
+#endif
diff --git a/libs/schedulers/tests/CMakeLists.txt b/libs/schedulers/tests/CMakeLists.txt
new file mode 100644
index 0000000000..1fd48867be
--- /dev/null
+++ b/libs/schedulers/tests/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_SCHEDULERS_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_SCHEDULERS_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.schedulers)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.schedulers)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.schedulers)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.schedulers)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.schedulers)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.schedulers)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.schedulers
+        HEADERS ${schedulers_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        DEPENDENCIES hpx_schedulers)
+    endif()
+endif()
diff --git a/libs/schedulers/tests/performance/CMakeLists.txt b/libs/schedulers/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/schedulers/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/schedulers/tests/regressions/CMakeLists.txt b/libs/schedulers/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/schedulers/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/schedulers/tests/unit/CMakeLists.txt b/libs/schedulers/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/schedulers/tests/unit/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/segmented_algorithms/CMakeLists.txt b/libs/segmented_algorithms/CMakeLists.txt
index 0f329173ce..a2ff78eb59 100644
--- a/libs/segmented_algorithms/CMakeLists.txt
+++ b/libs/segmented_algorithms/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(segmented_algorithms_headers
   hpx/parallel/segmented_algorithm.hpp
diff --git a/libs/segmented_algorithms/README.rst b/libs/segmented_algorithms/README.rst
index faf2f3909d..c356ed790e 100644
--- a/libs/segmented_algorithms/README.rst
+++ b/libs/segmented_algorithms/README.rst
@@ -12,4 +12,4 @@ segmented_algorithms
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/segmented_algorithms/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/segmented_algorithms/docs/index.html>`__.
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_difference.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_difference.hpp
index fa50939502..159ea94044 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_difference.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_difference.hpp
@@ -11,9 +11,9 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/adjacent_difference.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_find.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_find.hpp
index 83dc1cc8be..82d214801b 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_find.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/adjacent_find.hpp
@@ -10,9 +10,9 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/adjacent_find.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/all_any_none.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/all_any_none.hpp
index e33c3cf673..987566f3c1 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/all_any_none.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/all_any_none.hpp
@@ -10,9 +10,9 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/all_any_none.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/count.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/count.hpp
index d7c217e96b..dba77dd374 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/count.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/count.hpp
@@ -10,11 +10,11 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/count.hpp>
 #include <hpx/parallel/algorithms/detail/accumulate.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/distance.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/dispatch.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/dispatch.hpp
index 5e8059085a..455afb80db 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/dispatch.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/dispatch.hpp
@@ -17,8 +17,8 @@
 #include <hpx/traits/segmented_iterator_traits.hpp>
 #include <hpx/type_support/decay.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
 
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/reduce.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/reduce.hpp
index 70afc311ee..f859aacd70 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/reduce.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/reduce.hpp
@@ -12,8 +12,8 @@
 #include <hpx/traits/segmented_iterator_traits.hpp>
 #include <hpx/util/zip_iterator.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/zip_iterator.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/scan.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/scan.hpp
index f7fc28aa6d..8fdf929cc8 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/scan.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/scan.hpp
@@ -20,9 +20,9 @@
 #include <hpx/type_support/void_guard.hpp>
 #include <hpx/util/unwrap.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
+#include <hpx/execution/executors/execution.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
-#include <hpx/parallel/executors/execution.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/loop.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/transfer.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/transfer.hpp
index fd7d7885a0..242ed7e368 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/transfer.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/detail/transfer.hpp
@@ -12,8 +12,8 @@
 #include <hpx/lcos/dataflow.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/exclusive_scan.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/exclusive_scan.hpp
index e94781a720..e2de01f095 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/exclusive_scan.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/exclusive_scan.hpp
@@ -13,9 +13,9 @@
 
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/exclusive_scan.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/scan.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -204,6 +204,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 OutIter>::is_segmented_iterator is_out_seg;
 
             // check if OutIter is segmented in the same way as SegIter
+            // NOLINTNEXTLINE(bugprone-branch-clone)
             if (is_segmented_the_same(first, last, dest, is_out_seg()))
             {
                 return segmented_exclusive_scan_seq(
@@ -231,6 +232,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
             typedef typename hpx::traits::segmented_iterator_traits<
                 OutIter>::is_segmented_iterator is_out_seg;
 
+            // NOLINTNEXTLINE(bugprone-branch-clone)
             if (is_segmented_the_same(first, last, dest, is_out_seg()))
             {
                 return segmented_exclusive_scan_par(
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/fill.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/fill.hpp
index ca47a93935..d9dd0b3a5d 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/fill.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/fill.hpp
@@ -9,8 +9,8 @@
 
 #include <hpx/config.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/for_each.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/find.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/find.hpp
index 60a71b95e7..99903e616d 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/find.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/find.hpp
@@ -10,9 +10,9 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/find.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/for_each.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/for_each.hpp
index 11951b866f..ba292e8a3c 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/for_each.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/for_each.hpp
@@ -10,9 +10,9 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/for_each.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/generate.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/generate.hpp
index 73ab9d83c6..0a7efb3ff9 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/generate.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/generate.hpp
@@ -10,9 +10,9 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/generate.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/inclusive_scan.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/inclusive_scan.hpp
index 6b6e18de91..71b4abe812 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/inclusive_scan.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/inclusive_scan.hpp
@@ -13,9 +13,9 @@
 
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/inclusive_scan.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/scan.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
@@ -204,6 +204,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 OutIter>::is_segmented_iterator is_out_seg;
 
             // check if OutIter is segmented in the same way as SegIter
+            // NOLINTNEXTLINE(bugprone-branch-clone)
             if (is_segmented_the_same(first, last, dest, is_out_seg()))
             {
                 return segmented_inclusive_scan_seq(
@@ -232,6 +233,7 @@ namespace hpx { namespace parallel { inline namespace v1 {
                 OutIter>::is_segmented_iterator is_out_seg;
 
             // check if OutIter is segmented in the same way as SegIter
+            // NOLINTNEXTLINE(bugprone-branch-clone)
             if (is_segmented_the_same(first, last, dest, is_out_seg()))
             {
                 return segmented_inclusive_scan_par(
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/minmax.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/minmax.hpp
index 3801c523e6..ff46b15c18 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/minmax.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/minmax.hpp
@@ -10,9 +10,9 @@
 #include <hpx/config.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/minmax.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/reduce.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/reduce.hpp
index a5977211c8..c0f65a3b7e 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/reduce.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/reduce.hpp
@@ -11,11 +11,11 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/accumulate.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/detail/distance.hpp>
 #include <hpx/parallel/algorithms/reduce.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/reduce.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform.hpp
index c45029e4a0..098929a810 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform.hpp
@@ -13,9 +13,9 @@
 #include <hpx/util/tagged_pair.hpp>
 #include <hpx/util/tagged_tuple.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/transform.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
 #include <hpx/parallel/util/detail/handle_remote_exceptions.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_exclusive_scan.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_exclusive_scan.hpp
index 4478362bb5..e34a24e9c2 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_exclusive_scan.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_exclusive_scan.hpp
@@ -13,9 +13,9 @@
 
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/transform_exclusive_scan.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/scan.hpp>
 #include <hpx/parallel/segmented_algorithms/exclusive_scan.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_inclusive_scan.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_inclusive_scan.hpp
index 9fcda84851..6e2edee060 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_inclusive_scan.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_inclusive_scan.hpp
@@ -13,9 +13,9 @@
 
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/transform_inclusive_scan.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/scan.hpp>
 #include <hpx/parallel/segmented_algorithms/inclusive_scan.hpp>
diff --git a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_reduce.hpp b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_reduce.hpp
index 5e78390dd9..3a6add0317 100644
--- a/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_reduce.hpp
+++ b/libs/segmented_algorithms/include/hpx/parallel/segmented_algorithms/transform_reduce.hpp
@@ -12,9 +12,9 @@
 #include <hpx/functional/invoke.hpp>
 #include <hpx/traits/segmented_iterator_traits.hpp>
 
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/parallel/algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/algorithms/transform_reduce.hpp>
-#include <hpx/parallel/execution_policy.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/dispatch.hpp>
 #include <hpx/parallel/segmented_algorithms/detail/reduce.hpp>
 #include <hpx/parallel/util/detail/algorithm_result.hpp>
diff --git a/libs/serialization/CMakeLists.txt b/libs/serialization/CMakeLists.txt
index 970463e320..32db7641c6 100644
--- a/libs/serialization/CMakeLists.txt
+++ b/libs/serialization/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -151,10 +151,18 @@ add_hpx_module(serialization
   DEPENDENCIES
     hpx_assertion
     hpx_config
+    hpx_datastructures
     hpx_debugging
     hpx_errors
+    hpx_format
     hpx_hashing
     hpx_preprocessor
     hpx_type_support
   CMAKE_SUBDIRS examples tests
 )
+
+# Temporary needs hpx_util cause still depending on custom_exception_info which
+# is itself depending on hpx/naming_base.hpp
+target_link_libraries(hpx_serialization PUBLIC
+  hpx_naming_base
+  )
diff --git a/libs/serialization/README.rst b/libs/serialization/README.rst
index 4b5a96e068..9de2a3f0f2 100644
--- a/libs/serialization/README.rst
+++ b/libs/serialization/README.rst
@@ -13,4 +13,4 @@ serialization
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/serialization/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/serialization/docs/index.html>`__.
diff --git a/libs/serialization/include/hpx/serialization/access.hpp b/libs/serialization/include/hpx/serialization/access.hpp
index 40544aee17..2f1df1f11a 100644
--- a/libs/serialization/include/hpx/serialization/access.hpp
+++ b/libs/serialization/include/hpx/serialization/access.hpp
@@ -40,7 +40,7 @@ namespace hpx { namespace serialization {
 
     ///////////////////////////////////////////////////////////////////////////
     // This trait must live outside of 'class access' below as otherwise MSVC
-    // will find the serialize() function in 'class access' as a dependend class
+    // will find the serialize() function in 'class access' as a dependent class
     // (which is an MS extension)
     template <typename T>
     class has_serialize_adl
diff --git a/libs/serialization/include/hpx/serialization/array.hpp b/libs/serialization/include/hpx/serialization/array.hpp
index 6463bdc0ab..b9767b2dbb 100644
--- a/libs/serialization/include/hpx/serialization/array.hpp
+++ b/libs/serialization/include/hpx/serialization/array.hpp
@@ -82,6 +82,7 @@ namespace hpx { namespace serialization {
             bool archive_endianess_differs = ar.endian_big();
 #endif
 
+            // NOLINTNEXTLINE(bugprone-branch-clone)
             if (ar.disable_array_optimization() || archive_endianess_differs)
                 serialize_optimized(ar, v, std::false_type());
             else
diff --git a/libs/serialization/include/hpx/serialization/brace_initializable.hpp b/libs/serialization/include/hpx/serialization/brace_initializable.hpp
index 2481715069..fc2d87007e 100644
--- a/libs/serialization/include/hpx/serialization/brace_initializable.hpp
+++ b/libs/serialization/include/hpx/serialization/brace_initializable.hpp
@@ -164,9 +164,8 @@ namespace hpx { namespace serialization {
     void serialize_struct(Archive& archive, T& t, const unsigned int version,
         hpx::traits::detail::size<15>)
     {
-        auto&
-            [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15] =
-            t;
+        auto& [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14,
+            p15] = t;
         auto&& data = hpx::util::forward_as_tuple(
             p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
         serialize(archive, data, version);
diff --git a/libs/serialization/include/hpx/serialization/detail/pointer.hpp b/libs/serialization/include/hpx/serialization/detail/pointer.hpp
index 755a52a3cd..b944e46e82 100644
--- a/libs/serialization/include/hpx/serialization/detail/pointer.hpp
+++ b/libs/serialization/include/hpx/serialization/detail/pointer.hpp
@@ -9,7 +9,6 @@
 #define HPX_SERIALIZATION_DETAIL_POINTER_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/datastructures.hpp>
 #include <hpx/serialization/access.hpp>
 #include <hpx/serialization/basic_archive.hpp>
 #include <hpx/serialization/detail/non_default_constructible.hpp>
diff --git a/libs/serialization/include/hpx/serialization/input_archive.hpp b/libs/serialization/include/hpx/serialization/input_archive.hpp
index 272238e510..e947741d1f 100644
--- a/libs/serialization/include/hpx/serialization/input_archive.hpp
+++ b/libs/serialization/include/hpx/serialization/input_archive.hpp
@@ -5,8 +5,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/cstdint.hpp
-
 #ifndef HPX_SERIALIZATION_BASIC_INPUT_ARCHIVE_HPP
 #define HPX_SERIALIZATION_BASIC_INPUT_ARCHIVE_HPP
 
@@ -18,7 +16,6 @@
 #include <hpx/serialization/input_container.hpp>
 #include <hpx/serialization/traits/is_bitwise_serializable.hpp>
 
-#include <boost/cstdint.hpp>
 #include <boost/predef/other/endian.h>
 
 #include <cstddef>
@@ -47,9 +44,9 @@ namespace hpx { namespace serialization {
             // properly interpret the flags
 
             // FIXME: make bool once integer compression is implemented
-            std::uint64_t endianess = 0ul;
-            load(endianess);
-            if (endianess)
+            std::uint64_t endianness = 0ul;
+            load(endianness);
+            if (endianness)
                 this->base_type::flags_ = hpx::serialization::endian_big;
 
             // load flags sent by the other end to make sure both ends have
@@ -180,41 +177,6 @@ namespace hpx { namespace serialization {
             load_integral_impl(ul);
             val = static_cast<T>(ul);
         }
-
-#if defined(BOOST_HAS_INT128) && !defined(__NVCC__) && !defined(__CUDACC__)
-        void load_integral(boost::int128_type& t, std::false_type)
-        {
-            load_integral_impl(t);
-        }
-
-        void load_integral(boost::uint128_type& t, std::true_type)
-        {
-            load_integral_impl(t);
-        }
-
-        // On some platforms (gcc) std::is_integral<int128>::value
-        // evaluates to false. Thus, these functions re-route the
-        // serialization for those types to the proper implementation
-        void load_bitwise(boost::int128_type& t, std::false_type)
-        {
-            load_integral_impl(t);
-        }
-
-        void load_bitwise(boost::int128_type& t, std::true_type)
-        {
-            load_integral_impl(t);
-        }
-
-        void load_bitwise(boost::uint128_type& t, std::false_type)
-        {
-            load_integral_impl(t);
-        }
-
-        void load_bitwise(boost::uint128_type& t, std::true_type)
-        {
-            load_integral_impl(t);
-        }
-#endif
         template <class Promoted>
         void load_integral_impl(Promoted& l)
         {
diff --git a/libs/serialization/include/hpx/serialization/output_archive.hpp b/libs/serialization/include/hpx/serialization/output_archive.hpp
index 106eb749c8..e0b5991567 100644
--- a/libs/serialization/include/hpx/serialization/output_archive.hpp
+++ b/libs/serialization/include/hpx/serialization/output_archive.hpp
@@ -5,8 +5,6 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/cstdint.hpp
-
 #ifndef HPX_SERIALIZATION_OUTPUT_ARCHIVE_HPP
 #define HPX_SERIALIZATION_OUTPUT_ARCHIVE_HPP
 
@@ -18,9 +16,6 @@
 #include <hpx/serialization/output_container.hpp>
 #include <hpx/serialization/traits/is_bitwise_serializable.hpp>
 
-#if defined(BOOST_HAS_INT128) && !defined(__NVCC__) && !defined(__CUDACC__)
-#include <boost/cstdint.hpp>
-#endif
 #include <boost/predef/other/endian.h>
 
 #include <cstddef>
@@ -122,9 +117,9 @@ namespace hpx { namespace serialization {
             // properly interpret the flags
 
             // FIXME: make bool once integer compression is implemented
-            std::uint64_t endianess =
+            std::uint64_t endianness =
                 this->base_type::endian_big() ? ~0ul : 0ul;
-            save(endianess);
+            save(endianness);
 
             // send flags sent by the other end to make sure both ends have
             // the same assumptions about the archive format
@@ -271,41 +266,6 @@ namespace hpx { namespace serialization {
             save_integral_impl(static_cast<std::uint64_t>(val));
         }
 
-#if defined(BOOST_HAS_INT128) && !defined(__NVCC__) && !defined(__CUDACC__)
-        void save_integral(boost::int128_type t, std::false_type)
-        {
-            save_integral_impl(t);
-        }
-
-        void save_integral(boost::uint128_type t, std::true_type)
-        {
-            save_integral_impl(t);
-        }
-
-        // On some platforms (gcc) std::is_integral<int128>::value
-        // evaluates to false. Thus these functions re-route the
-        // serialization for those types to the proper implementation
-        void save_bitwise(boost::int128_type t, std::false_type)
-        {
-            save_integral_impl(t);
-        }
-
-        void save_bitwise(boost::int128_type t, std::true_type)
-        {
-            save_integral_impl(t);
-        }
-
-        void save_bitwise(boost::uint128_type t, std::false_type)
-        {
-            save_integral_impl(t);
-        }
-
-        void save_bitwise(boost::uint128_type t, std::true_type)
-        {
-            save_integral_impl(t);
-        }
-#endif
-
         template <class Promoted>
         void save_integral_impl(Promoted l)
         {
diff --git a/libs/serialization/include/hpx/serialization/output_container.hpp b/libs/serialization/include/hpx/serialization/output_container.hpp
index 6204dcfc48..e8ba325cef 100644
--- a/libs/serialization/include/hpx/serialization/output_container.hpp
+++ b/libs/serialization/include/hpx/serialization/output_container.hpp
@@ -31,26 +31,26 @@ namespace hpx { namespace serialization {
         ///////////////////////////////////////////////////////////////////////
         struct basic_chunker
         {
-            HPX_CONSTEXPR basic_chunker(std::vector<serialization_chunk>*) {}
+            constexpr basic_chunker(std::vector<serialization_chunk>*) {}
 
-            HPX_CONSTEXPR static std::size_t get_chunk_size()
+            static constexpr std::size_t get_chunk_size()
             {
                 return 0;
             }
 
             static void set_chunk_size(std::size_t) {}
 
-            HPX_CONSTEXPR static std::uint8_t get_chunk_type()
+            static constexpr std::uint8_t get_chunk_type()
             {
                 return chunk_type_index;
             }
 
-            HPX_CONSTEXPR static std::size_t get_chunk_data_index()
+            static constexpr std::size_t get_chunk_data_index()
             {
                 return 0;
             }
 
-            HPX_CONSTEXPR static std::size_t get_num_chunks()
+            static constexpr std::size_t get_num_chunks()
             {
                 return 1;
             }
diff --git a/libs/serialization/include/hpx/serialization/traits/serialization_access_data.hpp b/libs/serialization/include/hpx/serialization/traits/serialization_access_data.hpp
index be57fa1299..881805f847 100644
--- a/libs/serialization/include/hpx/serialization/traits/serialization_access_data.hpp
+++ b/libs/serialization/include/hpx/serialization/traits/serialization_access_data.hpp
@@ -24,14 +24,14 @@ namespace hpx { namespace traits {
     {
         using preprocessing_only = std::false_type;
 
-        HPX_CONSTEXPR static bool is_preprocessing()
+        static constexpr bool is_preprocessing()
         {
             return false;
         }
 
         // functions related to output operations
-        HPX_CXX14_CONSTEXPR static void write(Container& cont,
-            std::size_t count, std::size_t current, void const* address)
+        static constexpr void write(Container& cont, std::size_t count,
+            std::size_t current, void const* address)
         {
         }
 
@@ -43,19 +43,19 @@ namespace hpx { namespace traits {
         }
 
         // functions related to input operations
-        HPX_CXX14_CONSTEXPR static void read(Container const& cont,
-            std::size_t count, std::size_t current, void* address)
+        static constexpr void read(Container const& cont, std::size_t count,
+            std::size_t current, void* address)
         {
         }
 
-        HPX_CONSTEXPR static std::size_t init_data(Container const& cont,
+        static constexpr std::size_t init_data(Container const& cont,
             serialization::binary_filter* filter, std::size_t current,
             std::size_t decompressed_size)
         {
             return decompressed_size;
         }
 
-        HPX_CXX14_CONSTEXPR static void reset(Container& cont) {}
+        static constexpr void reset(Container& cont) {}
     };
 
     ///////////////////////////////////////////////////////////////////////
diff --git a/libs/serialization/include/hpx/serialization/tuple.hpp b/libs/serialization/include/hpx/serialization/tuple.hpp
index 5f6a2be992..50e16e6372 100644
--- a/libs/serialization/include/hpx/serialization/tuple.hpp
+++ b/libs/serialization/include/hpx/serialization/tuple.hpp
@@ -10,11 +10,11 @@
 #if !defined(HPX_RUNTIME_SERIALIZATION_TUPLE_HPP)
 #define HPX_RUNTIME_SERIALIZATION_TUPLE_HPP
 
-#include <hpx/datastructures/detail/pack.hpp>
 #include <hpx/datastructures/tuple.hpp>
 #include <hpx/serialization/detail/non_default_constructible.hpp>
 #include <hpx/serialization/serialization_fwd.hpp>
 #include <hpx/serialization/traits/is_bitwise_serializable.hpp>
+#include <hpx/type_support/pack.hpp>
 
 #include <cstddef>
 #include <type_traits>
@@ -23,7 +23,7 @@ namespace hpx { namespace traits {
 
     template <typename... Ts>
     struct is_bitwise_serializable<::hpx::util::tuple<Ts...>>
-      : ::hpx::util::detail::all_of<hpx::traits::is_bitwise_serializable<
+      : ::hpx::util::all_of<hpx::traits::is_bitwise_serializable<
             typename std::remove_const<Ts>::type>...>
     {
     };
@@ -41,8 +41,8 @@ namespace hpx { namespace util { namespace detail {
     struct save_construct_data_with_index_pack;
 
     template <typename Archive, std::size_t... Is, typename... Ts>
-    struct serialize_with_index_pack<Archive,
-        hpx::util::detail::pack_c<std::size_t, Is...>, Ts...>
+    struct serialize_with_index_pack<Archive, hpx::util::index_pack<Is...>,
+        Ts...>
     {
         static void call(Archive& ar, hpx::util::tuple<Ts...>& t, unsigned int)
         {
@@ -53,7 +53,7 @@ namespace hpx { namespace util { namespace detail {
 
     template <typename Archive, std::size_t... Is, typename... Ts>
     struct load_construct_data_with_index_pack<Archive,
-        hpx::util::detail::pack_c<std::size_t, Is...>, Ts...>
+        hpx::util::index_pack<Is...>, Ts...>
     {
         static void call(
             Archive& ar, hpx::util::tuple<Ts...>& t, unsigned int version)
@@ -68,7 +68,7 @@ namespace hpx { namespace util { namespace detail {
 
     template <typename Archive, std::size_t... Is, typename... Ts>
     struct save_construct_data_with_index_pack<Archive,
-        hpx::util::detail::pack_c<std::size_t, Is...>, Ts...>
+        hpx::util::index_pack<Is...>, Ts...>
     {
         static void call(
             Archive& ar, hpx::util::tuple<Ts...> const& t, unsigned int version)
@@ -88,8 +88,7 @@ namespace hpx { namespace serialization {
     void serialize(
         Archive& ar, hpx::util::tuple<Ts...>& t, unsigned int version)
     {
-        using Is =
-            typename hpx::util::detail::make_index_pack<sizeof...(Ts)>::type;
+        using Is = typename hpx::util::make_index_pack<sizeof...(Ts)>::type;
         hpx::util::detail::serialize_with_index_pack<Archive, Is, Ts...>::call(
             ar, t, version);
     }
@@ -103,8 +102,7 @@ namespace hpx { namespace serialization {
     void load_construct_data(
         Archive& ar, hpx::util::tuple<Ts...>* t, unsigned int version)
     {
-        using Is =
-            typename hpx::util::detail::make_index_pack<sizeof...(Ts)>::type;
+        using Is = typename hpx::util::make_index_pack<sizeof...(Ts)>::type;
         hpx::util::detail::load_construct_data_with_index_pack<Archive, Is,
             Ts...>::call(ar, *t, version);
     }
@@ -113,8 +111,7 @@ namespace hpx { namespace serialization {
     void save_construct_data(
         Archive& ar, hpx::util::tuple<Ts...> const* t, unsigned int version)
     {
-        using Is =
-            typename hpx::util::detail::make_index_pack<sizeof...(Ts)>::type;
+        using Is = typename hpx::util::make_index_pack<sizeof...(Ts)>::type;
         hpx::util::detail::save_construct_data_with_index_pack<Archive, Is,
             Ts...>::call(ar, *t, version);
     }
diff --git a/libs/serialization/tests/performance/serialization_overhead.cpp b/libs/serialization/tests/performance/serialization_overhead.cpp
index 8c0e3535ce..569c42bd4f 100644
--- a/libs/serialization/tests/performance/serialization_overhead.cpp
+++ b/libs/serialization/tests/performance/serialization_overhead.cpp
@@ -10,8 +10,8 @@
 #include <hpx/include/iostreams.hpp>
 #include <hpx/runtime/serialization/detail/preprocess_container.hpp>
 #include <hpx/testing.hpp>
+#include <hpx/util/from_string.hpp>
 
-#include <boost/lexical_cast.hpp>
 #include <boost/predef/other/endian.h>
 
 #include <algorithm>
@@ -73,7 +73,7 @@ double benchmark_serialization(std::size_t data_size, std::size_t iterations,
     std::string array_optimization =
         hpx::get_config_entry("hpx.parcel.array_optimization", "1");
 
-    if (boost::lexical_cast<int>(array_optimization) == 0)
+    if (hpx::util::from_string<int>(array_optimization) == 0)
     {
         out_archive_flags |= hpx::serialization::disable_array_optimization;
         out_archive_flags |= hpx::serialization::disable_data_chunking;
@@ -82,7 +82,8 @@ double benchmark_serialization(std::size_t data_size, std::size_t iterations,
     {
         std::string zero_copy_optimization =
             hpx::get_config_entry("hpx.parcel.zero_copy_optimization", "1");
-        if (!zerocopy || boost::lexical_cast<int>(zero_copy_optimization) == 0)
+        if (!zerocopy ||
+            hpx::util::from_string<int>(zero_copy_optimization) == 0)
         {
             out_archive_flags |= hpx::serialization::disable_data_chunking;
         }
diff --git a/libs/serialization/tests/performance/serialization_performance.cpp b/libs/serialization/tests/performance/serialization_performance.cpp
index 1f6a418442..bc3f0f381c 100644
--- a/libs/serialization/tests/performance/serialization_performance.cpp
+++ b/libs/serialization/tests/performance/serialization_performance.cpp
@@ -10,8 +10,8 @@
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/serialization/string.hpp>
 #include <hpx/serialization/vector.hpp>
+#include <hpx/util/from_string.hpp>
 #include <hpx/version.hpp>
-#include <type_traits>
 
 #include <chrono>
 #include <cstddef>
@@ -19,10 +19,9 @@
 #include <iostream>
 #include <stdexcept>
 #include <string>
+#include <type_traits>
 #include <vector>
 
-#include <boost/lexical_cast.hpp>
-
 std::size_t const kStringsCount = 100;
 std::string const kStringValue = "shgfkghsdfjhgsfjhfgjhfgjsffghgsfdhgsfdfkdjh"
                                  "fioukjhkfdljgdfkgvjafdhasgdfwurtjkghfsdjkfg";
@@ -231,7 +230,7 @@ int main(int argc, char** argv)
     std::size_t iterations;
     try
     {
-        iterations = boost::lexical_cast<size_t>(argv[1]);
+        iterations = hpx::util::from_string<size_t>(argv[1]);
     }
     catch (std::exception& exc)
     {
diff --git a/libs/serialization/tests/unit/serialization_builtins.cpp b/libs/serialization/tests/unit/serialization_builtins.cpp
index 9af9b5b184..767dc0102c 100644
--- a/libs/serialization/tests/unit/serialization_builtins.cpp
+++ b/libs/serialization/tests/unit/serialization_builtins.cpp
@@ -4,14 +4,10 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/cstdint.hpp
-
 #include <hpx/serialization/input_archive.hpp>
 #include <hpx/serialization/output_archive.hpp>
 #include <hpx/serialization/serialize.hpp>
 
-#include <boost/cstdint.hpp>
-
 #include <cstdint>
 #include <vector>
 
@@ -39,26 +35,6 @@ struct A
     }
 };
 
-#if defined(BOOST_HAS_INT128)
-std::ostream& operator<<(std::ostream& s, boost::int128_type i)
-{
-    std::int64_t low = i;
-    i >>= 64;
-    std::int64_t high = i;
-    s << std::hex << "high: i" << high << "; low: " << low;
-    return s;
-}
-
-std::ostream& operator<<(std::ostream& s, boost::uint128_type i)
-{
-    std::uint64_t low = i;
-    i >>= 64;
-    std::uint64_t high = i;
-    s << std::hex << "high: i" << high << "; low: " << low;
-    return s;
-}
-#endif
-
 #include <hpx/testing.hpp>
 
 void test_bool()
@@ -208,14 +184,6 @@ int main()
         (std::numeric_limits<unsigned long>::min)() + 100);
     test<unsigned long>((std::numeric_limits<unsigned long>::max)() - 100,
         (std::numeric_limits<unsigned long>::max)());
-#if defined(BOOST_HAS_INT128)
-    test<boost::int128_type>(
-        (std::numeric_limits<boost::int128_type>::max)() - 100,
-        (std::numeric_limits<boost::int128_type>::max)());
-    test<boost::uint128_type>(
-        (std::numeric_limits<boost::uint128_type>::max)() - 100,
-        (std::numeric_limits<boost::uint128_type>::max)());
-#endif
     test_fp<float>((std::numeric_limits<float>::min)(),
         (std::numeric_limits<float>::min)() + 100);
     test_fp<float>(-100, 100);
diff --git a/libs/serialization/tests/unit/serialize_buffer.cpp b/libs/serialization/tests/unit/serialize_buffer.cpp
index fd6a1e88a7..0b387f817f 100644
--- a/libs/serialization/tests/unit/serialize_buffer.cpp
+++ b/libs/serialization/tests/unit/serialize_buffer.cpp
@@ -51,7 +51,7 @@ void test(hpx::id_type dest, char* send_buffer, std::size_t size)
     {
         buffer_type b = f.get();
         HPX_TEST_EQ(b.size(), size);
-        HPX_TEST(0 == memcmp(b.data(), send_buffer, size));
+        HPX_TEST_EQ(0, memcmp(b.data(), send_buffer, size));
     }
 }
 
@@ -77,7 +77,7 @@ void test_stateful_allocator(hpx::id_type dest, char* send_buffer,
     {
         buffer_type b = f.get();
         HPX_TEST_EQ(b.size(), size);
-        HPX_TEST(0 == memcmp(b.data(), send_buffer, size));
+        HPX_TEST_EQ(0, memcmp(b.data(), send_buffer, size));
     }
 }
 
diff --git a/libs/serialization/tests/unit/zero_copy_serialization.cpp b/libs/serialization/tests/unit/zero_copy_serialization.cpp
index 8512872d48..0fdd674320 100644
--- a/libs/serialization/tests/unit/zero_copy_serialization.cpp
+++ b/libs/serialization/tests/unit/zero_copy_serialization.cpp
@@ -108,8 +108,8 @@ std::size_t get_archive_size(hpx::parcelset::parcel const& p,
 }
 
 ///////////////////////////////////////////////////////////////////////////////
-void test_parcel_serialization(
-    hpx::parcelset::parcel outp, int out_archive_flags, bool zero_copy)
+void test_parcel_serialization(hpx::parcelset::parcel outp,
+    std::uint32_t out_archive_flags, bool zero_copy)
 {
     // serialize data
     std::vector<hpx::serialization::serialization_chunk> out_chunks;
@@ -181,7 +181,7 @@ void test_normal_serialization(T& arg)
         reinterpret_cast<std::uint64_t>(&test_function1));
 
     // compose archive flags
-    unsigned out_archive_flags = hpx::serialization::disable_data_chunking;
+    std::uint32_t out_archive_flags = hpx::serialization::disable_data_chunking;
 #if BOOST_ENDIAN_BIG_BYTE
     out_archive_flags |= hpx::serialization::endian_big;
 #else
@@ -209,7 +209,7 @@ void test_normal_serialization(T1& arg1, T2& arg2)
         reinterpret_cast<std::uint64_t>(&test_function2));
 
     // compose archive flags
-    unsigned out_archive_flags = hpx::serialization::disable_data_chunking;
+    std::uint32_t out_archive_flags = hpx::serialization::disable_data_chunking;
 #if BOOST_ENDIAN_BIG_BYTE
     out_archive_flags |= hpx::serialization::endian_big;
 #else
@@ -238,7 +238,7 @@ void test_normal_serialization(
         reinterpret_cast<std::uint64_t>(&test_function2));
 
     // compose archive flags
-    unsigned out_archive_flags = hpx::serialization::disable_data_chunking;
+    std::uint32_t out_archive_flags = hpx::serialization::disable_data_chunking;
 #if BOOST_ENDIAN_BIG_BYTE
     out_archive_flags |= hpx::serialization::endian_big;
 #else
@@ -267,7 +267,7 @@ void test_zero_copy_serialization(T& arg)
         reinterpret_cast<std::uint64_t>(&test_function1));
 
     // compose archive flags
-    unsigned out_archive_flags = 0U;
+    std::uint32_t out_archive_flags = 0U;
 #if BOOST_ENDIAN_BIG_BYTE
     out_archive_flags |= hpx::serialization::endian_big;
 #else
@@ -295,7 +295,7 @@ void test_zero_copy_serialization(T1& arg1, T2& arg2)
         reinterpret_cast<std::uint64_t>(&test_function2));
 
     // compose archive flags
-    unsigned out_archive_flags = 0U;
+    std::uint32_t out_archive_flags = 0U;
 #if BOOST_ENDIAN_BIG_BYTE
     out_archive_flags |= hpx::serialization::endian_big;
 #else
@@ -324,7 +324,7 @@ void test_zero_copy_serialization(
         reinterpret_cast<std::uint64_t>(&test_function2));
 
     // compose archive flags
-    unsigned out_archive_flags = 0U;
+    std::uint32_t out_archive_flags = 0U;
 #if BOOST_ENDIAN_BIG_BYTE
     out_archive_flags |= hpx::serialization::endian_big;
 #else
diff --git a/libs/static_reinit/CMakeLists.txt b/libs/static_reinit/CMakeLists.txt
index 3265240f67..03461a7991 100644
--- a/libs/static_reinit/CMakeLists.txt
+++ b/libs/static_reinit/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/static_reinit/README.rst b/libs/static_reinit/README.rst
index 354cd8f0aa..9926c87a46 100644
--- a/libs/static_reinit/README.rst
+++ b/libs/static_reinit/README.rst
@@ -13,4 +13,4 @@ static_reinit
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/static_reinit/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/static_reinit/docs/index.html>`__.
diff --git a/libs/statistics/CMakeLists.txt b/libs/statistics/CMakeLists.txt
index a697fa459b..80665b1663 100644
--- a/libs/statistics/CMakeLists.txt
+++ b/libs/statistics/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/statistics/README.rst b/libs/statistics/README.rst
index 10287a4023..9657b267ce 100644
--- a/libs/statistics/README.rst
+++ b/libs/statistics/README.rst
@@ -12,4 +12,4 @@ statistics
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/statistics/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/statistics/docs/index.html>`__.
diff --git a/libs/statistics/include/hpx/statistics/max.hpp b/libs/statistics/include/hpx/statistics/max.hpp
index edba3d6ce6..9ce0422e3a 100644
--- a/libs/statistics/include/hpx/statistics/max.hpp
+++ b/libs/statistics/include/hpx/statistics/max.hpp
@@ -12,7 +12,7 @@
 namespace hpx { namespace util {
 
     template <typename T>
-    HPX_HOST_DEVICE HPX_CONSTEXPR inline T const&(max)(T const& a, T const& b)
+    HPX_HOST_DEVICE constexpr inline T const&(max)(T const& a, T const& b)
     {
         return a < b ? b : a;
     }
diff --git a/libs/statistics/include/hpx/statistics/min.hpp b/libs/statistics/include/hpx/statistics/min.hpp
index 30b89ea2c3..4d91ff2e73 100644
--- a/libs/statistics/include/hpx/statistics/min.hpp
+++ b/libs/statistics/include/hpx/statistics/min.hpp
@@ -12,7 +12,7 @@
 namespace hpx { namespace util {
 
     template <typename T>
-    HPX_HOST_DEVICE HPX_CONSTEXPR inline T const&(min)(T const& a, T const& b)
+    HPX_HOST_DEVICE constexpr inline T const&(min)(T const& a, T const& b)
     {
         return a < b ? a : b;
     }
diff --git a/libs/string_util/CMakeLists.txt b/libs/string_util/CMakeLists.txt
new file mode 100644
index 0000000000..25b4b76ed3
--- /dev/null
+++ b/libs/string_util/CMakeLists.txt
@@ -0,0 +1,25 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(string_util_headers
+    hpx/string_util/case_conv.hpp
+    hpx/string_util/classification.hpp
+    hpx/string_util/split.hpp
+    hpx/string_util/trim.hpp
+    )
+
+include(HPX_AddModule)
+add_hpx_module(string_util
+  GLOBAL_HEADER_GEN ON
+  FORCE_LINKING_GEN
+  HEADERS ${string_util_headers}
+  DEPENDENCIES
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/string_util/README.rst b/libs/string_util/README.rst
new file mode 100644
index 0000000000..cced4a475d
--- /dev/null
+++ b/libs/string_util/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+===========
+string_util
+===========
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/string_util/docs/index.html>`__.
diff --git a/libs/string_util/docs/index.rst b/libs/string_util/docs/index.rst
new file mode 100644
index 0000000000..d8e633a411
--- /dev/null
+++ b/libs/string_util/docs/index.rst
@@ -0,0 +1,19 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_string_util:
+
+===========
+string_util
+===========
+
+This module contains string utilities inspired by the Boost string algorithms
+library.
+
+See the :ref:`API reference <libs_string_util_api>` of this module for more
+details.
+
diff --git a/libs/string_util/examples/CMakeLists.txt b/libs/string_util/examples/CMakeLists.txt
new file mode 100644
index 0000000000..eac99b694e
--- /dev/null
+++ b/libs/string_util/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.string_util)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.string_util)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_STRING_UTIL_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.string_util)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.string_util)
+  endif()
+endif()
diff --git a/libs/string_util/include/hpx/string_util/case_conv.hpp b/libs/string_util/include/hpx/string_util/case_conv.hpp
new file mode 100644
index 0000000000..39354a0ecc
--- /dev/null
+++ b/libs/string_util/include/hpx/string_util/case_conv.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2020 ETH Zurich
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_STRING_UTIL_TO_LOWER_HPP
+#define HPX_STRING_UTIL_TO_LOWER_HPP
+
+#include <algorithm>
+#include <cctype>
+#include <string>
+
+namespace hpx { namespace string_util {
+    template <typename CharT, class Traits, class Alloc>
+    void to_lower(std::basic_string<CharT, Traits, Alloc>& s)
+    {
+        std::transform(std::begin(s), std::end(s), std::begin(s),
+            [](int c) { return std::tolower(c); });
+    }
+}}    // namespace hpx::string_util
+
+#endif
diff --git a/libs/string_util/include/hpx/string_util/classification.hpp b/libs/string_util/include/hpx/string_util/classification.hpp
new file mode 100644
index 0000000000..e7a1781378
--- /dev/null
+++ b/libs/string_util/include/hpx/string_util/classification.hpp
@@ -0,0 +1,49 @@
+//  Copyright (c) 2020 ETH Zurich
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_STRING_UTIL_CLASSIFICATION_HPP
+#define HPX_STRING_UTIL_CLASSIFICATION_HPP
+
+#include <cctype>
+#include <string>
+
+namespace hpx { namespace string_util {
+    namespace detail {
+        template <typename CharT, typename Traits, typename Allocator>
+        struct is_any_of_pred
+        {
+            bool operator()(int c) const noexcept
+            {
+                return chars.find(c) != std::string::npos;
+            }
+
+            std::basic_string<CharT, Traits, Allocator> chars;
+        };
+    }    // namespace detail
+
+    template <typename CharT, typename Traits, typename Allocator>
+    detail::is_any_of_pred<CharT, Traits, Allocator> is_any_of(
+        std::basic_string<CharT, Traits, Allocator> const& chars)
+    {
+        return detail::is_any_of_pred<CharT, Traits, Allocator>{chars};
+    }
+
+    inline auto is_any_of(char const* chars)
+    {
+        return detail::is_any_of_pred<char, std::char_traits<char>,
+            std::allocator<char>>{std::string{chars}};
+    }
+
+    struct is_space
+    {
+        bool operator()(int c) const noexcept
+        {
+            return std::isspace(c);
+        }
+    };
+}}    // namespace hpx::string_util
+
+#endif
diff --git a/libs/string_util/include/hpx/string_util/split.hpp b/libs/string_util/include/hpx/string_util/split.hpp
new file mode 100644
index 0000000000..f87901ec14
--- /dev/null
+++ b/libs/string_util/include/hpx/string_util/split.hpp
@@ -0,0 +1,80 @@
+//  Copyright (c) 2020 ETH Zurich
+//  Copyright (c) 2002-2006 Pavol Droba
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_STRING_UTIL_SPLIT_HPP
+#define HPX_STRING_UTIL_SPLIT_HPP
+
+#include <algorithm>
+#include <cctype>
+#include <cstddef>
+#include <string>
+#include <utility>
+
+namespace hpx { namespace string_util {
+    namespace detail {
+        template <typename It, typename CharT, typename Traits,
+            typename Allocator>
+        std::basic_string<CharT, Traits, Allocator> substr(
+            std::basic_string<CharT, Traits, Allocator> const& s,
+            It const& first, It const& last)
+        {
+            std::size_t const pos = std::distance(std::begin(s), first);
+            std::size_t const count = std::distance(first, last);
+            return s.substr(pos, count);
+        }
+    }    // namespace detail
+
+    enum class token_compress_mode
+    {
+        off,
+        on
+    };
+
+    template <typename Container, typename Predicate, typename CharT,
+        typename Traits, typename Allocator>
+    void split(Container& container,
+        std::basic_string<CharT, Traits, Allocator> const& str,
+        Predicate&& pred,
+        token_compress_mode compress_mode = token_compress_mode::off)
+    {
+        container.clear();
+
+        auto token_begin = std::begin(str);
+        auto token_end = std::end(str);
+
+        do
+        {
+            token_end = std::find_if(token_begin, std::end(str), pred);
+
+            container.push_back(detail::substr(str, token_begin, token_end));
+
+            if (token_end != std::end(str))
+            {
+                token_begin = token_end + 1;
+            }
+
+            if (compress_mode == token_compress_mode::on)
+            {
+                // Skip contiguous separators
+                while (token_end != std::end(str) && pred(int(*token_begin)))
+                {
+                    ++token_begin;
+                }
+            }
+        } while (token_end != std::end(str));
+    }
+
+    template <typename Container, typename Predicate>
+    void split(Container& container, char const* str, Predicate&& pred,
+        token_compress_mode compress_mode = token_compress_mode::off)
+    {
+        split(container, std::string{str}, std::forward<Predicate>(pred),
+            compress_mode);
+    }
+}}    // namespace hpx::string_util
+
+#endif
diff --git a/libs/string_util/include/hpx/string_util/trim.hpp b/libs/string_util/include/hpx/string_util/trim.hpp
new file mode 100644
index 0000000000..6b3738010a
--- /dev/null
+++ b/libs/string_util/include/hpx/string_util/trim.hpp
@@ -0,0 +1,38 @@
+//  Copyright (c) 2020 ETH Zurich
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_STRING_UTIL_TRIM_HPP
+#define HPX_STRING_UTIL_TRIM_HPP
+
+#include <algorithm>
+#include <cstddef>
+#include <string>
+
+namespace hpx { namespace string_util {
+    template <typename CharT, class Traits, class Alloc>
+    void trim(std::basic_string<CharT, Traits, Alloc>& s)
+    {
+        auto first = std::find_if_not(std::cbegin(s), std::cend(s),
+            [](int c) { return std::isspace(c); });
+        s.erase(std::begin(s), first);
+
+        auto last = std::find_if_not(std::crbegin(s), std::crend(s),
+            [](int c) { return std::isspace(c); });
+        s.erase(last.base(), std::end(s));
+    }
+
+    template <typename CharT, class Traits, class Alloc>
+    std::basic_string<CharT, Traits, Alloc> trim_copy(
+        std::basic_string<CharT, Traits, Alloc> const& s)
+    {
+        auto t = s;
+        trim(t);
+
+        return t;
+    }
+}}    // namespace hpx::string_util
+
+#endif
diff --git a/libs/string_util/tests/CMakeLists.txt b/libs/string_util/tests/CMakeLists.txt
new file mode 100644
index 0000000000..fe5ec0b916
--- /dev/null
+++ b/libs/string_util/tests/CMakeLists.txt
@@ -0,0 +1,42 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_STRING_UTIL_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_STRING_UTIL_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.string_util)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.string_util)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.string_util)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.string_util)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.string_util)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.string_util)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.string_util
+        HEADERS ${string_util_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        NOLIBS
+        DEPENDENCIES hpx_string_util)
+    endif()
+endif()
diff --git a/libs/string_util/tests/performance/CMakeLists.txt b/libs/string_util/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/string_util/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/string_util/tests/regressions/CMakeLists.txt b/libs/string_util/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/string_util/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/string_util/tests/unit/CMakeLists.txt b/libs/string_util/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..b4db8e193b
--- /dev/null
+++ b/libs/string_util/tests/unit/CMakeLists.txt
@@ -0,0 +1,30 @@
+# Copyright (c) 2020 ETH Zurich
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+set(tests
+    string_to_lower
+    string_split
+    string_trim
+)
+
+foreach(test ${tests})
+  set(sources ${test}.cpp)
+
+  source_group("Source Files" FILES ${sources})
+
+  set(folder_name "Tests/Unit/Modules/StringUtil")
+
+  add_hpx_executable(${test}_test
+    INTERNAL_FLAGS
+    SOURCES ${sources}
+    ${${test}_FLAGS}
+    EXCLUDE_FROM_ALL
+    NOLIBS
+    DEPENDENCIES hpx_string_util hpx_testing
+    FOLDER ${folder_name})
+
+  add_hpx_unit_test("modules.string_util" ${test} ${${test}_PARAMETERS})
+endforeach()
diff --git a/libs/string_util/tests/unit/string_split.cpp b/libs/string_util/tests/unit/string_split.cpp
new file mode 100644
index 0000000000..ce288ce20a
--- /dev/null
+++ b/libs/string_util/tests/unit/string_split.cpp
@@ -0,0 +1,138 @@
+//  Copyright (c) 2020      ETH Zurich
+//  Copyright (c) 2002-2003 Pavol Droba
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/testing.hpp>
+
+#include <cstddef>
+#include <iostream>
+#include <list>
+#include <string>
+#include <vector>
+
+template <typename T1, typename T2>
+void deep_compare(const T1& X, const T2& Y)
+{
+    HPX_TEST_EQ(X.size(), Y.size());
+    for (unsigned int nIndex = 0; nIndex < X.size(); ++nIndex)
+    {
+        HPX_TEST_EQ(X[nIndex], Y[nIndex]);
+    }
+}
+
+int main()
+{
+    std::string str2("Xx-abc--xX-abb-xx");
+    std::string str3("xx");
+    std::string strempty("");
+    const char* pch1 = "xx-abc--xx-abb";
+    std::vector<std::string> tokens;
+
+    // split tests
+    hpx::string_util::split(tokens, str2, hpx::string_util::is_any_of("xX"),
+        hpx::string_util::token_compress_mode::on);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(4));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string("-abc--"));
+    HPX_TEST_EQ(tokens[2], std::string("-abb-"));
+    HPX_TEST_EQ(tokens[3], std::string(""));
+
+    hpx::string_util::split(tokens, str2, hpx::string_util::is_any_of("xX"),
+        hpx::string_util::token_compress_mode::off);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string(""));
+    HPX_TEST_EQ(tokens[2], std::string("-abc--"));
+    HPX_TEST_EQ(tokens[3], std::string(""));
+    HPX_TEST_EQ(tokens[4], std::string("-abb-"));
+    HPX_TEST_EQ(tokens[5], std::string(""));
+    HPX_TEST_EQ(tokens[6], std::string(""));
+
+    hpx::string_util::split(tokens, pch1, hpx::string_util::is_any_of("x"),
+        hpx::string_util::token_compress_mode::on);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(3));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string("-abc--"));
+    HPX_TEST_EQ(tokens[2], std::string("-abb"));
+
+    hpx::string_util::split(tokens, pch1, hpx::string_util::is_any_of("x"),
+        hpx::string_util::token_compress_mode::off);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(5));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string(""));
+    HPX_TEST_EQ(tokens[2], std::string("-abc--"));
+    HPX_TEST_EQ(tokens[3], std::string(""));
+    HPX_TEST_EQ(tokens[4], std::string("-abb"));
+
+    hpx::string_util::split(tokens, str3, hpx::string_util::is_any_of(","),
+        hpx::string_util::token_compress_mode::on);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(1));
+    HPX_TEST_EQ(tokens[0], std::string("xx"));
+
+    hpx::string_util::split(tokens, str3, hpx::string_util::is_any_of(","),
+        hpx::string_util::token_compress_mode::off);
+
+    hpx::string_util::split(tokens, str3, hpx::string_util::is_any_of("xX"),
+        hpx::string_util::token_compress_mode::on);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(2));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string(""));
+
+    hpx::string_util::split(tokens, str3, hpx::string_util::is_any_of("xX"),
+        hpx::string_util::token_compress_mode::off);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(3));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string(""));
+    HPX_TEST_EQ(tokens[2], std::string(""));
+
+    split(tokens, strempty, hpx::string_util::is_any_of(".:,;"),
+        hpx::string_util::token_compress_mode::on);
+
+    HPX_TEST(tokens.size() == 1);
+    HPX_TEST(tokens[0] == std::string(""));
+
+    split(tokens, strempty, hpx::string_util::is_any_of(".:,;"),
+        hpx::string_util::token_compress_mode::off);
+
+    HPX_TEST(tokens.size() == 1);
+    HPX_TEST(tokens[0] == std::string(""));
+
+    // If using a compiler that supports forwarding references, we should be
+    // able to use rvalues, too
+    hpx::string_util::split(tokens, std::string("Xx-abc--xX-abb-xx"),
+        hpx::string_util::is_any_of("xX"),
+        hpx::string_util::token_compress_mode::on);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(4));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string("-abc--"));
+    HPX_TEST_EQ(tokens[2], std::string("-abb-"));
+    HPX_TEST_EQ(tokens[3], std::string(""));
+
+    hpx::string_util::split(tokens, std::string("Xx-abc--xX-abb-xx"),
+        hpx::string_util::is_any_of("xX"),
+        hpx::string_util::token_compress_mode::off);
+
+    HPX_TEST_EQ(tokens.size(), std::size_t(7));
+    HPX_TEST_EQ(tokens[0], std::string(""));
+    HPX_TEST_EQ(tokens[1], std::string(""));
+    HPX_TEST_EQ(tokens[2], std::string("-abc--"));
+    HPX_TEST_EQ(tokens[3], std::string(""));
+    HPX_TEST_EQ(tokens[4], std::string("-abb-"));
+    HPX_TEST_EQ(tokens[5], std::string(""));
+    HPX_TEST_EQ(tokens[6], std::string(""));
+
+    return hpx::util::report_errors();
+}
diff --git a/libs/string_util/tests/unit/string_to_lower.cpp b/libs/string_util/tests/unit/string_to_lower.cpp
new file mode 100644
index 0000000000..a0b88290e9
--- /dev/null
+++ b/libs/string_util/tests/unit/string_to_lower.cpp
@@ -0,0 +1,29 @@
+//  Copyright (c) 2020      ETH Zurich
+//  Copyright (c) 2002-2003 Pavol Droba
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/string_util/case_conv.hpp>
+#include <hpx/testing.hpp>
+
+#include <string>
+
+int main()
+{
+    std::string str1("AbCdEfG 123 xxxYYYzZzZ");
+    std::string str2("");
+
+    hpx::string_util::to_lower(str1);
+    HPX_TEST(str1 == "abcdefg 123 xxxyyyzzzz");
+
+    // to_lower is idempotent
+    hpx::string_util::to_lower(str1);
+    HPX_TEST(str1 == "abcdefg 123 xxxyyyzzzz");
+
+    hpx::string_util::to_lower(str2);
+    HPX_TEST(str2 == "");
+
+    return hpx::util::report_errors();
+}
diff --git a/libs/string_util/tests/unit/string_trim.cpp b/libs/string_util/tests/unit/string_trim.cpp
new file mode 100644
index 0000000000..65359a29fd
--- /dev/null
+++ b/libs/string_util/tests/unit/string_trim.cpp
@@ -0,0 +1,52 @@
+//  Copyright (c) 2020      ETH Zurich
+//  Copyright (c) 2002-2003 Pavol Droba
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/string_util/trim.hpp>
+#include <hpx/testing.hpp>
+
+#include <string>
+
+int main()
+{
+    std::string str1("     1x x x x1     ");
+    std::string str2("     2x x x x2     ");
+    std::string str3("x     ");
+    std::string str4("     x");
+    std::string str5("    ");
+
+    // general string test
+    HPX_TEST_EQ(hpx::string_util::trim_copy(str1), "1x x x x1");
+    HPX_TEST_EQ(hpx::string_util::trim_copy(str3), "x");
+    HPX_TEST_EQ(hpx::string_util::trim_copy(str4), "x");
+
+    // spaces-only string test
+    HPX_TEST_EQ(hpx::string_util::trim_copy(str5), "");
+
+    // empty string check
+    HPX_TEST_EQ(hpx::string_util::trim_copy(std::string("")), "");
+
+    // general string test
+    hpx::string_util::trim(str2);
+    HPX_TEST_EQ(str2, "2x x x x2");
+
+    hpx::string_util::trim(str3);
+    HPX_TEST_EQ(str3, "x");
+
+    hpx::string_util::trim(str4);
+    HPX_TEST_EQ(str4, "x");
+
+    // spaces-only string test
+    hpx::string_util::trim(str5);
+    HPX_TEST_EQ(str5, "");
+
+    // empty string check
+    str5 = "";
+    hpx::string_util::trim(str5);
+    HPX_TEST_EQ(str5, "");
+
+    return hpx::util::report_errors();
+}
diff --git a/libs/synchronization/CMakeLists.txt b/libs/synchronization/CMakeLists.txt
index a502957ecf..1f015284fc 100644
--- a/libs/synchronization/CMakeLists.txt
+++ b/libs/synchronization/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -30,7 +30,6 @@ set(synchronization_headers
   hpx/synchronization/spinlock.hpp
   hpx/synchronization/spinlock_no_backoff.hpp
   hpx/synchronization/spinlock_pool.hpp
-  hpx/synchronization/detail/yield_k.hpp
   )
 
 # Default location is $HPX_ROOT/libs/synchronization/include_compatibility
@@ -52,7 +51,6 @@ set(synchronization_compat_headers
   hpx/lcos/local/spinlock.hpp
   hpx/lcos/local/spinlock_no_backoff.hpp
   hpx/lcos/local/spinlock_pool.hpp
-  hpx/util/detail/yield_k.hpp
   )
 
 set(synchronization_sources
@@ -83,6 +81,8 @@ add_hpx_module(synchronization
     hpx_errors
     hpx_functional
     hpx_hashing
+    hpx_logging
+    hpx_threading_base
     hpx_thread_support
     hpx_timing
   CMAKE_SUBDIRS examples tests
diff --git a/libs/synchronization/README.rst b/libs/synchronization/README.rst
index 140e10ea60..7d5bd6e514 100644
--- a/libs/synchronization/README.rst
+++ b/libs/synchronization/README.rst
@@ -13,4 +13,4 @@ synchronization
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/synchronization/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/synchronization/docs/index.html>`__.
diff --git a/libs/synchronization/include/hpx/synchronization/detail/yield_k.hpp b/libs/synchronization/include/hpx/synchronization/detail/yield_k.hpp
deleted file mode 100644
index e678957793..0000000000
--- a/libs/synchronization/include/hpx/synchronization/detail/yield_k.hpp
+++ /dev/null
@@ -1,48 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2013 Thomas Heller
-//  Copyright (c) 2008 Peter Dimov
-//  Copyright (c) 2018 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#ifndef HPX_UTIL_DETAIL_YIELD_K_HPP
-#define HPX_UTIL_DETAIL_YIELD_K_HPP
-
-#include <hpx/config.hpp>
-#include <hpx/basic_execution/this_thread.hpp>
-#include <hpx/coroutines/thread_enums.hpp>
-
-#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-#include <hpx/errors/throw_exception.hpp>
-#endif
-
-#include <hpx/basic_execution/this_thread.hpp>
-#include <hpx/coroutines/thread_enums.hpp>
-
-#include <cstddef>
-
-namespace hpx { namespace util { namespace detail {
-#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-    HPX_API_EXPORT extern bool spinlock_break_on_deadlock;
-    HPX_API_EXPORT extern std::size_t spinlock_deadlock_detection_limit;
-#endif
-
-    inline void yield_k(std::size_t k, const char* thread_name,
-        hpx::threads::thread_state_enum p = hpx::threads::pending_boost)
-    {
-#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
-        if (k > 32 && spinlock_break_on_deadlock &&
-            k > spinlock_deadlock_detection_limit)
-        {
-            HPX_THROW_EXCEPTION(
-                deadlock, thread_name, "possible deadlock detected");
-        }
-#endif
-        hpx::basic_execution::this_thread::yield_k(k, thread_name);
-    }
-}}}    // namespace hpx::util::detail
-
-#endif
diff --git a/libs/synchronization/include/hpx/synchronization/mutex.hpp b/libs/synchronization/include/hpx/synchronization/mutex.hpp
index e1f3f1232f..0ee179590b 100644
--- a/libs/synchronization/include/hpx/synchronization/mutex.hpp
+++ b/libs/synchronization/include/hpx/synchronization/mutex.hpp
@@ -14,6 +14,7 @@
 #include <hpx/errors.hpp>
 #include <hpx/synchronization/detail/condition_variable.hpp>
 #include <hpx/synchronization/spinlock.hpp>
+#include <hpx/threading_base.hpp>
 #include <hpx/timing/steady_clock.hpp>
 
 namespace hpx { namespace threads {
diff --git a/libs/synchronization/include/hpx/synchronization/spinlock.hpp b/libs/synchronization/include/hpx/synchronization/spinlock.hpp
index 3d994be00b..b4b0213bfa 100644
--- a/libs/synchronization/include/hpx/synchronization/spinlock.hpp
+++ b/libs/synchronization/include/hpx/synchronization/spinlock.hpp
@@ -16,8 +16,8 @@
 #include <hpx/config.hpp>
 
 #include <hpx/basic_execution/register_locks.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/concurrency/itt_notify.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -71,8 +71,7 @@ namespace hpx { namespace lcos { namespace local {
 
             for (std::size_t k = 0; !acquire_lock(); ++k)
             {
-                util::detail::yield_k(k, "hpx::lcos::local::spinlock::lock",
-                    hpx::threads::pending_boost);
+                util::detail::yield_k(k, "hpx::lcos::local::spinlock::lock");
             }
 
             HPX_ITT_SYNC_ACQUIRED(this);
diff --git a/libs/synchronization/include_compatibility/hpx/util/detail/yield_k.hpp b/libs/synchronization/include_compatibility/hpx/util/detail/yield_k.hpp
deleted file mode 100644
index a42edca4b5..0000000000
--- a/libs/synchronization/include_compatibility/hpx/util/detail/yield_k.hpp
+++ /dev/null
@@ -1,19 +0,0 @@
-//  Copyright (c) 2019 Ste||ar Group
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/synchronization/config/defines.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
-
-#if defined(HPX_SYNCHRONIZATION_HAVE_DEPRECATION_WARNINGS)
-#if defined(HPX_MSVC)
-#pragma message("The header hpx/util/detail/yield_k.hpp is deprecated, \
-    please include hpx/synchronization/detail/yield_k.hpp instead")
-#else
-#warning "The header hpx/util/detail/yield_k.hpp is deprecated, \
-    please include hpx/synchronization/detail/yield_k.hpp instead"
-#endif
-#endif
diff --git a/libs/synchronization/src/detail/condition_variable.cpp b/libs/synchronization/src/detail/condition_variable.cpp
index 7f5ded6dbc..8e4c89fe5b 100644
--- a/libs/synchronization/src/detail/condition_variable.cpp
+++ b/libs/synchronization/src/detail/condition_variable.cpp
@@ -11,6 +11,7 @@
 #include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/logging.hpp>
+#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/synchronization/no_mutex.hpp>
 #include <hpx/synchronization/spinlock.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
diff --git a/libs/synchronization/src/mutex.cpp b/libs/synchronization/src/mutex.cpp
index 81ddc8dd1a..75a14e6f99 100644
--- a/libs/synchronization/src/mutex.cpp
+++ b/libs/synchronization/src/mutex.cpp
@@ -12,6 +12,7 @@
 #include <hpx/concurrency/itt_notify.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/runtime/threads/thread_data.hpp>
 #include <hpx/synchronization/condition_variable.hpp>
 #include <hpx/synchronization/spinlock.hpp>
 #include <hpx/timing/steady_clock.hpp>
diff --git a/libs/synchronization/tests/CMakeLists.txt b/libs/synchronization/tests/CMakeLists.txt
index 5fe3839724..fc0f9ca957 100644
--- a/libs/synchronization/tests/CMakeLists.txt
+++ b/libs/synchronization/tests/CMakeLists.txt
@@ -39,6 +39,5 @@ if (HPX_WITH_TESTS_HEADERS)
     modules.synchronization
     HEADERS ${synchronization_headers}
     HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
-    NOLIBS
     DEPENDENCIES hpx_synchronization)
 endif()
diff --git a/libs/synchronization/tests/performance/channel_mpmc_throughput.cpp b/libs/synchronization/tests/performance/channel_mpmc_throughput.cpp
index a87bb8566d..67b8b6869d 100644
--- a/libs/synchronization/tests/performance/channel_mpmc_throughput.cpp
+++ b/libs/synchronization/tests/performance/channel_mpmc_throughput.cpp
@@ -62,7 +62,7 @@ double thread_func_0(hpx::lcos::local::channel_mpmc<data>& c)
 
     std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-    return (end - start) / 1e9;
+    return static_cast<double>(end - start) / 1e9;
 }
 
 // Consume
@@ -81,7 +81,7 @@ double thread_func_1(hpx::lcos::local::channel_mpmc<data>& c)
 
     std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-    return (end - start) / 1e9;
+    return static_cast<double>(end - start) / 1e9;
 }
 
 int main(int argc, char* argv[])
diff --git a/libs/synchronization/tests/performance/channel_mpsc_throughput.cpp b/libs/synchronization/tests/performance/channel_mpsc_throughput.cpp
index 6fb3d4975f..4402527796 100644
--- a/libs/synchronization/tests/performance/channel_mpsc_throughput.cpp
+++ b/libs/synchronization/tests/performance/channel_mpsc_throughput.cpp
@@ -62,7 +62,7 @@ double thread_func_0(hpx::lcos::local::channel_mpsc<data>& c)
 
     std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-    return (end - start) / 1e9;
+    return static_cast<double>(end - start) / 1e9;
 }
 
 // Consume
@@ -81,7 +81,7 @@ double thread_func_1(hpx::lcos::local::channel_mpsc<data>& c)
 
     std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-    return (end - start) / 1e9;
+    return static_cast<double>(end - start) / 1e9;
 }
 
 int main(int argc, char* argv[])
diff --git a/libs/synchronization/tests/performance/channel_spsc_throughput.cpp b/libs/synchronization/tests/performance/channel_spsc_throughput.cpp
index b0c33c6a7a..9e859c3c29 100644
--- a/libs/synchronization/tests/performance/channel_spsc_throughput.cpp
+++ b/libs/synchronization/tests/performance/channel_spsc_throughput.cpp
@@ -62,7 +62,7 @@ double thread_func_0(hpx::lcos::local::channel_spsc<data>& c)
 
     std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-    return (end - start) / 1e9;
+    return static_cast<double>(end - start) / 1e9;
 }
 
 // Consume
@@ -81,7 +81,7 @@ double thread_func_1(hpx::lcos::local::channel_spsc<data>& c)
 
     std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-    return (end - start) / 1e9;
+    return static_cast<double>(end - start) / 1e9;
 }
 
 int main(int argc, char* argv[])
diff --git a/libs/synchronization/tests/unit/condition_variable.cpp b/libs/synchronization/tests/unit/condition_variable.cpp
index 44d257cc93..612a9a74b0 100644
--- a/libs/synchronization/tests/unit/condition_variable.cpp
+++ b/libs/synchronization/tests/unit/condition_variable.cpp
@@ -10,9 +10,9 @@
 
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/runtime/threads/thread.hpp>
 #include <hpx/synchronization/condition_variable.hpp>
 #include <hpx/synchronization/mutex.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/topology/topology.hpp>
 
 #include <hpx/testing.hpp>
diff --git a/libs/synchronization/tests/unit/local_mutex.cpp b/libs/synchronization/tests/unit/local_mutex.cpp
index cf6d5ed376..0f3e1d6b40 100644
--- a/libs/synchronization/tests/unit/local_mutex.cpp
+++ b/libs/synchronization/tests/unit/local_mutex.cpp
@@ -9,11 +9,11 @@
 
 #include <hpx/functional/bind.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/runtime/threads/thread.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/synchronization/condition_variable.hpp>
 #include <hpx/synchronization/mutex.hpp>
 #include <hpx/testing.hpp>
+#include <hpx/threading.hpp>
 
 #include <chrono>
 #include <mutex>
diff --git a/libs/synchronization/tests/unit/shared_mutex/thread_group.hpp b/libs/synchronization/tests/unit/shared_mutex/thread_group.hpp
index 966598e41b..52caa5147b 100644
--- a/libs/synchronization/tests/unit/shared_mutex/thread_group.hpp
+++ b/libs/synchronization/tests/unit/shared_mutex/thread_group.hpp
@@ -11,9 +11,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/errors/exception.hpp>
-#include <hpx/runtime/threads/thread.hpp>
 #include <hpx/synchronization/mutex.hpp>
 #include <hpx/synchronization/shared_mutex.hpp>
+#include <hpx/threading.hpp>
 
 #include <boost/thread/locks.hpp>
 
diff --git a/libs/synchronization/tests/unit/sliding_semaphore.cpp b/libs/synchronization/tests/unit/sliding_semaphore.cpp
index ff36ca83a2..fc59a9a6c9 100644
--- a/libs/synchronization/tests/unit/sliding_semaphore.cpp
+++ b/libs/synchronization/tests/unit/sliding_semaphore.cpp
@@ -35,7 +35,7 @@ int hpx_main()
     // Wait for all threads to finish executing.
     sem.wait(19);
 
-    HPX_TEST(count == 10);
+    HPX_TEST_EQ(count, 10);
 
     return hpx::finalize();
 }
diff --git a/libs/testing/CMakeLists.txt b/libs/testing/CMakeLists.txt
index f407321717..391ea01448 100644
--- a/libs/testing/CMakeLists.txt
+++ b/libs/testing/CMakeLists.txt
@@ -1,10 +1,10 @@
-# Copyright (c) 2019 The STE||AR-Group
+# Copyright (c) 2019-2020 The STE||AR-Group
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -36,6 +36,7 @@ add_hpx_module(testing
     hpx_assertion
     hpx_config
     hpx_preprocessor
+    hpx_util
   CMAKE_SUBDIRS examples tests
 )
 
diff --git a/libs/testing/README.rst b/libs/testing/README.rst
index 2fd21b4d94..48e44c88a4 100644
--- a/libs/testing/README.rst
+++ b/libs/testing/README.rst
@@ -12,4 +12,4 @@ testing
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/testing/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/testing/docs/index.html>`__.
diff --git a/libs/testing/include/hpx/testing.hpp b/libs/testing/include/hpx/testing.hpp
index bf69e6ca2d..0ff3248760 100644
--- a/libs/testing/include/hpx/testing.hpp
+++ b/libs/testing/include/hpx/testing.hpp
@@ -12,8 +12,7 @@
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-
-#include <boost/io/ios_state.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 
 // Use smart_ptr's spinlock header because this header is used by the CMake
 // config tests, and therefore we can't include other hpx headers in this file.
@@ -46,20 +45,13 @@ namespace hpx { namespace util {
             std::ostream& stream_;
             std::size_t sanity_failures_;
             std::size_t test_failures_;
-#if defined(HPX_HAVE_CXX11_NSDMI)
             mutex_type mutex_ = BOOST_DETAIL_SPINLOCK_INIT;
-#else
-            mutex_type mutex_;
-#endif
 
         public:
             fixture(std::ostream& stream)
               : stream_(stream)
               , sanity_failures_(0)
               , test_failures_(0)
-#if !defined(HPX_HAVE_CXX11_NSDMI)
-              , mutex_(BOOST_DETAIL_SPINLOCK_INIT)
-#endif
             {
             }
 
@@ -74,7 +66,7 @@ namespace hpx { namespace util {
                 if (!t)
                 {
                     std::lock_guard<mutex_type> l(mutex_);
-                    boost::io::ios_flags_saver ifs(stream_);
+                    hpx::util::ios_flags_saver ifs(stream_);
                     stream_ << file << "(" << line << "): " << msg
                             << " failed in function '" << function << "'"
                             << std::endl;
@@ -91,7 +83,7 @@ namespace hpx { namespace util {
                 if (!(t == u))
                 {
                     std::lock_guard<mutex_type> l(mutex_);
-                    boost::io::ios_flags_saver ifs(stream_);
+                    hpx::util::ios_flags_saver ifs(stream_);
                     stream_ << file << "(" << line << "): " << msg
                             << " failed in function '" << function << "': "
                             << "'" << t << "' != '" << u << "'" << std::endl;
@@ -109,7 +101,7 @@ namespace hpx { namespace util {
                 if (!(t != u))
                 {
                     std::lock_guard<mutex_type> l(mutex_);
-                    boost::io::ios_flags_saver ifs(stream_);
+                    hpx::util::ios_flags_saver ifs(stream_);
                     stream_ << file << "(" << line << "): " << msg
                             << " failed in function '" << function << "': "
                             << "'" << t << "' != '" << u << "'" << std::endl;
@@ -126,7 +118,7 @@ namespace hpx { namespace util {
                 if (!(t < u))
                 {
                     std::lock_guard<mutex_type> l(mutex_);
-                    boost::io::ios_flags_saver ifs(stream_);
+                    hpx::util::ios_flags_saver ifs(stream_);
                     stream_ << file << "(" << line << "): " << msg
                             << " failed in function '" << function << "': "
                             << "'" << t << "' >= '" << u << "'" << std::endl;
@@ -144,7 +136,7 @@ namespace hpx { namespace util {
                 if (!(t <= u))
                 {
                     std::lock_guard<mutex_type> l(mutex_);
-                    boost::io::ios_flags_saver ifs(stream_);
+                    hpx::util::ios_flags_saver ifs(stream_);
                     stream_ << file << "(" << line << "): " << msg
                             << " failed in function '" << function << "': "
                             << "'" << t << "' > '" << u << "'" << std::endl;
@@ -162,7 +154,7 @@ namespace hpx { namespace util {
                 if (!(t >= u && t <= v))
                 {
                     std::lock_guard<mutex_type> l(mutex_);
-                    boost::io::ios_flags_saver ifs(stream_);
+                    hpx::util::ios_flags_saver ifs(stream_);
                     if (!(t >= u))
                     {
                         stream_ << file << "(" << line << "): " << msg
diff --git a/libs/testing/src/testing.cpp b/libs/testing/src/testing.cpp
index 0eef061bd2..bbe7cab33d 100644
--- a/libs/testing/src/testing.cpp
+++ b/libs/testing/src/testing.cpp
@@ -9,6 +9,7 @@
 
 #include <hpx/assertion.hpp>
 #include <hpx/testing.hpp>
+#include <hpx/util.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -16,8 +17,6 @@
 #include <iostream>
 #include <sstream>
 
-#include <boost/io/ios_state.hpp>
-
 namespace hpx { namespace util {
     static test_failure_handler_type test_failure_handler;
 
@@ -76,7 +75,7 @@ namespace hpx { namespace util {
 
         else
         {
-            boost::io::ios_flags_saver ifs(stream);
+            hpx::util::ios_flags_saver ifs(stream);
             stream << sanity << " sanity check"    //-V128
                    << ((sanity == 1) ? " and " : "s and ") << test << " test"
                    << ((test == 1) ? " failed." : "s failed.") << std::endl;
diff --git a/libs/thread_pools/CMakeLists.txt b/libs/thread_pools/CMakeLists.txt
new file mode 100644
index 0000000000..4194738e6e
--- /dev/null
+++ b/libs/thread_pools/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(thread_pools_headers
+  hpx/thread_pools/detail/scoped_background_timer.hpp
+  hpx/thread_pools/scheduled_thread_pool.hpp
+  hpx/thread_pools/scheduled_thread_pool_impl.hpp
+  hpx/thread_pools/scheduling_loop.hpp)
+
+set(thread_pools_compat_headers
+  hpx/runtime/threads/detail/scheduled_thread_pool.hpp
+  hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp
+  hpx/runtime/threads/detail/scheduling_loop.hpp
+  hpx/runtime/threads/thread_pools.hpp
+  hpx/runtime/threads/scoped_background_timer.hpp)
+
+set(thread_pools_sources
+  scheduled_thread_pool.cpp)
+
+include(HPX_AddModule)
+add_hpx_module(thread_pools
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${thread_pools_sources}
+  HEADERS ${thread_pools_headers}
+  COMPAT_HEADERS ${thread_pools_compat_headers}
+  DEPENDENCIES
+    hpx_assertion
+    hpx_config
+    hpx_schedulers
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/thread_pools/README.rst b/libs/thread_pools/README.rst
new file mode 100644
index 0000000000..1acee978d1
--- /dev/null
+++ b/libs/thread_pools/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+============
+thread_pools
+============
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/thread_pools/docs/index.html>`__.
diff --git a/libs/thread_pools/docs/index.rst b/libs/thread_pools/docs/index.rst
new file mode 100644
index 0000000000..5ffac33a86
--- /dev/null
+++ b/libs/thread_pools/docs/index.rst
@@ -0,0 +1,18 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_thread_pools:
+
+============
+thread_pools
+============
+
+TODO: High-level description of the library.
+
+See the :ref:`API reference <libs_thread_pools_api>` of this module for more
+details.
+
diff --git a/libs/thread_pools/examples/CMakeLists.txt b/libs/thread_pools/examples/CMakeLists.txt
new file mode 100644
index 0000000000..413ea253fc
--- /dev/null
+++ b/libs/thread_pools/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.thread_pools)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.thread_pools)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_THREAD_POOLS_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.thread_pools)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.thread_pools)
+  endif()
+endif()
diff --git a/hpx/runtime/threads/scoped_background_timer.hpp b/libs/thread_pools/include/hpx/thread_pools/detail/scoped_background_timer.hpp
similarity index 83%
rename from hpx/runtime/threads/scoped_background_timer.hpp
rename to libs/thread_pools/include/hpx/thread_pools/detail/scoped_background_timer.hpp
index a7aab3bca2..b5a4174cfd 100644
--- a/hpx/runtime/threads/scoped_background_timer.hpp
+++ b/libs/thread_pools/include/hpx/thread_pools/detail/scoped_background_timer.hpp
@@ -13,9 +13,9 @@
 #include <cstdint>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace threads
-{
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
+namespace hpx { namespace threads {
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
     ////////////////////////////////////////////////////////////////////////////
     struct background_work_duration_counter
     {
@@ -39,9 +39,10 @@ namespace hpx { namespace threads
     struct background_exec_time_wrapper
     {
         background_exec_time_wrapper(
-                background_work_duration_counter& background_work_duration)
+            background_work_duration_counter& background_work_duration)
           : timestamp_(background_work_duration.background_exec_time_ != -1 ?
-                    util::hardware::timestamp() : -1)
+                    util::hardware::timestamp() :
+                    -1)
           , background_work_duration_(background_work_duration)
         {
         }
@@ -55,7 +56,6 @@ namespace hpx { namespace threads
         background_work_duration_counter& background_work_duration_;
     };
 #endif
-}}
+}}    // namespace hpx::threads
 
 #endif
-
diff --git a/hpx/runtime/threads/detail/scheduled_thread_pool.hpp b/libs/thread_pools/include/hpx/thread_pools/scheduled_thread_pool.hpp
similarity index 83%
rename from hpx/runtime/threads/detail/scheduled_thread_pool.hpp
rename to libs/thread_pools/include/hpx/thread_pools/scheduled_thread_pool.hpp
index ef84fc93b4..a357021d73 100644
--- a/hpx/runtime/threads/detail/scheduled_thread_pool.hpp
+++ b/libs/thread_pools/include/hpx/thread_pools/scheduled_thread_pool.hpp
@@ -9,16 +9,16 @@
 #define HPX_SCHEDULED_THREAD_POOL_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/affinity/affinity_data.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/function.hpp>
-#include <hpx/runtime/threads/detail/scheduling_loop.hpp>
-#include <hpx/runtime/threads/detail/network_background_callback.hpp>
-#include <hpx/affinity/affinity_data.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/thread_pools/scheduling_loop.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
+#include <hpx/threading_base/network_background_callback.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -34,8 +34,7 @@
 
 #include <hpx/config/warnings_prefix.hpp>
 
-namespace hpx { namespace threads { namespace detail
-{
+namespace hpx { namespace threads { namespace detail {
     ///////////////////////////////////////////////////////////////////////////
     template <typename Scheduler>
     struct init_tss_helper;
@@ -73,7 +72,8 @@ namespace hpx { namespace threads { namespace detail
         }
 
         void create_thread(thread_init_data& data, thread_id_type& id,
-            thread_state_enum initial_state, bool run_now, error_code& ec) override;
+            thread_state_enum initial_state, bool run_now,
+            error_code& ec) override;
 
         void create_work(thread_init_data& data,
             thread_state_enum initial_state, error_code& ec) override;
@@ -82,12 +82,13 @@ namespace hpx { namespace threads { namespace detail
             thread_state_enum new_state, thread_state_ex_enum new_state_ex,
             thread_priority priority, error_code& ec) override;
 
-        thread_id_type set_state(
-            util::steady_time_point const& abs_time, thread_id_type const& id,
-            thread_state_enum newstate, thread_state_ex_enum newstate_ex,
-            thread_priority priority, error_code& ec) override;
+        thread_id_type set_state(util::steady_time_point const& abs_time,
+            thread_id_type const& id, thread_state_enum newstate,
+            thread_state_ex_enum newstate_ex, thread_priority priority,
+            error_code& ec) override;
 
-        void report_error(std::size_t num, std::exception_ptr const& e) override;
+        void report_error(
+            std::size_t num, std::exception_ptr const& e) override;
 
         void abort_all_suspended_threads() override
         {
@@ -123,38 +124,9 @@ namespace hpx { namespace threads { namespace detail
             return sched_->Scheduler::reset_thread_distribution();
         }
 
-        void set_scheduler_mode(threads::policies::scheduler_mode mode) override
-        {
-            mode_ = mode;
-            return sched_->Scheduler::set_scheduler_mode(mode);
-        }
-
-        void add_scheduler_mode(threads::policies::scheduler_mode mode) override
-        {
-            mode_ = threads::policies::scheduler_mode(mode_ | mode);
-            return sched_->Scheduler::add_scheduler_mode(mode);
-        }
-
-        void add_remove_scheduler_mode(
-            threads::policies::scheduler_mode to_add_mode,
-            threads::policies::scheduler_mode to_remove_mode) override
-        {
-            mode_ = threads::policies::scheduler_mode(
-                (mode_ | to_add_mode) & ~to_remove_mode);
-            return sched_->Scheduler::add_remove_scheduler_mode(
-                to_add_mode, to_remove_mode);
-        }
-
-        void remove_scheduler_mode(
-            threads::policies::scheduler_mode mode) override
-        {
-            mode_ = threads::policies::scheduler_mode(mode_ & ~mode);
-            return sched_->Scheduler::remove_scheduler_mode(mode);
-        }
-
         ///////////////////////////////////////////////////////////////////
-        bool run(std::unique_lock<std::mutex>& l,
-            std::size_t pool_threads) override;
+        bool run(
+            std::unique_lock<std::mutex>& l, std::size_t pool_threads) override;
 
         template <typename Lock>
         void stop_locked(Lock& l, bool blocking = true);
@@ -164,10 +136,10 @@ namespace hpx { namespace threads { namespace detail
         void suspend_direct(error_code& ec = throws) override;
         void resume_direct(error_code& ec = throws) override;
 
-        void suspend_processing_unit_direct(std::size_t virt_core,
-            error_code& = hpx::throws) override;
-        void resume_processing_unit_direct(std::size_t virt_core,
-            error_code& = hpx::throws) override;
+        void suspend_processing_unit_direct(
+            std::size_t virt_core, error_code& = hpx::throws) override;
+        void resume_processing_unit_direct(
+            std::size_t virt_core, error_code& = hpx::throws) override;
 
         ///////////////////////////////////////////////////////////////////
         std::thread& get_os_thread_handle(
@@ -191,7 +163,7 @@ namespace hpx { namespace threads { namespace detail
         {
             std::size_t active_os_thread_count = 0;
             for (std::size_t thread_num = 0; thread_num < threads_.size();
-                ++thread_num)
+                 ++thread_num)
             {
                 if (sched_->Scheduler::get_state(thread_num).load() ==
                     state_running)
@@ -277,15 +249,18 @@ namespace hpx { namespace threads { namespace detail
 
         std::int64_t get_cumulative_duration(std::size_t, bool) override;
 
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
         std::int64_t get_background_work_duration(std::size_t, bool) override;
         std::int64_t get_background_overhead(std::size_t, bool) override;
 
         std::int64_t get_background_send_duration(std::size_t, bool) override;
         std::int64_t get_background_send_overhead(std::size_t, bool) override;
 
-        std::int64_t get_background_receive_duration(std::size_t, bool) override;
-        std::int64_t get_background_receive_overhead(std::size_t, bool) override;
+        std::int64_t get_background_receive_duration(
+            std::size_t, bool) override;
+        std::int64_t get_background_receive_overhead(
+            std::size_t, bool) override;
 #endif    // HPX_HAVE_BACKGROUND_THREAD_COUNTERS
 
 #if defined(HPX_HAVE_THREAD_IDLE_RATES)
@@ -313,8 +288,8 @@ namespace hpx { namespace threads { namespace detail
         void get_statistics(executor_statistics& s, error_code&) const override;
 
         // Provide the given processing unit to the scheduler.
-        void add_processing_unit(std::size_t virt_core,
-            std::size_t thread_num, error_code&  = hpx::throws) override;
+        void add_processing_unit(std::size_t virt_core, std::size_t thread_num,
+            error_code& = hpx::throws) override;
 
         // Remove the given processing unit from the scheduler.
         void remove_processing_unit(
@@ -333,7 +308,7 @@ namespace hpx { namespace threads { namespace detail
             error_code& ec = hpx::throws);
 
     private:
-        std::vector<std::thread> threads_;           // vector of OS-threads
+        std::vector<std::thread> threads_;    // vector of OS-threads
 
         // hold the used scheduler
         std::unique_ptr<Scheduler> sched_;
@@ -395,7 +370,8 @@ namespace hpx { namespace threads { namespace detail
             std::int64_t tfunc_times_;
             std::int64_t reset_tfunc_times_;
 
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
             // overall counters for background work
             std::int64_t background_duration_;
             std::int64_t reset_background_duration_;
diff --git a/hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp b/libs/thread_pools/include/hpx/thread_pools/scheduled_thread_pool_impl.hpp
similarity index 97%
rename from hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp
rename to libs/thread_pools/include/hpx/thread_pools/scheduled_thread_pool_impl.hpp
index 3abf72d100..025ea0af63 100644
--- a/hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp
+++ b/libs/thread_pools/include/hpx/thread_pools/scheduled_thread_pool_impl.hpp
@@ -9,28 +9,26 @@
 #define HPX_SCHEDULED_THREAD_POOL_IMPL_HPP
 
 #include <hpx/affinity/affinity_data.hpp>
-#include <hpx/apply.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/async.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/invoke.hpp>
-#include <hpx/resource_partitioner/detail/partitioner.hpp>
-#include <hpx/runtime/threads/detail/create_thread.hpp>
-#include <hpx/runtime/threads/detail/create_work.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool.hpp>
-#include <hpx/runtime/threads/detail/scheduling_loop.hpp>
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/state.hpp>
+#include <hpx/schedulers.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
+#include <hpx/thread_pools/scheduling_loop.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
+#include <hpx/threading_base/create_thread.hpp>
+#include <hpx/threading_base/create_work.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/set_thread_state.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util/yield_while.hpp>
 
 #include <boost/system/system_error.hpp>
 
@@ -155,12 +153,13 @@ namespace hpx { namespace threads { namespace detail {
     template <typename Scheduler>
     hpx::state scheduled_thread_pool<Scheduler>::get_state() const
     {
-        // get_worker_thread_num returns the global thread number which
+        // get_thread_num_tss returns the global thread number which
         // might be too large. This function might get called from within
         // background_work inside the os executors
         if (thread_count_ != 0)
         {
-            std::size_t num_thread = get_worker_thread_num() % thread_count_;
+            std::size_t num_thread =
+                detail::get_thread_num_tss() % thread_count_;
             if (num_thread != std::size_t(-1))
                 return get_state(num_thread);
         }
@@ -353,7 +352,7 @@ namespace hpx { namespace threads { namespace detail {
                 return this->sched_->Scheduler::get_thread_count() >
                     this->get_background_thread_count();
             },
-            "scheduled_thread_pool::suspend_internal", hpx::threads::pending);
+            "scheduled_thread_pool::suspend_internal");
 
         for (std::size_t i = 0; i != threads_.size(); ++i)
         {
@@ -421,7 +420,8 @@ namespace hpx { namespace threads { namespace detail {
         // needs to
         // be done in order to give the parcel pool threads higher
         // priority
-        if (mode_ & policies::reduce_thread_priority)
+        if (get_scheduler()->has_scheduler_mode(
+                policies::reduce_thread_priority))
         {
             topo.reduce_thread_priority(ec);
             if (ec)
@@ -491,7 +491,8 @@ namespace hpx { namespace threads { namespace detail {
                     nullptr, nullptr, max_background_threads_,
                     max_idle_loop_count_, max_busy_loop_count_);
 
-                if ((mode_ & policies::do_background_work) &&
+                if (get_scheduler()->has_scheduler_mode(
+                        policies::do_background_work) &&
                     network_background_callback_)
                 {
 #if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
@@ -506,7 +507,6 @@ namespace hpx { namespace threads { namespace detail {
 #endif
                 }
 
-                sched_->Scheduler::set_scheduler_mode(mode_);
                 detail::scheduling_loop(
                     thread_num, *sched_, counters, callbacks);
 
@@ -620,7 +620,7 @@ namespace hpx { namespace threads { namespace detail {
         return detail::set_thread_state(id, new_state,    //-V107
             new_state_ex, priority,
             thread_schedule_hint(
-                static_cast<std::int16_t>(get_worker_thread_num())),
+                static_cast<std::int16_t>(detail::get_thread_num_tss())),
             true, ec);
     }
 
@@ -633,7 +633,7 @@ namespace hpx { namespace threads { namespace detail {
         return detail::set_thread_state_timed(*sched_, abs_time, id, newstate,
             newstate_ex, priority,
             thread_schedule_hint(
-                static_cast<std::int16_t>(get_worker_thread_num())),
+                static_cast<std::int16_t>(detail::get_thread_num_tss())),
             nullptr, true, ec);
     }
 
@@ -1796,11 +1796,8 @@ namespace hpx { namespace threads { namespace detail {
         switch (p)
         {
         case threads::detail::min_concurrency:
-            //             return min_punits_;
-            break;
-
+            HPX_FALLTHROUGH;
         case threads::detail::max_concurrency:
-            //             return max_punits_;
             break;
 
         case threads::detail::current_concurrency:
@@ -1866,7 +1863,7 @@ namespace hpx { namespace threads { namespace detail {
     void scheduled_thread_pool<Scheduler>::add_processing_unit(
         std::size_t virt_core, std::size_t thread_num, error_code& ec)
     {
-        if (!(mode_ & threads::policies::enable_elasticity))
+        if (!get_scheduler()->has_scheduler_mode(policies::enable_elasticity))
         {
             HPX_THROW_EXCEPTION(invalid_status,
                 "scheduled_thread_pool<Scheduler>::add_processing_unit",
@@ -1886,7 +1883,7 @@ namespace hpx { namespace threads { namespace detail {
     void scheduled_thread_pool<Scheduler>::remove_processing_unit(
         std::size_t virt_core, error_code& ec)
     {
-        if (!(mode_ & threads::policies::enable_elasticity))
+        if (!get_scheduler()->has_scheduler_mode(policies::enable_elasticity))
         {
             HPX_THROW_EXCEPTION(invalid_status,
                 "scheduled_thread_pool<Scheduler>::remove_processing_unit",
@@ -1944,8 +1941,7 @@ namespace hpx { namespace threads { namespace detail {
                 [thread_num]() {
                     return thread_num == hpx::get_worker_thread_num();
                 },
-                "scheduled_thread_pool::remove_processing_unit_internal",
-                hpx::threads::pending);
+                "scheduled_thread_pool::remove_processing_unit_internal");
         }
 
         t.join();
@@ -1961,8 +1957,7 @@ namespace hpx { namespace threads { namespace detail {
             sched_->Scheduler::get_pu_mutex(virt_core), std::defer_lock);
 
         util::yield_while([&l]() { return !l.try_lock(); },
-            "scheduled_thread_pool::suspend_processing_unit_direct",
-            hpx::threads::pending);
+            "scheduled_thread_pool::suspend_processing_unit_direct");
 
         if (threads_.size() <= virt_core || !threads_[virt_core].joinable())
         {
@@ -1989,8 +1984,7 @@ namespace hpx { namespace threads { namespace detail {
 
         util::yield_while(
             [&state]() { return state.load() == state_pre_sleep; },
-            "scheduled_thread_pool::suspend_processing_unit_direct",
-            hpx::threads::pending);
+            "scheduled_thread_pool::suspend_processing_unit_direct");
     }
     template <typename Scheduler>
     void scheduled_thread_pool<Scheduler>::resume_processing_unit_direct(
@@ -2001,8 +1995,7 @@ namespace hpx { namespace threads { namespace detail {
         std::unique_lock<typename Scheduler::pu_mutex_type> l(
             sched_->Scheduler::get_pu_mutex(virt_core), std::defer_lock);
         util::yield_while([&l]() { return !l.try_lock(); },
-            "scheduled_thread_pool::resume_processing_unit_direct",
-            hpx::threads::pending);
+            "scheduled_thread_pool::resume_processing_unit_direct");
 
         if (threads_.size() <= virt_core || !threads_[virt_core].joinable())
         {
@@ -2024,8 +2017,7 @@ namespace hpx { namespace threads { namespace detail {
                 this->sched_->Scheduler::resume(virt_core);
                 return state.load() == state_sleeping;
             },
-            "scheduled_thread_pool::resume_processing_unit_direct",
-            hpx::threads::pending);
+            "scheduled_thread_pool::resume_processing_unit_direct");
     }
 }}}    // namespace hpx::threads::detail
 
diff --git a/hpx/runtime/threads/detail/scheduling_loop.hpp b/libs/thread_pools/include/hpx/thread_pools/scheduling_loop.hpp
similarity index 82%
rename from hpx/runtime/threads/detail/scheduling_loop.hpp
rename to libs/thread_pools/include/hpx/thread_pools/scheduling_loop.hpp
index d61c58f562..8c6ceb4535 100644
--- a/hpx/runtime/threads/detail/scheduling_loop.hpp
+++ b/libs/thread_pools/include/hpx/thread_pools/scheduling_loop.hpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2019 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -13,21 +13,18 @@
 #include <hpx/concurrency/itt_notify.hpp>
 #include <hpx/functional/unique_function.hpp>
 #include <hpx/hardware/timestamp.hpp>
-#include <hpx/runtime/get_thread_name.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
-# include <hpx/runtime/threads/scoped_background_timer.hpp>
-#endif
-#include <hpx/state.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/hardware/timestamp.hpp>
-#include <hpx/concurrency/itt_notify.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
+#include <hpx/thread_pools/detail/scoped_background_timer.hpp>
+#endif
 
 #if defined(HPX_HAVE_APEX)
-#include <hpx/util/external_timer.hpp>
+#include <hpx/threading_base/external_timer.hpp>
 #endif
 
 #include <atomic>
@@ -37,32 +34,31 @@
 #include <memory>
 #include <utility>
 
-namespace hpx { namespace threads { namespace detail
-{
+namespace hpx { namespace threads { namespace detail {
     ///////////////////////////////////////////////////////////////////////
     inline void write_new_state_log_debug(std::size_t num_thread,
         thread_data* thrd, thread_state_enum state, char const* info)
     {
-        LTM_(debug) << "tfunc(" << num_thread << "): " //-V128
-            << "thread(" << thrd->get_thread_id() << "), "
-            << "description(" << thrd->get_description() << "), "
-            << "new state(" << get_thread_state_name(state) << "), "
-            << info;
+        LTM_(debug) << "tfunc(" << num_thread << "): "    //-V128
+                    << "thread(" << thrd->get_thread_id() << "), "
+                    << "description(" << thrd->get_description() << "), "
+                    << "new state(" << get_thread_state_name(state) << "), "
+                    << info;
     }
     inline void write_new_state_log_warning(std::size_t num_thread,
         thread_data* thrd, thread_state_enum state, char const* info)
     {
         // log this in any case
-        LTM_(warning) << "tfunc(" << num_thread << "): " //-V128
-            << "thread(" << thrd->get_thread_id() << "), "
-            << "description(" << thrd->get_description() << "), "
-            << "new state(" << get_thread_state_name(state) << "), "
-            << info;
+        LTM_(warning) << "tfunc(" << num_thread << "): "    //-V128
+                      << "thread(" << thrd->get_thread_id() << "), "
+                      << "description(" << thrd->get_description() << "), "
+                      << "new state(" << get_thread_state_name(state) << "), "
+                      << info;
     }
-    inline void write_old_state_log(std::size_t num_thread,
-        thread_data* thrd, thread_state_enum state)
+    inline void write_old_state_log(
+        std::size_t num_thread, thread_data* thrd, thread_state_enum state)
     {
-        LTM_(debug) << "tfunc(" << num_thread << "): " //-V128
+        LTM_(debug) << "tfunc(" << num_thread << "): "    //-V128
                     << "thread(" << thrd->get_thread_id() << "), "
                     << "description(" << thrd->get_description() << "), "
                     << "old state(" << get_thread_state_name(state) << ")";
@@ -73,26 +69,34 @@ namespace hpx { namespace threads { namespace detail
     class switch_status
     {
     public:
-        switch_status (thread_data* t, thread_state prev_state)
-          : thread_(t), prev_state_(prev_state),
-            next_thread_id_(nullptr),
-            need_restore_state_(t->set_state_tagged(active, prev_state_, orig_state_))
-        {}
+        switch_status(thread_data* t, thread_state prev_state)
+          : thread_(t)
+          , prev_state_(prev_state)
+          , next_thread_id_(nullptr)
+          , need_restore_state_(
+                t->set_state_tagged(active, prev_state_, orig_state_))
+        {
+        }
 
-        ~switch_status ()
+        ~switch_status()
         {
             if (need_restore_state_)
+            {
                 store_state(prev_state_);
+            }
         }
 
-        bool is_valid() const { return need_restore_state_; }
+        bool is_valid() const
+        {
+            return need_restore_state_;
+        }
 
         // allow to change the state the thread will be switched to after
         // execution
-        thread_state operator=(thread_result_type && new_state)
+        thread_state operator=(thread_result_type&& new_state)
         {
-            prev_state_ = thread_state(new_state.first,
-                prev_state_.state_ex(), prev_state_.tag() + 1);
+            prev_state_ = thread_state(
+                new_state.first, prev_state_.state_ex(), prev_state_.tag() + 1);
             next_thread_id_ = std::move(new_state.second);
             return prev_state_;
         }
@@ -112,7 +116,9 @@ namespace hpx { namespace threads { namespace detail
         bool store_state(thread_state& newstate)
         {
             disable_restore();
-            if (thread_->restore_state(prev_state_, orig_state_)) {
+
+            if (thread_->restore_state(prev_state_, orig_state_))
+            {
                 newstate = prev_state_;
                 return true;
             }
@@ -120,7 +126,10 @@ namespace hpx { namespace threads { namespace detail
         }
 
         // disable default handling in destructor
-        void disable_restore() { need_restore_state_ = false; }
+        void disable_restore()
+        {
+            need_restore_state_ = false;
+        }
 
         thread_data* get_next_thread() const
         {
@@ -143,10 +152,10 @@ namespace hpx { namespace threads { namespace detail
           : thread_(t)
           , prev_state_(prev_state)
           , next_thread_id_(nullptr)
-          , need_restore_state_(
-                t->set_state_tagged(active, prev_state_, orig_state_,
-                    std::memory_order_relaxed))
-        {}
+          , need_restore_state_(t->set_state_tagged(
+                active, prev_state_, orig_state_, std::memory_order_relaxed))
+        {
+        }
 
         ~switch_status_background()
         {
@@ -154,14 +163,17 @@ namespace hpx { namespace threads { namespace detail
                 store_state(prev_state_);
         }
 
-        bool is_valid() const { return need_restore_state_; }
+        bool is_valid() const
+        {
+            return need_restore_state_;
+        }
 
         // allow to change the state the thread will be switched to after
         // execution
-        thread_state operator=(thread_result_type && new_state)
+        thread_state operator=(thread_result_type&& new_state)
         {
-            prev_state_ = thread_state(new_state.first,
-                prev_state_.state_ex(), prev_state_.tag() + 1);
+            prev_state_ = thread_state(
+                new_state.first, prev_state_.state_ex(), prev_state_.tag() + 1);
             next_thread_id_ = std::move(new_state.second);
             return prev_state_;
         }
@@ -191,7 +203,10 @@ namespace hpx { namespace threads { namespace detail
         }
 
         // disable default handling in destructor
-        void disable_restore() { need_restore_state_ = false; }
+        void disable_restore()
+        {
+            need_restore_state_ = false;
+        }
 
         thread_data* get_next_thread() const
         {
@@ -214,7 +229,8 @@ namespace hpx { namespace threads { namespace detail
           : start_timestamp_(util::hardware::timestamp())
           , tfunc_time_(tfunc_time)
           , exec_time_(exec_time)
-        {}
+        {
+        }
 
         void collect_exec_time(std::int64_t timestamp)
         {
@@ -245,7 +261,8 @@ namespace hpx { namespace threads { namespace detail
         exec_time_wrapper(idle_collect_rate& idle_rate)
           : timestamp_(util::hardware::timestamp())
           , idle_rate_(idle_rate)
-        {}
+        {
+        }
         ~exec_time_wrapper()
         {
             idle_rate_.collect_exec_time(timestamp_);
@@ -302,16 +319,17 @@ namespace hpx { namespace threads { namespace detail
     };
 
     ///////////////////////////////////////////////////////////////////////////
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
     struct scheduling_counters
     {
         scheduling_counters(std::int64_t& executed_threads,
-                std::int64_t& executed_thread_phases, std::int64_t& tfunc_time,
-                std::int64_t& exec_time, std::int64_t& idle_loop_count,
-                std::int64_t& busy_loop_count, bool& is_active,
-                std::int64_t& background_work_duration,
-                std::int64_t& background_send_duration,
-                std::int64_t& background_receive_duration)
+            std::int64_t& executed_thread_phases, std::int64_t& tfunc_time,
+            std::int64_t& exec_time, std::int64_t& idle_loop_count,
+            std::int64_t& busy_loop_count, bool& is_active,
+            std::int64_t& background_work_duration,
+            std::int64_t& background_send_duration,
+            std::int64_t& background_receive_duration)
           : executed_threads_(executed_threads)
           , executed_thread_phases_(executed_thread_phases)
           , tfunc_time_(tfunc_time)
@@ -322,7 +340,8 @@ namespace hpx { namespace threads { namespace detail
           , background_send_duration_(background_send_duration)
           , background_receive_duration_(background_receive_duration)
           , is_active_(is_active)
-        {}
+        {
+        }
 
         std::int64_t& executed_threads_;
         std::int64_t& executed_thread_phases_;
@@ -339,18 +358,18 @@ namespace hpx { namespace threads { namespace detail
     struct scheduling_counters
     {
         scheduling_counters(std::int64_t& executed_threads,
-                std::int64_t& executed_thread_phases,
-                std::int64_t& tfunc_time, std::int64_t& exec_time,
-                std::int64_t& idle_loop_count, std::int64_t& busy_loop_count,
-                bool& is_active)
-          : executed_threads_(executed_threads),
-            executed_thread_phases_(executed_thread_phases),
-            tfunc_time_(tfunc_time),
-            exec_time_(exec_time),
-            idle_loop_count_(idle_loop_count),
-            busy_loop_count_(busy_loop_count),
-            is_active_(is_active)
-        {}
+            std::int64_t& executed_thread_phases, std::int64_t& tfunc_time,
+            std::int64_t& exec_time, std::int64_t& idle_loop_count,
+            std::int64_t& busy_loop_count, bool& is_active)
+          : executed_threads_(executed_threads)
+          , executed_thread_phases_(executed_thread_phases)
+          , tfunc_time_(tfunc_time)
+          , exec_time_(exec_time)
+          , idle_loop_count_(idle_loop_count)
+          , busy_loop_count_(busy_loop_count)
+          , is_active_(is_active)
+        {
+        }
 
         std::int64_t& executed_threads_;
         std::int64_t& executed_thread_phases_;
@@ -361,7 +380,7 @@ namespace hpx { namespace threads { namespace detail
         bool& is_active_;
     };
 
-#endif // HPX_HAVE_BACKGROUND_THREAD_COUNTERS
+#endif    // HPX_HAVE_BACKGROUND_THREAD_COUNTERS
 
     struct scheduling_callbacks
     {
@@ -381,7 +400,8 @@ namespace hpx { namespace threads { namespace detail
           , max_background_threads_(max_background_threads)
           , max_idle_loop_count_(max_idle_loop_count)
           , max_busy_loop_count_(max_busy_loop_count)
-        {}
+        {
+        }
 
         callback_type outer_;
         callback_type inner_;
@@ -393,8 +413,10 @@ namespace hpx { namespace threads { namespace detail
 
     template <typename SchedulingPolicy>
     thread_id_type create_background_thread(SchedulingPolicy& scheduler,
-        scheduling_callbacks& callbacks, std::shared_ptr<bool>& background_running,
-        threads::thread_schedule_hint schedulehint, std::int64_t& idle_loop_count)
+        scheduling_callbacks& callbacks,
+        std::shared_ptr<bool>& background_running,
+        threads::thread_schedule_hint schedulehint,
+        std::int64_t& idle_loop_count)
     {
         thread_id_type background_thread;
         background_running.reset(new bool(true));
@@ -423,8 +445,8 @@ namespace hpx { namespace threads { namespace detail
 
         // Create in suspended to prevent the thread from being scheduled
         // directly...
-        scheduler.SchedulingPolicy::create_thread(background_init,
-            &background_thread, suspended, true, hpx::throws);
+        scheduler.SchedulingPolicy::create_thread(
+            background_init, &background_thread, suspended, true, hpx::throws);
         HPX_ASSERT(background_thread);
         scheduler.SchedulingPolicy::increment_background_thread_count();
         // We can now set the state to pending
@@ -437,7 +459,8 @@ namespace hpx { namespace threads { namespace detail
     // and create a new one that is supposed to be executed inside the
     // scheduling_loop, true otherwise
     template <typename SchedulingPolicy>
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
     bool call_background_thread(thread_id_type& background_thread,
         thread_data*& next_thrd, SchedulingPolicy& scheduler,
         std::size_t num_thread, bool running,
@@ -454,7 +477,8 @@ namespace hpx { namespace threads { namespace detail
     {
         if (HPX_UNLIKELY(background_thread))
         {
-            thread_state state = get_thread_id_data(background_thread)->get_state();
+            thread_state state =
+                get_thread_id_data(background_thread)->get_state();
             thread_state_enum state_val = state.state();
 
             if (HPX_LIKELY(pending == state_val))
@@ -468,7 +492,8 @@ namespace hpx { namespace threads { namespace detail
                     if (HPX_LIKELY(thrd_stat.is_valid() &&
                             thrd_stat.get_previous() == pending))
                     {
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
                         // measure background work duration
                         background_work_duration_counter bg_work_duration(
                             background_work_exec_time_init);
@@ -505,18 +530,18 @@ namespace hpx { namespace threads { namespace detail
 
                     if (HPX_LIKELY(state_val == pending_boost))
                     {
-                        get_thread_id_data(background_thread)->set_state(pending);
+                        get_thread_id_data(background_thread)
+                            ->set_state(pending);
                     }
-                    else if(terminated == state_val)
+                    else if (terminated == state_val)
                     {
-                        std::int64_t busy_count = 0;
                         scheduler.SchedulingPolicy::
                             decrement_background_thread_count();
                         scheduler.SchedulingPolicy::destroy_thread(
-                            get_thread_id_data(background_thread), busy_count);
+                            get_thread_id_data(background_thread));
                         background_thread.reset();
                     }
-                    else if(suspended == state_val)
+                    else if (suspended == state_val)
                     {
                         return false;
                     }
@@ -537,7 +562,7 @@ namespace hpx { namespace threads { namespace detail
         std::atomic<hpx::state>& this_state = scheduler.get_state(num_thread);
 
 #if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
-        util::itt::stack_context ctx;        // helper for itt support
+        util::itt::stack_context ctx;    // helper for itt support
         util::itt::thread_domain thread_domain;
         util::itt::id threadid(thread_domain, &scheduler);
         util::itt::string_handle task_id("task_id");
@@ -548,8 +573,10 @@ namespace hpx { namespace threads { namespace detail
         std::int64_t& idle_loop_count = counters.idle_loop_count_;
         std::int64_t& busy_loop_count = counters.busy_loop_count_;
 
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
-        std::int64_t& bg_work_exec_time_init = counters.background_work_duration_;
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
+        std::int64_t& bg_work_exec_time_init =
+            counters.background_work_duration_;
 #endif    // HPX_HAVE_BACKGROUND_THREAD_COUNTERS
 
         idle_collect_rate idle_rate(counters.tfunc_time_, counters.exec_time_);
@@ -562,7 +589,7 @@ namespace hpx { namespace threads { namespace detail
         std::shared_ptr<bool> background_running = nullptr;
         thread_id_type background_thread;
 
-        if ((scheduler.SchedulingPolicy::get_scheduler_mode() &
+        if (scheduler.SchedulingPolicy::has_scheduler_mode(
                 policies::do_background_work) &&
             num_thread < params.max_background_threads_ &&
             !params.background_.empty())
@@ -580,23 +607,24 @@ namespace hpx { namespace threads { namespace detail
 
         std::size_t added = std::size_t(-1);
         thread_data* next_thrd = nullptr;
-        while (true) {
+        while (true)
+        {
             thread_data* thrd = next_thrd;
             // Get the next HPX thread from the queue
-            bool running = this_state.load(
-                std::memory_order_relaxed) < state_pre_sleep;
+            bool running =
+                this_state.load(std::memory_order_relaxed) < state_pre_sleep;
 
             // extract the stealing mode once per loop iteration
             bool enable_stealing =
-                scheduler.SchedulingPolicy::get_scheduler_mode() &
-                    policies::enable_stealing;
+                scheduler.SchedulingPolicy::has_scheduler_mode(
+                    policies::enable_stealing);
 
             // stealing staged threads is enabled if:
             // - fast idle mode is on: same as normal stealing
             // - fast idle mode off: only after normal stealing has failed for
             //                       a while
             bool enable_stealing_staged = enable_stealing;
-            if (!(scheduler.SchedulingPolicy::get_scheduler_mode() &
+            if (!scheduler.SchedulingPolicy::has_scheduler_mode(
                     policies::fast_idle_mode))
             {
                 enable_stealing_staged = enable_stealing_staged &&
@@ -604,8 +632,8 @@ namespace hpx { namespace threads { namespace detail
             }
 
             if (HPX_LIKELY(thrd ||
-                    scheduler.SchedulingPolicy::get_next_thread(num_thread,
-                        running, thrd, enable_stealing)))
+                    scheduler.SchedulingPolicy::get_next_thread(
+                        num_thread, running, thrd, enable_stealing)))
             {
                 tfunc_time_wrapper tfunc_time_collector(idle_rate);
                 HPX_ASSERT(thrd->get_scheduler_base() == &scheduler);
@@ -631,7 +659,7 @@ namespace hpx { namespace threads { namespace detail
                     {
                         // tries to set state to active (only if state is still
                         // the same as 'state')
-                        detail::switch_status thrd_stat (thrd, state);
+                        detail::switch_status thrd_stat(thrd, state);
                         if (HPX_LIKELY(thrd_stat.is_valid() &&
                                 thrd_stat.get_previous() == pending))
                         {
@@ -640,19 +668,22 @@ namespace hpx { namespace threads { namespace detail
                             // thread returns new required state
                             // store the returned state in the thread
                             {
-                                is_active_wrapper utilization(counters.is_active_);
+                                is_active_wrapper utilization(
+                                    counters.is_active_);
 #if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
                                 util::itt::caller_context cctx(ctx);
-//                                 util::itt::undo_frame_context undoframe(fctx);
-                                util::itt::task task = thrd->get_description()
-                                    .get_task_itt(thread_domain);
+                                // util::itt::undo_frame_context undoframe(fctx);
+                                util::itt::task task =
+                                    thrd->get_description().get_task_itt(
+                                        thread_domain);
                                 task.add_metadata(task_id, thrd);
-                                task.add_metadata(task_phase, thrd->get_thread_phase());
+                                task.add_metadata(
+                                    task_phase, thrd->get_thread_phase());
 #endif
                                 // Record time elapsed in thread changing state
                                 // and add to aggregate execution time.
-                                exec_time_wrapper exec_time_collector(idle_rate);
-
+                                exec_time_wrapper exec_time_collector(
+                                    idle_rate);
 
 #if defined(HPX_HAVE_APEX)
                                 // get the APEX data pointer, in case we are resuming the
@@ -697,7 +728,8 @@ namespace hpx { namespace threads { namespace detail
                         }
 
                         // store and retrieve the new state in the thread
-                        if (HPX_UNLIKELY(!thrd_stat.store_state(state))) {
+                        if (HPX_UNLIKELY(!thrd_stat.store_state(state)))
+                        {
                             // some other worker-thread got in between and changed
                             // the state of this thread, we just continue with
                             // the next one
@@ -724,7 +756,8 @@ namespace hpx { namespace threads { namespace detail
                     // now we just keep it in the map of threads.
                     if (HPX_UNLIKELY(state_val == pending))
                     {
-                        if (HPX_LIKELY(next_thrd == nullptr)) {
+                        if (HPX_LIKELY(next_thrd == nullptr))
+                        {
                             // schedule other work
                             scheduler.SchedulingPolicy::wait_or_add_new(
                                 num_thread, running, idle_loop_count,
@@ -747,8 +780,8 @@ namespace hpx { namespace threads { namespace detail
                         {
                             // reschedule this thread right away if the
                             // background work will be triggered
-                            if (HPX_UNLIKELY(
-                                busy_loop_count > params.max_busy_loop_count_))
+                            if (HPX_UNLIKELY(busy_loop_count >
+                                    params.max_busy_loop_count_))
                             {
                                 next_thrd = thrd;
                             }
@@ -765,8 +798,7 @@ namespace hpx { namespace threads { namespace detail
                                     thrd,
                                     threads::thread_schedule_hint(
                                         static_cast<std::int16_t>(num_thread)),
-                                    true,
-                                    thread_priority_boost);
+                                    true, thread_priority_boost);
                                 scheduler.SchedulingPolicy::do_some_work(
                                     num_thread);
                             }
@@ -784,11 +816,17 @@ namespace hpx { namespace threads { namespace detail
                         }
                     }
                 }
-                else if (HPX_UNLIKELY(active == state_val)) {
-                    LTM_(warning) << "tfunc(" << num_thread << "): " //-V128
-                        "thread(" << thrd->get_thread_id() << "), "
-                        "description(" << thrd->get_description() << "), "
-                        "rescheduling";
+                else if (HPX_UNLIKELY(active == state_val))
+                {
+                    LTM_(warning) << "tfunc(" << num_thread
+                                  << "): "    //-V128
+                                     "thread("
+                                  << thrd->get_thread_id()
+                                  << "), "
+                                     "description("
+                                  << thrd->get_description()
+                                  << "), "
+                                     "rescheduling";
 
                     // re-schedule thread, if it is still marked as active
                     // this might happen, if some thread has been added to the
@@ -802,15 +840,15 @@ namespace hpx { namespace threads { namespace detail
                 }
 
                 // Remove the mapping from thread_map_ if HPX thread is depleted
-                // or terminated, this will delete the HPX thread as all
-                // references go out of scope.
+                // or terminated, this will delete the HPX thread.
                 // REVIEW: what has to be done with depleted HPX threads?
-                if (HPX_LIKELY(state_val == depleted || state_val == terminated))
+                if (HPX_LIKELY(
+                        state_val == depleted || state_val == terminated))
                 {
 #ifdef HPX_HAVE_THREAD_CUMULATIVE_COUNTS
                     ++counters.executed_threads_;
 #endif
-                    scheduler.SchedulingPolicy::destroy_thread(thrd, busy_loop_count);
+                    scheduler.SchedulingPolicy::destroy_thread(thrd);
                 }
             }
 
@@ -819,13 +857,12 @@ namespace hpx { namespace threads { namespace detail
             {
                 --idle_loop_count;
 
-                if (scheduler.SchedulingPolicy::wait_or_add_new(
-                        num_thread, running, idle_loop_count,
-                        enable_stealing_staged, added))
+                if (scheduler.SchedulingPolicy::wait_or_add_new(num_thread,
+                        running, idle_loop_count, enable_stealing_staged,
+                        added))
                 {
                     // Clean up terminated threads before trying to exit
-                    bool can_exit =
-                        !running &&
+                    bool can_exit = !running &&
                         scheduler.SchedulingPolicy::cleanup_terminated(
                             num_thread, true) &&
                         scheduler.SchedulingPolicy::get_queue_length(
@@ -847,8 +884,8 @@ namespace hpx { namespace threads { namespace detail
 
                         if (can_exit)
                         {
-                            if (!(scheduler.SchedulingPolicy::get_scheduler_mode()
-                                  & policies::delay_exit))
+                            if (!scheduler.SchedulingPolicy::has_scheduler_mode(
+                                    policies::delay_exit))
                             {
                                 // If this is an inner scheduler, try to exit immediately
 #if defined(HPX_HAVE_NETWORKING)
@@ -883,15 +920,16 @@ namespace hpx { namespace threads { namespace detail
                             {
                                 // Otherwise, keep idling for some time
                                 if (!may_exit)
-                                    idle_loop_count = params.max_idle_loop_count_;
+                                    idle_loop_count =
+                                        params.max_idle_loop_count_;
                                 may_exit = true;
                             }
                         }
                     }
                 }
                 else if (!may_exit && added == 0 &&
-                    (scheduler.SchedulingPolicy::get_scheduler_mode() &
-                        policies::fast_idle_mode))
+                    (scheduler.SchedulingPolicy::has_scheduler_mode(
+                        policies::fast_idle_mode)))
                 {
                     // speed up idle suspend if no work was stolen
                     idle_loop_count -= params.max_idle_loop_count_ / 256;
@@ -1006,7 +1044,9 @@ namespace hpx { namespace threads { namespace detail
                             get_thread_id_data(background_thread),
                             threads::thread_schedule_hint(
                                 static_cast<std::int16_t>(num_thread)),
-                            true, get_thread_id_data(background_thread)->get_priority());
+                            true,
+                            get_thread_id_data(background_thread)
+                                ->get_priority());
                         scheduler.SchedulingPolicy::do_some_work(num_thread);
                         background_thread.reset();
                         background_running.reset();
@@ -1014,8 +1054,7 @@ namespace hpx { namespace threads { namespace detail
                     else
 #endif
                     {
-                        bool can_exit =
-                            !running &&
+                        bool can_exit = !running &&
                             scheduler.SchedulingPolicy::cleanup_terminated(
                                 true) &&
                             scheduler.SchedulingPolicy::get_thread_count(
@@ -1040,8 +1079,8 @@ namespace hpx { namespace threads { namespace detail
             }
         }
     }
-}}}
+}}}    // namespace hpx::threads::detail
 
 #endif
-
-
+// NOTE: This line only exists to please doxygen. Without the line doxygen
+// generates incomplete xml output.
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/convert_format.hpp b/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduled_thread_pool.hpp
similarity index 50%
rename from libs/logging/include_compatibility/hpx/util/logging/format/formatter/convert_format.hpp
rename to libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduled_thread_pool.hpp
index c3b2f295f9..8b0a9761cf 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/convert_format.hpp
+++ b/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduled_thread_pool.hpp
@@ -1,21 +1,21 @@
-//  Copyright (c) 2019 Mikael Simberg
+//  Copyright (c) 2019 STE||AR Group
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/convert_format.hpp>
+#include <hpx/thread_pools/config/defines.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
 
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_THREAD_POOLS_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
-    "The header hpx/util/logging/format/formatter/convert_format.hpp is deprecated, \
-    please include hpx/logging/format/formatter/convert_format.hpp instead")
+    "The header hpx/runtime/threads/detail/scheduled_thread_pool.hpp is deprecated, \
+    please include hpx/thread_pools/scheduled_thread_pool.hpp instead")
 #else
 #warning                                                                       \
-    "The header hpx/util/logging/format/formatter/convert_format.hpp is deprecated, \
-    please include hpx/logging/format/formatter/convert_format.hpp instead"
+    "The header hpx/runtime/threads/detail/scheduled_thread_pool.hpp is deprecated, \
+    please include hpx/thread_pools/scheduled_thread_pool.hpp instead"
 #endif
 #endif
diff --git a/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp b/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp
new file mode 100644
index 0000000000..39307489de
--- /dev/null
+++ b/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/thread_pools/config/defines.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool_impl.hpp>
+
+#if defined(HPX_THREAD_POOLS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp is deprecated, \
+    please include hpx/thread_pools/scheduled_thread_pool_impl.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp is deprecated, \
+    please include hpx/thread_pools/scheduled_thread_pool_impl.hpp instead"
+#endif
+#endif
diff --git a/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduling_loop.hpp b/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduling_loop.hpp
new file mode 100644
index 0000000000..5c8503e283
--- /dev/null
+++ b/libs/thread_pools/include_compatibility/hpx/runtime/threads/detail/scheduling_loop.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/thread_pools/config/defines.hpp>
+#include <hpx/thread_pools/scheduling_loop.hpp>
+
+#if defined(HPX_THREAD_POOLS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/detail/scheduling_loop.hpp is deprecated, \
+    please include hpx/thread_pools/scheduling_loop.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/detail/scheduling_loop.hpp is deprecated, \
+    please include hpx/thread_pools/scheduling_loop.hpp instead"
+#endif
+#endif
diff --git a/libs/thread_pools/include_compatibility/hpx/runtime/threads/scoped_background_timer.hpp b/libs/thread_pools/include_compatibility/hpx/runtime/threads/scoped_background_timer.hpp
new file mode 100644
index 0000000000..11c84745b2
--- /dev/null
+++ b/libs/thread_pools/include_compatibility/hpx/runtime/threads/scoped_background_timer.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/thread_pools/config/defines.hpp>
+#include <hpx/thread_pools/detail/scoped_background_timer.hpp>
+
+#if defined(HPX_THREAD_POOLS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/scoped_background_timer.hpp is deprecated, \
+    please include hpx/thread_pools/detail/scoped_background_timer.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/scoped_background_timer.hpp is deprecated, \
+    please include hpx/thread_pools/detail/scoped_background_timer.hpp instead"
+#endif
+#endif
diff --git a/libs/thread_pools/include_compatibility/hpx/runtime/threads/thread_pools.hpp b/libs/thread_pools/include_compatibility/hpx/runtime/threads/thread_pools.hpp
new file mode 100644
index 0000000000..f94d27e54c
--- /dev/null
+++ b/libs/thread_pools/include_compatibility/hpx/runtime/threads/thread_pools.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/thread_pools/config/defines.hpp>
+#include <hpx/thread_data/thread_pool_base.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
+
+#if defined(HPX_THREAD_POOLS_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_pools.hpp is deprecated, \
+    please include hpx/thread_pools/scheduled_thread_pool.hpp \
+    or hpx/thread_data/thread_pool_base.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/thread_pools.hpp is deprecated, \
+    please include hpx/thread_pools/scheduled_thread_pool.hpp \
+    or hpx/thread_data/thread_pool_base.hpp instead"
+#endif
+#endif
diff --git a/src/runtime/threads/detail/scheduled_thread_pool.cpp b/libs/thread_pools/src/scheduled_thread_pool.cpp
similarity index 64%
rename from src/runtime/threads/detail/scheduled_thread_pool.cpp
rename to libs/thread_pools/src/scheduled_thread_pool.cpp
index 9efa274d5b..81e5f7cc06 100644
--- a/src/runtime/threads/detail/scheduled_thread_pool.cpp
+++ b/libs/thread_pools/src/scheduled_thread_pool.cpp
@@ -4,62 +4,68 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#include <hpx/runtime/threads/detail/scheduled_thread_pool.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool_impl.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
 /// explicit template instantiation for the thread pools of our choice
 #if defined(HPX_HAVE_LOCAL_SCHEDULER)
-#include <hpx/runtime/threads/policies/local_queue_scheduler.hpp>
+#include <hpx/schedulers/local_queue_scheduler.hpp>
 template class HPX_EXPORT hpx::threads::policies::local_queue_scheduler<>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::local_queue_scheduler<>>;
 #endif
 
 #if defined(HPX_HAVE_STATIC_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_queue_scheduler.hpp>
+#include <hpx/schedulers/static_queue_scheduler.hpp>
 template class HPX_EXPORT hpx::threads::policies::static_queue_scheduler<>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::static_queue_scheduler<>>;
 #endif
 
 #if defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp>
-template class HPX_EXPORT hpx::threads::policies::static_priority_queue_scheduler<>;
+#include <hpx/schedulers/static_priority_queue_scheduler.hpp>
+template class HPX_EXPORT
+    hpx::threads::policies::static_priority_queue_scheduler<>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::static_priority_queue_scheduler<>>;
 #endif
 
-#include <hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp>
-template class HPX_EXPORT hpx::threads::policies::local_priority_queue_scheduler<
-    std::mutex, hpx::threads::policies::lockfree_fifo>;
+#include <hpx/schedulers/local_priority_queue_scheduler.hpp>
+template class HPX_EXPORT
+    hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
+        hpx::threads::policies::lockfree_fifo>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
         hpx::threads::policies::lockfree_fifo>>;
 #if defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
-template class HPX_EXPORT hpx::threads::policies::local_priority_queue_scheduler<
-    std::mutex, hpx::threads::policies::lockfree_lifo>;
+template class HPX_EXPORT
+    hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
+        hpx::threads::policies::lockfree_lifo>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
         hpx::threads::policies::lockfree_lifo>>;
 #endif
 
 #if defined(HPX_HAVE_ABP_SCHEDULER) && defined(HPX_HAVE_CXX11_STD_ATOMIC_128BIT)
-template class HPX_EXPORT hpx::threads::policies::local_priority_queue_scheduler<
-    std::mutex, hpx::threads::policies::lockfree_abp_fifo>;
+template class HPX_EXPORT
+    hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
+        hpx::threads::policies::lockfree_abp_fifo>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
         hpx::threads::policies::lockfree_abp_fifo>>;
-template class HPX_EXPORT hpx::threads::policies::local_priority_queue_scheduler<
-    std::mutex, hpx::threads::policies::lockfree_abp_lifo>;
+template class HPX_EXPORT
+    hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
+        hpx::threads::policies::lockfree_abp_lifo>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::local_priority_queue_scheduler<std::mutex,
         hpx::threads::policies::lockfree_abp_lifo>>;
 #endif
 
 #if defined(HPX_HAVE_SHARED_PRIORITY_SCHEDULER)
-#include <hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp>
-template class HPX_EXPORT hpx::threads::policies::shared_priority_queue_scheduler<>;
+#include <hpx/schedulers/shared_priority_queue_scheduler.hpp>
+template class HPX_EXPORT
+    hpx::threads::policies::shared_priority_queue_scheduler<>;
 template class HPX_EXPORT hpx::threads::detail::scheduled_thread_pool<
     hpx::threads::policies::shared_priority_queue_scheduler<>>;
 #endif
diff --git a/libs/thread_pools/tests/CMakeLists.txt b/libs/thread_pools/tests/CMakeLists.txt
new file mode 100644
index 0000000000..08bae5acb1
--- /dev/null
+++ b/libs/thread_pools/tests/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_THREAD_POOLS_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_THREAD_POOLS_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.thread_pools)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.thread_pools)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.thread_pools)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.thread_pools)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.thread_pools)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.thread_pools)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.thread_pools
+        HEADERS ${thread_pools_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        DEPENDENCIES hpx_thread_pools)
+    endif()
+endif()
diff --git a/libs/thread_pools/tests/performance/CMakeLists.txt b/libs/thread_pools/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/thread_pools/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/thread_pools/tests/regressions/CMakeLists.txt b/libs/thread_pools/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/thread_pools/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/thread_pools/tests/unit/CMakeLists.txt b/libs/thread_pools/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/thread_pools/tests/unit/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/thread_support/CMakeLists.txt b/libs/thread_support/CMakeLists.txt
index 043fe15436..1ce2a3c157 100644
--- a/libs/thread_support/CMakeLists.txt
+++ b/libs/thread_support/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(thread_support_headers
   hpx/thread_support/set_thread_name.hpp
diff --git a/libs/thread_support/README.rst b/libs/thread_support/README.rst
index 1ae4f9b0c7..c107072cec 100644
--- a/libs/thread_support/README.rst
+++ b/libs/thread_support/README.rst
@@ -12,4 +12,4 @@ thread_support
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/thread_support/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/thread_support/docs/index.html>`__.
diff --git a/libs/thread_support/include/hpx/thread_support/thread_specific_ptr.hpp b/libs/thread_support/include/hpx/thread_support/thread_specific_ptr.hpp
index a6c113fcf5..70a64a1b9d 100644
--- a/libs/thread_support/include/hpx/thread_support/thread_specific_ptr.hpp
+++ b/libs/thread_support/include/hpx/thread_support/thread_specific_ptr.hpp
@@ -57,11 +57,11 @@ namespace hpx { namespace util {
         }
 
     private:
-        static HPX_NATIVE_TLS T* ptr_;
+        static thread_local T* ptr_;
     };
 
     template <typename T, typename Tag>
-    HPX_NATIVE_TLS T* thread_specific_ptr<T, Tag>::ptr_ = nullptr;
+    thread_local T* thread_specific_ptr<T, Tag>::ptr_ = nullptr;
 }}    // namespace hpx::util
 
 #else
diff --git a/libs/thread_support/tests/unit/range.cpp b/libs/thread_support/tests/unit/range.cpp
index 9639d4861d..cef436007d 100644
--- a/libs/thread_support/tests/unit/range.cpp
+++ b/libs/thread_support/tests/unit/range.cpp
@@ -108,12 +108,12 @@ void adl_range()
 void vector_range()
 {
     std::vector<int> r(3);
-    HPX_TEST(hpx::util::begin(r) == r.begin());
-    HPX_TEST(hpx::util::end(r) == r.end());
+    HPX_TEST_EQ(hpx::util::begin(r), r.begin());
+    HPX_TEST_EQ(hpx::util::end(r), r.end());
 
     std::vector<int> cr(3);
-    HPX_TEST(hpx::util::begin(cr) == cr.begin());
-    HPX_TEST(hpx::util::end(cr) == cr.end());
+    HPX_TEST_EQ(hpx::util::begin(cr), cr.begin());
+    HPX_TEST_EQ(hpx::util::end(cr), cr.end());
     HPX_TEST_EQ(hpx::util::size(cr), 3u);
     HPX_TEST_EQ(hpx::util::empty(cr), false);
 }
diff --git a/libs/threading/CMakeLists.txt b/libs/threading/CMakeLists.txt
new file mode 100644
index 0000000000..0bbedef356
--- /dev/null
+++ b/libs/threading/CMakeLists.txt
@@ -0,0 +1,39 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(threading_headers
+  hpx/threading/thread.hpp)
+
+set(threading_compat_headers
+  hpx/runtime/threads/thread.hpp)
+
+set(threading_sources
+  thread.cpp)
+
+include(HPX_AddModule)
+add_hpx_module(threading
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  SOURCES ${threading_sources}
+  HEADERS ${threading_headers}
+  COMPAT_HEADERS ${threading_compat_headers}
+  DEPENDENCIES
+    hpx_assertion
+    hpx_config
+    hpx_coroutines
+    hpx_errors
+    hpx_execution
+    hpx_functional
+    hpx_threading_base
+    hpx_timing
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/threading/README.rst b/libs/threading/README.rst
new file mode 100644
index 0000000000..b777bfa7d5
--- /dev/null
+++ b/libs/threading/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+======
+thread
+======
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/thread/docs/index.html>`__.
diff --git a/libs/threading/docs/index.rst b/libs/threading/docs/index.rst
new file mode 100644
index 0000000000..41d3d4d3bf
--- /dev/null
+++ b/libs/threading/docs/index.rst
@@ -0,0 +1,18 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_threading:
+
+=========
+threading
+=========
+
+TODO: High-level description of the library.
+
+See the :ref:`API reference <libs_thread_api>` of this module for more
+details.
+
diff --git a/libs/threading/examples/CMakeLists.txt b/libs/threading/examples/CMakeLists.txt
new file mode 100644
index 0000000000..9504d0323c
--- /dev/null
+++ b/libs/threading/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.threading)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.threading)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_THREADING_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.threading)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.threading)
+  endif()
+endif()
diff --git a/hpx/runtime/threads/thread.hpp b/libs/threading/include/hpx/threading/thread.hpp
similarity index 74%
rename from hpx/runtime/threads/thread.hpp
rename to libs/threading/include/hpx/threading/thread.hpp
index 3a7e244931..cf7214efe7 100644
--- a/hpx/runtime/threads/thread.hpp
+++ b/libs/threading/include/hpx/threading/thread.hpp
@@ -10,12 +10,12 @@
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/synchronization/spinlock.hpp>
-#include <hpx/lcos_fwd.hpp>
 #include <hpx/functional/deferred_call.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/lcos_fwd.hpp>
+#include <hpx/synchronization/spinlock.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/timing/steady_clock.hpp>
 #include <hpx/util_fwd.hpp>
 
@@ -23,20 +23,19 @@
 #include <exception>
 #include <iosfwd>
 #include <mutex>
-#include <utility>
 #include <type_traits>
+#include <utility>
 
 #include <hpx/config/warnings_prefix.hpp>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx
-{
+namespace hpx {
     ///////////////////////////////////////////////////////////////////////////
     using thread_termination_handler_type =
         std::function<void(std::exception_ptr const& e)>;
     void set_thread_termination_handler(thread_termination_handler_type f);
 
-    class thread
+    class HPX_EXPORT thread
     {
         typedef lcos::local::spinlock mutex_type;
         void terminate(const char* function, const char* reason) const;
@@ -47,9 +46,9 @@ namespace hpx
 
         thread() noexcept;
 
-        template <typename F, typename Enable = typename
-            std::enable_if<!std::is_same<typename hpx::util::decay<F>::type,
-                thread>::value>::type>
+        template <typename F,
+            typename Enable = typename std::enable_if<!std::is_same<
+                typename hpx::util::decay<F>::type, thread>::value>::type>
         explicit thread(F&& f)
         {
             auto thrd_data = threads::get_self_id_data();
@@ -104,7 +103,7 @@ namespace hpx
 
         id get_id() const noexcept;
 
-        native_handle_type native_handle() const //-V659
+        native_handle_type native_handle() const    //-V659
         {
             std::lock_guard<mutex_type> l(mtx_);
             return id_;
@@ -152,75 +151,88 @@ namespace hpx
     private:
         threads::thread_id_type id_;
 
-        friend bool operator== (thread::id const& x, thread::id const& y) noexcept;
-        friend bool operator!= (thread::id const& x, thread::id const& y) noexcept;
-        friend bool operator< (thread::id const& x, thread::id const& y) noexcept;
-        friend bool operator> (thread::id const& x, thread::id const& y) noexcept;
-        friend bool operator<= (thread::id const& x, thread::id const& y) noexcept;
-        friend bool operator>= (thread::id const& x, thread::id const& y) noexcept;
+        friend bool operator==(
+            thread::id const& x, thread::id const& y) noexcept;
+        friend bool operator!=(
+            thread::id const& x, thread::id const& y) noexcept;
+        friend bool operator<(
+            thread::id const& x, thread::id const& y) noexcept;
+        friend bool operator>(
+            thread::id const& x, thread::id const& y) noexcept;
+        friend bool operator<=(
+            thread::id const& x, thread::id const& y) noexcept;
+        friend bool operator>=(
+            thread::id const& x, thread::id const& y) noexcept;
 
         template <typename Char, typename Traits>
-        friend std::basic_ostream<Char, Traits>&
-        operator<< (std::basic_ostream<Char, Traits>&, thread::id const&);
+        friend std::basic_ostream<Char, Traits>& operator<<(
+            std::basic_ostream<Char, Traits>&, thread::id const&);
 
         friend class thread;
 
     public:
-        id() noexcept : id_(threads::invalid_thread_id) {}
+        id() noexcept
+          : id_(threads::invalid_thread_id)
+        {
+        }
         explicit id(threads::thread_id_type const& i) noexcept
           : id_(i)
-        {}
-        explicit id(threads::thread_id_type && i) noexcept
+        {
+        }
+        explicit id(threads::thread_id_type&& i) noexcept
           : id_(std::move(i))
-        {}
+        {
+        }
 
-        threads::thread_id_type const& native_handle() const { return id_; }
+        threads::thread_id_type const& native_handle() const
+        {
+            return id_;
+        }
     };
 
-    inline bool operator== (thread::id const& x, thread::id const& y) noexcept
+    inline bool operator==(thread::id const& x, thread::id const& y) noexcept
     {
         return x.id_ == y.id_;
     }
 
-    inline bool operator!= (thread::id const& x, thread::id const& y) noexcept
+    inline bool operator!=(thread::id const& x, thread::id const& y) noexcept
     {
         return !(x == y);
     }
 
-    inline bool operator< (thread::id const& x, thread::id const& y) noexcept
+    inline bool operator<(thread::id const& x, thread::id const& y) noexcept
     {
         return x.id_ < y.id_;
     }
 
-    inline bool operator> (thread::id const& x, thread::id const& y) noexcept
+    inline bool operator>(thread::id const& x, thread::id const& y) noexcept
     {
         return y < x;
     }
 
-    inline bool operator<= (thread::id const& x, thread::id const& y) noexcept
+    inline bool operator<=(thread::id const& x, thread::id const& y) noexcept
     {
         return !(x > y);
     }
 
-    inline bool operator>= (thread::id const& x, thread::id const& y) noexcept
+    inline bool operator>=(thread::id const& x, thread::id const& y) noexcept
     {
         return !(x < y);
     }
 
     template <typename Char, typename Traits>
-    std::basic_ostream<Char, Traits>&
-    operator<< (std::basic_ostream<Char, Traits>& out, thread::id const& id)
+    std::basic_ostream<Char, Traits>& operator<<(
+        std::basic_ostream<Char, Traits>& out, thread::id const& id)
     {
         out << id.id_;
         return out;
     }
 
-//     template <class T> struct hash;
-//     template <> struct hash<thread::id>;
+    //     template <class T> struct hash;
+    //     template <> struct hash<thread::id>;
 
     ///////////////////////////////////////////////////////////////////////////
-    namespace this_thread
-    {
+    namespace this_thread {
         HPX_API_EXPORT thread::id get_id() noexcept;
 
         HPX_API_EXPORT void yield() noexcept;
@@ -236,7 +248,8 @@ namespace hpx
 
         HPX_API_EXPORT void interrupt();
 
-        HPX_API_EXPORT void sleep_until(util::steady_time_point const& abs_time);
+        HPX_API_EXPORT void sleep_until(
+            util::steady_time_point const& abs_time);
 
         inline void sleep_for(util::steady_duration const& rel_time)
         {
@@ -272,8 +285,8 @@ namespace hpx
             explicit restore_interruption(disable_interruption& d);
             ~restore_interruption();
         };
-    }
-}
+    }    // namespace this_thread
+}    // namespace hpx
 
 #include <hpx/config/warnings_suffix.hpp>
 
diff --git a/libs/threading/include_compatibility/hpx/runtime/threads/thread.hpp b/libs/threading/include_compatibility/hpx/runtime/threads/thread.hpp
new file mode 100644
index 0000000000..881cf81ed9
--- /dev/null
+++ b/libs/threading/include_compatibility/hpx/runtime/threads/thread.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading/config/defines.hpp>
+#include <hpx/threading/thread.hpp>
+
+#if defined(HPX_THREADING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/runtime/threads/thread.hpp is deprecated, \
+    please include hpx/threading/thread.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/thread.hpp is deprecated, \
+    please include hpx/threading/thread.hpp instead"
+#endif
+#endif
diff --git a/src/runtime/threads/thread.cpp b/libs/threading/src/thread.cpp
similarity index 97%
rename from src/runtime/threads/thread.cpp
rename to libs/threading/src/thread.cpp
index 7f8d5989f3..7219fe8ffc 100644
--- a/src/runtime/threads/thread.cpp
+++ b/libs/threading/src/thread.cpp
@@ -13,12 +13,11 @@
 #include <hpx/lcos/detail/future_data.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
+#include <hpx/threading.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/timing/steady_clock.hpp>
 
 #include <cstddef>
@@ -82,7 +81,8 @@ namespace hpx {
                 }
                 catch (...)
                 {
-                    detail::thread_termination_handler(std::current_exception());
+                    detail::thread_termination_handler(
+                        std::current_exception());
                 }
             }
             else
diff --git a/libs/threading/tests/CMakeLists.txt b/libs/threading/tests/CMakeLists.txt
new file mode 100644
index 0000000000..c64fe0284a
--- /dev/null
+++ b/libs/threading/tests/CMakeLists.txt
@@ -0,0 +1,41 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_THREADING_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_THREADING_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.threading)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.threading)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.threading)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.threading)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.threading)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.threading)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.threading
+        HEADERS ${threading_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        DEPENDENCIES hpx_threading)
+    endif()
+endif()
diff --git a/libs/threading/tests/performance/CMakeLists.txt b/libs/threading/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/threading/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/threading/tests/regressions/CMakeLists.txt b/libs/threading/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/threading/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/threading/tests/unit/CMakeLists.txt b/libs/threading/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/threading/tests/unit/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/threading_base/CMakeLists.txt b/libs/threading_base/CMakeLists.txt
new file mode 100644
index 0000000000..c6136de5e8
--- /dev/null
+++ b/libs/threading_base/CMakeLists.txt
@@ -0,0 +1,96 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(threading_base_headers
+  hpx/threading_base/annotated_function.hpp
+  hpx/threading_base/callback_notifier.hpp
+  hpx/threading_base/create_thread.hpp
+  hpx/threading_base/create_work.hpp
+  hpx/threading_base/execution_agent.hpp
+  hpx/threading_base/external_timer.hpp
+  hpx/threading_base/network_background_callback.hpp
+  hpx/threading_base/print.hpp
+  hpx/threading_base/register_thread.hpp
+  hpx/threading_base/scheduler_base.hpp
+  hpx/threading_base/scheduler_mode.hpp
+  hpx/threading_base/scheduler_state.hpp
+  hpx/threading_base/set_thread_state.hpp
+  hpx/threading_base/thread_data.hpp
+  hpx/threading_base/thread_data_stackful.hpp
+  hpx/threading_base/thread_data_stackless.hpp
+  hpx/threading_base/thread_description.hpp
+  hpx/threading_base/thread_helpers.hpp
+  hpx/threading_base/thread_init_data.hpp
+  hpx/threading_base/thread_num_tss.hpp
+  hpx/threading_base/thread_pool_base.hpp
+  hpx/threading_base/thread_queue_init_parameters.hpp
+  hpx/threading_base/thread_specific_ptr.hpp
+  hpx/threading_base/threading_base_fwd.hpp)
+
+set(threading_base_compat_headers
+  hpx/runtime/threads/detail/create_thread.hpp
+  hpx/runtime/threads/detail/create_work.hpp
+  hpx/runtime/threads/detail/network_background_callback.hpp
+  hpx/runtime/threads/detail/set_thread_state.hpp
+  hpx/runtime/threads/detail/thread_num_tss.hpp
+  hpx/runtime/threads/execution_agent.hpp
+  hpx/runtime/threads/policies/callback_notifier.hpp
+  hpx/runtime/threads/policies/scheduler_base.hpp
+  hpx/runtime/threads/policies/scheduler_mode.hpp
+  hpx/runtime/threads/policies/thread_queue_init_parameters.hpp
+  hpx/runtime/threads/register_thread.hpp
+  hpx/runtime/threads/thread_data.hpp
+  hpx/runtime/threads/thread_data_stackful.hpp
+  hpx/runtime/threads/thread_data_stackless.hpp
+  hpx/runtime/threads/thread_helpers.hpp
+  hpx/runtime/threads/thread_init_data.hpp
+  hpx/runtime/threads/thread_pool_base.hpp
+  hpx/runtime/threads/thread_specific_ptr.hpp
+  hpx/util/annotated_function.hpp
+  hpx/util/external_timer.hpp
+  hpx/util/thread_description.hpp)
+
+set(threading_base_sources
+  execution_agent.cpp
+  external_timer.cpp
+  register_thread.cpp
+  scheduler_base.cpp
+  thread_data.cpp
+  thread_data_stackful.cpp
+  thread_data_stackless.cpp
+  thread_description.cpp
+  thread_helpers.cpp
+  thread_num_tss.cpp
+  thread_pool_base.cpp)
+
+include(HPX_AddModule)
+add_hpx_module(threading_base
+  COMPATIBILITY_HEADERS ON
+  DEPRECATION_WARNINGS
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN ON
+  EXCLUDE_FROM_GLOBAL_HEADER
+  "hpx/threading_base/thread_data_stackful.hpp"
+  "hpx/threading_base/thread_data_stackless.hpp"
+  SOURCES ${threading_base_sources}
+  HEADERS ${threading_base_headers}
+  COMPAT_HEADERS ${threading_base_compat_headers}
+  DEPENDENCIES
+    hpx_affinity
+    hpx_allocator_support
+    hpx_config
+    hpx_coroutines
+    hpx_errors
+    hpx_hardware
+    hpx_logging
+    hpx_memory
+    hpx_naming_base
+  CMAKE_SUBDIRS examples tests
+)
diff --git a/libs/threading_base/README.rst b/libs/threading_base/README.rst
new file mode 100644
index 0000000000..3f6a6ed8e9
--- /dev/null
+++ b/libs/threading_base/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+==============
+threading_base
+==============
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/thread_data/docs/index.html>`__.
diff --git a/libs/threading_base/docs/index.rst b/libs/threading_base/docs/index.rst
new file mode 100644
index 0000000000..8850f8e7c2
--- /dev/null
+++ b/libs/threading_base/docs/index.rst
@@ -0,0 +1,25 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_threading_base:
+
+==============
+threading_base
+==============
+
+This module contains the base class definition required for threads. The base
+class :cpp:class:`hpx::threads::thread_data` is inherited by two specializations
+for stackful and stackless threads:
+:cpp:class:`hpx::threads::thread_data_stackful` and
+:cpp:class:`hpx::threads::thread_data_stackless`. In addition, the module
+defines the base classes for schedulers and thread pools:
+:cpp:class:`hpx::threads::policies::scheduler_base` and
+:cpp:class:`hpx::threads::thread_pool_base`.
+
+See the :ref:`API reference <libs_thread_data_api>` of this module for more
+details.
+
diff --git a/libs/threading_base/examples/CMakeLists.txt b/libs/threading_base/examples/CMakeLists.txt
new file mode 100644
index 0000000000..05374f741b
--- /dev/null
+++ b/libs/threading_base/examples/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+if (HPX_WITH_EXAMPLES)
+  add_hpx_pseudo_target(examples.modules.threading_base)
+  add_hpx_pseudo_dependencies(examples.modules examples.modules.threading_base)
+  if (HPX_WITH_TESTS AND HPX_WITH_TESTS_EXAMPLES AND HPX_THREADING_BASE_WITH_TESTS)
+    add_hpx_pseudo_target(tests.examples.modules.threading_base)
+    add_hpx_pseudo_dependencies(tests.examples.modules tests.examples.modules.threading_base)
+  endif()
+endif()
diff --git a/hpx/util/annotated_function.hpp b/libs/threading_base/include/hpx/threading_base/annotated_function.hpp
similarity index 69%
rename from hpx/util/annotated_function.hpp
rename to libs/threading_base/include/hpx/threading_base/annotated_function.hpp
index 52f4437f75..ec6803d5ad 100644
--- a/hpx/util/annotated_function.hpp
+++ b/libs/threading_base/include/hpx/threading_base/annotated_function.hpp
@@ -11,28 +11,26 @@
 
 #if defined(HPX_HAVE_THREAD_DESCRIPTION)
 #include <hpx/functional/invoke.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/functional/traits/get_function_address.hpp>
 #include <hpx/functional/traits/get_function_annotation.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/type_support/decay.hpp>
-#include <hpx/util/thread_description.hpp>
 
 #if HPX_HAVE_ITTNOTIFY != 0
 #include <hpx/concurrency/itt_notify.hpp>
 #elif defined(HPX_HAVE_APEX)
-#include <hpx/util/external_timer.hpp>
+#include <hpx/threading_base/external_timer.hpp>
 #endif
 #endif
 
 #include <cstddef>
 #include <cstdint>
+#include <string>
 #include <type_traits>
 #include <utility>
-#include <string>
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
 #if defined(HPX_HAVE_THREAD_DESCRIPTION)
     ///////////////////////////////////////////////////////////////////////////
 #if defined(HPX_COMPUTE_DEVICE_CODE)
@@ -42,7 +40,9 @@ namespace hpx { namespace util
 
         explicit annotate_function(char const* name) {}
         template <typename F>
-        explicit HPX_HOST_DEVICE annotate_function(F && f) {}
+        explicit HPX_HOST_DEVICE annotate_function(F&& f)
+        {
+        }
 
         // add empty (but non-trivial) destructor to silence warnings
         HPX_HOST_DEVICE ~annotate_function() {}
@@ -53,16 +53,16 @@ namespace hpx { namespace util
         HPX_NON_COPYABLE(annotate_function);
 
         explicit annotate_function(char const* name)
-          : task_(thread_domain_,
-                hpx::util::itt::string_handle(name))
-        {}
+          : task_(thread_domain_, hpx::util::itt::string_handle(name))
+        {
+        }
         template <typename F>
-        explicit annotate_function(F && f)
+        explicit annotate_function(F&& f)
           : task_(thread_domain_,
                 hpx::traits::get_function_annotation_itt<
-                    typename std::decay<F>::type
-                >::call(f))
-        {}
+                    typename std::decay<F>::type>::call(f))
+        {
+        }
 
     private:
         hpx::util::itt::thread_domain thread_domain_;
@@ -75,25 +75,24 @@ namespace hpx { namespace util
 
         explicit annotate_function(char const* name)
           : desc_(hpx::threads::get_self_ptr() ?
-                hpx::threads::set_thread_description(
-                    hpx::threads::get_self_id(), name) :
-                nullptr)
+                    hpx::threads::set_thread_description(
+                        hpx::threads::get_self_id(), name) :
+                    nullptr)
         {
 #if defined(HPX_HAVE_APEX)
             /* update the task wrapper in APEX to use the specified name */
-            threads::set_self_timer_data(
-                external_timer::update_task(threads::get_self_timer_data(),
-                std::string(name)));
+            threads::set_self_timer_data(external_timer::update_task(
+                threads::get_self_timer_data(), std::string(name)));
 #endif
         }
 
         template <typename F>
-        explicit annotate_function(F && f)
+        explicit annotate_function(F&& f)
           : desc_(hpx::threads::get_self_ptr() ?
-                hpx::threads::set_thread_description(
-                    hpx::threads::get_self_id(),
-                    hpx::util::thread_description(f)) :
-                nullptr)
+                    hpx::threads::set_thread_description(
+                        hpx::threads::get_self_id(),
+                        hpx::util::thread_description(f)) :
+                    nullptr)
         {
 #if defined(HPX_HAVE_APEX)
             /* no need to update the task description in APEX, because
@@ -114,28 +113,32 @@ namespace hpx { namespace util
     };
 #endif
 
-    namespace detail
-    {
+    namespace detail {
         template <typename F>
         struct annotated_function
         {
             annotated_function() noexcept
               : name_(nullptr)
-            {}
+            {
+            }
 
             annotated_function(F const& f, char const* name)
-              : f_(f), name_(name)
-            {}
+              : f_(f)
+              , name_(name)
+            {
+            }
 
-            annotated_function(F && f, char const* name)
-              : f_(std::move(f)), name_(name)
-            {}
+            annotated_function(F&& f, char const* name)
+              : f_(std::move(f))
+              , name_(name)
+            {
+            }
 
         public:
-            template <typename ... Ts>
-            typename invoke_result<
-                typename util::decay_unwrap<F>::type, Ts...>::type
-            operator()(Ts && ... ts)
+            template <typename... Ts>
+            typename invoke_result<typename util::decay_unwrap<F>::type,
+                Ts...>::type
+            operator()(Ts&&... ts)
             {
                 return util::invoke(f_, std::forward<Ts>(ts)...);
             }
@@ -143,7 +146,9 @@ namespace hpx { namespace util
             template <typename Archive>
             void serialize(Archive& ar, unsigned int const /*version*/)
             {
+                // clang-format off
                 ar & f_;
+                // clang-format on
             }
 
             ///////////////////////////////////////////////////////////////////
@@ -155,8 +160,7 @@ namespace hpx { namespace util
             std::size_t get_function_address() const
             {
                 return traits::get_function_address<
-                        typename util::decay_unwrap<F>::type
-                    >::call(f_);
+                    typename util::decay_unwrap<F>::type>::call(f_);
             }
 
             ///////////////////////////////////////////////////////////////////
@@ -176,15 +180,14 @@ namespace hpx { namespace util
             typename util::decay_unwrap<F>::type f_;
             char const* name_;
         };
-    }
+    }    // namespace detail
 
     template <typename F>
-    detail::annotated_function<typename std::decay<F>::type>
-    annotated_function(F && f, char const* name = nullptr)
+    detail::annotated_function<typename std::decay<F>::type> annotated_function(
+        F&& f, char const* name = nullptr)
     {
-        typedef detail::annotated_function<
-            typename std::decay<F>::type
-        > result_type;
+        typedef detail::annotated_function<typename std::decay<F>::type>
+            result_type;
 
         return result_type(std::forward<F>(f), name);
     }
@@ -197,7 +200,9 @@ namespace hpx { namespace util
 
         explicit annotate_function(char const* /*name*/) {}
         template <typename F>
-        explicit HPX_HOST_DEVICE annotate_function(F && /*f*/) {}
+        explicit HPX_HOST_DEVICE annotate_function(F&& /*f*/)
+        {
+        }
 
         // add empty (but non-trivial) destructor to silence warnings
         HPX_HOST_DEVICE ~annotate_function() {}
@@ -210,36 +215,35 @@ namespace hpx { namespace util
     ///
     /// \param function
     template <typename F>
-    F && annotated_function(F && f, char const* = nullptr)
+    F&& annotated_function(F&& f, char const* = nullptr)
     {
         return std::forward<F>(f);
     }
 #endif
-}}
+}}    // namespace hpx::util
 
 #if defined(HPX_HAVE_THREAD_DESCRIPTION)
-namespace hpx { namespace traits
-{
+namespace hpx { namespace traits {
     template <typename F>
-    struct get_function_address<util::detail::annotated_function<F> >
+    struct get_function_address<util::detail::annotated_function<F>>
     {
-        static std::size_t
-        call(util::detail::annotated_function<F> const& f) noexcept
+        static std::size_t call(
+            util::detail::annotated_function<F> const& f) noexcept
         {
             return f.get_function_address();
         }
     };
 
     template <typename F>
-    struct get_function_annotation<util::detail::annotated_function<F> >
+    struct get_function_annotation<util::detail::annotated_function<F>>
     {
-        static char const*
-        call(util::detail::annotated_function<F> const& f) noexcept
+        static char const* call(
+            util::detail::annotated_function<F> const& f) noexcept
         {
             return f.get_function_annotation();
         }
     };
-}}
+}}    // namespace hpx::traits
 #endif
 
 #endif
diff --git a/hpx/runtime/threads/policies/callback_notifier.hpp b/libs/threading_base/include/hpx/threading_base/callback_notifier.hpp
similarity index 95%
rename from hpx/runtime/threads/policies/callback_notifier.hpp
rename to libs/threading_base/include/hpx/threading_base/callback_notifier.hpp
index 0cc3f5690e..143756b243 100644
--- a/hpx/runtime/threads/policies/callback_notifier.hpp
+++ b/libs/threading_base/include/hpx/threading_base/callback_notifier.hpp
@@ -57,8 +57,8 @@ namespace hpx { namespace threads { namespace policies {
             {
                 if (callback)
                 {
-                    callback(
-                        local_thread_num, global_thread_num, pool_name, postfix);
+                    callback(local_thread_num, global_thread_num, pool_name,
+                        postfix);
                 }
             }
         }
@@ -96,7 +96,7 @@ namespace hpx { namespace threads { namespace policies {
         on_error_type on_error_;
     };
 
-}}}
+}}}    // namespace hpx::threads::policies
 
 #include <hpx/config/warnings_suffix.hpp>
 
diff --git a/hpx/runtime/threads/detail/create_thread.hpp b/libs/threading_base/include/hpx/threading_base/create_thread.hpp
similarity index 66%
rename from hpx/runtime/threads/detail/create_thread.hpp
rename to libs/threading_base/include/hpx/threading_base/create_thread.hpp
index e3c7a2b2fb..00b4067ad1 100644
--- a/hpx/runtime/threads/detail/create_thread.hpp
+++ b/libs/threading_base/include/hpx/threading_base/create_thread.hpp
@@ -8,48 +8,50 @@
 #define HPX_RUNTIME_THREADS_DETAIL_CREATE_THREAD_JAN_13_2013_0439PM
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/logging.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 
 #include <cstddef>
 #include <sstream>
 
-namespace hpx { namespace threads { namespace detail
-{
-    inline void create_thread(
-        policies::scheduler_base* scheduler, thread_init_data& data,
-        threads::thread_id_type& id,
-        thread_state_enum initial_state = pending,
-        bool run_now = true, error_code& ec = throws)
+namespace hpx { namespace threads { namespace detail {
+    inline void create_thread(policies::scheduler_base* scheduler,
+        thread_init_data& data, threads::thread_id_type& id,
+        thread_state_enum initial_state = pending, bool run_now = true,
+        error_code& ec = throws)
     {
         // verify parameters
-        switch (initial_state) {
+        switch (initial_state)
+        {
+        // NOLINTNEXTLINE(bugprone-branch-clone)
         case pending:
+            HPX_FALLTHROUGH;
         case pending_do_not_schedule:
+            HPX_FALLTHROUGH;
         case pending_boost:
+            HPX_FALLTHROUGH;
         case suspended:
             break;
 
         default:
-            {
-                std::ostringstream strm;
-                strm << "invalid initial state: "
-                     << get_thread_state_name(initial_state);
-                HPX_THROWS_IF(ec, bad_parameter,
-                    "threads::detail::create_thread",
-                    strm.str());
-                return;
-            }
+        {
+            std::ostringstream strm;
+            strm << "invalid initial state: "
+                 << get_thread_state_name(initial_state);
+            HPX_THROWS_IF(ec, bad_parameter, "threads::detail::create_thread",
+                strm.str());
+            return;
+        }
         }
 
 #ifdef HPX_HAVE_THREAD_DESCRIPTION
         if (!data.description)
         {
-            HPX_THROWS_IF(ec, bad_parameter,
-                "threads::detail::create_thread", "description is nullptr");
+            HPX_THROWS_IF(ec, bad_parameter, "threads::detail::create_thread",
+                "description is nullptr");
             return;
         }
 #endif
@@ -57,7 +59,8 @@ namespace hpx { namespace threads { namespace detail
         thread_self* self = get_self_ptr();
 
 #ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
-        if (nullptr == data.parent_id) {
+        if (nullptr == data.parent_id)
+        {
             if (self)
             {
                 data.parent_id = threads::get_self_id();
@@ -65,7 +68,7 @@ namespace hpx { namespace threads { namespace detail
             }
         }
         if (0 == data.parent_locality_id)
-            data.parent_locality_id = get_locality_id();
+            data.parent_locality_id = detail::get_locality_id(hpx::throws);
 #endif
 
         if (nullptr == data.scheduler_base)
@@ -101,7 +104,6 @@ namespace hpx { namespace threads { namespace detail
         // thread.
         scheduler->do_some_work(data.schedulehint.hint);
     }
-}}}
+}}}    // namespace hpx::threads::detail
 
 #endif
-
diff --git a/hpx/runtime/threads/detail/create_work.hpp b/libs/threading_base/include/hpx/threading_base/create_work.hpp
similarity index 69%
rename from hpx/runtime/threads/detail/create_work.hpp
rename to libs/threading_base/include/hpx/threading_base/create_work.hpp
index 74904956cb..71e071b4e8 100644
--- a/hpx/runtime/threads/detail/create_work.hpp
+++ b/libs/threading_base/include/hpx/threading_base/create_work.hpp
@@ -8,23 +8,23 @@
 #define HPX_RUNTIME_THREADS_DETAIL_CREATE_WORK_JAN_13_2013_0526PM
 
 #include <hpx/config.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/logging.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 
 #include <sstream>
 
-namespace hpx { namespace threads { namespace detail
-{
+namespace hpx { namespace threads { namespace detail {
     inline void create_work(policies::scheduler_base* scheduler,
         thread_init_data& data,
         thread_state_enum initial_state = threads::pending,
         error_code& ec = throws)
     {
         // verify parameters
-        switch (initial_state) {
+        switch (initial_state)
+        {
         case pending:
         case pending_do_not_schedule:
         case pending_boost:
@@ -32,40 +32,39 @@ namespace hpx { namespace threads { namespace detail
             break;
 
         default:
-            {
-                std::ostringstream strm;
-                strm << "invalid initial state: "
-                     << get_thread_state_name(initial_state);
-                HPX_THROWS_IF(ec, bad_parameter,
-                    "thread::detail::create_work",
-                    strm.str());
-                return;
-            }
+        {
+            std::ostringstream strm;
+            strm << "invalid initial state: "
+                 << get_thread_state_name(initial_state);
+            HPX_THROWS_IF(
+                ec, bad_parameter, "thread::detail::create_work", strm.str());
+            return;
+        }
         }
 
 #ifdef HPX_HAVE_THREAD_DESCRIPTION
         if (!data.description)
         {
-            HPX_THROWS_IF(ec, bad_parameter,
-                "thread::detail::create_work", "description is nullptr");
+            HPX_THROWS_IF(ec, bad_parameter, "thread::detail::create_work",
+                "description is nullptr");
             return;
         }
 #endif
 
-        LTM_(info)
-            << "create_work: initial_state("
-            << get_thread_state_name(initial_state) << "), thread_priority("
-            << get_thread_priority_name(data.priority)
+        LTM_(info) << "create_work: initial_state("
+                   << get_thread_state_name(initial_state)
+                   << "), thread_priority("
+                   << get_thread_priority_name(data.priority)
 #ifdef HPX_HAVE_THREAD_DESCRIPTION
-            << "), description(" << data.description
+                   << "), description(" << data.description
 #endif
-            << ")";
+                   << ")";
 
         thread_self* self = get_self_ptr();
 
 #ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
-        if (nullptr == data.parent_id) {
-
+        if (nullptr == data.parent_id)
+        {
             if (self)
             {
                 data.parent_id = threads::get_self_id();
@@ -73,7 +72,7 @@ namespace hpx { namespace threads { namespace detail
             }
         }
         if (0 == data.parent_locality_id)
-            data.parent_locality_id = get_locality_id();
+            data.parent_locality_id = detail::get_locality_id(hpx::throws);
 #endif
 
         if (nullptr == data.scheduler_base)
@@ -101,7 +100,8 @@ namespace hpx { namespace threads { namespace detail
             // For critical priority threads, create the thread immediately.
             scheduler->create_thread(data, nullptr, initial_state, true, ec);
         }
-        else {
+        else
+        {
             // Create a task description for the new thread.
             scheduler->create_thread(data, nullptr, initial_state, false, ec);
         }
@@ -110,7 +110,6 @@ namespace hpx { namespace threads { namespace detail
         // thread.
         scheduler->do_some_work(data.schedulehint.hint);
     }
-}}}
+}}}    // namespace hpx::threads::detail
 
 #endif
-
diff --git a/hpx/runtime/threads/execution_agent.hpp b/libs/threading_base/include/hpx/threading_base/execution_agent.hpp
similarity index 100%
rename from hpx/runtime/threads/execution_agent.hpp
rename to libs/threading_base/include/hpx/threading_base/execution_agent.hpp
diff --git a/libs/threading_base/include/hpx/threading_base/external_timer.hpp b/libs/threading_base/include/hpx/threading_base/external_timer.hpp
new file mode 100644
index 0000000000..1c46416321
--- /dev/null
+++ b/libs/threading_base/include/hpx/threading_base/external_timer.hpp
@@ -0,0 +1,331 @@
+//  Copyright (c) 2007-2016 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#pragma once    // prevent multiple inclusions of this header file.
+
+#include <hpx/config.hpp>
+#include <hpx/assertion.hpp>
+#include <hpx/coroutines/thread_id_type.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <cstdint>
+#include <memory>
+#include <string>
+
+namespace hpx { namespace util {
+
+#ifdef HPX_HAVE_APEX
+
+    using enable_parent_task_handler_type = std::function<bool()>;
+
+    HPX_EXPORT void set_enable_parent_task_handler(
+        enable_parent_task_handler_type f);
+
+    namespace external_timer {
+
+        // HPX provides a smart pointer to a data object that maintains
+        // information about an hpx_thread. Any library (i.e. APEX) that wants
+        // to use this callback API needs to extend this class.
+        struct task_wrapper
+        {
+        };
+
+        // Enumeration of function type flags
+        typedef enum functions_t
+        {
+            init_flag = 0,
+            finalize_flag,
+            register_thread_flag,
+            new_task_string_flag,
+            new_task_address_flag,
+            update_task_string_flag,
+            update_task_address_flag,
+            sample_value_flag,
+            send_flag,
+            recv_flag,
+            start_flag,
+            stop_flag,
+            yield_flag
+        } functions_t;
+
+        // Typedefs of function pointers
+        typedef uint64_t init_t(const char*, const uint64_t, const uint64_t);
+        typedef void finalize_t(void);
+        typedef void register_thread_t(const std::string&);
+        typedef std::shared_ptr<task_wrapper> new_task_string_t(
+            const std::string&, const uint64_t,
+            const std::shared_ptr<task_wrapper>);
+        typedef std::shared_ptr<task_wrapper> new_task_address_t(
+            uintptr_t, const uint64_t, const std::shared_ptr<task_wrapper>);
+        typedef void sample_value_t(const std::string&, double);
+        typedef void send_t(uint64_t, uint64_t, uint64_t);
+        typedef void recv_t(uint64_t, uint64_t, uint64_t, uint64_t);
+        typedef std::shared_ptr<task_wrapper> update_task_string_t(
+            std::shared_ptr<task_wrapper>, const std::string&);
+        typedef std::shared_ptr<task_wrapper> update_task_address_t(
+            std::shared_ptr<task_wrapper>, uintptr_t);
+        typedef void start_t(std::shared_ptr<task_wrapper>);
+        typedef void stop_t(std::shared_ptr<task_wrapper>);
+        typedef void yield_t(std::shared_ptr<task_wrapper>);
+
+        // Structure for compiler type-checking of function pointer assignment
+        typedef struct registration
+        {
+            functions_t type;
+            union
+            {
+                init_t* init;
+                finalize_t* finalize;
+                register_thread_t* register_thread;
+                new_task_string_t* new_task_string;
+                new_task_address_t* new_task_address;
+                update_task_string_t* update_task_string;
+                update_task_address_t* update_task_address;
+                sample_value_t* sample_value;
+                send_t* send;
+                recv_t* recv;
+                start_t* start;
+                stop_t* stop;
+                yield_t* yield;
+            } record;
+        } registration_t;
+
+        // The actual function pointers. Some of them need to be exported,
+        // because through the miracle of chained headers they get referenced
+        // outside of the HPX library.
+        extern init_t* init_function;
+        extern finalize_t* finalize_function;
+        extern register_thread_t* register_thread_function;
+        extern new_task_string_t* new_task_string_function;
+        extern new_task_address_t* new_task_address_function;
+        extern sample_value_t* sample_value_function;
+        extern send_t* send_function;
+        extern recv_t* recv_function;
+        HPX_EXPORT extern update_task_string_t* update_task_string_function;
+        HPX_EXPORT extern update_task_address_t* update_task_address_function;
+        HPX_EXPORT extern start_t* start_function;
+        HPX_EXPORT extern stop_t* stop_function;
+        HPX_EXPORT extern yield_t* yield_function;
+
+        // The function registration interface
+        HPX_EXPORT void register_external_timer(
+            registration_t& registration_record);
+
+        // The actual API. For all cases, check if the function pointer is null,
+        // and if not null call the registered function.
+        static inline uint64_t init(const char* thread_name,
+            const uint64_t comm_rank, const uint64_t comm_size)
+        {
+            return (init_function == nullptr) ?
+                0ULL :
+                init_function(thread_name, comm_rank, comm_size);
+        };
+        static inline void finalize(void)
+        {
+            if (finalize_function != nullptr)
+            {
+                finalize_function();
+            }
+        };
+        static inline void register_thread(const std::string& name)
+        {
+            if (register_thread_function != nullptr)
+            {
+                register_thread_function(name);
+            }
+        };
+        static inline std::shared_ptr<task_wrapper> new_task(
+            const std::string& name, const uint64_t task_id,
+            const std::shared_ptr<task_wrapper> parent_task)
+        {
+            return (new_task_string_function == nullptr) ?
+                0ULL :
+                new_task_string_function(name, task_id, parent_task);
+        };
+        static inline std::shared_ptr<task_wrapper> new_task(uintptr_t address,
+            const uint64_t task_id,
+            const std::shared_ptr<task_wrapper> parent_task)
+        {
+            return (new_task_address_function == nullptr) ?
+                0ULL :
+                new_task_address_function(address, task_id, parent_task);
+        };
+        static inline void sample_value(const std::string& name, double value)
+        {
+            if (sample_value_function != nullptr)
+            {
+                sample_value_function(name, value);
+            }
+        };
+        static inline void send(uint64_t tag, uint64_t size, uint64_t target)
+        {
+            if (send_function != nullptr)
+            {
+                send_function(tag, size, target);
+            }
+        };
+        static inline void recv(uint64_t tag, uint64_t size,
+            uint64_t source_rank, uint64_t source_thread)
+        {
+            if (recv_function != nullptr)
+            {
+                recv_function(tag, size, source_rank, source_thread);
+            }
+        };
+        static inline std::shared_ptr<task_wrapper> update_task(
+            std::shared_ptr<task_wrapper> wrapper, const std::string& name)
+        {
+            return (update_task_string_function == nullptr) ?
+                0ULL :
+                update_task_string_function(wrapper, name);
+        };
+        static inline std::shared_ptr<task_wrapper> update_task(
+            std::shared_ptr<task_wrapper> wrapper, uintptr_t address)
+        {
+            return (update_task_address_function == nullptr) ?
+                0ULL :
+                update_task_address_function(wrapper, address);
+        };
+        static inline void start(std::shared_ptr<task_wrapper> task_wrapper_ptr)
+        {
+            if (start_function != nullptr)
+            {
+                start_function(task_wrapper_ptr);
+            }
+        };
+        static inline void stop(std::shared_ptr<task_wrapper> task_wrapper_ptr)
+        {
+            if (stop_function != nullptr)
+            {
+                stop_function(task_wrapper_ptr);
+            }
+        };
+        static inline void yield(std::shared_ptr<task_wrapper> task_wrapper_ptr)
+        {
+            if (yield_function != nullptr)
+            {
+                yield_function(task_wrapper_ptr);
+            }
+        };
+
+        HPX_EXPORT std::shared_ptr<task_wrapper> new_task(
+            thread_description const& description,
+            std::uint32_t parent_locality_id,
+            threads::thread_id_type const& parent_task);
+
+        HPX_EXPORT inline std::shared_ptr<task_wrapper> update_task(
+            std::shared_ptr<task_wrapper> wrapper,
+            thread_description const& description)
+        {
+            if (wrapper == nullptr)
+            {
+                threads::thread_id_type parent_task(nullptr);
+                // doesn't matter which locality we use, the parent is null
+                return new_task(description, 0, parent_task);
+            }
+            else if (description.kind() ==
+                thread_description::data_type_description)
+            {
+                // Disambiguate the call by making a temporary string object
+                return update_task(
+                    wrapper, std::string(description.get_description()));
+            }
+            else
+            {
+                HPX_ASSERT(description.kind() ==
+                    thread_description::data_type_address);
+                return update_task(wrapper, description.get_address());
+            }
+        }
+
+        // This is a scoped object around task scheduling to measure the time
+        // spent executing hpx threads
+        struct scoped_timer
+        {
+            explicit scoped_timer(std::shared_ptr<task_wrapper> data_ptr)
+              : stopped(false)
+              , data_(nullptr)
+            {
+                // APEX internal actions are not timed. Otherwise, we would end
+                // up with recursive timers. So it's possible to have a null
+                // task wrapper pointer here.
+                if (data_ptr != nullptr)
+                {
+                    data_ = data_ptr;
+                    hpx::util::external_timer::start(data_);
+                }
+            }
+            ~scoped_timer()
+            {
+                stop();
+            }
+
+            void stop()
+            {
+                if (!stopped)
+                {
+                    stopped = true;
+                    // APEX internal actions are not timed. Otherwise, we would
+                    // end up with recursive timers. So it's possible to have a
+                    // null task wrapper pointer here.
+                    if (data_ != nullptr)
+                    {
+                        hpx::util::external_timer::stop(data_);
+                    }
+                }
+            }
+
+            void yield()
+            {
+                if (!stopped)
+                {
+                    stopped = true;
+                    // APEX internal actions are not timed. Otherwise, we would
+                    // end up with recursive timers. So it's possible to have a
+                    // null task wrapper pointer here.
+                    if (data_ != nullptr)
+                    {
+                        hpx::util::external_timer::yield(data_);
+                    }
+                }
+            }
+
+            bool stopped;
+            std::shared_ptr<task_wrapper> data_;
+        };
+    }    // namespace external_timer
+
+#else
+    namespace external_timer {
+
+        struct task_wrapper
+        {
+        };
+
+        inline std::shared_ptr<task_wrapper> new_task(
+            thread_description const& description,
+            std::uint32_t parent_locality_id,
+            threads::thread_id_type const& parent_task)
+        {
+            return nullptr;
+        }
+
+        inline std::shared_ptr<task_wrapper> update_task(
+            std::shared_ptr<task_wrapper> wrapper,
+            thread_description const& description)
+        {
+            return nullptr;
+        }
+
+        struct scoped_timer
+        {
+            explicit scoped_timer(std::shared_ptr<task_wrapper> data_ptr) {}
+            ~scoped_timer() {}
+            void stop(void) {}
+            void yield(void) {}
+        };
+    }    // namespace external_timer
+#endif
+}}    // namespace hpx::util
diff --git a/hpx/runtime/threads/detail/network_background_callback.hpp b/libs/threading_base/include/hpx/threading_base/network_background_callback.hpp
similarity index 95%
rename from hpx/runtime/threads/detail/network_background_callback.hpp
rename to libs/threading_base/include/hpx/threading_base/network_background_callback.hpp
index 7be08dcf91..a3c24bcb53 100644
--- a/hpx/runtime/threads/detail/network_background_callback.hpp
+++ b/libs/threading_base/include/hpx/threading_base/network_background_callback.hpp
@@ -22,6 +22,6 @@ namespace hpx { namespace threads { namespace detail {
     using network_background_callback_type =
         util::function_nonser<bool(std::size_t)>;
 #endif
-}}}
+}}}    // namespace hpx::threads::detail
 
 #endif
diff --git a/libs/threading_base/include/hpx/threading_base/print.hpp b/libs/threading_base/include/hpx/threading_base/print.hpp
new file mode 100644
index 0000000000..5bb88d0db6
--- /dev/null
+++ b/libs/threading_base/include/hpx/threading_base/print.hpp
@@ -0,0 +1,158 @@
+//  Copyright (c) 2019 John Biddiscombe
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_THREADING_BASE_PRINT_HPP
+#define HPX_THREADING_BASE_PRINT_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/debugging/print.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+
+#include <iostream>
+#include <sstream>
+#include <thread>
+
+// ------------------------------------------------------------
+/// \cond NODETAIL
+namespace hpx { namespace debug {
+    // ------------------------------------------------------------------
+    // safely dump thread pointer/description
+    // ------------------------------------------------------------------
+    template <typename T>
+    struct threadinfo
+    {
+    };
+
+    // ------------------------------------------------------------------
+    // safely dump thread pointer/description
+    // ------------------------------------------------------------------
+    template <>
+    struct threadinfo<threads::thread_data*>
+    {
+        threadinfo(const threads::thread_data* v)
+          : data(v)
+        {
+        }
+        const threads::thread_data* data;
+        friend std::ostream& operator<<(std::ostream& os, const threadinfo& d)
+        {
+            os << ptr(d.data) << " \""
+               << ((d.data != nullptr) ? d.data->get_description() : "nullptr")
+               << "\"";
+            return os;
+        }
+    };
+
+    template <>
+    struct threadinfo<threads::thread_id_type*>
+    {
+        threadinfo(const threads::thread_id_type* v)
+          : data(v)
+        {
+        }
+        const threads::thread_id_type* data;
+        friend std::ostream& operator<<(std::ostream& os, const threadinfo& d)
+        {
+            if (d.data == nullptr)
+                os << "nullptr";
+            else
+                os << threadinfo<threads::thread_data*>(
+                    get_thread_id_data(*d.data));
+            return os;
+        }
+    };
+
+    template <>
+    struct threadinfo<hpx::threads::thread_init_data>
+    {
+        threadinfo(const hpx::threads::thread_init_data& v)
+          : data(v)
+        {
+        }
+        const hpx::threads::thread_init_data& data;
+        friend std::ostream& operator<<(std::ostream& os, const threadinfo& d)
+        {
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+            os << std::left << " \"" << d.data.description.get_description()
+               << "\"";
+#else
+            os << "??? " << /*hex<8,uintptr_t>*/ (uintptr_t(&d.data));
+#endif
+            return os;
+        }
+    };
+
+#ifdef HPX_HAVE_CXX17_FOLD_EXPRESSIONS
+    namespace detail {
+        // ------------------------------------------------------------------
+        // helper class for printing thread ID, either std:: or hpx::
+        // ------------------------------------------------------------------
+        struct current_thread_print_helper
+        {
+        };
+
+        inline std::ostream& operator<<(
+            std::ostream& os, const current_thread_print_helper&)
+        {
+            if (hpx::threads::get_self_id() == hpx::threads::invalid_thread_id)
+            {
+                os << "-------------- ";
+            }
+            else
+            {
+                hpx::threads::thread_data* dummy =
+                    hpx::threads::get_self_id_data();
+                os << dummy << " ";
+            }
+            os << hex<12, std::thread::id>(std::this_thread::get_id())
+#ifdef DEBUGGING_PRINT_LINUX
+               << " cpu " << debug::dec<3, int>(sched_getcpu()) << " ";
+#else
+               << " cpu "
+               << "--- ";
+#endif
+            return os;
+        }
+
+        // ------------------------------------------------------------------
+        // helper class for printing time since start
+        // ------------------------------------------------------------------
+        struct current_time_print_helper
+        {
+        };
+
+        inline std::ostream& operator<<(
+            std::ostream& os, const current_time_print_helper&)
+        {
+            using namespace std::chrono;
+            static high_resolution_clock::time_point log_t_start =
+                high_resolution_clock::now();
+            //
+            auto now = high_resolution_clock::now();
+            auto nowt = duration_cast<microseconds>(now - log_t_start).count();
+            //
+            os << debug::dec<10>(nowt) << " ";
+            return os;
+        }
+
+        template <typename... Args>
+        void display(const char* prefix, Args... args)
+        {
+            // using a temp stream object with a single copy to cout at the end
+            // prevents multiple threads from injecting overlapping text
+            std::stringstream tempstream;
+            tempstream << prefix << detail::current_time_print_helper()
+                       << detail::current_thread_print_helper();
+            ((tempstream << args << " "), ...);
+            tempstream << std::endl;
+            std::cout << tempstream.str();
+        }
+    }    // namespace detail
+#endif
+}}    // namespace hpx::debug
+/// \endcond
+
+#endif
diff --git a/hpx/runtime/threads/register_thread.hpp b/libs/threading_base/include/hpx/threading_base/register_thread.hpp
similarity index 98%
rename from hpx/runtime/threads/register_thread.hpp
rename to libs/threading_base/include/hpx/threading_base/register_thread.hpp
index 2bf0f63684..e72987f305 100644
--- a/hpx/runtime/threads/register_thread.hpp
+++ b/libs/threading_base/include/hpx/threading_base/register_thread.hpp
@@ -11,11 +11,14 @@
 #define HPX_RUNTIME_THREADS_REGISTER_THREAD_HPP
 
 #include <hpx/config.hpp>
+#include <hpx/config/asio.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+
+#include <boost/asio/io_service.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -84,6 +87,12 @@ namespace hpx { namespace threads {
         using get_default_pool_type = std::function<thread_pool_base*()>;
         HPX_EXPORT void set_get_default_pool(get_default_pool_type f);
         HPX_EXPORT thread_pool_base* get_self_or_default_pool();
+
+        using get_default_timer_service_type =
+            std::function<boost::asio::io_service*()>;
+        HPX_EXPORT void set_get_default_timer_service(
+            get_default_timer_service_type f);
+        HPX_EXPORT boost::asio::io_service* get_default_timer_service();
     }    // namespace detail
 
     inline threads::thread_id_type register_thread_plain(
diff --git a/hpx/runtime/threads/policies/scheduler_base.hpp b/libs/threading_base/include/hpx/threading_base/scheduler_base.hpp
similarity index 94%
rename from hpx/runtime/threads/policies/scheduler_base.hpp
rename to libs/threading_base/include/hpx/threading_base/scheduler_base.hpp
index 243cf560b9..154c093460 100644
--- a/hpx/runtime/threads/policies/scheduler_base.hpp
+++ b/libs/threading_base/include/hpx/threading_base/scheduler_base.hpp
@@ -11,13 +11,13 @@
 #include <hpx/assertion.hpp>
 #include <hpx/concurrency/cache_line_data.hpp>
 #include <hpx/format.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/state.hpp>
-#include <hpx/util_fwd.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
+#include <hpx/threading_base/threading_base_fwd.hpp>
 #if defined(HPX_HAVE_SCHEDULER_LOCAL_STORAGE)
 #include <hpx/coroutines/detail/tss.hpp>
 #endif
@@ -105,24 +105,20 @@ namespace hpx { namespace threads { namespace policies {
         std::pair<hpx::state, hpx::state> get_minmax_state() const;
 
         ///////////////////////////////////////////////////////////////////////
-        bool has_work_stealing() const
-        {
-            return (get_scheduler_mode() & policies::enable_stealing);
-        }
-
-        bool has_work_stealing_numa() const
+        // get/set scheduler mode
+        scheduler_mode get_scheduler_mode() const
         {
-            return (get_scheduler_mode() & policies::enable_stealing_numa);
+            return mode_.data_.load(std::memory_order_relaxed);
         }
 
         // get/set scheduler mode
-        scheduler_mode get_scheduler_mode() const
+        bool has_scheduler_mode(scheduler_mode mode) const
         {
-            return mode_.data_.load(std::memory_order_relaxed);
+            return (mode_.data_.load(std::memory_order_relaxed) & mode) != 0;
         }
 
         // set mode flags that control scheduler behaviour
-        // This set function is virtual so that flags may be overriden
+        // This set function is virtual so that flags may be overridden
         // by schedulers that do not support certain operations/modes.
         // All other mode set functions should call this one to ensure
         // that flags are always consistent
@@ -221,8 +217,7 @@ namespace hpx { namespace threads { namespace policies {
             bool allow_fallback = false,
             thread_priority priority = thread_priority_normal) = 0;
 
-        virtual void destroy_thread(
-            threads::thread_data* thrd, std::int64_t& busy_count) = 0;
+        virtual void destroy_thread(threads::thread_data* thrd) = 0;
 
         virtual bool wait_or_add_new(std::size_t num_thread, bool running,
             std::int64_t& idle_loop_count, bool enable_stealing,
diff --git a/libs/threading_base/include/hpx/threading_base/scheduler_mode.hpp b/libs/threading_base/include/hpx/threading_base/scheduler_mode.hpp
new file mode 100644
index 0000000000..658f98d47b
--- /dev/null
+++ b/libs/threading_base/include/hpx/threading_base/scheduler_mode.hpp
@@ -0,0 +1,92 @@
+//  Copyright (c) 2015-2017 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#if !defined(HPX_THREADS_SCHEDULER_MODE_AUG_27_2017_1136AM)
+#define HPX_THREADS_SCHEDULER_MODE_AUG_27_2017_1136AM
+
+#include <cstdint>
+
+namespace hpx { namespace threads { namespace policies {
+    /// This enumeration describes the possible modes of a scheduler.
+    enum scheduler_mode : std::uint32_t
+    {
+        /// As the name suggests, this option can be used to disable all other
+        /// options.
+        nothing_special = 0x000,
+        /// The scheduler will periodically call a provided callback function
+        /// from a special HPX thread to enable performing background-work, for
+        /// instance driving networking progress or garbage-collect AGAS.
+        do_background_work = 0x001,
+        /// The kernel priority of the os-thread driving the scheduler will be
+        /// reduced below normal.
+        reduce_thread_priority = 0x002,
+        /// The scheduler will wait for some unspecified amount of time before
+        /// exiting the scheduling loop while being terminated to make sure no
+        /// other work is being scheduled during processing the shutdown
+        /// request.
+        delay_exit = 0x004,
+        /// Some schedulers have the capability to act as 'embedded'
+        /// schedulers. In this case it needs to periodically invoke a provided
+        /// callback into the outer scheduler more frequently than normal. This
+        /// option enables this behavior.
+        fast_idle_mode = 0x008,
+        /// This option allows for the scheduler to dynamically increase and
+        /// reduce the number of processing units it runs on. Setting this value
+        /// not succeed for schedulers that do not support this functionality.
+        enable_elasticity = 0x010,
+        /// This option allows schedulers that support work thread/stealing to
+        /// enable/disable it
+        enable_stealing = 0x020,
+        /// This option allows schedulersthat support it to disallow stealing
+        /// between numa domains
+        enable_stealing_numa = 0x040,
+        /// This option tells schedulersthat support it to add tasks round
+        /// robin to queues on each core
+        assign_work_round_robin = 0x080,
+        /// This option tells schedulers that support it to add tasks round to
+        /// the same core/queue that the parent task is running on
+        assign_work_thread_parent = 0x100,
+        /// This option tells schedulers that support it to always (try to)
+        /// steal high priority tasks from other queues before finishing their
+        /// own lower priority tasks
+        steal_high_priority_first = 0x200,
+        /// This option tells schedulers that support it to steal tasks only
+        /// when their local queues are empty
+        steal_after_local = 0x400,
+        /// This option allows for certain schedulers to explicitly disable
+        /// exponential idle-back off
+        enable_idle_backoff = 0x800,
+
+        // clang-format off
+        /// This option represents the default mode.
+        default_mode =
+            do_background_work |
+            reduce_thread_priority |
+            delay_exit |
+            enable_stealing |
+            enable_stealing_numa |
+            assign_work_round_robin |
+            steal_after_local |
+            enable_idle_backoff,
+        /// This enables all available options.
+        all_flags =
+            do_background_work |
+            reduce_thread_priority |
+            delay_exit |
+            fast_idle_mode |
+            enable_elasticity |
+            enable_stealing |
+            enable_stealing_numa |
+            assign_work_round_robin |
+            assign_work_thread_parent |
+            steal_high_priority_first |
+            steal_after_local |
+            enable_idle_backoff
+        // clang-format on
+    };
+}}}    // namespace hpx::threads::policies
+
+#endif
diff --git a/libs/threading_base/include/hpx/threading_base/scheduler_state.hpp b/libs/threading_base/include/hpx/threading_base/scheduler_state.hpp
new file mode 100644
index 0000000000..2883c07169
--- /dev/null
+++ b/libs/threading_base/include/hpx/threading_base/scheduler_state.hpp
@@ -0,0 +1,37 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2011 Bryce Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#if !defined(HPX_THREAD_DATA_SCHEDULER_STATE)
+#define HPX_THREAD_DATA_SCHEDULER_STATE
+
+#include <hpx/config.hpp>
+
+namespace hpx {
+    enum state
+    {
+        state_invalid = -1,
+        state_initialized = 0,
+        first_valid_runtime_state = state_initialized,
+        state_pre_startup = 1,
+        state_startup = 2,
+        state_pre_main = 3,
+        state_starting = 4,
+        state_running = 5,
+        state_suspended = 6,
+        state_pre_sleep = 7,
+        state_sleeping = 8,
+        state_pre_shutdown = 9,
+        state_shutdown = 10,
+        state_stopping = 11,
+        state_terminating = 12,
+        state_stopped = 13,
+        last_valid_runtime_state = state_stopped
+    };
+}
+
+#endif    // HPX_703646B3_0567_484E_AD34_A752B8163B30
diff --git a/hpx/runtime/threads/detail/set_thread_state.hpp b/libs/threading_base/include/hpx/threading_base/set_thread_state.hpp
similarity index 64%
rename from hpx/runtime/threads/detail/set_thread_state.hpp
rename to libs/threading_base/include/hpx/threading_base/set_thread_state.hpp
index 0856fe59f3..37ae939031 100644
--- a/hpx/runtime/threads/detail/set_thread_state.hpp
+++ b/libs/threading_base/include/hpx/threading_base/set_thread_state.hpp
@@ -8,22 +8,21 @@
 #define HPX_RUNTIME_THREADS_DETAIL_SET_THREAD_STATE_JAN_13_2013_0518PM
 
 #include <hpx/config.hpp>
-#include <hpx/assertion.hpp>
 #include <hpx/config/asio.hpp>
+#include <hpx/assertion.hpp>
+#include <hpx/coroutines/coroutine.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/functional/bind_front.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/coroutines/coroutine.hpp>
-#include <hpx/runtime/threads/detail/create_thread.hpp>
-#include <hpx/runtime/threads/detail/create_work.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime_fwd.hpp>
+#include <hpx/threading_base/create_thread.hpp>
+#include <hpx/threading_base/create_work.hpp>
+#include <hpx/threading_base/register_thread.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/io_service_pool.hpp>
 
 #include <boost/asio/basic_waitable_timer.hpp>
+#include <boost/asio/io_service.hpp>
 
 #include <atomic>
 #include <chrono>
@@ -32,23 +31,21 @@
 #include <memory>
 #include <sstream>
 
-namespace hpx { namespace threads { namespace detail
-{
+namespace hpx { namespace threads { namespace detail {
     ///////////////////////////////////////////////////////////////////////////
-    inline thread_state set_thread_state(
-        thread_id_type const& id, thread_state_enum new_state,
-        thread_state_ex_enum new_state_ex, thread_priority priority,
+    inline thread_state set_thread_state(thread_id_type const& id,
+        thread_state_enum new_state, thread_state_ex_enum new_state_ex,
+        thread_priority priority,
         thread_schedule_hint schedulehint = thread_schedule_hint(),
-        bool retry_on_active = true,
-        error_code& ec = throws);
+        bool retry_on_active = true, error_code& ec = throws);
 
     ///////////////////////////////////////////////////////////////////////////
-    inline thread_result_type set_active_state(
-        thread_id_type const& thrd, thread_state_enum newstate,
-        thread_state_ex_enum newstate_ex, thread_priority priority,
-        thread_state previous_state)
+    inline thread_result_type set_active_state(thread_id_type const& thrd,
+        thread_state_enum newstate, thread_state_ex_enum newstate_ex,
+        thread_priority priority, thread_state previous_state)
     {
-        if (HPX_UNLIKELY(!thrd)) {
+        if (HPX_UNLIKELY(!thrd))
+        {
             HPX_THROW_EXCEPTION(null_thread_id,
                 "threads::detail::set_active_state",
                 "null thread id encountered");
@@ -64,16 +61,16 @@ namespace hpx { namespace threads { namespace detail
         {
             LTM_(warning)
                 << "set_active_state: thread is still active, however "
-                      "it was non-active since the original set_state "
-                      "request was issued, aborting state change, thread("
+                   "it was non-active since the original set_state "
+                   "request was issued, aborting state change, thread("
                 << thrd << "), description("
-                << get_thread_id_data(thrd)->get_description() << "), new state("
-                << get_thread_state_name(newstate) << ")";
+                << get_thread_id_data(thrd)->get_description()
+                << "), new state(" << get_thread_state_name(newstate) << ")";
             return thread_result_type(terminated, invalid_thread_id);
         }
 
         // just retry, set_state will create new thread if target is still active
-        error_code ec(lightweight);      // do not throw
+        error_code ec(lightweight);    // do not throw
         detail::set_thread_state(thrd, newstate, newstate_ex, priority,
             thread_schedule_hint(), true, ec);
 
@@ -86,43 +83,41 @@ namespace hpx { namespace threads { namespace detail
         thread_priority priority, thread_schedule_hint schedulehint,
         bool retry_on_active, error_code& ec)
     {
-        if (HPX_UNLIKELY(!thrd)) {
-            HPX_THROWS_IF(ec, null_thread_id, "threads::detail::set_thread_state",
+        if (HPX_UNLIKELY(!thrd))
+        {
+            HPX_THROWS_IF(ec, null_thread_id,
+                "threads::detail::set_thread_state",
                 "null thread id encountered");
             return thread_state(unknown, wait_unknown);
         }
 
         // set_state can't be used to force a thread into active state
-        if (new_state == threads::active) {
+        if (new_state == threads::active)
+        {
             std::ostringstream strm;
             strm << "invalid new state: " << get_thread_state_name(new_state);
-            HPX_THROWS_IF(ec, bad_parameter, "threads::detail::set_thread_state",
-                strm.str());
+            HPX_THROWS_IF(ec, bad_parameter,
+                "threads::detail::set_thread_state", strm.str());
             return thread_state(unknown, wait_unknown);
         }
 
-        // we know that the id is actually the pointer to the thread
-        if (!thrd) {
-            if (&ec != &throws)
-                ec = make_success_code();
-            return thread_state(terminated, wait_unknown);
-            // this thread has already been terminated
-        }
-
         thread_state previous_state;
-        do {
+        do
+        {
             // action depends on the current state
             previous_state = get_thread_id_data(thrd)->get_state();
             thread_state_enum previous_state_val = previous_state.state();
 
             // nothing to do here if the state doesn't change
-            if (new_state == previous_state_val) {
+            if (new_state == previous_state_val)
+            {
                 LTM_(warning)
                     << "set_thread_state: old thread state is the same as new "
                        "thread state, aborting state change, thread("
                     << thrd << "), description("
-                    << get_thread_id_data(thrd)->get_description() << "), new state("
-                    << get_thread_state_name(new_state) << ")";
+                    << get_thread_id_data(thrd)->get_description()
+                    << "), new state(" << get_thread_state_name(new_state)
+                    << ")";
 
                 if (&ec != &throws)
                     ec = make_success_code();
@@ -132,69 +127,70 @@ namespace hpx { namespace threads { namespace detail
 
             // the thread to set the state for is currently running, so we
             // schedule another thread to execute the pending set_state
-            switch (previous_state_val) {
+            switch (previous_state_val)
+            {
             case active:
+            {
+                if (retry_on_active)
                 {
-                    if (retry_on_active)
-                    {
-                        // schedule a new thread to set the state
-                        LTM_(warning)
-                            << "set_thread_state: thread is currently active, "
-                               "scheduling new thread, thread("
-                            << thrd << "), description("
-                            << get_thread_id_data(thrd)->get_description()
-                            << "), new state("
-                            << get_thread_state_name(new_state) << ")";
-
-                        thread_init_data data(
-                            util::bind(&set_active_state, thrd, new_state,
-                                new_state_ex, priority, previous_state),
-                            "set state for active thread", priority);
-
-                        create_work(
-                            get_thread_id_data(thrd)->get_scheduler_base(),
-                            data, pending, ec);
-
-                        if (&ec != &throws)
-                            ec = make_success_code();
-                    }
-                    else
-                    {
-                        LTM_(warning)
-                            << "set_thread_state: thread is currently active, "
-                               "but not scheduling new thread because "
-                               "retry_on_active = false, thread("
-                            << thrd << "), description("
-                            << get_thread_id_data(thrd)->get_description()
-                            << "), new state("
-                            << get_thread_state_name(new_state) << ")";
-                        ec = make_success_code();
-                    }
+                    // schedule a new thread to set the state
+                    LTM_(warning)
+                        << "set_thread_state: thread is currently active, "
+                           "scheduling new thread, thread("
+                        << thrd << "), description("
+                        << get_thread_id_data(thrd)->get_description()
+                        << "), new state(" << get_thread_state_name(new_state)
+                        << ")";
+
+                    thread_init_data data(
+                        util::bind(&set_active_state, thrd, new_state,
+                            new_state_ex, priority, previous_state),
+                        "set state for active thread", priority);
+
+                    create_work(get_thread_id_data(thrd)->get_scheduler_base(),
+                        data, pending, ec);
 
-                    return previous_state;     // done
+                    if (&ec != &throws)
+                        ec = make_success_code();
                 }
-                break;
-            case terminated:
+                else
                 {
-                    LTM_(warning) << "set_thread_state: thread is terminated, "
-                                     "aborting state "
-                                     "change, thread("
-                                  << thrd << "), description("
-                                  << get_thread_id_data(thrd)->get_description()
-                                  << "), new state("
-                                  << get_thread_state_name(new_state) << ")";
+                    LTM_(warning)
+                        << "set_thread_state: thread is currently active, "
+                           "but not scheduling new thread because "
+                           "retry_on_active = false, thread("
+                        << thrd << "), description("
+                        << get_thread_id_data(thrd)->get_description()
+                        << "), new state(" << get_thread_state_name(new_state)
+                        << ")";
+                    ec = make_success_code();
+                }
 
-                    if (&ec != &throws)
-                        ec = make_success_code();
+                return previous_state;    // done
+            }
+            break;
+            case terminated:
+            {
+                LTM_(warning) << "set_thread_state: thread is terminated, "
+                                 "aborting state "
+                                 "change, thread("
+                              << thrd << "), description("
+                              << get_thread_id_data(thrd)->get_description()
+                              << "), new state("
+                              << get_thread_state_name(new_state) << ")";
 
-                    // If the thread has been terminated while this set_state was
-                    // pending nothing has to be done anymore.
-                    return previous_state;
-                }
-                break;
+                if (&ec != &throws)
+                    ec = make_success_code();
+
+                // If the thread has been terminated while this set_state was
+                // pending nothing has to be done anymore.
+                return previous_state;
+            }
+            break;
             case pending:
             case pending_boost:
-                if (suspended == new_state) {
+                if (suspended == new_state)
+                {
                     // we do not allow explicit resetting of a state to suspended
                     // without the thread being executed.
                     std::ostringstream strm;
@@ -209,24 +205,24 @@ namespace hpx { namespace threads { namespace detail
                     LTM_(fatal) << strm.str();
 
                     HPX_THROWS_IF(ec, bad_parameter,
-                        "threads::detail::set_thread_state",
-                        strm.str());
+                        "threads::detail::set_thread_state", strm.str());
                     return thread_state(unknown, wait_unknown);
                 }
                 break;
             case suspended:
-                break;      // fine, just set the new state
+                break;    // fine, just set the new state
             case pending_do_not_schedule:
+                HPX_FALLTHROUGH;
             default:
-                {
-                    std::ostringstream strm;
-                    strm << "set_thread_state: previous state was "
-                         << get_thread_state_name(previous_state_val) << " ("
-                         << previous_state_val << ")";
-                    HPX_ASSERT_MSG(
-                        false, strm.str().c_str());    // should not happen
-                    break;
-                }
+            {
+                std::ostringstream strm;
+                strm << "set_thread_state: previous state was "
+                     << get_thread_state_name(previous_state_val) << " ("
+                     << previous_state_val << ")";
+                HPX_ASSERT_MSG(
+                    false, strm.str().c_str());    // should not happen
+                break;
+            }
             }
 
             // If the previous state was pending we are supposed to remove the
@@ -236,29 +232,33 @@ namespace hpx { namespace threads { namespace detail
             // (if it's not pending anymore).
 
             LTM_(info) << "set_thread_state: thread(" << thrd
-                       << "), "
-                          "description("
+                       << "), description("
                        << get_thread_id_data(thrd)->get_description()
-                       << "), "
-                          "new state("
-                       << get_thread_state_name(new_state)
-                       << "), "
-                          "old state("
+                       << "), new state(" << get_thread_state_name(new_state)
+                       << "), old state("
                        << get_thread_state_name(previous_state_val) << ")";
 
             // So all what we do here is to set the new state.
             if (get_thread_id_data(thrd)->restore_state(
                     new_state, new_state_ex, previous_state))
+            {
                 break;
+            }
 
             // state has changed since we fetched it from the thread, retry
-            LTM_(error)
-                << "set_thread_state: state has been changed since it was fetched, "
-                   "retrying, thread(" << thrd << "), "
-                   "description(" << get_thread_id_data(thrd)->get_description() << "), "
-                   "new state(" << get_thread_state_name(new_state) << "), "
-                   "old state(" << get_thread_state_name(previous_state_val)
-                << ")";
+            LTM_(error) << "set_thread_state: state has been changed since it "
+                           "was fetched, "
+                           "retrying, thread("
+                        << thrd
+                        << "), "
+                           "description("
+                        << get_thread_id_data(thrd)->get_description()
+                        << "), "
+                           "new state("
+                        << get_thread_state_name(new_state)
+                        << "), "
+                           "old state("
+                        << get_thread_state_name(previous_state_val) << ")";
         } while (true);
 
         thread_state_enum previous_state_val = previous_state.state();
@@ -269,12 +269,13 @@ namespace hpx { namespace threads { namespace detail
             // REVIEW: Passing a specific target thread may interfere with the
             // round robin queuing.
 
-            auto thrd_data = get_thread_id_data(thrd);
-            thrd_data->get_scheduler_base()->schedule_thread(thrd_data,
-                schedulehint, false, thrd_data->get_priority());
+            auto* thrd_data = get_thread_id_data(thrd);
+            auto* scheduler = thrd_data->get_scheduler_base();
+            scheduler->schedule_thread(
+                thrd_data, schedulehint, false, thrd_data->get_priority());
             // NOTE: Don't care if the hint is a NUMA hint, just want to wake up
             // a thread.
-            thrd_data->get_scheduler_base()->do_some_work(schedulehint.hint);
+            scheduler->do_some_work(schedulehint.hint);
         }
 
         if (&ec != &throws)
@@ -292,13 +293,15 @@ namespace hpx { namespace threads { namespace detail
         std::shared_ptr<std::atomic<bool>> const& triggered,
         bool retry_on_active, thread_state_ex_enum my_statex)
     {
-        if (HPX_UNLIKELY(!thrd)) {
+        if (HPX_UNLIKELY(!thrd))
+        {
             HPX_THROW_EXCEPTION(null_thread_id,
                 "threads::detail::wake_timer_thread",
                 "null thread id encountered (id)");
             return thread_result_type(terminated, invalid_thread_id);
         }
-        if (HPX_UNLIKELY(!timer_id)) {
+        if (HPX_UNLIKELY(!timer_id))
+        {
             HPX_THROW_EXCEPTION(null_thread_id,
                 "threads::detail::wake_timer_thread",
                 "null thread id encountered (timer_id)");
@@ -322,14 +325,14 @@ namespace hpx { namespace threads { namespace detail
     /// behalf of one of the threads#detail#set_thread_state functions).
     template <typename SchedulingPolicy>
     thread_result_type at_timer(SchedulingPolicy& scheduler,
-        util::steady_clock::time_point& abs_time,
-        thread_id_type const& thrd, thread_state_enum newstate,
-        thread_state_ex_enum newstate_ex, thread_priority priority,
-        std::atomic<bool>* started, bool retry_on_active)
+        util::steady_clock::time_point& abs_time, thread_id_type const& thrd,
+        thread_state_enum newstate, thread_state_ex_enum newstate_ex,
+        thread_priority priority, std::atomic<bool>* started,
+        bool retry_on_active)
     {
-        if (HPX_UNLIKELY(!thrd)) {
-            HPX_THROW_EXCEPTION(null_thread_id,
-                "threads::detail::at_timer",
+        if (HPX_UNLIKELY(!thrd))
+        {
+            HPX_THROW_EXCEPTION(null_thread_id, "threads::detail::at_timer",
                 "null thread id encountered");
             return thread_result_type(terminated, invalid_thread_id);
         }
@@ -339,24 +342,24 @@ namespace hpx { namespace threads { namespace detail
         // allowing the deadline_timer to go out of scope gracefully
         thread_id_type self_id = get_self_id();
 
-        std::shared_ptr<std::atomic<bool> > triggered(
-            std::make_shared<std::atomic<bool> >(false));
+        std::shared_ptr<std::atomic<bool>> triggered(
+            std::make_shared<std::atomic<bool>>(false));
 
         thread_init_data data(
-            util::bind_front(&wake_timer_thread,
-                thrd, newstate, newstate_ex, priority,
-                self_id, triggered, retry_on_active),
+            util::bind_front(&wake_timer_thread, thrd, newstate, newstate_ex,
+                priority, self_id, triggered, retry_on_active),
             "wake_timer", priority);
 
         thread_id_type wake_id = invalid_thread_id;
         create_thread(&scheduler, data, wake_id, suspended);
 
         // create timer firing in correspondence with given time
-        typedef boost::asio::basic_waitable_timer<
-            util::steady_clock> deadline_timer;
+        using deadline_timer =
+            boost::asio::basic_waitable_timer<util::steady_clock>;
 
-        deadline_timer t (
-            get_thread_pool("timer-pool")->get_io_service(), abs_time);
+        boost::asio::io_service* s = get_default_timer_service();
+        HPX_ASSERT(s);
+        deadline_timer t(*s, abs_time);
 
         // let the timer invoke the set_state on the new (suspended) thread
         t.async_wait([wake_id, priority, retry_on_active](
@@ -384,7 +387,7 @@ namespace hpx { namespace threads { namespace detail
 
         HPX_ASSERT(statex == wait_abort || statex == wait_timeout);
 
-        if (wait_timeout != statex) //-V601
+        if (wait_timeout != statex)    //-V601
         {
             triggered->store(true);
             // wake_timer_thread has not been executed yet, cancel timer
@@ -407,7 +410,8 @@ namespace hpx { namespace threads { namespace detail
         thread_priority priority, thread_schedule_hint schedulehint,
         std::atomic<bool>* started, bool retry_on_active, error_code& ec)
     {
-        if (HPX_UNLIKELY(!thrd)) {
+        if (HPX_UNLIKELY(!thrd))
+        {
             HPX_THROWS_IF(ec, null_thread_id,
                 "threads::detail::set_thread_state",
                 "null thread id encountered");
@@ -417,13 +421,13 @@ namespace hpx { namespace threads { namespace detail
         // this creates a new thread which creates the timer and handles the
         // requested actions
         thread_init_data data(
-            util::bind(&at_timer<SchedulingPolicy>,
-                std::ref(scheduler), abs_time.value(), thrd, newstate, newstate_ex,
-                priority, started, retry_on_active),
-                "at_timer (expire at)", priority, schedulehint);
+            util::bind(&at_timer<SchedulingPolicy>, std::ref(scheduler),
+                abs_time.value(), thrd, newstate, newstate_ex, priority,
+                started, retry_on_active),
+            "at_timer (expire at)", priority, schedulehint);
 
         thread_id_type newid = invalid_thread_id;
-        create_thread(&scheduler, data, newid, pending, true, ec); //-V601
+        create_thread(&scheduler, data, newid, pending, true, ec);    //-V601
         return newid;
     }
 
@@ -460,6 +464,6 @@ namespace hpx { namespace threads { namespace detail
             pending, wait_timeout, thread_priority_normal,
             thread_schedule_hint(), started, retry_on_active, ec);
     }
-}}}
+}}}    // namespace hpx::threads::detail
 
 #endif
diff --git a/hpx/runtime/threads/thread_data.hpp b/libs/threading_base/include/hpx/threading_base/thread_data.hpp
similarity index 80%
rename from hpx/runtime/threads/thread_data.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_data.hpp
index 1759a296c7..f9e858f102 100644
--- a/hpx/runtime/threads/thread_data.hpp
+++ b/libs/threading_base/include/hpx/threading_base/thread_data.hpp
@@ -14,37 +14,39 @@
 #include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/concurrency/spinlock_pool.hpp>
 #include <hpx/coroutines/coroutine.hpp>
-#include <hpx/coroutines/thread_id_type.hpp>
 #include <hpx/coroutines/detail/combined_tagged_state.hpp>
+#include <hpx/coroutines/thread_id_type.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/function.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/runtime/get_locality_id.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
-#include <hpx/logging.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
+#include <hpx/naming_base.hpp>
 #include <hpx/thread_support/atomic_count.hpp>
-#include <hpx/util/backtrace.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/util/backtrace.hpp>    // TODO: Move to a separate module.
 #if defined(HPX_HAVE_APEX)
-#include <hpx/util/external_timer.hpp>
+#include <hpx/threading_base/external_timer.hpp>
 #endif
 
 #include <atomic>
 #include <cstddef>
 #include <cstdint>
 #include <forward_list>
+#include <memory>
 #include <stack>
 #include <string>
 #include <utility>
-#include <memory>
 
 #include <hpx/config/warnings_prefix.hpp>
 
 ////////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads {
+    namespace detail {
+        using get_locality_id_type = std::uint32_t(hpx::error_code&);
+        HPX_EXPORT void set_get_locality_id(get_locality_id_type* f);
+        HPX_EXPORT std::uint32_t get_locality_id(hpx::error_code&);
+    }    // namespace detail
 
     ////////////////////////////////////////////////////////////////////////////
     /// A \a thread is the representation of a ParalleX thread. It's a first
@@ -96,7 +98,7 @@ namespace hpx { namespace threads {
         ///
         /// \param newstate [in] The new state to be set for the thread.
         ///
-        /// \note           This function will be seldomly used directly. Most of
+        /// \note           This function will be seldom used directly. Most of
         ///                 the time the state of a thread will have to be
         ///                 changed using the threadmanager. Moreover,
         ///                 changing the thread state using this function does
@@ -165,7 +167,7 @@ namespace hpx { namespace threads {
         /// \param oldstate [in] The old state of the thread which still has to
         ///                 be the current state.
         ///
-        /// \note           This function will be seldomly used directly. Most of
+        /// \note           This function will be seldom used directly. Most of
         ///                 the time the state of a thread will have to be
         ///                 changed using the threadmanager. Moreover,
         ///                 changing the thread state using this function does
@@ -244,9 +246,10 @@ namespace hpx { namespace threads {
     public:
         /// Return the id of the component this thread is running in
 #if !defined(HPX_GCC_VERSION) || (HPX_GCC_VERSION >= 70300)
-        HPX_CXX14_CONSTEXPR
+        constexpr
 #endif
-        naming::address_type get_component_id() const noexcept
+            naming::address_type
+            get_component_id() const noexcept
         {
             return 0;
         }
@@ -301,27 +304,30 @@ namespace hpx { namespace threads {
 #ifndef HPX_HAVE_THREAD_PARENT_REFERENCE
         /// Return the locality of the parent thread
 #if !defined(HPX_GCC_VERSION) || (HPX_GCC_VERSION >= 70300)
-        HPX_CONSTEXPR
+        constexpr
 #endif
-        std::uint32_t get_parent_locality_id() const noexcept
+            std::uint32_t
+            get_parent_locality_id() const noexcept
         {
             return naming::invalid_locality_id;
         }
 
         /// Return the thread id of the parent thread
 #if !defined(HPX_GCC_VERSION) || (HPX_GCC_VERSION >= 70300)
-        HPX_CONSTEXPR
+        constexpr
 #endif
-        thread_id_type get_parent_thread_id() const noexcept
+            thread_id_type
+            get_parent_thread_id() const noexcept
         {
             return threads::invalid_thread_id;
         }
 
         /// Return the phase of the parent thread
 #if !defined(HPX_GCC_VERSION) || (HPX_GCC_VERSION >= 70300)
-        HPX_CONSTEXPR
+        constexpr
 #endif
-        std::size_t get_parent_thread_phase() const noexcept
+            std::size_t
+            get_parent_thread_phase() const noexcept
         {
             return 0;
         }
@@ -360,9 +366,10 @@ namespace hpx { namespace threads {
 
 #ifdef HPX_HAVE_THREAD_FULLBACKTRACE_ON_SUSPENSION
 #if !defined(HPX_GCC_VERSION) || (HPX_GCC_VERSION >= 70300)
-        HPX_CONSTEXPR
+        constexpr
 #endif
-        char const* get_backtrace() const noexcept
+            char const*
+            get_backtrace() const noexcept
         {
             return nullptr;
         }
@@ -372,9 +379,10 @@ namespace hpx { namespace threads {
         }
 #else
 #if !defined(HPX_GCC_VERSION) || (HPX_GCC_VERSION >= 70300)
-        HPX_CONSTEXPR
+        constexpr
 #endif
-        util::backtrace const* get_backtrace() const noexcept
+            util::backtrace const*
+            get_backtrace() const noexcept
         {
             return nullptr;
         }
@@ -435,9 +443,10 @@ namespace hpx { namespace threads {
 #endif
 
 #if !defined(HPX_GCC_VERSION) || (HPX_GCC_VERSION >= 70300)
-        HPX_CXX14_CONSTEXPR
+        constexpr
 #endif
-        thread_priority get_priority() const noexcept
+            thread_priority
+            get_priority() const noexcept
         {
             return priority_;
         }
@@ -523,7 +532,7 @@ namespace hpx { namespace threads {
             return 0;
         }
 #else
-        virtual std::size_t get_thread_phase() const noexcept= 0;
+        virtual std::size_t get_thread_phase() const noexcept = 0;
 #endif
         virtual std::size_t get_thread_data() const = 0;
         virtual std::size_t set_thread_data(std::size_t data) = 0;
@@ -532,8 +541,8 @@ namespace hpx { namespace threads {
             thread_init_data& init_data, thread_state_enum newstate) = 0;
 
 #if defined(HPX_HAVE_APEX)
-        std::shared_ptr<util::external_timer::task_wrapper>
-            get_timer_data() const noexcept
+        std::shared_ptr<util::external_timer::task_wrapper> get_timer_data()
+            const noexcept
         {
             return timer_data_;
         }
@@ -606,17 +615,81 @@ namespace hpx { namespace threads {
         bool is_stackless_;
     };
 
-    HPX_CXX14_CONSTEXPR inline thread_data* get_thread_id_data(
-        thread_id_type const& tid)
+    constexpr inline thread_data* get_thread_id_data(thread_id_type const& tid)
     {
         return static_cast<thread_data*>(tid.get());
     }
+
+    ///////////////////////////////////////////////////////////////////////
+    /// The function \a get_self returns a reference to the (OS thread
+    /// specific) self reference to the current HPX thread.
+    HPX_API_EXPORT thread_self& get_self();
+
+    /// The function \a get_self_ptr returns a pointer to the (OS thread
+    /// specific) self reference to the current HPX thread.
+    HPX_API_EXPORT thread_self* get_self_ptr();
+
+    /// The function \a get_ctx_ptr returns a pointer to the internal data
+    /// associated with each coroutine.
+    HPX_API_EXPORT thread_self_impl_type* get_ctx_ptr();
+
+    /// The function \a get_self_ptr_checked returns a pointer to the (OS
+    /// thread specific) self reference to the current HPX thread.
+    HPX_API_EXPORT thread_self* get_self_ptr_checked(error_code& ec = throws);
+
+    /// The function \a get_self_id returns the HPX thread id of the current
+    /// thread (or zero if the current thread is not a HPX thread).
+    HPX_API_EXPORT thread_id_type get_self_id();
+
+    /// The function \a get_self_id_data returns the data of the HPX thread id
+    /// associated with the current thread (or nullptr if the current thread is
+    /// not a HPX thread).
+    HPX_API_EXPORT thread_data* get_self_id_data();
+
+    /// The function \a get_parent_id returns the HPX thread id of the
+    /// current thread's parent (or zero if the current thread is not a
+    /// HPX thread).
+    ///
+    /// \note This function will return a meaningful value only if the
+    ///       code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE
+    ///       being defined.
+    HPX_API_EXPORT thread_id_type get_parent_id();
+
+    /// The function \a get_parent_phase returns the HPX phase of the
+    /// current thread's parent (or zero if the current thread is not a
+    /// HPX thread).
+    ///
+    /// \note This function will return a meaningful value only if the
+    ///       code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE
+    ///       being defined.
+    HPX_API_EXPORT std::size_t get_parent_phase();
+
+    /// The function \a get_self_stacksize returns the stack size of the
+    /// current thread (or zero if the current thread is not a HPX thread).
+    HPX_API_EXPORT std::size_t get_self_stacksize();
+
+    /// The function \a get_parent_locality_id returns the id of the locality of
+    /// the current thread's parent (or zero if the current thread is not a
+    /// HPX thread).
+    ///
+    /// \note This function will return a meaningful value only if the
+    ///       code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE
+    ///       being defined.
+    HPX_API_EXPORT std::uint32_t get_parent_locality_id();
+
+    /// The function \a get_self_component_id returns the lva of the
+    /// component the current thread is acting on
+    ///
+    /// \note This function will return a meaningful value only if the
+    ///       code was compiled with HPX_HAVE_THREAD_TARGET_ADDRESS
+    ///       being defined.
+    HPX_API_EXPORT std::uint64_t get_self_component_id();
 }}    // namespace hpx::threads
 
 #include <hpx/config/warnings_suffix.hpp>
 
-#include <hpx/runtime/threads/thread_data_stackful.hpp>
-#include <hpx/runtime/threads/thread_data_stackless.hpp>
+#include <hpx/threading_base/thread_data_stackful.hpp>
+#include <hpx/threading_base/thread_data_stackless.hpp>
 
 namespace hpx { namespace threads {
 
@@ -629,5 +702,5 @@ namespace hpx { namespace threads {
         }
         return static_cast<thread_data_stackful*>(this)->call(agent_storage);
     }
-}}
+}}     // namespace hpx::threads
 #endif /*HPX_RUNTIME_THREADS_THREAD_DATA_HPP*/
diff --git a/hpx/runtime/threads/thread_data_stackful.hpp b/libs/threading_base/include/hpx/threading_base/thread_data_stackful.hpp
similarity index 96%
rename from hpx/runtime/threads/thread_data_stackful.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_data_stackful.hpp
index 337a68f01f..b21d40e9cc 100644
--- a/hpx/runtime/threads/thread_data_stackful.hpp
+++ b/libs/threading_base/include/hpx/threading_base/thread_data_stackful.hpp
@@ -15,9 +15,9 @@
 #include <hpx/coroutines/thread_id_type.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/function.hpp>
-#include <hpx/runtime/threads/execution_agent.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading_base/execution_agent.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 
 #include <cstddef>
 #include <cstdint>
diff --git a/hpx/runtime/threads/thread_data_stackless.hpp b/libs/threading_base/include/hpx/threading_base/thread_data_stackless.hpp
similarity index 96%
rename from hpx/runtime/threads/thread_data_stackless.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_data_stackless.hpp
index 8b56699071..9705fbc0cb 100644
--- a/hpx/runtime/threads/thread_data_stackless.hpp
+++ b/libs/threading_base/include/hpx/threading_base/thread_data_stackless.hpp
@@ -16,9 +16,8 @@
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/function.hpp>
-#include <hpx/runtime/threads/execution_agent.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
 
 #include <cstddef>
 #include <utility>
diff --git a/hpx/util/thread_description.hpp b/libs/threading_base/include/hpx/threading_base/thread_description.hpp
similarity index 66%
rename from hpx/util/thread_description.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_description.hpp
index 8fad8359a3..80318fbff5 100644
--- a/hpx/util/thread_description.hpp
+++ b/libs/threading_base/include/hpx/threading_base/thread_description.hpp
@@ -9,11 +9,11 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/runtime/actions/basic_action_fwd.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
+#include <hpx/functional/traits/get_action_name.hpp>
 #include <hpx/functional/traits/get_function_address.hpp>
 #include <hpx/functional/traits/get_function_annotation.hpp>
 #include <hpx/functional/traits/is_action.hpp>
+#include <hpx/threading_base/threading_base_fwd.hpp>
 #if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
 #include <hpx/concurrency/itt_notify.hpp>
 #endif
@@ -24,8 +24,7 @@
 #include <type_traits>
 #include <utility>
 
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
 #if defined(HPX_HAVE_THREAD_DESCRIPTION)
     ///////////////////////////////////////////////////////////////////////////
     struct thread_description
@@ -40,8 +39,8 @@ namespace hpx { namespace util
     private:
         union data
         {
-            char const* desc_; //-V117
-            std::size_t addr_; //-V117
+            char const* desc_;    //-V117
+            std::size_t addr_;    //-V117
         };
 
         data_type type_;
@@ -66,8 +65,8 @@ namespace hpx { namespace util
         }
 
 #if HPX_HAVE_ITTNOTIFY != 0 && !defined(HPX_HAVE_APEX)
-        thread_description(char const* desc,
-                util::itt::string_handle const& sh) noexcept
+        thread_description(
+            char const* desc, util::itt::string_handle const& sh) noexcept
           : type_(data_type_description)
         {
             data_.desc_ = desc ? desc : "<unknown>";
@@ -76,13 +75,12 @@ namespace hpx { namespace util
 #endif
 
         /* The priority of description is name, altname, address */
-        template <typename F, typename =
-            typename std::enable_if<
+        template <typename F,
+            typename = typename std::enable_if<
                 !std::is_same<F, thread_description>::value &&
-                !traits::is_action<F>::value
-            >::type>
-        explicit thread_description(F const& f,
-                char const* altname = nullptr) noexcept
+                !traits::is_action<F>::value>::type>
+        explicit thread_description(
+            F const& f, char const* altname = nullptr) noexcept
           : type_(data_type_description)
         {
             char const* name = traits::get_function_annotation<F>::call(f);
@@ -117,12 +115,11 @@ namespace hpx { namespace util
 #endif
         }
 
-        template <typename Action, typename =
-            typename std::enable_if<
-                traits::is_action<Action>::value
-            >::type>
-        explicit thread_description(Action,
-                char const* altname = nullptr) noexcept
+        template <typename Action,
+            typename =
+                typename std::enable_if<traits::is_action<Action>::value>::type>
+        explicit thread_description(
+            Action, char const* altname = nullptr) noexcept
           : type_(data_type_description)
         {
             data_.desc_ = hpx::actions::detail::get_action_name<Action>();
@@ -147,7 +144,7 @@ namespace hpx { namespace util
         {
             HPX_ASSERT(type_ == data_type_description);
             return desc_itt_ ? desc_itt_ :
-                util::itt::string_handle(get_description());
+                               util::itt::string_handle(get_description());
         }
 
         util::itt::task get_task_itt(util::itt::domain const& domain) const
@@ -206,30 +203,24 @@ namespace hpx { namespace util
         HPX_EXPORT void init_from_alternative_name(char const* altname);
 
     public:
-        thread_description() noexcept
-        {
-        }
+        thread_description() noexcept {}
 
-        thread_description(char const* /*desc*/) noexcept
-        {
-        }
+        thread_description(char const* /*desc*/) noexcept {}
 
-        template <typename F, typename =
-            typename std::enable_if<
+        template <typename F,
+            typename = typename std::enable_if<
                 !std::is_same<F, thread_description>::value &&
-                !traits::is_action<F>::value
-            >::type>
-        explicit thread_description(F const& /*f*/,
-            char const* /*altname*/ = nullptr) noexcept
+                !traits::is_action<F>::value>::type>
+        explicit thread_description(
+            F const& /*f*/, char const* /*altname*/ = nullptr) noexcept
         {
         }
 
-        template <typename Action, typename =
-            typename std::enable_if<
-                traits::is_action<Action>::value
-            >::type>
-        explicit thread_description(Action,
-            char const* /*altname*/ = nullptr) noexcept
+        template <typename Action,
+            typename =
+                typename std::enable_if<traits::is_action<Action>::value>::type>
+        explicit thread_description(
+            Action, char const* /*altname*/ = nullptr) noexcept
         {
         }
 
@@ -287,9 +278,45 @@ namespace hpx { namespace util
     };
 #endif
 
-    HPX_EXPORT std::ostream& operator<<(std::ostream&, thread_description const&);
+    HPX_EXPORT std::ostream& operator<<(
+        std::ostream&, thread_description const&);
     HPX_EXPORT std::string as_string(thread_description const& desc);
-}}
+}}    // namespace hpx::util
 
-#endif
+namespace hpx { namespace threads {
+    ///////////////////////////////////////////////////////////////////////////
+    /// The function get_thread_description is part of the thread related API
+    /// allows to query the description of one of the threads known to the
+    /// thread-manager.
+    ///
+    /// \param id         [in] The thread id of the thread being queried.
+    /// \param ec         [in,out] this represents the error status on exit,
+    ///                   if this is pre-initialized to \a hpx#throws
+    ///                   the function will throw on error instead.
+    ///
+    /// \returns          This function returns the description of the
+    ///                   thread referenced by the \a id parameter. If the
+    ///                   thread is not known to the thread-manager the return
+    ///                   value will be the string "<unknown>".
+    ///
+    /// \note             As long as \a ec is not pre-initialized to
+    ///                   \a hpx#throws this function doesn't
+    ///                   throw but returns the result code using the
+    ///                   parameter \a ec. Otherwise it throws an instance
+    ///                   of hpx#exception.
+    HPX_API_EXPORT util::thread_description get_thread_description(
+        thread_id_type const& id, error_code& ec = throws);
+    HPX_API_EXPORT util::thread_description set_thread_description(
+        thread_id_type const& id,
+        util::thread_description const& desc = util::thread_description(),
+        error_code& ec = throws);
+
+    HPX_API_EXPORT util::thread_description get_thread_lco_description(
+        thread_id_type const& id, error_code& ec = throws);
+    HPX_API_EXPORT util::thread_description set_thread_lco_description(
+        thread_id_type const& id,
+        util::thread_description const& desc = util::thread_description(),
+        error_code& ec = throws);
+}}    // namespace hpx::threads
 
+#endif
diff --git a/hpx/runtime/threads/thread_helpers.hpp b/libs/threading_base/include/hpx/threading_base/thread_helpers.hpp
similarity index 86%
rename from hpx/runtime/threads/thread_helpers.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_helpers.hpp
index da23482ece..3972824438 100644
--- a/hpx/runtime/threads/thread_helpers.hpp
+++ b/libs/threading_base/include/hpx/threading_base/thread_helpers.hpp
@@ -15,15 +15,11 @@
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/unique_function.hpp>
-#include <hpx/runtime/thread_pool_helpers.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/register_thread.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/runtime/threads_fwd.hpp>
+#include <hpx/threading_base/register_thread.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
-#include <hpx/util_fwd.hpp>
 
 #include <atomic>
 #include <chrono>
@@ -35,10 +31,6 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads {
-    /// \cond NOINTERNAL
-    class thread_init_data;
-    /// \endcond
-
     ///////////////////////////////////////////////////////////////////////////
     /// \brief  Set the thread state of the \a thread referenced by the
     ///         thread_id \a id.
@@ -163,40 +155,6 @@ namespace hpx { namespace threads {
             priority, retry_on_active, ec);
     }
 
-    ///////////////////////////////////////////////////////////////////////////
-    /// The function get_thread_description is part of the thread related API
-    /// allows to query the description of one of the threads known to the
-    /// thread-manager.
-    ///
-    /// \param id         [in] The thread id of the thread being queried.
-    /// \param ec         [in,out] this represents the error status on exit,
-    ///                   if this is pre-initialized to \a hpx#throws
-    ///                   the function will throw on error instead.
-    ///
-    /// \returns          This function returns the description of the
-    ///                   thread referenced by the \a id parameter. If the
-    ///                   thread is not known to the thread-manager the return
-    ///                   value will be the string "<unknown>".
-    ///
-    /// \note             As long as \a ec is not pre-initialized to
-    ///                   \a hpx#throws this function doesn't
-    ///                   throw but returns the result code using the
-    ///                   parameter \a ec. Otherwise it throws an instance
-    ///                   of hpx#exception.
-    HPX_API_EXPORT util::thread_description get_thread_description(
-        thread_id_type const& id, error_code& ec = throws);
-    HPX_API_EXPORT util::thread_description set_thread_description(
-        thread_id_type const& id,
-        util::thread_description const& desc = util::thread_description(),
-        error_code& ec = throws);
-
-    HPX_API_EXPORT util::thread_description get_thread_lco_description(
-        thread_id_type const& id, error_code& ec = throws);
-    HPX_API_EXPORT util::thread_description set_thread_lco_description(
-        thread_id_type const& id,
-        util::thread_description const& desc = util::thread_description(),
-        error_code& ec = throws);
-
     ///////////////////////////////////////////////////////////////////////////
     /// The function get_thread_backtrace is part of the thread related API
     /// allows to query the currently stored thread back trace (which is
@@ -439,22 +397,6 @@ namespace hpx { namespace threads {
     HPX_API_EXPORT void reset_continuation_recursion_count();
     /// \endcond
 
-    /// Returns a reference to the executor which was used to create
-    /// the given thread.
-    ///
-    /// \throws If <code>&ec != &throws</code>, never throws, but will set \a ec
-    ///         to an appropriate value when an error occurs. Otherwise, this
-    ///         function will throw an \a hpx#exception with an error code of
-    ///         \a hpx#yield_aborted if it is signaled with \a wait_aborted.
-    ///         If called outside of a HPX-thread, this function will throw
-    ///         an \a hpx#exception with an error code of \a hpx::null_thread_id.
-    ///         If this function is called while the thread-manager is not
-    ///         running, it will throw an \a hpx#exception with an error code of
-    ///         \a hpx#invalid_status.
-    ///
-    HPX_API_EXPORT threads::executors::current_executor get_executor(
-        thread_id_type const& id, error_code& ec = throws);
-
     /// Returns a pointer to the pool that was used to run the current thread
     ///
     /// \throws If <code>&ec != &throws</code>, never throws, but will set \a ec
@@ -468,31 +410,6 @@ namespace hpx { namespace threads {
     ///         \a hpx#invalid_status.
     HPX_EXPORT threads::thread_pool_base* get_pool(
         thread_id_type const& id, error_code& ec = throws);
-
-    /// \cond NOINTERNAL
-    /// Reset internal (round robin) thread distribution scheme
-    HPX_API_EXPORT void reset_thread_distribution();
-
-    /// Set the new scheduler mode
-    HPX_API_EXPORT void set_scheduler_mode(
-        threads::policies::scheduler_mode new_mode);
-
-    /// Add the given flags to the scheduler mode
-    HPX_API_EXPORT void add_scheduler_mode(
-        threads::policies::scheduler_mode to_add);
-
-    /// Add/remove the given flags to the scheduler mode
-    HPX_API_EXPORT void add_remove_scheduler_mode(
-        threads::policies::scheduler_mode to_add,
-        threads::policies::scheduler_mode to_remove);
-
-    /// Remove the given flags from the scheduler mode
-    HPX_API_EXPORT void remove_scheduler_mode(
-        threads::policies::scheduler_mode to_remove);
-
-    /// Get the global topology instance
-    HPX_API_EXPORT topology const& get_topology();
-    /// \endcond
 }}    // namespace hpx::threads
 
 namespace hpx { namespace this_thread {
@@ -674,22 +591,6 @@ namespace hpx { namespace this_thread {
             threads::invalid_thread_id, description, ec);
     }
 
-    /// Returns a reference to the executor which was used to create the current
-    /// thread.
-    ///
-    /// \throws If <code>&ec != &throws</code>, never throws, but will set \a ec
-    ///         to an appropriate value when an error occurs. Otherwise, this
-    ///         function will throw an \a hpx#exception with an error code of
-    ///         \a hpx#yield_aborted if it is signaled with \a wait_aborted.
-    ///         If called outside of a HPX-thread, this function will throw
-    ///         an \a hpx#exception with an error code of \a hpx::null_thread_id.
-    ///         If this function is called while the thread-manager is not
-    ///         running, it will throw an \a hpx#exception with an error code of
-    ///         \a hpx#invalid_status.
-    ///
-    HPX_EXPORT threads::executors::current_executor get_executor(
-        error_code& ec = throws);
-
     /// Returns a pointer to the pool that was used to run the current thread
     ///
     /// \throws If <code>&ec != &throws</code>, never throws, but will set \a ec
diff --git a/libs/threading_base/include/hpx/threading_base/thread_init_data.hpp b/libs/threading_base/include/hpx/threading_base/thread_init_data.hpp
new file mode 100644
index 0000000000..9586d3b1f9
--- /dev/null
+++ b/libs/threading_base/include/hpx/threading_base/thread_init_data.hpp
@@ -0,0 +1,154 @@
+//  Copyright (c) 2007-2013 Hartmut Kaiser
+//  Copyright (c) 2008-2009 Chirag Dekate, Anshul Tandon
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_RUNTIME_THREADS_THREAD_INIT_DATA_HPP
+#define HPX_RUNTIME_THREADS_THREAD_INIT_DATA_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/coroutines/thread_enums.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/threading_base/threading_base_fwd.hpp>
+#if defined(HPX_HAVE_APEX)
+#include <hpx/threading_base/external_timer.hpp>
+#endif
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <utility>
+
+namespace hpx { namespace threads {
+    HPX_API_EXPORT std::ptrdiff_t get_default_stack_size();
+    HPX_API_EXPORT std::ptrdiff_t get_stack_size(thread_stacksize);
+
+    ///////////////////////////////////////////////////////////////////////////
+    class thread_init_data
+    {
+    public:
+        thread_init_data()
+          : func()
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+          , description()
+#endif
+#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
+          , parent_locality_id(0)
+          , parent_id(nullptr)
+          , parent_phase(0)
+#endif
+#ifdef HPX_HAVE_APEX
+          , timer_data(nullptr)
+#endif
+          , priority(thread_priority_normal)
+          , schedulehint()
+          , stacksize(HPX_SMALL_STACK_SIZE)
+          , scheduler_base(nullptr)
+        {
+        }
+
+        thread_init_data& operator=(thread_init_data&& rhs)
+        {
+            func = std::move(rhs.func);
+            priority = rhs.priority;
+            schedulehint = rhs.schedulehint;
+            stacksize = rhs.stacksize;
+            scheduler_base = rhs.scheduler_base;
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+            description = rhs.description;
+#endif
+#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
+            parent_locality_id = rhs.parent_locality_id;
+            parent_id = rhs.parent_id;
+            parent_phase = rhs.parent_phase;
+#endif
+#ifdef HPX_HAVE_APEX
+            // HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION
+            // and HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on
+            timer_data = rhs.timer_data;
+#endif
+            return *this;
+        }
+
+        thread_init_data(thread_init_data&& rhs)
+          : func(std::move(rhs.func))
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+          , description(rhs.description)
+#endif
+#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
+          , parent_locality_id(rhs.parent_locality_id)
+          , parent_id(rhs.parent_id)
+          , parent_phase(rhs.parent_phase)
+#endif
+#ifdef HPX_HAVE_APEX
+          // HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION and
+          // HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on
+          , timer_data(util::external_timer::new_task(
+                description, parent_locality_id, parent_id))
+#endif
+          , priority(rhs.priority)
+          , schedulehint(rhs.schedulehint)
+          , stacksize(rhs.stacksize)
+          , scheduler_base(rhs.scheduler_base)
+        {
+            if (stacksize == 0)
+                stacksize = HPX_SMALL_STACK_SIZE;
+        }
+
+        template <typename F>
+        thread_init_data(F&& f, util::thread_description const& desc,
+            thread_priority priority_ = thread_priority_normal,
+            thread_schedule_hint os_thread = thread_schedule_hint(),
+            std::ptrdiff_t stacksize_ = HPX_SMALL_STACK_SIZE,
+            policies::scheduler_base* scheduler_base_ = nullptr)
+          : func(std::forward<F>(f))
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+          , description(desc)
+#endif
+#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
+          , parent_locality_id(0)
+          , parent_id(nullptr)
+          , parent_phase(0)
+#endif
+#ifdef HPX_HAVE_APEX
+          // HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION and
+          // HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on
+          , timer_data(util::external_timer::new_task(
+                description, parent_locality_id, parent_id))
+#endif
+          , priority(priority_)
+          , schedulehint(os_thread)
+          , stacksize(stacksize_)
+          , scheduler_base(scheduler_base_)
+        {
+            if (stacksize == 0)
+                stacksize = HPX_SMALL_STACK_SIZE;
+        }
+
+        threads::thread_function_type func;
+
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+        util::thread_description description;
+#endif
+#if defined(HPX_HAVE_THREAD_PARENT_REFERENCE)
+        std::uint32_t parent_locality_id;
+        threads::thread_id_type parent_id;
+        std::size_t parent_phase;
+#endif
+#ifdef HPX_HAVE_APEX
+        // HPX_HAVE_APEX forces the HPX_HAVE_THREAD_DESCRIPTION and
+        // HPX_HAVE_THREAD_PARENT_REFERENCE settings to be on
+        std::shared_ptr<util::external_timer::task_wrapper> timer_data;
+#endif
+
+        thread_priority priority;
+        thread_schedule_hint schedulehint;
+        std::ptrdiff_t stacksize;
+
+        policies::scheduler_base* scheduler_base;
+    };
+}}    // namespace hpx::threads
+
+#endif /*HPX_RUNTIME_THREADS_THREAD_INIT_DATA_HPP*/
diff --git a/libs/threading_base/include/hpx/threading_base/thread_num_tss.hpp b/libs/threading_base/include/hpx/threading_base/thread_num_tss.hpp
new file mode 100644
index 0000000000..784252e299
--- /dev/null
+++ b/libs/threading_base/include/hpx/threading_base/thread_num_tss.hpp
@@ -0,0 +1,96 @@
+//  Copyright (c) 2007-2015 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#if !defined(HPX_RUNTIME_THREADS_DETAIL_THREAD_NUM_TSS_JUL_17_2015_0811PM)
+#define HPX_RUNTIME_THREADS_DETAIL_THREAD_NUM_TSS_JUL_17_2015_0811PM
+
+#include <hpx/config.hpp>
+#include <hpx/errors.hpp>
+
+#include <cstddef>
+#include <cstdint>
+#include <tuple>
+#include <utility>
+
+#include <hpx/config/warnings_prefix.hpp>
+
+namespace hpx { namespace threads { namespace detail {
+    // set/get the global thread Id to/from thread local storage
+    HPX_EXPORT std::size_t set_thread_num_tss(std::size_t num);
+    HPX_EXPORT std::size_t get_thread_num_tss();
+
+    // this struct holds the local thread Id and the pool index
+    // associated with the thread
+    struct thread_pool
+    {
+        std::size_t local_thread_num;
+        std::size_t pool_index;
+    };
+    HPX_EXPORT void set_thread_pool_tss(const thread_pool&);
+    HPX_EXPORT thread_pool get_thread_pool_tss();
+
+    ///////////////////////////////////////////////////////////////////////////
+    struct reset_tss_helper
+    {
+        reset_tss_helper(std::size_t thread_num)
+          : thread_num_(set_thread_num_tss(thread_num))
+        {
+        }
+
+        ~reset_tss_helper()
+        {
+            set_thread_num_tss(thread_num_);
+        }
+
+        std::size_t previous_thread_num() const
+        {
+            return thread_num_;
+        }
+
+    private:
+        std::size_t thread_num_;
+    };
+}}}    // namespace hpx::threads::detail
+
+namespace hpx {
+    ///////////////////////////////////////////////////////////////////////////
+    /// \brief Return the number of the current OS-thread running in the
+    ///        runtime instance the current HPX-thread is executed with.
+    ///
+    /// This function returns the zero based index of the OS-thread which
+    /// executes the current HPX-thread.
+    ///
+    /// \note   The returned value is zero based and its maximum value is
+    ///         smaller than the overall number of OS-threads executed (as
+    ///         returned by \a get_os_thread_count().
+    ///
+    /// \note   This function needs to be executed on a HPX-thread. It will
+    ///         fail otherwise (it will return -1).
+    HPX_API_EXPORT std::size_t get_worker_thread_num();
+
+    ///////////////////////////////////////////////////////////////////////////
+    /// \brief Return the number of the current OS-thread running in the
+    ///        runtime instance the current HPX-thread is executed with.
+    ///
+    /// This function returns the zero based index of the OS-thread which
+    /// executes the current HPX-thread.
+    ///
+    /// \param ec [in,out] this represents the error status on exit.
+    ///
+    /// \note   The returned value is zero based and its maximum value is
+    ///         smaller than the overall number of OS-threads executed (as
+    ///         returned by \a get_os_thread_count(). It will return -1 if
+    ///         the current thread is not a known thread or if the runtime is
+    ///         not in running state.
+    ///
+    /// \note   This function needs to be executed on a HPX-thread. It will
+    ///         fail otherwise (it will return -1).
+    HPX_API_EXPORT std::size_t get_worker_thread_num(error_code& ec);
+}    // namespace hpx
+
+#include <hpx/config/warnings_suffix.hpp>
+
+#endif
diff --git a/hpx/runtime/threads/thread_pool_base.hpp b/libs/threading_base/include/hpx/threading_base/thread_pool_base.hpp
similarity index 68%
rename from hpx/runtime/threads/thread_pool_base.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_pool_base.hpp
index 1633fcb7d9..d7ef43f26a 100644
--- a/hpx/runtime/threads/thread_pool_base.hpp
+++ b/libs/threading_base/include/hpx/threading_base/thread_pool_base.hpp
@@ -9,22 +9,19 @@
 #define HPX_RUNTIME_THREADS_DETAIL_THREAD_POOL_JUN_11_2015_1137AM
 
 #include <hpx/config.hpp>
+#include <hpx/affinity/affinity_data.hpp>
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/runtime/thread_pool_helpers.hpp>
-#include <hpx/runtime/threads/detail/network_background_callback.hpp>
-#include <hpx/affinity/affinity_data.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
+#include <hpx/functional.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
+#include <hpx/threading_base/network_background_callback.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/timing/steady_clock.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/timing/steady_clock.hpp>
-#include <hpx/state.hpp>
-#include <hpx/util_fwd.hpp>
 
-#include <thread>
 #include <cstddef>
 #include <cstdint>
 #include <exception>
@@ -33,22 +30,83 @@
 #include <memory>
 #include <mutex>
 #include <string>
+#include <thread>
 #include <vector>
 
 #include <hpx/config/warnings_prefix.hpp>
 
-namespace hpx { namespace threads
-{
+namespace hpx { namespace threads {
+    /// \brief Data structure which stores statistics collected by an
+    ///        executor instance.
+    struct executor_statistics
+    {
+        executor_statistics()
+          : tasks_scheduled_(0)
+          , tasks_completed_(0)
+          , queue_length_(0)
+        {
+        }
+
+        std::uint64_t tasks_scheduled_;
+        std::uint64_t tasks_completed_;
+        std::uint64_t queue_length_;
+    };
+
+    namespace detail {
+        ///////////////////////////////////////////////////////////////////////
+        enum executor_parameter
+        {
+            min_concurrency = 1,
+            max_concurrency = 2,
+            current_concurrency = 3
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        // The interface below is used by the resource manager to
+        // interact with the executor.
+        struct manage_executor
+        {
+            virtual ~manage_executor() {}
+
+            // Return the requested policy element
+            virtual std::size_t get_policy_element(
+                executor_parameter p, error_code& ec) const = 0;
+
+            // Return statistics collected by this scheduler
+            virtual void get_statistics(
+                executor_statistics& stats, error_code& ec) const = 0;
+
+            // Provide the given processing unit to the scheduler.
+            virtual void add_processing_unit(std::size_t virt_core,
+                std::size_t thread_num, error_code& ec) = 0;
+
+            // Remove the given processing unit from the scheduler.
+            virtual void remove_processing_unit(
+                std::size_t thread_num, error_code& ec) = 0;
+
+            // return the description string of the underlying scheduler
+            virtual char const* get_description() const = 0;
+        };
+    }    // namespace detail
+
     ///////////////////////////////////////////////////////////////////////////
     /// \cond NOINTERNAL
     struct pool_id_type
     {
         pool_id_type(std::size_t index, std::string const& name)
-          : index_(index), name_(name)
-        {}
+          : index_(index)
+          , name_(name)
+        {
+        }
 
-        std::size_t index() const { return index_; };
-        std::string const& name() const { return name_; }
+        std::size_t index() const
+        {
+            return index_;
+        };
+        std::string const& name() const
+        {
+            return name_;
+        }
 
     private:
         std::size_t const index_;
@@ -101,7 +159,7 @@ namespace hpx { namespace threads
     // note: this data structure has to be protected from races from the outside
 
     /// \brief The base class used to manage a pool of OS threads.
-    class thread_pool_base : public detail::manage_executor
+    class HPX_EXPORT thread_pool_base : public detail::manage_executor
     {
     public:
         /// \cond NOINTERNAL
@@ -111,8 +169,8 @@ namespace hpx { namespace threads
 
         virtual void init(std::size_t num_threads, std::size_t threads_offset);
 
-        virtual bool run(std::unique_lock<std::mutex>& l,
-            std::size_t num_threads) = 0;
+        virtual bool run(
+            std::unique_lock<std::mutex>& l, std::size_t num_threads) = 0;
 
         virtual void stop(
             std::unique_lock<std::mutex>& l, bool blocking = true) = 0;
@@ -168,8 +226,7 @@ namespace hpx { namespace threads
         /// \cond NOINTERNAL
         virtual std::size_t get_os_thread_count() const = 0;
 
-        virtual std::thread& get_os_thread_handle(
-            std::size_t num_thread) = 0;
+        virtual std::thread& get_os_thread_handle(std::size_t num_thread) = 0;
 
         virtual std::size_t get_active_os_thread_count() const;
 
@@ -182,10 +239,10 @@ namespace hpx { namespace threads
             thread_state_enum new_state, thread_state_ex_enum new_state_ex,
             thread_priority priority, error_code& ec) = 0;
 
-        virtual thread_id_type set_state(util::steady_time_point const& abs_time,
-            thread_id_type const& id, thread_state_enum newstate,
-            thread_state_ex_enum newstate_ex, thread_priority priority,
-            error_code& ec) = 0;
+        virtual thread_id_type set_state(
+            util::steady_time_point const& abs_time, thread_id_type const& id,
+            thread_state_enum newstate, thread_state_ex_enum newstate_ex,
+            thread_priority priority, error_code& ec) = 0;
 
         std::size_t get_pool_index() const
         {
@@ -211,87 +268,178 @@ namespace hpx { namespace threads
         // performance counters
 #if defined(HPX_HAVE_THREAD_CUMULATIVE_COUNTS)
         virtual std::int64_t get_executed_threads(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_executed_thread_phases(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 #if defined(HPX_HAVE_THREAD_IDLE_RATES)
         virtual std::int64_t get_thread_phase_duration(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_thread_duration(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_thread_phase_overhead(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_thread_overhead(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_cumulative_thread_duration(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_cumulative_thread_overhead(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 #endif
 #endif
 
         virtual std::int64_t get_cumulative_duration(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 
-#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) && defined(HPX_HAVE_THREAD_IDLE_RATES)
+#if defined(HPX_HAVE_BACKGROUND_THREAD_COUNTERS) &&                            \
+    defined(HPX_HAVE_THREAD_IDLE_RATES)
         virtual std::int64_t get_background_work_duration(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_background_overhead(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 
         virtual std::int64_t get_background_send_duration(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_background_send_overhead(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 
         virtual std::int64_t get_background_receive_duration(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_background_receive_overhead(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 #endif    // HPX_HAVE_BACKGROUND_THREAD_COUNTERS
 
 #if defined(HPX_HAVE_THREAD_IDLE_RATES)
-        virtual std::int64_t avg_idle_rate_all(bool /*reset*/) { return 0; }
-        virtual std::int64_t avg_idle_rate(std::size_t, bool) { return 0; }
+        virtual std::int64_t avg_idle_rate_all(bool /*reset*/)
+        {
+            return 0;
+        }
+        virtual std::int64_t avg_idle_rate(std::size_t, bool)
+        {
+            return 0;
+        }
 
 #if defined(HPX_HAVE_THREAD_CREATION_AND_CLEANUP_RATES)
         virtual std::int64_t avg_creation_idle_rate(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t avg_cleanup_idle_rate(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 #endif
 #endif
 
-        virtual std::int64_t get_queue_length(std::size_t, bool) { return 0; }
+        virtual std::int64_t get_queue_length(std::size_t, bool)
+        {
+            return 0;
+        }
 
 #if defined(HPX_HAVE_THREAD_QUEUE_WAITTIME)
         virtual std::int64_t get_average_thread_wait_time(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_average_task_wait_time(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 #endif
 
 #if defined(HPX_HAVE_THREAD_STEALING_COUNTS)
         virtual std::int64_t get_num_pending_misses(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_num_pending_accesses(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 
         virtual std::int64_t get_num_stolen_from_pending(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_num_stolen_to_pending(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_num_stolen_from_staged(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
         virtual std::int64_t get_num_stolen_to_staged(
-            std::size_t /*thread_num*/, bool /*reset*/) { return 0; }
+            std::size_t /*thread_num*/, bool /*reset*/)
+        {
+            return 0;
+        }
 #endif
 
         virtual std::int64_t get_thread_count(thread_state_enum /*state*/,
             thread_priority /*priority*/, std::size_t /*num_thread*/,
-            bool /*reset*/) { return 0; }
+            bool /*reset*/)
+        {
+            return 0;
+        }
 
-        virtual std::int64_t get_background_thread_count() { return 0; }
+        virtual std::int64_t get_background_thread_count()
+        {
+            return 0;
+        }
 
         std::int64_t get_thread_count_unknown(
             std::size_t num_thread, bool reset)
@@ -345,15 +493,11 @@ namespace hpx { namespace threads
 
         virtual void reset_thread_distribution() {}
 
-        virtual void set_scheduler_mode(threads::policies::scheduler_mode) {}
-        virtual void add_scheduler_mode(threads::policies::scheduler_mode) {}
-        virtual void add_remove_scheduler_mode(threads::policies::scheduler_mode,
-            threads::policies::scheduler_mode) {}
-        virtual void remove_scheduler_mode(threads::policies::scheduler_mode) {}
-
-        //
         virtual void abort_all_suspended_threads() {}
-        virtual bool cleanup_terminated(bool /*delete_all*/) { return false; }
+        virtual bool cleanup_terminated(bool /*delete_all*/)
+        {
+            return false;
+        }
 
         virtual hpx::state get_state() const = 0;
         virtual hpx::state get_state(std::size_t num_thread) const = 0;
@@ -384,21 +528,14 @@ namespace hpx { namespace threads
             std::size_t thread_num, error_code& ec = throws) override = 0;
 
         // \brief Remove the given processing unit from the scheduler.
-        virtual void remove_processing_unit(std::size_t thread_num,
-            error_code& ec = throws) override = 0;
+        virtual void remove_processing_unit(
+            std::size_t thread_num, error_code& ec = throws) override = 0;
 
         // \brief Return the description string of the underlying scheduler.
         char const* get_description() const override;
 
         /// \endcond
 
-        /// \cond NOINTERNAL
-        policies::scheduler_mode get_scheduler_mode() const
-        {
-            return mode_;
-        }
-        /// \endcond
-
     protected:
         /// \cond NOINTERNAL
         void init_pool_time_scale();
@@ -408,9 +545,6 @@ namespace hpx { namespace threads
         /// \cond NOINTERNAL
         pool_id_type id_;
 
-        // Mode of operation of the pool
-        policies::scheduler_mode mode_;
-
         // The thread_offset is equal to the accumulated number of
         // threads in all pools preceding this pool
         // in the thread indexation. That means, that in order to know
@@ -427,7 +561,7 @@ namespace hpx { namespace threads
         threads::policies::callback_notifier& notifier_;
         /// \endcond
     };
-}}
+}}    // namespace hpx::threads
 
 #include <hpx/config/warnings_suffix.hpp>
 
diff --git a/hpx/runtime/threads/policies/thread_queue_init_parameters.hpp b/libs/threading_base/include/hpx/threading_base/thread_queue_init_parameters.hpp
similarity index 100%
rename from hpx/runtime/threads/policies/thread_queue_init_parameters.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_queue_init_parameters.hpp
diff --git a/hpx/runtime/threads/thread_specific_ptr.hpp b/libs/threading_base/include/hpx/threading_base/thread_specific_ptr.hpp
similarity index 85%
rename from hpx/runtime/threads/thread_specific_ptr.hpp
rename to libs/threading_base/include/hpx/threading_base/thread_specific_ptr.hpp
index 16631cc9e7..c51b48da43 100644
--- a/hpx/runtime/threads/thread_specific_ptr.hpp
+++ b/libs/threading_base/include/hpx/threading_base/thread_specific_ptr.hpp
@@ -9,17 +9,17 @@
 // (C) Copyright 2008 Anthony Williams
 // (C) Copyright 2011-2012 Vicente J. Botet Escriba
 
-#if !defined(HPX_UTIL_RUNTIME_THREADS_THREAD_SPECIFIC_PTR_MAR_20_2014_0941A320PM)
+#if !defined(                                                                  \
+    HPX_UTIL_RUNTIME_THREADS_THREAD_SPECIFIC_PTR_MAR_20_2014_0941A320PM)
 #define HPX_UTIL_RUNTIME_THREADS_THREAD_SPECIFIC_PTR_MAR_20_2014_0941A320PM
 
 #include <hpx/config.hpp>
 #include <hpx/coroutines/detail/tss.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 
 #include <memory>
 
-namespace hpx { namespace threads
-{
+namespace hpx { namespace threads {
     ///////////////////////////////////////////////////////////////////////////
     template <typename T>
     class thread_specific_ptr
@@ -30,8 +30,7 @@ namespace hpx { namespace threads
         thread_specific_ptr(thread_specific_ptr&);
         thread_specific_ptr& operator=(thread_specific_ptr&);
 
-        struct delete_data
-          : coroutines::detail::tss_cleanup_function
+        struct delete_data : coroutines::detail::tss_cleanup_function
         {
             void operator()(void* data) override
             {
@@ -42,9 +41,10 @@ namespace hpx { namespace threads
         struct run_custom_cleanup_function
           : coroutines::detail::tss_cleanup_function
         {
-            explicit run_custom_cleanup_function(void (*cleanup_function_)(T*)):
-                cleanup_function(cleanup_function_)
-            {}
+            explicit run_custom_cleanup_function(void (*cleanup_function_)(T*))
+              : cleanup_function(cleanup_function_)
+            {
+            }
 
             void operator()(void* data) override
             {
@@ -61,7 +61,8 @@ namespace hpx { namespace threads
 
         thread_specific_ptr()
           : cleanup_(std::make_shared<delete_data>())
-        {}
+        {
+        }
 
         explicit thread_specific_ptr(void (*func_)(T*))
         {
@@ -108,6 +109,6 @@ namespace hpx { namespace threads
             }
         }
     };
-}}
+}}    // namespace hpx::threads
 
 #endif
diff --git a/libs/threading_base/include/hpx/threading_base/threading_base_fwd.hpp b/libs/threading_base/include/hpx/threading_base/threading_base_fwd.hpp
new file mode 100644
index 0000000000..6dae0c3306
--- /dev/null
+++ b/libs/threading_base/include/hpx/threading_base/threading_base_fwd.hpp
@@ -0,0 +1,87 @@
+//  Copyright (c) 2007-2015 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+/// \file hpx/runtime/threads/thread_data_fwd.hpp
+
+#if !defined(HPX_THREADING_BASE_THREADING_BASE_FWD)
+#define HPX_THREADING_BASE_THREADING_BASE_FWD
+
+#include <hpx/config.hpp>
+#include <hpx/coroutines/coroutine_fwd.hpp>
+#include <hpx/coroutines/thread_enums.hpp>
+#include <hpx/coroutines/thread_id_type.hpp>
+#include <hpx/errors.hpp>
+#include <hpx/functional/function.hpp>
+#include <hpx/functional/unique_function.hpp>
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <utility>
+
+#if defined(HPX_HAVE_APEX)
+namespace hpx { namespace util { namespace external_timer {
+    struct task_wrapper;
+}}}    // namespace hpx::util::external_timer
+#endif
+
+namespace hpx { namespace threads {
+
+    class thread_data;
+    class thread_data_stackful;
+    class thread_data_stackless;
+
+    namespace policies {
+        struct scheduler_base;
+    }
+    class thread_pool_base;
+
+    /// \cond NOINTERNAL
+    using thread_id_type = thread_id;
+
+    using coroutine_type = coroutines::coroutine;
+    using stackless_coroutine_type = coroutines::stackless_coroutine;
+
+    using thread_result_type = std::pair<thread_state_enum, thread_id_type>;
+    using thread_arg_type = thread_state_ex_enum;
+
+    using thread_function_sig = thread_result_type(thread_arg_type);
+    using thread_function_type =
+        util::unique_function_nonser<thread_function_sig>;
+
+    using thread_self = coroutines::detail::coroutine_self;
+    using thread_self_impl_type = coroutines::detail::coroutine_impl;
+
+    using thread_result_type = std::pair<thread_state_enum, thread_id_type>;
+    using thread_arg_type = thread_state_ex_enum;
+
+    using thread_function_sig = thread_result_type(thread_arg_type);
+    using thread_function_type =
+        util::unique_function_nonser<thread_function_sig>;
+
+#if defined(HPX_HAVE_APEX)
+    HPX_API_EXPORT std::shared_ptr<hpx::util::external_timer::task_wrapper>
+    get_self_timer_data(void);
+    HPX_API_EXPORT void set_self_timer_data(
+        std::shared_ptr<hpx::util::external_timer::task_wrapper> data);
+#endif
+    /// \endcond
+}}    // namespace hpx::threads
+
+namespace std {
+    template <>
+    struct hash<::hpx::threads::thread_id>
+    {
+        std::size_t operator()(::hpx::threads::thread_id const& v) const
+            noexcept
+        {
+            std::hash<::hpx::threads::thread_data const*> hasher_;
+            return hasher_(static_cast<::hpx::threads::thread_data*>(v.get()));
+        }
+    };
+}    // namespace std
+
+#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/spacer.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/create_thread.hpp
similarity index 50%
rename from libs/logging/include_compatibility/hpx/util/logging/format/formatter/spacer.hpp
rename to libs/threading_base/include_compatibility/hpx/runtime/threads/detail/create_thread.hpp
index c0d19fcf4f..31aee1f244 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/spacer.hpp
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/create_thread.hpp
@@ -1,21 +1,21 @@
-//  Copyright (c) 2019 Mikael Simberg
+//  Copyright (c) 2019 STE||AR Group
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/spacer.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/create_thread.hpp>
 
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
-    "The header hpx/util/logging/format/formatter/spacer.hpp is deprecated, \
-    please include hpx/logging/format/formatter/spacer.hpp instead")
+    "The header hpx/runtime/threads/detail/create_thread.hpp is deprecated, \
+    please include hpx/threading_base/create_thread.hpp instead")
 #else
 #warning                                                                       \
-    "The header hpx/util/logging/format/formatter/spacer.hpp is deprecated, \
-    please include hpx/logging/format/formatter/spacer.hpp instead"
+    "The header hpx/runtime/threads/detail/create_thread.hpp is deprecated, \
+    please include hpx/threading_base/create_thread.hpp instead"
 #endif
 #endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/time.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/create_work.hpp
similarity index 50%
rename from libs/logging/include_compatibility/hpx/util/logging/format/formatter/time.hpp
rename to libs/threading_base/include_compatibility/hpx/runtime/threads/detail/create_work.hpp
index ec9ff5a872..f61976d4ca 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/time.hpp
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/create_work.hpp
@@ -1,21 +1,21 @@
-//  Copyright (c) 2019 Mikael Simberg
+//  Copyright (c) 2019 STE||AR Group
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/time.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/create_work.hpp>
 
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
-    "The header hpx/util/logging/format/formatter/time.hpp is deprecated, \
-    please include hpx/logging/format/formatter/time.hpp instead")
+    "The header hpx/runtime/threads/detail/create_work.hpp is deprecated, \
+    please include hpx/threading_base/create_work.hpp instead")
 #else
 #warning                                                                       \
-    "The header hpx/util/logging/format/formatter/time.hpp is deprecated, \
-    please include hpx/logging/format/formatter/time.hpp instead"
+    "The header hpx/runtime/threads/detail/create_work.hpp is deprecated, \
+    please include hpx/threading_base/create_work.hpp instead"
 #endif
 #endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/network_background_callback.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/network_background_callback.hpp
new file mode 100644
index 0000000000..535c13b284
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/network_background_callback.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/network_background_callback.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/detail/network_background_callback.hpp is \
+    deprecated, \
+    please include hpx/threading_base/network_background_callback.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/detail/network_background_callback.hpp is \
+    deprecated, \
+    please include hpx/threading_base/network_background_callback.hpp instead"
+#endif
+#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/time_strf.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/set_thread_state.hpp
similarity index 50%
rename from libs/logging/include_compatibility/hpx/util/logging/format/formatter/time_strf.hpp
rename to libs/threading_base/include_compatibility/hpx/runtime/threads/detail/set_thread_state.hpp
index 4a1d4da20a..3c0be6a0db 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/time_strf.hpp
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/set_thread_state.hpp
@@ -1,21 +1,21 @@
-//  Copyright (c) 2019 Mikael Simberg
+//  Copyright (c) 2019 STE||AR Group
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/time_strf.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/set_thread_state.hpp>
 
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
-    "The header hpx/util/logging/format/formatter/time_strf.hpp is deprecated, \
-    please include hpx/logging/format/formatter/time_strf.hpp instead")
+    "The header hpx/runtime/threads/detail/set_thread_state.hpp is deprecated, \
+    please include hpx/threading_base/set_thread_state.hpp instead")
 #else
 #warning                                                                       \
-    "The header hpx/util/logging/format/formatter/time_strf.hpp is deprecated, \
-    please include hpx/logging/format/formatter/time_strf.hpp instead"
+    "The header hpx/runtime/threads/detail/set_thread_state.hpp is deprecated, \
+    please include hpx/threading_base/set_thread_state.hpp instead"
 #endif
 #endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/thread_num_tss.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/thread_num_tss.hpp
new file mode 100644
index 0000000000..14b96de25b
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/detail/thread_num_tss.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/detail/thread_num_tss.hpp is deprecated, \
+    please include hpx/threading_base/thread_num_tss.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/detail/thread_num_tss.hpp is deprecated, \
+    please include hpx/threading_base/thread_num_tss.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/execution_agent.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/execution_agent.hpp
new file mode 100644
index 0000000000..91934208b1
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/execution_agent.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/execution_agent.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/execution_agent.hpp is deprecated, \
+    please include hpx/threading_base/execution_agent.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/execution_agent.hpp is deprecated, \
+    please include hpx/threading_base/execution_agent.hpp instead"
+#endif
+#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/named_spacer.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/callback_notifier.hpp
similarity index 50%
rename from libs/logging/include_compatibility/hpx/util/logging/format/formatter/named_spacer.hpp
rename to libs/threading_base/include_compatibility/hpx/runtime/threads/policies/callback_notifier.hpp
index 5ce03e51fb..f816edb352 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/format/formatter/named_spacer.hpp
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/callback_notifier.hpp
@@ -1,21 +1,21 @@
-//  Copyright (c) 2019 Mikael Simberg
+//  Copyright (c) 2019 STE||AR Group
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/format/formatter/named_spacer.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
 
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
-    "The header hpx/util/logging/format/formatter/named_spacer.hpp is deprecated, \
-    please include hpx/logging/format/formatter/named_spacer.hpp instead")
+    "The header hpx/runtime/threads/policies/callback_notifier.hpp is deprecated, \
+    please include hpx/threading_base/callback_notifier.hpp instead")
 #else
 #warning                                                                       \
-    "The header hpx/util/logging/format/formatter/named_spacer.hpp is deprecated, \
-    please include hpx/logging/format/formatter/named_spacer.hpp instead"
+    "The header hpx/runtime/threads/policies/callback_notifier.hpp is deprecated, \
+    please include hpx/threading_base/callback_notifier.hpp instead"
 #endif
 #endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/scheduler_base.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/scheduler_base.hpp
new file mode 100644
index 0000000000..de9f7bcc89
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/scheduler_base.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/scheduler_base.hpp is deprecated, \
+    please include hpx/threading_base/scheduler_base.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/scheduler_base.hpp is deprecated, \
+    please include hpx/threading_base/scheduler_base.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/scheduler_mode.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/scheduler_mode.hpp
new file mode 100644
index 0000000000..9ab5a954eb
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/scheduler_mode.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/scheduler_mode.hpp is deprecated, \
+    please include hpx/threading_base/scheduler_mode.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/scheduler_mode.hpp is deprecated, \
+    please include hpx/threading_base/scheduler_mode.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/thread_queue_init_parameters.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/thread_queue_init_parameters.hpp
new file mode 100644
index 0000000000..a1a0f2ba2e
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/policies/thread_queue_init_parameters.hpp
@@ -0,0 +1,23 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/thread_queue_init_parameters.hpp \
+    is deprecated, \
+    please include hpx/threading_base/thread_queue_init_parameters.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/thread_queue_init_parameters.hpp \
+    is deprecated, \
+    please include hpx/threading_base/thread_queue_init_parameters.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/register_thread.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/register_thread.hpp
new file mode 100644
index 0000000000..d22390dc93
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/register_thread.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/register_thread.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/policies/register_thread.hpp is deprecated, \
+    please include hpx/threading_base/register_thread.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/policies/register_thread.hpp is deprecated, \
+    please include hpx/threading_base/register_thread.hpp instead"
+#endif
+#endif
diff --git a/libs/logging/include_compatibility/hpx/util/logging/detail/format_write_detail.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/scheduler_base.hpp
similarity index 50%
rename from libs/logging/include_compatibility/hpx/util/logging/detail/format_write_detail.hpp
rename to libs/threading_base/include_compatibility/hpx/runtime/threads/scheduler_base.hpp
index bd4ba1e012..049478a9d3 100644
--- a/libs/logging/include_compatibility/hpx/util/logging/detail/format_write_detail.hpp
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/scheduler_base.hpp
@@ -1,21 +1,21 @@
-//  Copyright (c) 2019 Mikael Simberg
+//  Copyright (c) 2019 STE||AR Group
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
-#include <hpx/logging/config/defines.hpp>
-#include <hpx/logging/detail/format_write_detail.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
 
-#if defined(HPX_LOGGING_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
 #if defined(HPX_MSVC)
 #pragma message(                                                               \
-    "The header hpx/util/logging/detail/format_write_detail.hpp is deprecated, \
-    please include hpx/logging/detail/format_write_detail.hpp instead")
+    "The header hpx/runtime/threads/policies/scheduler_base.hpp is deprecated, \
+    please include hpx/threading_base/scheduler_base.hpp instead")
 #else
 #warning                                                                       \
-    "The header hpx/util/logging/detail/format_write_detail.hpp is deprecated, \
-    please include hpx/logging/detail/format_write_detail.hpp instead"
+    "The header hpx/runtime/threads/policies/scheduler_base.hpp is deprecated, \
+    please include hpx/threading_base/scheduler_base.hpp instead"
 #endif
 #endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data.hpp
new file mode 100644
index 0000000000..326194f9b9
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_data.hpp is deprecated, \
+    please include hpx/threading_base/thread_data.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/thread_data.hpp is deprecated, \
+    please include hpx/threading_base/thread_data.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data_stackful.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data_stackful.hpp
new file mode 100644
index 0000000000..dd0942fe23
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data_stackful.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_data_stackful.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_data_stackful.hpp is deprecated, \
+    please include hpx/threading_base/thread_data_stackful.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/thread_data_stackful.hpp is deprecated, \
+    please include hpx/threading_base/thread_data_stackful.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data_stackless.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data_stackless.hpp
new file mode 100644
index 0000000000..4e641ae4f3
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_data_stackless.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_data_stackless.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_data_stackless.hpp is deprecated, \
+    please include hpx/threading_base/thread_data_stackless.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/thread_data_stackless.hpp is deprecated, \
+    please include hpx/threading_base/thread_data_stackless.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_helpers.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_helpers.hpp
new file mode 100644
index 0000000000..c72967fa05
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_helpers.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_helpers.hpp is deprecated, \
+    please include hpx/threading_base/thread_helpers.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/thread_helpers.hpp is deprecated, \
+    please include hpx/threading_base/thread_helpers.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_init_data.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_init_data.hpp
new file mode 100644
index 0000000000..d624fe7b71
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_init_data.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_init_data.hpp is deprecated, \
+    please include hpx/threading_base/thread_init_data.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/thread_init_data.hpp is deprecated, \
+    please include hpx/threading_base/thread_init_data.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_pool_base.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_pool_base.hpp
new file mode 100644
index 0000000000..a837369493
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_pool_base.hpp
@@ -0,0 +1,20 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_pool_base.hpp is deprecated, \
+    please include hpx/threading_base/thread_pool_base.hpp instead")
+#else
+#warning "The header hpx/runtime/threads/thread_pool_base.hpp is deprecated, \
+    please include hpx/threading_base/thread_pool_base.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_specific_ptr.hpp b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_specific_ptr.hpp
new file mode 100644
index 0000000000..771fda103b
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/runtime/threads/thread_specific_ptr.hpp
@@ -0,0 +1,21 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_specific_ptr.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message(                                                               \
+    "The header hpx/runtime/threads/thread_specific_ptr.hpp is deprecated, \
+    please include hpx/threading_base/thread_specific_ptr.hpp instead")
+#else
+#warning                                                                       \
+    "The header hpx/runtime/threads/thread_specific_ptr.hpp is deprecated, \
+    please include hpx/threading_base/thread_specific_ptr.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/util/annotated_function.hpp b/libs/threading_base/include_compatibility/hpx/util/annotated_function.hpp
new file mode 100644
index 0000000000..c34607195d
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/util/annotated_function.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/annotated_function.hpp is deprecated, \
+    please include hpx/threading_base/annotated_function.hpp instead")
+#else
+#warning "The header hpx/util/annotated_function.hpp is deprecated, \
+    please include hpx/threading_base/annotated_function.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/util/external_timer.hpp b/libs/threading_base/include_compatibility/hpx/util/external_timer.hpp
new file mode 100644
index 0000000000..972b716b64
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/util/external_timer.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/external_timer.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/external_timer.hpp is deprecated, \
+    please include hpx/threading_base/external_timer.hpp instead")
+#else
+#warning "The header hpx/util/external_timer.hpp is deprecated, \
+    please include hpx/threading_base/external_timer.hpp instead"
+#endif
+#endif
diff --git a/libs/threading_base/include_compatibility/hpx/util/thread_description.hpp b/libs/threading_base/include_compatibility/hpx/util/thread_description.hpp
new file mode 100644
index 0000000000..75115097aa
--- /dev/null
+++ b/libs/threading_base/include_compatibility/hpx/util/thread_description.hpp
@@ -0,0 +1,19 @@
+//  Copyright (c) 2019 STE||AR Group
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/threading_base/config/defines.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+
+#if defined(HPX_THREAD_DATA_HAVE_DEPRECATION_WARNINGS)
+#if defined(HPX_MSVC)
+#pragma message("The header hpx/util/thread_description.hpp is deprecated, \
+    please include hpx/threading_base/thread_description.hpp instead")
+#else
+#warning "The header hpx/util/thread_description.hpp is deprecated, \
+    please include hpx/threading_base/thread_description.hpp instead"
+#endif
+#endif
diff --git a/src/runtime/threads/execution_agent.cpp b/libs/threading_base/src/execution_agent.cpp
similarity index 85%
rename from src/runtime/threads/execution_agent.cpp
rename to libs/threading_base/src/execution_agent.cpp
index d37a2b76bd..03bb8a685d 100644
--- a/src/runtime/threads/execution_agent.cpp
+++ b/libs/threading_base/src/execution_agent.cpp
@@ -6,17 +6,15 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/errors/throw_exception.hpp>
 #include <hpx/format.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/coroutines/thread_enums.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
-#include <hpx/runtime/threads/execution_agent.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/execution_agent.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
 #ifdef HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION
 #include <hpx/util/backtrace.hpp>
@@ -37,6 +35,13 @@ namespace hpx { namespace threads {
     std::string execution_agent::description() const
     {
         thread_id_type id = self_.get_thread_id();
+        if (HPX_UNLIKELY(!id))
+        {
+            HPX_THROW_EXCEPTION(null_thread_id, "execution_agent::description",
+                "null thread id encountered (is this executed on a "
+                "HPX-thread?)");
+        }
+
         return hpx::util::format(
             "{}: {}", id, get_thread_id_data(id)->get_description());
     }
@@ -126,9 +131,17 @@ namespace hpx { namespace threads {
         const char* desc, threads::thread_state_enum state)
     {
         thread_id_type id = self_.get_thread_id();
+        if (HPX_UNLIKELY(!id))
+        {
+            HPX_THROW_EXCEPTION(null_thread_id, "execution_agent::do_yield",
+                "null thread id encountered (is this executed on a "
+                "HPX-thread?)");
+        }
 
         // handle interruption, if needed
-        threads::interruption_point(id);
+        thread_data* thrd_data = get_thread_id_data(id);
+        HPX_ASSERT(thrd_data);
+        thrd_data->interruption_point();
 
         threads::thread_state_ex_enum statex = threads::wait_unknown;
 
@@ -140,15 +153,15 @@ namespace hpx { namespace threads {
 #ifdef HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION
             detail::reset_backtrace bt(id, ec);
 #endif
-            HPX_ASSERT(get_thread_id_data(id)->get_state().state() == active);
+            HPX_ASSERT(thrd_data->get_state().state() == active);
             HPX_ASSERT(state != active);
-            statex = self_.yield(threads::thread_result_type(state,
-                threads::thread_id_type{nullptr}));
+            statex = self_.yield(
+                threads::thread_result_type(state, threads::invalid_thread_id));
             HPX_ASSERT(get_thread_id_data(id)->get_state().state() == active);
         }
 
         // handle interruption, if needed
-        threads::interruption_point(id);
+        thrd_data->interruption_point();
 
         // handle interrupt and abort
         if (statex == threads::wait_abort)
@@ -160,7 +173,6 @@ namespace hpx { namespace threads {
         }
 
         return statex;
-        // HPX_ASSERT(statex == threads::wait_signaled);
     }
 
     void execution_agent::do_resume(
@@ -189,7 +201,8 @@ namespace hpx { namespace threads {
             {
             // The thread is still running... we yield our current context
             // and retry..
-            case active: {
+            case active:
+            {
                 hpx::basic_execution::this_thread::yield_k(
                     k, "hpx::threads::execution_agent::resume");
                 ++k;
@@ -200,7 +213,8 @@ namespace hpx { namespace threads {
                     << get_thread_id_data(id)->get_description() << ")";
                 continue;
             }
-            case terminated: {
+            case terminated:
+            {
                 LTM_(warning)
                     << "resume: thread is terminated, aborting state "
                        "change, thread("
@@ -214,7 +228,8 @@ namespace hpx { namespace threads {
                 // We can now safely set the new state...
                 break;
             case pending_do_not_schedule:
-            default: {
+            default:
+            {
                 // should not happen...
                 std::ostringstream strm;
                 strm << "resume: previous state was "
@@ -231,8 +246,7 @@ namespace hpx { namespace threads {
             // at some point will ignore this thread by simply skipping it
             // (if it's not pending anymore).
 
-            LTM_(info) << "resume: thread(" << id
-                       << "), description("
+            LTM_(info) << "resume: thread(" << id << "), description("
                        << get_thread_id_data(id)->get_description()
                        << "), old state("
                        << get_thread_state_name(previous_state_val) << ")";
@@ -248,10 +262,8 @@ namespace hpx { namespace threads {
             LTM_(error)
                 << "resume: state has been changed since it was fetched, "
                    "retrying, thread("
-                << id
-                << "), description("
-                << get_thread_id_data(id)->get_description()
-                << "), old state("
+                << id << "), description("
+                << get_thread_id_data(id)->get_description() << "), old state("
                 << get_thread_state_name(previous_state_val) << ")";
 
         } while (true);
diff --git a/libs/threading_base/src/external_timer.cpp b/libs/threading_base/src/external_timer.cpp
new file mode 100644
index 0000000000..ba56695279
--- /dev/null
+++ b/libs/threading_base/src/external_timer.cpp
@@ -0,0 +1,153 @@
+//  Copyright (c) 2007-2013 Kevin Huck
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#include <hpx/config.hpp>
+#include <hpx/assertion.hpp>
+#include <hpx/threading_base/external_timer.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+
+namespace hpx { namespace util {
+
+#ifdef HPX_HAVE_APEX
+
+    static enable_parent_task_handler_type enable_parent_task_handler;
+
+    void set_enable_parent_task_handler(enable_parent_task_handler_type f)
+    {
+        enable_parent_task_handler = f;
+    }
+
+    namespace external_timer {
+
+        std::shared_ptr<task_wrapper> new_task(
+            thread_description const& description,
+            std::uint32_t parent_locality_id,
+            threads::thread_id_type const& parent_task)
+        {
+            std::shared_ptr<task_wrapper> parent_wrapper = nullptr;
+            // Parent pointers aren't reliable in distributed runs.
+            if (parent_task != nullptr && enable_parent_task_handler &&
+                enable_parent_task_handler())
+            {
+                parent_wrapper =
+                    get_thread_id_data(parent_task)->get_timer_data();
+            }
+
+            if (description.kind() == thread_description::data_type_description)
+            {
+                return new_task(
+                    description.get_description(), UINTMAX_MAX, parent_wrapper);
+            }
+            else
+            {
+                HPX_ASSERT(description.kind() ==
+                    thread_description::data_type_address);
+                return new_task(
+                    description.get_address(), UINTMAX_MAX, parent_wrapper);
+            }
+        }
+
+        /* register the function pointers */
+        void register_external_timer(registration_t& registration)
+        {
+            switch (registration.type)
+            {
+            case init_flag:
+            {
+                init_function = registration.record.init;
+                break;
+            }
+            case finalize_flag:
+            {
+                finalize_function = registration.record.finalize;
+                break;
+            }
+            case register_thread_flag:
+            {
+                register_thread_function = registration.record.register_thread;
+                break;
+            }
+            case new_task_string_flag:
+            {
+                new_task_string_function = registration.record.new_task_string;
+                break;
+            }
+            case new_task_address_flag:
+            {
+                new_task_address_function =
+                    registration.record.new_task_address;
+                break;
+            }
+            case update_task_string_flag:
+            {
+                update_task_string_function =
+                    registration.record.update_task_string;
+                break;
+            }
+            case update_task_address_flag:
+            {
+                update_task_address_function =
+                    registration.record.update_task_address;
+                break;
+            }
+            case sample_value_flag:
+            {
+                sample_value_function = registration.record.sample_value;
+                break;
+            }
+            case send_flag:
+            {
+                send_function = registration.record.send;
+                break;
+            }
+            case recv_flag:
+            {
+                recv_function = registration.record.recv;
+                break;
+            }
+            case start_flag:
+            {
+                start_function = registration.record.start;
+                break;
+            }
+            case stop_flag:
+            {
+                stop_function = registration.record.stop;
+                break;
+            }
+            case yield_flag:
+            {
+                yield_function = registration.record.yield;
+                break;
+            }
+            }
+        }
+
+        /* Instantiate the function pointers. */
+        init_t* init_function{nullptr};
+        finalize_t* finalize_function{nullptr};
+        register_thread_t* register_thread_function{nullptr};
+        new_task_string_t* new_task_string_function{nullptr};
+        new_task_address_t* new_task_address_function{nullptr};
+        sample_value_t* sample_value_function{nullptr};
+        send_t* send_function{nullptr};
+        recv_t* recv_function{nullptr};
+        update_task_string_t* update_task_string_function{nullptr};
+        update_task_address_t* update_task_address_function{nullptr};
+        start_t* start_function{nullptr};
+        stop_t* stop_function{nullptr};
+        yield_t* yield_function{nullptr};
+
+    }    // namespace external_timer
+
+#endif
+
+}}    // namespace hpx::util
diff --git a/libs/threading_base/src/register_thread.cpp b/libs/threading_base/src/register_thread.cpp
new file mode 100644
index 0000000000..7de6a46107
--- /dev/null
+++ b/libs/threading_base/src/register_thread.cpp
@@ -0,0 +1,87 @@
+//  Copyright (c) 2007-2016 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/assertion.hpp>
+#include <hpx/threading_base/register_thread.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
+
+#include <cstddef>
+#include <limits>
+#include <string>
+#include <utility>
+
+namespace hpx { namespace threads { namespace detail {
+    static get_default_pool_type get_default_pool;
+
+    void set_get_default_pool(get_default_pool_type f)
+    {
+        get_default_pool = f;
+    }
+
+    HPX_EXPORT thread_pool_base* get_self_or_default_pool()
+    {
+        thread_pool_base* pool = nullptr;
+        auto thrd_data = get_self_id_data();
+        if (thrd_data)
+        {
+            pool = thrd_data->get_scheduler_base()->get_parent_pool();
+        }
+        else if (detail::get_default_pool)
+        {
+            pool = detail::get_default_pool();
+            HPX_ASSERT(pool);
+        }
+        else
+        {
+            HPX_THROW_EXCEPTION(invalid_status,
+                "hpx::threads::detail::get_self_or_default_pool",
+                "Attempting to register a thread outside the HPX runtime and "
+                "no default pool handler is installed. Did you mean to run "
+                "this on an HPX thread?");
+        }
+
+        return pool;
+    }
+
+    static get_default_timer_service_type get_default_timer_service_f;
+
+    void set_get_default_timer_service(get_default_timer_service_type f)
+    {
+        get_default_timer_service_f = f;
+    }
+
+    HPX_EXPORT boost::asio::io_service* get_default_timer_service()
+    {
+        boost::asio::io_service* timer_service = nullptr;
+        if (detail::get_default_timer_service_f)
+        {
+            timer_service = detail::get_default_timer_service_f();
+            HPX_ASSERT(timer_service);
+        }
+        else
+        {
+#if defined(HPX_HAVE_TIMER_POOL)
+            HPX_THROW_EXCEPTION(invalid_status,
+                "hpx::threads::detail::get_default_timer_service",
+                "No timer service installed. When running timed threads "
+                "without a runtime a timer service has to be installed "
+                "manually using "
+                "hpx::threads::detail::set_get_default_timer_service.");
+#else
+            HPX_THROW_EXCEPTION(invalid_status,
+                "hpx::threads::detail::get_default_timer_service",
+                "No timer service installed. Rebuild HPX with "
+                "HPX_WITH_TIMER_POOL=ON or provide a timer service manually "
+                "using hpx::threads::detail::set_get_default_timer_service.");
+#endif
+        }
+
+        return timer_service;
+    }
+}}}    // namespace hpx::threads::detail
diff --git a/src/runtime/threads/policies/scheduler_base.cpp b/libs/threading_base/src/scheduler_base.cpp
similarity index 80%
rename from src/runtime/threads/policies/scheduler_base.cpp
rename to libs/threading_base/src/scheduler_base.cpp
index 75e6510f93..564fd83861 100644
--- a/src/runtime/threads/policies/scheduler_base.cpp
+++ b/libs/threading_base/src/scheduler_base.cpp
@@ -6,14 +6,12 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
-#include <hpx/resource_partitioner/detail/partitioner.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/state.hpp>
-#include <hpx/util/yield_while.hpp>
-#include <hpx/util_fwd.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #if defined(HPX_HAVE_SCHEDULER_LOCAL_STORAGE)
 #include <hpx/coroutines/detail/tss.hpp>
 #endif
@@ -35,8 +33,7 @@
 #include <vector>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace threads { namespace policies
-{
+namespace hpx { namespace threads { namespace policies {
     scheduler_base::scheduler_base(std::size_t num_threads,
         char const* description, thread_queue_init_parameters thread_queue_init,
         scheduler_mode mode)
@@ -55,7 +52,7 @@ namespace hpx { namespace threads { namespace policies
         double max_time = thread_queue_init.max_idle_backoff_time_;
 
         wait_counts_.resize(num_threads);
-        for (auto && data : wait_counts_)
+        for (auto&& data : wait_counts_)
         {
             data.data_.wait_count_ = 0;
             data.data_.max_idle_backoff_time_ = max_time;
@@ -70,7 +67,7 @@ namespace hpx { namespace threads { namespace policies
     {
 #if defined(HPX_HAVE_THREAD_MANAGER_IDLE_BACKOFF)
         if (mode_.data_.load(std::memory_order_relaxed) &
-                policies::enable_idle_backoff)
+            policies::enable_idle_backoff)
         {
             // Put this thread to sleep for some time, additionally it gets
             // woken up on new work.
@@ -94,7 +91,7 @@ namespace hpx { namespace threads { namespace policies
             }
         }
 #else
-        (void)num_thread;
+        (void) num_thread;
 #endif
     }
 
@@ -122,8 +119,8 @@ namespace hpx { namespace threads { namespace policies
         hpx::state expected = state_sleeping;
         states_[num_thread].compare_exchange_strong(expected, state_running);
 
-        HPX_ASSERT(expected == state_sleeping ||
-            expected == state_stopping || expected == state_terminating);
+        HPX_ASSERT(expected == state_sleeping || expected == state_stopping ||
+            expected == state_terminating);
     }
 
     void scheduler_base::resume(std::size_t num_thread)
@@ -338,64 +335,14 @@ namespace hpx { namespace threads { namespace policies
 
     void scheduler_base::update_scheduler_mode(scheduler_mode mode, bool set)
     {
-        if (set) {
-            add_scheduler_mode(mode);
-        }
-        else {
-            remove_scheduler_mode(mode);
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    std::size_t scheduler_base::domain_from_local_thread_index(std::size_t n)
-    {
-        auto &rp = resource::get_partitioner();
-        auto const& topo = rp.get_topology();
-        std::size_t global_id = local_to_global_thread_index(n);
-        std::size_t pu_num = rp.get_pu_num(global_id);
-
-        return topo.get_numa_node_number(pu_num);
-    }
-
-    // assumes queues use index 0..N-1 and correspond to the pool cores
-    std::size_t scheduler_base::num_domains(const std::size_t workers)
-    {
-        auto &rp = resource::get_partitioner();
-        auto const& topo = rp.get_topology();
-
-        std::set<std::size_t> domains;
-        for (std::size_t local_id = 0; local_id != workers; ++local_id)
+        if (set)
         {
-            std::size_t global_id = local_to_global_thread_index(local_id);
-            std::size_t pu_num = rp.get_pu_num(global_id);
-            std::size_t dom = topo.get_numa_node_number(pu_num);
-            domains.insert(dom);
+            add_scheduler_mode(mode);
         }
-        return domains.size();
-    }
-
-    // either threads in same domain, or not in same domain
-    // depending on the predicate
-    std::vector<std::size_t> scheduler_base::domain_threads(
-        std::size_t local_id, const std::vector<std::size_t> &ts,
-        std::function<bool(std::size_t, std::size_t)> pred)
-    {
-        std::vector<std::size_t> result;
-        auto &rp = resource::get_partitioner();
-        auto const& topo = rp.get_topology();
-        std::size_t global_id = local_to_global_thread_index(local_id);
-        std::size_t pu_num = rp.get_pu_num(global_id);
-        std::size_t numa = topo.get_numa_node_number(pu_num);
-        for (auto local_id : ts)
+        else
         {
-            global_id = local_to_global_thread_index(local_id);
-            pu_num = rp.get_pu_num(global_id);
-            if (pred(numa, topo.get_numa_node_number(pu_num)))
-            {
-                result.push_back(local_id);
-            }
+            remove_scheduler_mode(mode);
         }
-        return result;
     }
 
     ///////////////////////////////////////////////////////////////////////////
@@ -424,13 +371,12 @@ namespace hpx { namespace threads { namespace policies
     }
 
     void scheduler_base::add_new_tss_node(void const* key,
-        std::shared_ptr<coroutines::detail::tss_cleanup_function>
-            const& func, void* tss_data)
+        std::shared_ptr<coroutines::detail::tss_cleanup_function> const& func,
+        void* tss_data)
     {
         if (!thread_data_)
         {
-            thread_data_ =
-                std::make_shared<coroutines::detail::tss_storage>();
+            thread_data_ = std::make_shared<coroutines::detail::tss_storage>();
         }
         thread_data_->insert(key, func, tss_data);
     }
@@ -452,8 +398,8 @@ namespace hpx { namespace threads { namespace policies
     }
 
     void scheduler_base::set_tss_data(void const* key,
-        std::shared_ptr<coroutines::detail::tss_cleanup_function>
-            const& func, void* tss_data, bool cleanup_existing)
+        std::shared_ptr<coroutines::detail::tss_cleanup_function> const& func,
+        void* tss_data, bool cleanup_existing)
     {
         if (coroutines::detail::tss_data_node* const current_node =
                 find_tss_data(key))
@@ -463,11 +409,10 @@ namespace hpx { namespace threads { namespace policies
             else
                 erase_tss_node(key, cleanup_existing);
         }
-        else if(func || (tss_data != 0))
+        else if (func || (tss_data != 0))
         {
             add_new_tss_node(key, func, tss_data);
         }
     }
 #endif
-}}}
-
+}}}    // namespace hpx::threads::policies
diff --git a/libs/threading_base/src/thread_data.cpp b/libs/threading_base/src/thread_data.cpp
new file mode 100644
index 0000000000..b99dd7326d
--- /dev/null
+++ b/libs/threading_base/src/thread_data.cpp
@@ -0,0 +1,384 @@
+//  Copyright (c) 2007-2016 Hartmut Kaiser
+//  Copyright (c) 2008-2009 Chirag Dekate, Anshul Tandon
+//  Copyright (c) 2011      Bryce Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/assertion.hpp>
+#include <hpx/basic_execution/register_locks.hpp>
+#include <hpx/coroutines/detail/coroutine_accessor.hpp>
+#include <hpx/errors.hpp>
+#include <hpx/functional/function.hpp>
+#include <hpx/logging.hpp>
+#include <hpx/naming_base.hpp>
+#include <hpx/thread_support/unlock_guard.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#if defined(HPX_HAVE_APEX)
+#include <hpx/threading_base/external_timer.hpp>
+#endif
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+
+////////////////////////////////////////////////////////////////////////////////
+namespace hpx { namespace threads {
+    namespace detail {
+        static get_locality_id_type* get_locality_id_f;
+
+        void set_get_locality_id(get_locality_id_type* f)
+        {
+            get_locality_id_f = f;
+        }
+
+        std::uint32_t get_locality_id(hpx::error_code& ec)
+        {
+            if (get_locality_id_f)
+            {
+                return get_locality_id_f(ec);
+            }
+
+            return naming::invalid_locality_id;
+        }
+    }    // namespace detail
+
+    thread_data::thread_data(thread_init_data& init_data, void* queue,
+        thread_state_enum newstate, bool is_stackless)
+        : current_state_(thread_state(newstate, wait_signaled))
+#ifdef HPX_HAVE_THREAD_DESCRIPTION
+        , description_(init_data.description)
+        , lco_description_()
+#endif
+#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
+        , parent_locality_id_(init_data.parent_locality_id)
+        , parent_thread_id_(init_data.parent_id)
+        , parent_thread_phase_(init_data.parent_phase)
+#endif
+#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
+        , marked_state_(unknown)
+#endif
+#ifdef HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION
+        , backtrace_(nullptr
+#endif
+        , priority_(init_data.priority)
+        , requested_interrupt_(false)
+        , enabled_interrupt_(true)
+        , ran_exit_funcs_(false)
+        , scheduler_base_(init_data.scheduler_base)
+        , stacksize_(init_data.stacksize)
+        , queue_(queue)
+        , is_stackless_(is_stackless)
+    {
+            LTM_(debug) << "thread::thread(" << this << "), description("
+                        << get_description() << ")";
+
+#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
+            // store the thread id of the parent thread, mainly for debugging
+            // purposes
+            if (parent_thread_id_)
+            {
+                thread_self* self = get_self_ptr();
+                if (self)
+                {
+                    parent_thread_id_ = threads::get_self_id();
+                    parent_thread_phase_ = self->get_thread_phase();
+                }
+            }
+            if (0 == parent_locality_id_)
+                parent_locality_id_ = detail::get_locality_id(hpx::throws);
+#endif
+#if defined(HPX_HAVE_APEX)
+            set_timer_data(init_data.timer_data);
+#endif
+    }
+
+    thread_data::~thread_data()
+    {
+            free_thread_exit_callbacks();
+    }
+
+    void thread_data::run_thread_exit_callbacks()
+    {
+            mutex_type::scoped_lock l(this);
+
+            while (!exit_funcs_.empty())
+            {
+                {
+                    hpx::util::unlock_guard<mutex_type::scoped_lock> ul(l);
+                    if (!exit_funcs_.front().empty())
+                        exit_funcs_.front()();
+                }
+                exit_funcs_.pop_front();
+            }
+            ran_exit_funcs_ = true;
+    }
+
+    bool thread_data::add_thread_exit_callback(
+        util::function_nonser<void()> const& f)
+    {
+            mutex_type::scoped_lock l(this);
+
+            if (ran_exit_funcs_ || get_state().state() == terminated)
+            {
+                return false;
+            }
+
+            exit_funcs_.push_front(f);
+
+            return true;
+    }
+
+    void thread_data::free_thread_exit_callbacks()
+    {
+            mutex_type::scoped_lock l(this);
+
+            // Exit functions should have been executed.
+            HPX_ASSERT(exit_funcs_.empty() || ran_exit_funcs_);
+
+            exit_funcs_.clear();
+    }
+
+    bool thread_data::interruption_point(bool throw_on_interrupt)
+    {
+            // We do not protect enabled_interrupt_ and requested_interrupt_
+            // from concurrent access here (which creates a benign data race) in
+            // order to avoid infinite recursion. This function is called by
+            // this_thread::suspend which causes problems if the lock would call
+            // suspend itself.
+            if (enabled_interrupt_ && requested_interrupt_)
+            {
+                // Verify that there are no more registered locks for this
+                // OS-thread. This will throw if there are still any locks
+                // held.
+                util::force_error_on_lock();
+
+                // now interrupt this thread
+                if (throw_on_interrupt)
+                    throw hpx::thread_interrupted();
+
+                return true;
+            }
+            return false;
+    }
+
+    void thread_data::rebind_base(
+        thread_init_data& init_data, thread_state_enum newstate)
+    {
+            LTM_(debug) << "~thread(" << this << "), description("    //-V128
+                        << get_description() << "), phase("
+                        << get_thread_phase() << "), rebind";
+
+            free_thread_exit_callbacks();
+
+            current_state_.store(thread_state(newstate, wait_signaled));
+
+#ifdef HPX_HAVE_THREAD_DESCRIPTION
+            description_ = (init_data.description);
+            lco_description_ = util::thread_description();
+#endif
+#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
+            parent_locality_id_ = init_data.parent_locality_id;
+            parent_thread_id_ = init_data.parent_id;
+            parent_thread_phase_ = init_data.parent_phase;
+#endif
+#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
+            set_marked_state(unknown);
+#endif
+#ifdef HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION
+            backtrace_ = nullptr;
+#endif
+            priority_ = init_data.priority;
+            requested_interrupt_ = false;
+            enabled_interrupt_ = true;
+            ran_exit_funcs_ = false;
+            exit_funcs_.clear();
+            scheduler_base_ = init_data.scheduler_base;
+
+            HPX_ASSERT(init_data.stacksize == get_stack_size());
+
+            LTM_(debug) << "thread::thread(" << this << "), description("
+                        << get_description() << "), rebind";
+
+#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
+            // store the thread id of the parent thread, mainly for debugging
+            // purposes
+            if (nullptr == parent_thread_id_)
+            {
+                thread_self* self = get_self_ptr();
+                if (self)
+                {
+                    parent_thread_id_ = threads::get_self_id();
+                    parent_thread_phase_ = self->get_thread_phase();
+                }
+            }
+            if (0 == parent_locality_id_)
+            {
+                parent_locality_id_ = detail::get_locality_id(hpx::throws);
+            }
+#endif
+#if defined(HPX_HAVE_APEX)
+            set_timer_data(init_data.timer_data);
+#endif
+            HPX_ASSERT(init_data.stacksize != 0);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    thread_self& get_self()
+    {
+            thread_self* p = get_self_ptr();
+            if (HPX_UNLIKELY(p == nullptr))
+            {
+                HPX_THROW_EXCEPTION(null_thread_id, "threads::get_self",
+                    "null thread id encountered (is this executed on a "
+                    "HPX-thread?)");
+            }
+            return *p;
+    }
+
+    thread_self* get_self_ptr()
+    {
+            return thread_self::get_self();
+    }
+
+    namespace detail {
+            void set_self_ptr(thread_self * self)
+            {
+                thread_self::set_self(self);
+            }
+    }     // namespace detail
+
+    thread_self::impl_type* get_ctx_ptr()
+    {
+            using hpx::threads::coroutines::detail::coroutine_accessor;
+            return coroutine_accessor::get_impl(get_self());
+    }
+
+    thread_self* get_self_ptr_checked(error_code& ec)
+    {
+            thread_self* p = thread_self::get_self();
+
+            if (HPX_UNLIKELY(p == nullptr))
+            {
+                HPX_THROWS_IF(ec, null_thread_id,
+                    "threads::get_self_ptr_checked",
+                    "null thread id encountered (is this executed on a "
+                    "HPX-thread?)");
+                return nullptr;
+            }
+
+            if (&ec != &throws)
+                ec = make_success_code();
+
+            return p;
+    }
+
+    thread_id_type get_self_id()
+    {
+            thread_self* self = get_self_ptr();
+            if (HPX_LIKELY(nullptr != self))
+                return self->get_thread_id();
+
+            return threads::invalid_thread_id;
+    }
+
+    thread_data* get_self_id_data()
+    {
+            thread_self* self = get_self_ptr();
+            if (HPX_LIKELY(nullptr != self))
+                return get_thread_id_data(self->get_thread_id());
+
+            return nullptr;
+    }
+
+    std::size_t get_self_stacksize()
+    {
+            thread_data* thrd_data = get_self_id_data();
+            return thrd_data ? thrd_data->get_stack_size() : 0;
+    }
+
+#ifndef HPX_HAVE_THREAD_PARENT_REFERENCE
+    thread_id_type get_parent_id()
+    {
+            return threads::invalid_thread_id;
+    }
+
+    std::size_t get_parent_phase()
+    {
+            return 0;
+    }
+
+    std::uint32_t get_parent_locality_id()
+    {
+            return naming::invalid_locality_id;
+    }
+#else
+    thread_id_type get_parent_id()
+    {
+        thread_data* thrd_data = get_self_id_data();
+        if (HPX_LIKELY(nullptr != thrd_data))
+        {
+            return thrd_data->get_parent_thread_id();
+        }
+        return threads::invalid_thread_id;
+    }
+
+    std::size_t get_parent_phase()
+    {
+        thread_data* thrd_data = get_self_id_data();
+        if (HPX_LIKELY(nullptr != thrd_data))
+        {
+            return thrd_data->get_parent_thread_phase();
+        }
+        return 0;
+    }
+
+    std::uint32_t get_parent_locality_id()
+    {
+        thread_data* thrd_data = get_self_id_data();
+        if (HPX_LIKELY(nullptr != thrd_data))
+        {
+            return thrd_data->get_parent_locality_id();
+        }
+        return naming::invalid_locality_id;
+    }
+#endif
+
+    naming::address_type get_self_component_id()
+    {
+#ifndef HPX_HAVE_THREAD_TARGET_ADDRESS
+            return 0;
+#else
+        thread_data* thrd_data = get_self_id_data();
+        if (HPX_LIKELY(nullptr != thrd_data))
+        {
+            return thrd_data->get_component_id();
+        }
+        return 0;
+#endif
+    }
+
+#if defined(HPX_HAVE_APEX)
+    std::shared_ptr<hpx::util::external_timer::task_wrapper>
+        get_self_timer_data()
+    {
+            thread_data* thrd_data = get_self_id_data();
+            if (HPX_LIKELY(nullptr != thrd_data))
+            {
+                return thrd_data->get_timer_data();
+            }
+            return nullptr;
+    }
+    void set_self_timer_data(
+        std::shared_ptr<hpx::util::external_timer::task_wrapper> data)
+    {
+            thread_data* thrd_data = get_self_id_data();
+            if (HPX_LIKELY(nullptr != thrd_data))
+            {
+                thrd_data->set_timer_data(data);
+            }
+            return;
+    }
+#endif
+}}    // namespace hpx::threads
diff --git a/src/runtime/threads/thread_data_stackful.cpp b/libs/threading_base/src/thread_data_stackful.cpp
similarity index 94%
rename from src/runtime/threads/thread_data_stackful.cpp
rename to libs/threading_base/src/thread_data_stackful.cpp
index 26d70f19f8..c8c31cf639 100644
--- a/src/runtime/threads/thread_data_stackful.cpp
+++ b/libs/threading_base/src/thread_data_stackful.cpp
@@ -7,7 +7,7 @@
 #include <hpx/config.hpp>
 #include <hpx/allocator_support/internal_allocator.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 
 ////////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads {
diff --git a/src/runtime/threads/thread_data_stackless.cpp b/libs/threading_base/src/thread_data_stackless.cpp
similarity index 94%
rename from src/runtime/threads/thread_data_stackless.cpp
rename to libs/threading_base/src/thread_data_stackless.cpp
index d08e64c792..ec9308d37d 100644
--- a/src/runtime/threads/thread_data_stackless.cpp
+++ b/libs/threading_base/src/thread_data_stackless.cpp
@@ -7,7 +7,7 @@
 #include <hpx/config.hpp>
 #include <hpx/allocator_support/internal_allocator.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 
 ////////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads {
diff --git a/libs/threading_base/src/thread_description.cpp b/libs/threading_base/src/thread_description.cpp
new file mode 100644
index 0000000000..e3b6ed5798
--- /dev/null
+++ b/libs/threading_base/src/thread_description.cpp
@@ -0,0 +1,143 @@
+//  Copyright (c) 2016-2017 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/assertion.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/util/to_string.hpp>
+
+#include <iostream>
+#include <sstream>
+#include <string>
+
+namespace hpx { namespace util {
+    std::ostream& operator<<(std::ostream& os, thread_description const& d)
+    {
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+        if (d.kind() == thread_description::data_type_description)
+        {
+            os << d.get_description();
+        }
+        else
+        {
+            HPX_ASSERT(d.kind() == thread_description::data_type_address);
+            os << d.get_address();    //-V128
+        }
+#else
+        os << "<unknown>";
+#endif
+        return os;
+    }
+
+    std::string as_string(thread_description const& desc)
+    {
+#if defined(HPX_HAVE_THREAD_DESCRIPTION)
+        if (desc.kind() == util::thread_description::data_type_description)
+            return desc ? desc.get_description() : "<unknown>";
+
+        std::stringstream strm;
+        strm << "address: 0x" << std::hex
+             << util::to_string(desc.get_address());
+        return strm.str();
+#else
+        return "<unknown>";
+#endif
+    }
+
+    /* The priority of description is altname, id::name, id::address */
+    void thread_description::init_from_alternative_name(char const* altname)
+    {
+#if defined(HPX_HAVE_THREAD_DESCRIPTION) &&                                    \
+    !defined(HPX_HAVE_THREAD_DESCRIPTION_FULL)
+        if (altname != nullptr)
+        {
+            type_ = data_type_description;
+            data_.desc_ = altname;
+            return;
+        }
+        hpx::threads::thread_id_type id = hpx::threads::get_self_id();
+        if (id)
+        {
+            // get the current task description
+            thread_description desc = hpx::threads::get_thread_description(id);
+            type_ = desc.kind();
+            // if the current task has a description, use it.
+            if (type_ == data_type_description)
+            {
+                data_.desc_ = desc.get_description();
+            }
+            else
+            {
+                // otherwise, use the address of the task.
+                HPX_ASSERT(type_ == data_type_address);
+                data_.addr_ = desc.get_address();
+            }
+        }
+#endif
+    }
+}}    // namespace hpx::util
+
+namespace hpx { namespace threads {
+    util::thread_description get_thread_description(
+        thread_id_type const& id, error_code& ec)
+    {
+        return id ? get_thread_id_data(id)->get_description() :
+                    util::thread_description("<unknown>");
+    }
+
+    util::thread_description set_thread_description(thread_id_type const& id,
+        util::thread_description const& desc, error_code& ec)
+    {
+        if (HPX_UNLIKELY(!id))
+        {
+            HPX_THROWS_IF(ec, null_thread_id,
+                "hpx::threads::set_thread_description",
+                "null thread id encountered");
+            return util::thread_description();
+        }
+        if (&ec != &throws)
+            ec = make_success_code();
+
+        return get_thread_id_data(id)->set_description(desc);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    util::thread_description get_thread_lco_description(
+        thread_id_type const& id, error_code& ec)
+    {
+        if (HPX_UNLIKELY(!id))
+        {
+            HPX_THROWS_IF(ec, null_thread_id,
+                "hpx::threads::get_thread_lco_description",
+                "null thread id encountered");
+            return nullptr;
+        }
+
+        if (&ec != &throws)
+            ec = make_success_code();
+
+        return get_thread_id_data(id)->get_lco_description();
+    }
+
+    util::thread_description set_thread_lco_description(
+        thread_id_type const& id, util::thread_description const& desc,
+        error_code& ec)
+    {
+        if (HPX_UNLIKELY(!id))
+        {
+            HPX_THROWS_IF(ec, null_thread_id,
+                "hpx::threads::set_thread_lco_description",
+                "null thread id encountered");
+            return nullptr;
+        }
+
+        if (&ec != &throws)
+            ec = make_success_code();
+
+        return get_thread_id_data(id)->set_lco_description(desc);
+    }
+}}    // namespace hpx::threads
diff --git a/src/runtime/threads/thread_helpers.cpp b/libs/threading_base/src/thread_helpers.cpp
similarity index 82%
rename from src/runtime/threads/thread_helpers.cpp
rename to libs/threading_base/src/thread_helpers.cpp
index beca90ea28..c55e68f175 100644
--- a/src/runtime/threads/thread_helpers.cpp
+++ b/libs/threading_base/src/thread_helpers.cpp
@@ -5,7 +5,7 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 
 #include <hpx/assertion.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
@@ -13,19 +13,16 @@
 #ifdef HPX_HAVE_VERIFY_LOCKS
 #include <hpx/basic_execution/register_locks.hpp>
 #endif
-#include <hpx/runtime.hpp>
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
-#include <hpx/runtime/threads/executors/current_executor.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/state.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/set_thread_state.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #ifdef HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION
 #include <hpx/util/backtrace.hpp>
 #endif
+#include <hpx/basic_execution/this_thread.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
-#include <hpx/util/yield_while.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -205,7 +202,7 @@ namespace hpx { namespace threads {
     }
 
     ////////////////////////////////////////////////////////////////////////////
-    static HPX_NATIVE_TLS std::size_t continuation_recursion_count(0);
+    static thread_local std::size_t continuation_recursion_count(0);
 
     std::size_t& get_continuation_recursion_count()
     {
@@ -271,67 +268,6 @@ namespace hpx { namespace threads {
         get_thread_id_data(id)->free_thread_exit_callbacks();
     }
 
-    ///////////////////////////////////////////////////////////////////////////
-    /// The get_thread_description function is part of the thread related API and
-    /// allows to query the description of one of the thread id
-    util::thread_description get_thread_description(
-        thread_id_type const& id, error_code& ec)
-    {
-        return id ? get_thread_id_data(id)->get_description() :
-                    util::thread_description("<unknown>");
-    }
-
-    util::thread_description set_thread_description(thread_id_type const& id,
-        util::thread_description const& desc, error_code& ec)
-    {
-        if (HPX_UNLIKELY(!id))
-        {
-            HPX_THROWS_IF(ec, null_thread_id,
-                "hpx::threads::set_thread_description",
-                "null thread id encountered");
-            return util::thread_description();
-        }
-        if (&ec != &throws)
-            ec = make_success_code();
-
-        return get_thread_id_data(id)->set_description(desc);
-    }
-
-    util::thread_description get_thread_lco_description(
-        thread_id_type const& id, error_code& ec)
-    {
-        if (HPX_UNLIKELY(!id))
-        {
-            HPX_THROWS_IF(ec, null_thread_id,
-                "hpx::threads::get_thread_lco_description",
-                "null thread id encountered");
-            return nullptr;
-        }
-
-        if (&ec != &throws)
-            ec = make_success_code();
-
-        return get_thread_id_data(id)->get_lco_description();
-    }
-
-    util::thread_description set_thread_lco_description(
-        thread_id_type const& id, util::thread_description const& desc,
-        error_code& ec)
-    {
-        if (HPX_UNLIKELY(!id))
-        {
-            HPX_THROWS_IF(ec, null_thread_id,
-                "hpx::threads::set_thread_lco_description",
-                "null thread id encountered");
-            return nullptr;
-        }
-
-        if (&ec != &throws)
-            ec = make_success_code();
-
-        return get_thread_id_data(id)->set_lco_description(desc);
-    }
-
     ///////////////////////////////////////////////////////////////////////////
 #ifdef HPX_HAVE_THREAD_FULLBACKTRACE_ON_SUSPENSION
     char const* get_thread_backtrace(thread_id_type const& id, error_code& ec)
@@ -376,23 +312,6 @@ namespace hpx { namespace threads {
         return get_thread_id_data(id)->set_backtrace(bt);
     }
 
-    threads::executors::current_executor get_executor(
-        thread_id_type const& id, error_code& ec)
-    {
-        if (HPX_UNLIKELY(!id))
-        {
-            HPX_THROWS_IF(ec, null_thread_id, "hpx::threads::get_executor",
-                "null thread id encountered");
-            return executors::current_executor(nullptr);
-        }
-
-        if (&ec != &throws)
-            ec = make_success_code();
-
-        return executors::current_executor(
-            get_thread_id_data(id)->get_scheduler_base());
-    }
-
     threads::thread_pool_base* get_pool(
         thread_id_type const& id, error_code& ec)
     {
@@ -631,11 +550,6 @@ namespace hpx { namespace this_thread {
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    threads::executors::current_executor get_executor(error_code& ec)
-    {
-        return threads::get_executor(threads::get_self_id(), ec);
-    }
-
     threads::thread_pool_base* get_pool(error_code& ec)
     {
         return threads::get_pool(threads::get_self_id(), ec);
@@ -667,19 +581,6 @@ namespace hpx { namespace this_thread {
         bool sufficient_stack_space =
             std::size_t(remaining_stack) >= space_needed;
 
-        // We might find ourselves in the situation where we don't have enough
-        // stack space, but can't really schedule a new thread. In this sitation,
-        // it would be best to change the code that provoked this behaviour
-        // instead of dynamically schedule a new thread. A such, we throw an
-        // exception to point to that problem instead of silently hanging because
-        // the thread will never be executed.
-        if (!sufficient_stack_space &&
-            !hpx::threads::threadmanager_is(hpx::state::state_running))
-        {
-            HPX_THROW_EXCEPTION(invalid_status, "has_sufficient_stack_space",
-                "A potential stack overflow has been detected. Unable to "
-                "schedule new thread during startup/shutdown.");
-        }
         return sufficient_stack_space;
 #else
         return true;
diff --git a/src/runtime/threads/detail/thread_num_tss.cpp b/libs/threading_base/src/thread_num_tss.cpp
similarity index 74%
rename from src/runtime/threads/detail/thread_num_tss.cpp
rename to libs/threading_base/src/thread_num_tss.cpp
index 6eefa7c905..89e16f19b2 100644
--- a/src/runtime/threads/detail/thread_num_tss.cpp
+++ b/libs/threading_base/src/thread_num_tss.cpp
@@ -4,7 +4,9 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-#include <hpx/runtime/threads/detail/thread_num_tss.hpp>
+#include <hpx/config.hpp>
+#include <hpx/errors.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -15,13 +17,13 @@ namespace hpx { namespace threads { namespace detail {
     namespace {
         std::size_t& thread_num_tss()
         {
-            HPX_NATIVE_TLS std::size_t thread_num_tss_ = std::size_t(-1);
+            static thread_local std::size_t thread_num_tss_ = std::size_t(-1);
             return thread_num_tss_;
         }
 
         thread_pool& thread_pool_tss()
         {
-            HPX_NATIVE_TLS thread_pool thread_pool_tss_ = {
+            static thread_local thread_pool thread_pool_tss_ = {
                 std::uint16_t(-1), std::uint16_t(-1)};
             return thread_pool_tss_;
         }
@@ -55,3 +57,15 @@ namespace hpx { namespace threads { namespace detail {
     }
 
 }}}    // namespace hpx::threads::detail
+
+namespace hpx {
+    std::size_t get_worker_thread_num(error_code& ec)
+    {
+        return threads::detail::get_thread_num_tss();
+    }
+
+    std::size_t get_worker_thread_num()
+    {
+        return get_worker_thread_num(throws);
+    }
+}    // namespace hpx
diff --git a/src/runtime/threads/thread_pool_base.cpp b/libs/threading_base/src/thread_pool_base.cpp
similarity index 82%
rename from src/runtime/threads/thread_pool_base.cpp
rename to libs/threading_base/src/thread_pool_base.cpp
index f34a4459e6..9452d9ff88 100644
--- a/src/runtime/threads/thread_pool_base.cpp
+++ b/libs/threading_base/src/thread_pool_base.cpp
@@ -4,18 +4,17 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <hpx/affinity/affinity_data.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/runtime/get_worker_thread_num.hpp>
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
-#include <hpx/affinity/affinity_data.hpp>
-#include <hpx/runtime/threads/policies/callback_notifier.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/topology/topology.hpp>
-#include <hpx/state.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/hardware/timestamp.hpp>
+#include <hpx/threading_base/callback_notifier.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/scheduler_state.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
+#include <hpx/topology/topology.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -24,13 +23,10 @@
 #include <string>
 #include <thread>
 
-namespace hpx { namespace threads
-{
+namespace hpx { namespace threads {
     ///////////////////////////////////////////////////////////////////////////
-    thread_pool_base::thread_pool_base(
-        thread_pool_init_parameters const& init)
+    thread_pool_base::thread_pool_base(thread_pool_init_parameters const& init)
       : id_(init.index_, init.name_)
-      , mode_(init.mode_)
       , thread_offset_(init.thread_offset_)
       , affinity_data_(init.affinity_data_)
       , timestamp_scale_(1.0)
@@ -48,12 +44,12 @@ namespace hpx { namespace threads
         threads::resize(used_processing_units, hardware_concurrency());
 
         for (std::size_t thread_num = 0; thread_num < get_os_thread_count();
-            ++thread_num)
+             ++thread_num)
         {
             if (sched->get_state(thread_num).load() <= state_suspended)
             {
-                used_processing_units |=
-                    affinity_data_.get_pu_mask(topo, thread_num + get_thread_offset());
+                used_processing_units |= affinity_data_.get_pu_mask(
+                    topo, thread_num + get_thread_offset());
             }
         }
 
@@ -72,9 +68,10 @@ namespace hpx { namespace threads
         std::size_t active_os_thread_count = 0;
 
         for (std::size_t thread_num = 0; thread_num < get_os_thread_count();
-            ++thread_num)
+             ++thread_num)
         {
-            if (get_scheduler()->get_state(thread_num).load() <= state_suspended)
+            if (get_scheduler()->get_state(thread_num).load() <=
+                state_suspended)
             {
                 ++active_os_thread_count;
             }
@@ -112,10 +109,9 @@ namespace hpx { namespace threads
         }
     }
 
-    void thread_pool_base::init(std::size_t pool_threads,
-        std::size_t threads_offset)
+    void thread_pool_base::init(
+        std::size_t pool_threads, std::size_t threads_offset)
     {
         thread_offset_ = threads_offset;
     }
-}}
-
+}}    // namespace hpx::threads
diff --git a/libs/threading_base/tests/CMakeLists.txt b/libs/threading_base/tests/CMakeLists.txt
new file mode 100644
index 0000000000..980ed9cbb7
--- /dev/null
+++ b/libs/threading_base/tests/CMakeLists.txt
@@ -0,0 +1,44 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+include(HPX_Message)
+include(HPX_Option)
+
+if (NOT HPX_WITH_TESTS AND HPX_TOP_LEVEL)
+  hpx_set_option(HPX_THREADING_BASE_WITH_TESTS VALUE OFF FORCE)
+  return()
+endif()
+
+if (HPX_THREADING_BASE_WITH_TESTS)
+    if (HPX_WITH_TESTS_UNIT)
+      add_hpx_pseudo_target(tests.unit.modules.threading_base)
+      add_hpx_pseudo_dependencies(tests.unit.modules tests.unit.modules.threading_base)
+      add_subdirectory(unit)
+    endif()
+
+    if (HPX_WITH_TESTS_REGRESSIONS)
+      add_hpx_pseudo_target(tests.regressions.modules.threading_base)
+      add_hpx_pseudo_dependencies(tests.regressions.modules tests.regressions.modules.threading_base)
+      add_subdirectory(regressions)
+    endif()
+
+    if (HPX_WITH_TESTS_BENCHMARKS)
+      add_hpx_pseudo_target(tests.performance.modules.threading_base)
+      add_hpx_pseudo_dependencies(tests.performance.modules tests.performance.modules.threading_base)
+      add_subdirectory(performance)
+    endif()
+
+    if (HPX_WITH_TESTS_HEADERS)
+      add_hpx_header_tests(
+        modules.threading_base
+        HEADERS ${threading_base_headers}
+        HEADER_ROOT ${PROJECT_SOURCE_DIR}/include
+        EXCLUDE
+        "hpx/threading_base/thread_data_stackful.hpp"
+        "hpx/threading_base/thread_data_stackless.hpp"
+        DEPENDENCIES hpx_threading_base)
+    endif()
+endif()
diff --git a/libs/threading_base/tests/performance/CMakeLists.txt b/libs/threading_base/tests/performance/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/threading_base/tests/performance/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/threading_base/tests/regressions/CMakeLists.txt b/libs/threading_base/tests/regressions/CMakeLists.txt
new file mode 100644
index 0000000000..85718aa846
--- /dev/null
+++ b/libs/threading_base/tests/regressions/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
diff --git a/libs/threading_base/tests/unit/CMakeLists.txt b/libs/threading_base/tests/unit/CMakeLists.txt
new file mode 100644
index 0000000000..e050627465
--- /dev/null
+++ b/libs/threading_base/tests/unit/CMakeLists.txt
@@ -0,0 +1,5 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/libs/threadmanager/CMakeLists.txt b/libs/threadmanager/CMakeLists.txt
index f8824f19dc..d06a3da3cb 100644
--- a/libs/threadmanager/CMakeLists.txt
+++ b/libs/threadmanager/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.3.2 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -32,15 +32,20 @@ add_hpx_module(threadmanager
   DEPENDENCIES
     hpx_allocator_support
     hpx_assertion
+    hpx_command_line_handling
     hpx_concurrency
     hpx_coroutines
     hpx_errors
     hpx_execution
+    hpx_format
     hpx_functional
     hpx_hardware
+    hpx_io_service
     hpx_plugin
     hpx_program_options
     hpx_resource_partitioner
+    hpx_runtime_configuration
+    hpx_schedulers
     hpx_serialization
     hpx_topology
   CMAKE_SUBDIRS examples tests
diff --git a/libs/threadmanager/README.rst b/libs/threadmanager/README.rst
index 169436b6d2..adec845f14 100644
--- a/libs/threadmanager/README.rst
+++ b/libs/threadmanager/README.rst
@@ -13,4 +13,4 @@ thread_manager
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/thread_manager/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/thread_manager/docs/index.html>`__.
diff --git a/libs/threadmanager/include/hpx/threadmanager.hpp b/libs/threadmanager/include/hpx/threadmanager.hpp
index 43610627d4..253cb134f8 100644
--- a/libs/threadmanager/include/hpx/threadmanager.hpp
+++ b/libs/threadmanager/include/hpx/threadmanager.hpp
@@ -13,14 +13,14 @@
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/concurrency/spinlock.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 #include <hpx/resource_partitioner/detail/partitioner.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool.hpp>
-#include <hpx/runtime/threads/detail/thread_num_tss.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
 #include <hpx/state.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -271,7 +271,7 @@ namespace hpx { namespace threads {
         {
             for (auto& pool_iter : pools_)
             {
-                pool_iter->set_scheduler_mode(mode);
+                pool_iter->get_scheduler()->set_scheduler_mode(mode);
             }
         }
 
@@ -279,7 +279,7 @@ namespace hpx { namespace threads {
         {
             for (auto& pool_iter : pools_)
             {
-                pool_iter->add_scheduler_mode(mode);
+                pool_iter->get_scheduler()->add_scheduler_mode(mode);
             }
         }
 
@@ -289,7 +289,7 @@ namespace hpx { namespace threads {
         {
             for (auto& pool_iter : pools_)
             {
-                pool_iter->add_remove_scheduler_mode(
+                pool_iter->get_scheduler()->add_remove_scheduler_mode(
                     to_add_mode, to_remove_mode);
             }
         }
@@ -298,7 +298,7 @@ namespace hpx { namespace threads {
         {
             for (auto& pool_iter : pools_)
             {
-                pool_iter->remove_scheduler_mode(mode);
+                pool_iter->get_scheduler()->remove_scheduler_mode(mode);
             }
         }
 
diff --git a/libs/threadmanager/src/threadmanager.cpp b/libs/threadmanager/src/threadmanager.cpp
index fd9c756572..1a40bb9022 100644
--- a/libs/threadmanager/src/threadmanager.cpp
+++ b/libs/threadmanager/src/threadmanager.cpp
@@ -10,6 +10,8 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/concurrency/itt_notify.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/hardware/timestamp.hpp>
@@ -18,20 +20,20 @@
 #include <hpx/logging.hpp>
 #include <hpx/resource_partitioner/detail/partitioner.hpp>
 #include <hpx/runtime/thread_pool_helpers.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool.hpp>
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
 #include <hpx/runtime/threads/executors/current_executor.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
-#include <hpx/runtime/threads/policies/thread_queue_init_parameters.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/runtime/threads/thread_init_data.hpp>
 #include <hpx/runtime/threads/thread_pool_suspension_helpers.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/runtime_fwd.hpp>
+#include <hpx/schedulers.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool.hpp>
+#include <hpx/threading_base/set_thread_state.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_init_data.hpp>
+#include <hpx/threading_base/thread_queue_init_parameters.hpp>
 #include <hpx/threadmanager.hpp>
 #include <hpx/topology/topology.hpp>
-#include <hpx/util/command_line_handling.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -45,17 +47,6 @@
 #include <utility>
 #include <vector>
 
-#ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace threads { namespace policies {
-    ///////////////////////////////////////////////////////////////////////////
-    // We control whether to collect queue wait times using this global bool.
-    // It will be set by any of the related performance counters. Once set it
-    // stays set, thus no race conditions will occur.
-    HPX_EXPORT bool maintain_queue_wait_times = false;
-}}}    // namespace hpx::threads::policies
-#endif
-
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace detail {
 
@@ -192,6 +183,7 @@ namespace hpx { namespace threads {
         if (size == thread_stacksize_unknown)
             return "unknown";
 
+        // TODO: Hold on to reference of runtime_configuration.
         util::runtime_configuration const& rtcfg = hpx::get_config();
         if (rtcfg.get_stack_size(thread_stacksize_small) == size)
             size = thread_stacksize_small;
@@ -249,52 +241,51 @@ namespace hpx { namespace threads {
         std::size_t thread_offset = 0;
 
         std::size_t max_background_threads =
-            hpx::util::safe_lexical_cast<std::size_t>(
+            hpx::util::from_string<std::size_t>(
                 hpx::get_config_entry("hpx.max_background_threads",
                     (std::numeric_limits<std::size_t>::max)()));
         std::size_t const max_idle_loop_count =
-            hpx::util::safe_lexical_cast<std::int64_t>(hpx::get_config_entry(
+            hpx::util::from_string<std::int64_t>(hpx::get_config_entry(
                 "hpx.max_idle_loop_count", HPX_IDLE_LOOP_COUNT_MAX));
         std::size_t const max_busy_loop_count =
-            hpx::util::safe_lexical_cast<std::int64_t>(hpx::get_config_entry(
+            hpx::util::from_string<std::int64_t>(hpx::get_config_entry(
                 "hpx.max_busy_loop_count", HPX_BUSY_LOOP_COUNT_MAX));
 
         std::int64_t const max_thread_count =
-            hpx::util::safe_lexical_cast<std::int64_t>(
+            hpx::util::from_string<std::int64_t>(
                 hpx::get_config_entry("hpx.thread_queue.max_thread_count",
                     std::to_string(HPX_THREAD_QUEUE_MAX_THREAD_COUNT)));
         std::int64_t const min_tasks_to_steal_pending =
-            hpx::util::safe_lexical_cast<std::int64_t>(hpx::get_config_entry(
+            hpx::util::from_string<std::int64_t>(hpx::get_config_entry(
                 "hpx.thread_queue.min_tasks_to_steal_pending",
                 std::to_string(HPX_THREAD_QUEUE_MIN_TASKS_TO_STEAL_PENDING)));
         std::int64_t const min_tasks_to_steal_staged =
-            hpx::util::safe_lexical_cast<std::int64_t>(hpx::get_config_entry(
+            hpx::util::from_string<std::int64_t>(hpx::get_config_entry(
                 "hpx.thread_queue.min_tasks_to_steal_staged",
                 std::to_string(HPX_THREAD_QUEUE_MIN_TASKS_TO_STEAL_STAGED)));
         std::int64_t const min_add_new_count =
-            hpx::util::safe_lexical_cast<std::int64_t>(
+            hpx::util::from_string<std::int64_t>(
                 hpx::get_config_entry("hpx.thread_queue.min_add_new_count",
                     std::to_string(HPX_THREAD_QUEUE_MIN_ADD_NEW_COUNT)));
         std::int64_t const max_add_new_count =
-            hpx::util::safe_lexical_cast<std::int64_t>(
+            hpx::util::from_string<std::int64_t>(
                 hpx::get_config_entry("hpx.thread_queue.max_add_new_count",
                     std::to_string(HPX_THREAD_QUEUE_MAX_ADD_NEW_COUNT)));
         std::int64_t const min_delete_count =
-            hpx::util::safe_lexical_cast<std::int64_t>(
+            hpx::util::from_string<std::int64_t>(
                 hpx::get_config_entry("hpx.thread_queue.min_delete_count",
                     std::to_string(HPX_THREAD_QUEUE_MIN_DELETE_COUNT)));
         std::int64_t const max_delete_count =
-            hpx::util::safe_lexical_cast<std::int64_t>(
+            hpx::util::from_string<std::int64_t>(
                 hpx::get_config_entry("hpx.thread_queue.max_delete_count",
                     std::to_string(HPX_THREAD_QUEUE_MAX_DELETE_COUNT)));
         std::int64_t const max_terminated_threads =
-            hpx::util::safe_lexical_cast<std::int64_t>(
+            hpx::util::from_string<std::int64_t>(
                 hpx::get_config_entry("hpx.thread_queue.max_terminated_threads",
                     std::to_string(HPX_THREAD_QUEUE_MAX_TERMINATED_THREADS)));
-        double const max_idle_backoff_time =
-            hpx::util::safe_lexical_cast<double>(
-                hpx::get_config_entry("hpx.max_idle_backoff_time",
-                    std::to_string(HPX_IDLE_BACKOFF_TIME_MAX)));
+        double const max_idle_backoff_time = hpx::util::from_string<double>(
+            hpx::get_config_entry("hpx.max_idle_backoff_time",
+                std::to_string(HPX_IDLE_BACKOFF_TIME_MAX)));
 
         std::ptrdiff_t small_stacksize = get_stack_size(thread_stacksize_small);
         std::ptrdiff_t medium_stacksize =
@@ -884,7 +875,7 @@ namespace hpx { namespace threads {
     }
 
     ///////////////////////////////////////////////////////////////////////////
-    HPX_CONSTEXPR std::size_t all_threads = std::size_t(-1);
+    constexpr std::size_t all_threads = std::size_t(-1);
 
     std::int64_t threadmanager::get_queue_length(bool reset)
     {
@@ -1243,23 +1234,4 @@ namespace hpx { namespace threads {
             }
         }
     }
-
-    ///////////////////////////////////////////////////////////////////////////
-    std::int64_t get_thread_count(thread_state_enum state)
-    {
-        return get_thread_manager().get_thread_count(state);
-    }
-
-    std::int64_t get_thread_count(
-        thread_priority priority, thread_state_enum state)
-    {
-        return get_thread_manager().get_thread_count(state, priority);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    bool enumerate_threads(util::function_nonser<bool(thread_id_type)> const& f,
-        thread_state_enum state)
-    {
-        return get_thread_manager().enumerate_threads(f, state);
-    }
 }}    // namespace hpx::threads
diff --git a/libs/timing/CMakeLists.txt b/libs/timing/CMakeLists.txt
index 0056f47f99..d3bcf5469a 100644
--- a/libs/timing/CMakeLists.txt
+++ b/libs/timing/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
diff --git a/libs/timing/README.rst b/libs/timing/README.rst
index 7f41fb84a0..1b1285f801 100644
--- a/libs/timing/README.rst
+++ b/libs/timing/README.rst
@@ -13,4 +13,4 @@ timing
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/timing/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/timing/docs/index.html>`__.
diff --git a/libs/topology/CMakeLists.txt b/libs/topology/CMakeLists.txt
index e38481c46b..99bf5ea43b 100644
--- a/libs/topology/CMakeLists.txt
+++ b/libs/topology/CMakeLists.txt
@@ -1,10 +1,10 @@
-# Copyright (c) 2019 The STE||AR-Group
+# Copyright (c) 2019-2020 The STE||AR-Group
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
@@ -43,6 +43,7 @@ add_hpx_module(topology
     hpx_format
     hpx_logging
     hpx_type_support
+    hpx_util
     hpx::hwloc
   CMAKE_SUBDIRS examples tests
 )
diff --git a/libs/topology/README.rst b/libs/topology/README.rst
index 463aa5842a..541882802c 100644
--- a/libs/topology/README.rst
+++ b/libs/topology/README.rst
@@ -13,4 +13,4 @@ topology
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/topology/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/topology/docs/index.html>`__.
diff --git a/libs/topology/src/topology.cpp b/libs/topology/src/topology.cpp
index 6e1ac80578..d5e46ac018 100644
--- a/libs/topology/src/topology.cpp
+++ b/libs/topology/src/topology.cpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2008-2009 Chirag Dekate, Anshul Tandon
 //  Copyright (c) 2012-2013 Thomas Heller
 //
@@ -12,8 +12,7 @@
 #include <hpx/logging.hpp>
 #include <hpx/topology/cpu_mask.hpp>
 #include <hpx/topology/topology.hpp>
-
-#include <boost/io/ios_state.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 
 #include <cstddef>
 #include <iomanip>
@@ -924,7 +923,7 @@ namespace hpx { namespace threads {
     void topology::print_affinity_mask(std::ostream& os, std::size_t num_thread,
         mask_cref_type m, const std::string& pool_name) const
     {
-        boost::io::ios_flags_saver ifs(os);
+        hpx::util::ios_flags_saver ifs(os);
         bool first = true;
 
         for (std::size_t i = 0; i != num_of_pus_; ++i)
@@ -1313,7 +1312,8 @@ namespace hpx { namespace threads {
     namespace {
         hpx_hwloc_bitmap_wrapper& bitmap_storage()
         {
-            HPX_NATIVE_TLS hpx_hwloc_bitmap_wrapper bitmap_storage_(nullptr);
+            static thread_local hpx_hwloc_bitmap_wrapper bitmap_storage_(
+                nullptr);
 
             return bitmap_storage_;
         }
diff --git a/libs/type_support/CMakeLists.txt b/libs/type_support/CMakeLists.txt
index 01ef6f22ac..fb78841c1d 100644
--- a/libs/type_support/CMakeLists.txt
+++ b/libs/type_support/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(type_support_headers
   hpx/type_support/detail/wrap_int.hpp
@@ -14,6 +14,7 @@ set(type_support_headers
   hpx/type_support/identity.hpp
   hpx/type_support/lazy_conditional.hpp
   hpx/type_support/lazy_enable_if.hpp
+  hpx/type_support/pack.hpp
   hpx/type_support/static.hpp
   hpx/type_support/unwrap_ref.hpp
   hpx/type_support/unused.hpp
diff --git a/libs/type_support/README.rst b/libs/type_support/README.rst
index d21da5cd2f..1b375a057b 100644
--- a/libs/type_support/README.rst
+++ b/libs/type_support/README.rst
@@ -13,4 +13,4 @@ type_support
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/type_support/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/type_support/docs/index.html>`__.
diff --git a/libs/type_support/include/hpx/type_support/decay.hpp b/libs/type_support/include/hpx/type_support/decay.hpp
index 18b91753cb..4f25131c4e 100644
--- a/libs/type_support/include/hpx/type_support/decay.hpp
+++ b/libs/type_support/include/hpx/type_support/decay.hpp
@@ -5,16 +5,11 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #ifndef HPX_UTIL_DECAY_HPP
 #define HPX_UTIL_DECAY_HPP
 
 #include <hpx/config.hpp>
 
-#include <boost/ref.hpp>
-
 #include <functional>
 #include <type_traits>
 #include <utility>
@@ -33,12 +28,6 @@ namespace hpx { namespace util {
             typedef TD type;
         };
 
-        template <typename X>
-        struct decay_unwrap_impl<::boost::reference_wrapper<X>>
-        {
-            typedef X& type;
-        };
-
         template <typename X>
         struct decay_unwrap_impl<::std::reference_wrapper<X>>
         {
diff --git a/libs/type_support/include/hpx/type_support/detail/wrap_int.hpp b/libs/type_support/include/hpx/type_support/detail/wrap_int.hpp
index acaa9aeae8..36a817c3f9 100644
--- a/libs/type_support/include/hpx/type_support/detail/wrap_int.hpp
+++ b/libs/type_support/include/hpx/type_support/detail/wrap_int.hpp
@@ -13,7 +13,7 @@ namespace hpx { namespace traits { namespace detail {
     // wraps int so that int argument is favored over wrap_int
     struct wrap_int
     {
-        HPX_CONSTEXPR wrap_int(int) {}
+        constexpr wrap_int(int) {}
     };
 }}}    // namespace hpx::traits::detail
 
diff --git a/libs/type_support/include/hpx/type_support/pack.hpp b/libs/type_support/include/hpx/type_support/pack.hpp
new file mode 100644
index 0000000000..a0aa9343fb
--- /dev/null
+++ b/libs/type_support/include/hpx/type_support/pack.hpp
@@ -0,0 +1,202 @@
+//  Copyright (c) 2014-2020 Agustin Berge
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef HPX_UTIL_PACK_HPP
+#define HPX_UTIL_PACK_HPP
+
+#include <hpx/config.hpp>
+
+#include <cstddef>
+#include <type_traits>
+
+namespace hpx { namespace util {
+
+    template <typename... Ts>
+    struct pack
+    {
+        typedef pack type;
+        static const std::size_t size = sizeof...(Ts);
+    };
+
+    template <typename T, T... Vs>
+    struct pack_c
+    {
+        typedef pack_c type;
+        static const std::size_t size = sizeof...(Vs);
+    };
+
+    template <std::size_t... Is>
+    using index_pack = pack_c<std::size_t, Is...>;
+
+    ///////////////////////////////////////////////////////////////////////////
+    namespace detail {
+        template <typename Left, typename Right>
+        struct make_index_pack_join;
+
+        template <std::size_t... Left, std::size_t... Right>
+        struct make_index_pack_join<index_pack<Left...>, index_pack<Right...>>
+          : index_pack<Left..., (sizeof...(Left) + Right)...>
+        {
+        };
+    }    // namespace detail
+
+    template <std::size_t N>
+    struct make_index_pack
+#if defined(HPX_HAVE_BUILTIN_INTEGER_PACK)
+      : index_pack<__integer_pack(N)...>
+#elif defined(HPX_HAVE_BUILTIN_MAKE_INTEGER_SEQ)
+      : __make_integer_seq<pack_c, std::size_t, N>
+#else
+      : detail::make_index_pack_join<typename make_index_pack<N / 2>::type,
+            typename make_index_pack<N - N / 2>::type>
+#endif
+    {
+    };
+
+    template <>
+    struct make_index_pack<0> : pack_c<std::size_t>
+    {
+    };
+
+    template <>
+    struct make_index_pack<1> : index_pack<0>
+    {
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Workaround for clang bug [https://bugs.llvm.org/show_bug.cgi?id=35077]
+    namespace detail {
+        template <typename T>
+        struct is_true : std::integral_constant<bool, (bool) T::value>
+        {
+        };
+
+        template <typename T>
+        struct is_false : std::integral_constant<bool, !(bool) T::value>
+        {
+        };
+    }    // namespace detail
+
+    ///////////////////////////////////////////////////////////////////////////
+    namespace detail {
+        template <typename... Ts>
+        struct always_true : std::true_type
+        {
+        };
+
+        template <typename... Ts>
+        struct always_false : std::false_type
+        {
+        };
+
+        template <typename... Ts>
+        static std::false_type all_of(...);
+
+        template <typename... Ts>
+        static auto all_of(int) -> always_true<
+            typename std::enable_if<is_true<Ts>::value>::type...>;
+    }    // namespace detail
+
+    template <typename... Ts>
+    struct all_of : decltype(detail::all_of<Ts...>(0))
+    {
+    };
+
+    template <>
+    struct all_of<>    // <fake-type>
+      : std::true_type
+    {
+    };
+
+    namespace detail {
+        template <typename... Ts>
+        static std::true_type any_of(...);
+
+        template <typename... Ts>
+        static auto any_of(int) -> always_false<
+            typename std::enable_if<is_false<Ts>::value>::type...>;
+    }    // namespace detail
+
+    template <typename... Ts>
+    struct any_of : decltype(detail::any_of<Ts...>(0))
+    {
+    };
+
+    template <>
+    struct any_of<>    // <fake-type>
+      : std::false_type
+    {
+    };
+
+    template <typename... Ts>
+    struct none_of : std::integral_constant<bool, !any_of<Ts...>::value>
+    {
+    };
+
+    template <typename T, typename... Ts>
+    struct contains : any_of<std::is_same<T, Ts>...>
+    {
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    namespace detail {
+        struct empty
+        {
+        };
+
+#if defined(HPX_HAVE_BUILTIN_TYPE_PACK_ELEMENT)
+        template <std::size_t I, typename Ts, bool C = (I < Ts::size)>
+        struct at_index_impl
+        {
+            using type = empty;
+        };
+
+        template <std::size_t I, typename... Ts>
+        struct at_index_impl<I, pack<Ts...>, true>
+        {
+            using type = struct
+            {
+                using type = __type_pack_element<I, Ts...>;
+            };
+        };
+#else
+        template <std::size_t I, typename T>
+        struct indexed
+        {
+            typedef T type;
+        };
+
+        template <typename Ts, typename Is>
+        struct indexer;
+
+        template <typename... Ts, std::size_t... Is>
+        struct indexer<pack<Ts...>, pack_c<std::size_t, Is...>>
+          : indexed<Is, Ts>...
+        {
+        };
+
+        template <std::size_t I, typename Ts>
+        struct at_index_impl
+        {
+            static empty check_(...);
+
+            template <std::size_t J, typename T>
+            static indexed<J, T> check_(indexed<J, T> const&);
+
+            typedef decltype(check_<I>(
+                indexer<Ts, typename make_index_pack<Ts::size>::type>())) type;
+        };
+#endif
+    }    // namespace detail
+
+    template <std::size_t I, typename... Ts>
+    struct at_index : detail::at_index_impl<I, pack<Ts...>>::type
+    {
+    };
+
+}}    // namespace hpx::util
+
+#endif
diff --git a/libs/type_support/include/hpx/type_support/unused.hpp b/libs/type_support/include/hpx/type_support/unused.hpp
index 2789dab0fd..2685283128 100644
--- a/libs/type_support/include/hpx/type_support/unused.hpp
+++ b/libs/type_support/include/hpx/type_support/unused.hpp
@@ -25,25 +25,22 @@ namespace hpx { namespace util {
     ///////////////////////////////////////////////////////////////////////////
     struct unused_type
     {
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE unused_type() noexcept {}
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE unused_type() noexcept {}
 
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE unused_type(
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE unused_type(
             unused_type const&)
         {
         }
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE unused_type(unused_type&&)
-        {
-        }
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE unused_type(unused_type&&) {}
 
         template <typename T>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE unused_type(
-            T const&) noexcept
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE unused_type(T const&) noexcept
         {
         }
 
         template <typename T>
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE unused_type const&
-        operator=(T const&) const noexcept
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE unused_type const& operator=(
+            T const&) const noexcept
         {
             return *this;
         }
@@ -55,8 +52,8 @@ namespace hpx { namespace util {
             return *this;
         }
 
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE unused_type const&
-        operator=(unused_type const&) const noexcept
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE unused_type const& operator=(
+            unused_type const&) const noexcept
         {
             return *this;
         }
@@ -67,8 +64,8 @@ namespace hpx { namespace util {
             return *this;
         }
 
-        HPX_CONSTEXPR HPX_HOST_DEVICE HPX_FORCEINLINE unused_type const&
-        operator=(unused_type&&) const noexcept
+        constexpr HPX_HOST_DEVICE HPX_FORCEINLINE unused_type const& operator=(
+            unused_type&&) const noexcept
         {
             return *this;
         }
@@ -83,7 +80,7 @@ namespace hpx { namespace util {
 #if defined(HPX_MSVC_NVCC)
     HPX_CONSTANT
 #endif
-    HPX_CONSTEXPR_OR_CONST unused_type unused = unused_type();
+    constexpr unused_type unused = unused_type();
 }}    // namespace hpx::util
 
 //////////////////////////////////////////////////////////////////////////////
diff --git a/libs/type_support/include/hpx/type_support/unwrap_ref.hpp b/libs/type_support/include/hpx/type_support/unwrap_ref.hpp
index 062b129697..561bc59e6e 100644
--- a/libs/type_support/include/hpx/type_support/unwrap_ref.hpp
+++ b/libs/type_support/include/hpx/type_support/unwrap_ref.hpp
@@ -4,16 +4,11 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/ref.hpp
-// hpxinspect:nodeprecatedname:boost::reference_wrapper
-
 #if !defined(HPX_UTIL_UNWRAP_REF_JAN_05_2017_0356PM)
 #define HPX_UTIL_UNWRAP_REF_JAN_05_2017_0356PM
 
 #include <hpx/config.hpp>
 
-#include <boost/ref.hpp>
-
 #include <functional>
 
 namespace hpx { namespace util {
@@ -23,18 +18,6 @@ namespace hpx { namespace util {
         typedef T type;
     };
 
-    template <typename T>
-    struct unwrap_reference<boost::reference_wrapper<T>>
-    {
-        typedef T type;
-    };
-
-    template <typename T>
-    struct unwrap_reference<boost::reference_wrapper<T> const>
-    {
-        typedef T type;
-    };
-
     template <typename T>
     struct unwrap_reference<std::reference_wrapper<T>>
     {
diff --git a/libs/util/CMakeLists.txt b/libs/util/CMakeLists.txt
index fa97f72aab..29c03d786d 100644
--- a/libs/util/CMakeLists.txt
+++ b/libs/util/CMakeLists.txt
@@ -1,10 +1,10 @@
-# Copyright (c) 2019 The STE||AR-Group
+# Copyright (c) 2019-2020 The STE||AR-Group
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-cmake_minimum_required(VERSION 3.6.3 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
 
 set(util_headers
   hpx/util/detail/reserve.hpp
@@ -12,8 +12,9 @@ set(util_headers
   hpx/util/calculate_fanout.hpp
   hpx/util/get_and_reset_value.hpp
   hpx/util/insert_checked.hpp
+  hpx/util/ios_flags_saver.hpp
   hpx/util/manage_config.hpp
-  hpx/util/safe_lexical_cast.hpp
+  hpx/util/sed_transform.hpp
 )
 
 set(util_compat_headers
@@ -22,6 +23,7 @@ set(util_compat_headers
 
 set(util_sources
   manage_config.cpp
+  sed_transform.cpp
 )
 
 include(HPX_AddModule)
@@ -38,6 +40,7 @@ add_hpx_module(util
   DEPENDENCIES
     hpx_config
     hpx_concepts
+    hpx_format
     hpx_iterator_support
   CMAKE_SUBDIRS examples tests
 )
diff --git a/libs/util/README.rst b/libs/util/README.rst
index 70ad88df9b..3f15e8bbcb 100644
--- a/libs/util/README.rst
+++ b/libs/util/README.rst
@@ -12,4 +12,4 @@ util
 This library is part of HPX.
 
 Documentation can be found `here
-<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/util/docs/index.html>`__.
+<https://stellar-group.github.io/hpx-docs/latest/html/libs/util/docs/index.html>`__.
diff --git a/libs/util/include/hpx/util/get_entry_as.hpp b/libs/util/include/hpx/util/get_entry_as.hpp
new file mode 100644
index 0000000000..17fe8c9005
--- /dev/null
+++ b/libs/util/include/hpx/util/get_entry_as.hpp
@@ -0,0 +1,42 @@
+/*=============================================================================
+    Copyright (c) 2014 Anton Bikineev
+
+//  SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef HPX_UTIL_GET_ENTRY_AS_HPP
+#define HPX_UTIL_GET_ENTRY_AS_HPP
+
+#include <hpx/config.hpp>
+#include <hpx/util/from_string.hpp>
+
+#include <string>
+#include <type_traits>
+
+namespace hpx { namespace util {
+
+    template <typename DestType, typename Config,
+        typename std::enable_if<!std::is_same<DestType, std::string>::value,
+            bool>::type = false>
+    DestType get_entry_as(
+        Config const& config, std::string const& key, DestType const& dflt)
+    {
+        std::string const& entry = config.get_entry(key, "");
+        if (entry.empty())
+            return dflt;
+        return from_string<DestType>(entry, dflt);
+    }
+
+    template <typename DestType, typename Config,
+        typename std::enable_if<std::is_same<DestType, std::string>::value,
+            bool>::type = false>
+    DestType get_entry_as(
+        Config const& config, std::string const& key, DestType const& dflt)
+    {
+        return config.get_entry(key, dflt);
+    }
+
+}}    // namespace hpx::util
+
+#endif /*HPX_UTIL_GET_ENTRY_AS_HPP*/
diff --git a/libs/util/include/hpx/util/ios_flags_saver.hpp b/libs/util/include/hpx/util/ios_flags_saver.hpp
new file mode 100644
index 0000000000..a16fdecd20
--- /dev/null
+++ b/libs/util/include/hpx/util/ios_flags_saver.hpp
@@ -0,0 +1,52 @@
+//  Copyright (c) 2020 Hartmut Kaiser
+//  Copyright 2002, 2005 Daryle Walker
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#if !defined(HPX_UTIL_IOS_FLAGS_SAVER_HPP)
+#define HPX_UTIL_IOS_FLAGS_SAVER_HPP
+
+#include <ios>
+
+namespace hpx { namespace util {
+
+    // this is taken from the Boost.Io library
+    class ios_flags_saver
+    {
+    public:
+        typedef ::std::ios_base state_type;
+        typedef ::std::ios_base::fmtflags aspect_type;
+
+        explicit ios_flags_saver(state_type& s)
+          : s_save_(s)
+          , a_save_(s.flags())
+        {
+        }
+        ios_flags_saver(state_type& s, aspect_type const& a)
+          : s_save_(s)
+          , a_save_(s.flags(a))
+        {
+        }
+
+        ~ios_flags_saver()
+        {
+            restore();
+        }
+
+        ios_flags_saver(ios_flags_saver const&) = delete;
+        ios_flags_saver& operator=(ios_flags_saver const&) = delete;
+
+        void restore()
+        {
+            s_save_.flags(a_save_);
+        }
+
+    private:
+        state_type& s_save_;
+        aspect_type const a_save_;
+    };
+}}    // namespace hpx::util
+
+#endif
diff --git a/libs/util/include/hpx/util/manage_config.hpp b/libs/util/include/hpx/util/manage_config.hpp
index 57b38d02ef..cd81529525 100644
--- a/libs/util/include/hpx/util/manage_config.hpp
+++ b/libs/util/include/hpx/util/manage_config.hpp
@@ -8,7 +8,7 @@
 #define HPX_UTIL_MANAGE_CONFIG_APR_11_2012_0519PM
 
 #include <hpx/config.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <map>
 #include <string>
@@ -30,7 +30,7 @@ namespace hpx { namespace util {
         {
             map_type::const_iterator it = config_.find(key);
             if (it != config_.end())
-                return hpx::util::safe_lexical_cast<T>((*it).second, dflt);
+                return hpx::util::from_string<T>((*it).second, dflt);
             return dflt;
         }
 
diff --git a/libs/util/include/hpx/util/safe_lexical_cast.hpp b/libs/util/include/hpx/util/safe_lexical_cast.hpp
deleted file mode 100644
index 47eddee347..0000000000
--- a/libs/util/include/hpx/util/safe_lexical_cast.hpp
+++ /dev/null
@@ -1,52 +0,0 @@
-/*=============================================================================
-    Copyright (c) 2014 Anton Bikineev
-
-//  SPDX-License-Identifier: BSL-1.0
-    Distributed under the Boost Software License, Version 1.0. (See accompanying
-    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-=============================================================================*/
-#ifndef HPX_UTIL_SAFE_LEXICAL_CAST_HPP
-#define HPX_UTIL_SAFE_LEXICAL_CAST_HPP
-
-#include <hpx/config.hpp>
-
-#include <boost/lexical_cast.hpp>
-
-#include <string>
-#include <type_traits>
-
-namespace hpx { namespace util {
-    template <typename DestType, typename SrcType>
-    DestType safe_lexical_cast(
-        SrcType const& value, DestType const& dflt = DestType())
-    {
-        try
-        {
-            return boost::lexical_cast<DestType>(value);
-        }
-        catch (boost::bad_lexical_cast const&)
-        {
-            ;
-        }
-        return dflt;
-    }
-
-    template <typename DestType, typename Config>
-    typename std::enable_if<std::is_integral<DestType>::value, DestType>::type
-    get_entry_as(
-        Config const& config, std::string const& key, DestType const& dflt)
-    {
-        return safe_lexical_cast(config.get_entry(key, dflt), dflt);
-    }
-
-    template <typename DestType, typename Config>
-    DestType get_entry_as(
-        Config const& config, std::string const& key, std::string const& dflt)
-    {
-        return safe_lexical_cast(
-            config.get_entry(key, dflt), safe_lexical_cast<DestType>(dflt));
-    }
-
-}}    // namespace hpx::util
-
-#endif /*HPX_UTIL_SAFE_LEXICAL_CAST_HPP*/
diff --git a/libs/util/include/hpx/util/sed_transform.hpp b/libs/util/include/hpx/util/sed_transform.hpp
new file mode 100644
index 0000000000..18ef5b95b0
--- /dev/null
+++ b/libs/util/include/hpx/util/sed_transform.hpp
@@ -0,0 +1,74 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2011 Bryce Adelstein-Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#if !defined(HPX_EC1602ED_CCC2_471C_BC28_1DBB98902F40)
+#define HPX_EC1602ED_CCC2_471C_BC28_1DBB98902F40
+
+#include <hpx/config.hpp>
+
+#include <memory>
+#include <string>
+
+#if defined(HPX_MSVC_WARNING_PRAGMA)
+#pragma warning(push)
+#pragma warning(disable : 4251)
+#endif
+
+namespace hpx { namespace util {
+
+    /// Parse a sed command.
+    ///
+    /// \param input    [in] The content to parse.
+    /// \param search   [out] If the parsing is successful, this string is set to
+    ///                 the search expression.
+    /// \param search   [out] If the parsing is successful, this string is set to
+    ///                 the replace expression.
+    ///
+    /// \returns \a true if the parsing was successful, false otherwise.
+    ///
+    /// \note Currently, only supports search and replace syntax (s/search/replace/)
+    HPX_EXPORT bool parse_sed_expression(
+        std::string const& input, std::string& search, std::string& replace);
+
+    /// An unary function object which applies a sed command to its subject and
+    /// returns the resulting string.
+    ///
+    /// \note Currently, only supports search and replace syntax (s/search/replace/)
+    struct HPX_EXPORT sed_transform
+    {
+    private:
+        struct command;
+
+        std::shared_ptr<command> command_;
+
+    public:
+        sed_transform(std::string const& search, std::string const& replace);
+
+        sed_transform(std::string const& expression);
+
+        std::string operator()(std::string const& input) const;
+
+        explicit operator bool() const noexcept
+        {
+            // avoid compiler warning about conversion to bool
+            return command_.get() ? true : false;
+        }
+
+        bool operator!() const
+        {
+            return !command_.get();
+        }
+    };
+
+}}    // namespace hpx::util
+
+#if defined(HPX_MSVC_WARNING_PRAGMA)
+#pragma warning(pop)
+#endif
+
+#endif    // HPX_EC1602ED_CCC2_471C_BC28_1DBB98902F40
diff --git a/libs/util/src/sed_transform.cpp b/libs/util/src/sed_transform.cpp
new file mode 100644
index 0000000000..257c44dd5e
--- /dev/null
+++ b/libs/util/src/sed_transform.cpp
@@ -0,0 +1,110 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2011 Bryce Adelstein-Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#include <hpx/util/sed_transform.hpp>
+
+#include <memory>
+#include <regex>
+#include <string>
+
+namespace hpx { namespace util {
+
+    bool parse_sed_expression(
+        std::string const& input, std::string& search, std::string& replace)
+    {
+        if (input.size() <= 2)
+            return false;
+
+        // s/search/replace/
+        // ^^
+        if ('s' != input.at(0) || '/' != input.at(1))
+            return false;
+
+        std::string::size_type const search_begin = 2;
+        std::string::size_type search_end = search_begin;
+
+        // s/search/replace/
+        //   ^^^^^^
+        while (true)
+        {
+            // See if we're at the end of the string.
+            if ((input.size() - 1) < search_end)
+                return false;
+
+            // If this is an escape, then don't check the next character.
+            if ('\\' == input.at(search_end++))
+            {
+                // See if we're at the end of the string.
+                if ((input.size() - 1) < ++search_end)
+                    return false;
+            }
+
+            if ('/' == input.at(search_end))
+            {
+                --search_end;
+                break;
+            }
+        }
+
+        // s/search/replace/
+        //         ^
+        if ('/' != input.at(search_end + 1))
+            return false;
+
+        std::string::size_type const replace_begin = search_end + 2;
+        std::string::size_type replace_end = input.size() - 1;
+
+        // s/search/replace/
+        //                 ^ (optional)
+        if ('/' == input.at(replace_end))
+            --replace_end;
+
+        search = input.substr(search_begin, (search_end - search_begin) + 1);
+        replace =
+            input.substr(replace_begin, (replace_end - replace_begin) + 1);
+
+        return true;
+    }
+
+    struct sed_transform::command
+    {
+        command(std::string const& search, std::string const& replace)
+          : search_(search)
+          , replace_(replace)
+        {
+        }
+
+        std::regex search_;
+        std::string replace_;
+    };
+
+    sed_transform::sed_transform(
+        std::string const& search, std::string const& replace)
+      : command_(std::make_shared<command>(search, replace))
+    {
+    }
+
+    sed_transform::sed_transform(std::string const& expression)
+    {
+        std::string search, replace;
+
+        if (parse_sed_expression(expression, search, replace))
+            command_ = std::make_shared<command>(search, replace);
+    }
+
+    std::string sed_transform::operator()(std::string const& input) const
+    {
+        if (!command_)
+            return input;
+
+        return std::regex_replace(input, command_->search_, command_->replace_,
+            std::regex_constants::match_default |
+                std::regex_constants::format_sed);
+    }
+
+}}    // namespace hpx::util
diff --git a/libs/version/CMakeLists.txt b/libs/version/CMakeLists.txt
new file mode 100644
index 0000000000..985ddd0b90
--- /dev/null
+++ b/libs/version/CMakeLists.txt
@@ -0,0 +1,34 @@
+# Copyright (c) 2019 The STE||AR-Group
+#
+# SPDX-License-Identifier: BSL-1.0
+# Distributed under the Boost Software License, Version 1.0. (See accompanying
+# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+set(version_headers hpx/version.hpp)
+
+set(version_sources version.cpp)
+
+if(HPX_WITH_PARCELPORT_MPI)
+  set(mpi_dependencies hpx::mpi)
+endif()
+
+include(HPX_AddModule)
+add_hpx_module(version
+  COMPATIBILITY_HEADERS OFF
+  FORCE_LINKING_GEN
+  GLOBAL_HEADER_GEN OFF
+  SOURCES ${version_sources}
+  HEADERS ${version_headers}
+  DEPENDENCIES
+    hpx_config
+    hpx_prefix
+    hpx::hwloc
+    ${mpi_dependencies}
+  CMAKE_SUBDIRS
+)
+
+target_include_directories(hpx_version PRIVATE $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}>)
diff --git a/libs/version/README.rst b/libs/version/README.rst
new file mode 100644
index 0000000000..0520ce949f
--- /dev/null
+++ b/libs/version/README.rst
@@ -0,0 +1,16 @@
+
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+=======
+version
+=======
+
+This library is part of HPX.
+
+Documentation can be found `here
+<https://stellar-group.github.io/hpx/docs/sphinx/latest/html/libs/version/docs/index.html>`__.
diff --git a/libs/version/docs/index.rst b/libs/version/docs/index.rst
new file mode 100644
index 0000000000..9899b3508b
--- /dev/null
+++ b/libs/version/docs/index.rst
@@ -0,0 +1,13 @@
+..
+    Copyright (c) 2019 The STE||AR-Group
+
+    SPDX-License-Identifier: BSL-1.0
+    Distributed under the Boost Software License, Version 1.0. (See accompanying
+    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+.. _libs_version:
+
+=======
+version
+=======
+
diff --git a/hpx/version.hpp b/libs/version/include/hpx/version.hpp
similarity index 92%
rename from hpx/version.hpp
rename to libs/version/include/hpx/version.hpp
index 7447f91762..beee30dba3 100644
--- a/hpx/version.hpp
+++ b/libs/version/include/hpx/version.hpp
@@ -16,8 +16,7 @@
 #include <string>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx
-{
+namespace hpx {
     // Returns the major HPX version.
     HPX_EXPORT std::uint8_t major_version();
 
@@ -71,10 +70,6 @@ namespace hpx
 
     // Return the HPX configuration information
     HPX_EXPORT std::string configuration_string();
-
-    // Return the HPX runtime configuration information
-    HPX_EXPORT std::string runtime_configuration_string(
-        util::command_line_handling const& cfg);
-}
+}    // namespace hpx
 
 #endif
diff --git a/src/version.cpp b/libs/version/src/version.cpp
similarity index 66%
rename from src/version.cpp
rename to libs/version/src/version.cpp
index 6c789541a2..31a111e0ac 100644
--- a/src/version.cpp
+++ b/libs/version/src/version.cpp
@@ -8,26 +8,22 @@
 ////////////////////////////////////////////////////////////////////////////////
 
 #include <hpx/config.hpp>
-#include <hpx/config/version.hpp>
 #include <hpx/config/config_strings.hpp>
-
-#if defined(HPX_HAVE_PARCELPORT_MPI)
-// Intel MPI does not like to be included after stdio.h. As such, we include mpi.h
-// as soon as possible.
-#include <hpx/plugins/parcelport/mpi/mpi.hpp>
-#endif
-
-#include <hpx/errors.hpp>
-#include <hpx/preprocessor/stringize.hpp>
-#include <hpx/runtime_fwd.hpp>
-#include <hpx/util/command_line_handling.hpp>
-#include <hpx/util/find_prefix.hpp>
+#include <hpx/config/version.hpp>
 #include <hpx/format.hpp>
+#include <hpx/prefix/find_prefix.hpp>
+#include <hpx/preprocessor/stringize.hpp>
 #include <hpx/version.hpp>
 
 #include <boost/config.hpp>
 #include <boost/version.hpp>
 
+#if defined(HPX_HAVE_PARCELPORT_MPI)
+// Intel MPI does not like to be included after stdio.h. As such, we include mpi.h
+// as soon as possible.
+#include <mpi.h>
+#endif
+
 #include <hwloc.h>
 
 #include <cstdint>
@@ -35,8 +31,7 @@
 #include <string>
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx
-{
+namespace hpx {
     std::uint8_t major_version()
     {
         return HPX_VERSION_MAJOR;
@@ -59,10 +54,8 @@ namespace hpx
 
     std::string full_version_as_string()
     {
-        return hpx::util::format("{}.{}.{}", //-V609
-            HPX_VERSION_MAJOR,
-            HPX_VERSION_MINOR,
-            HPX_VERSION_SUBMINOR);
+        return hpx::util::format("{}.{}.{}",    //-V609
+            HPX_VERSION_MAJOR, HPX_VERSION_MINOR, HPX_VERSION_SUBMINOR);
     }
 
     std::uint8_t agas_version()
@@ -82,8 +75,8 @@ namespace hpx
 
         // add type and library version
 #if defined(OPEN_MPI)
-        strm << "OpenMPI V" << OMPI_MAJOR_VERSION << "."
-             << OMPI_MINOR_VERSION << "." << OMPI_RELEASE_VERSION;
+        strm << "OpenMPI V" << OMPI_MAJOR_VERSION << "." << OMPI_MINOR_VERSION
+             << "." << OMPI_RELEASE_VERSION;
 #elif defined(MPICH)
         strm << "MPICH V" << MPICH_VERSION;
 #elif defined(MVAPICH2_VERSION)
@@ -108,12 +101,12 @@ namespace hpx
             "(A general purpose parallel C++ runtime system for distributed "
             "applications\n"
             "of any scale).\n\n"
-            "Copyright (c) 2007-2019, The STE||AR Group,\n"
+            "Copyright (c) 2007-2020, The STE||AR Group,\n"
             "http://stellar-group.org, email:hpx-users@stellar.cct.lsu.edu\n\n"
-//  SPDX-License-Identifier: BSL-1.0
             "Distributed under the Boost Software License, "
             "Version 1.0. (See accompanying\n"
-            "file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n";
+            "file LICENSE_1_0.txt or copy at "
+            "http://www.boost.org/LICENSE_1_0.txt)\n";
         return copyright;
     }
 
@@ -121,8 +114,9 @@ namespace hpx
     std::string full_build_string()
     {
         std::ostringstream strm;
-        strm << "{config}:\n" << configuration_string()
-             << "{version}: " << build_string() << "\n"
+        strm << "{config}:\n"
+             << configuration_string() << "{version}: " << build_string()
+             << "\n"
              << "{boost}: " << boost_version() << "\n"
              << "{build-type}: " << build_type() << "\n"
              << "{date}: " << build_date_time() << "\n"
@@ -155,22 +149,23 @@ namespace hpx
         strm << "\n";
 
 #if defined(HPX_PARCEL_MAX_CONNECTIONS)
-        strm << "  HPX_PARCEL_MAX_CONNECTIONS="
-             << HPX_PARCEL_MAX_CONNECTIONS << "\n";
+        strm << "  HPX_PARCEL_MAX_CONNECTIONS=" << HPX_PARCEL_MAX_CONNECTIONS
+             << "\n";
 #endif
 #if defined(HPX_PARCEL_MAX_CONNECTIONS_PER_LOCALITY)
         strm << "  HPX_PARCEL_MAX_CONNECTIONS_PER_LOCALITY="
              << HPX_PARCEL_MAX_CONNECTIONS_PER_LOCALITY << "\n";
 #endif
 #if defined(HPX_AGAS_LOCAL_CACHE_SIZE)
-        strm << "  HPX_AGAS_LOCAL_CACHE_SIZE="
-             << HPX_AGAS_LOCAL_CACHE_SIZE << "\n";
+        strm << "  HPX_AGAS_LOCAL_CACHE_SIZE=" << HPX_AGAS_LOCAL_CACHE_SIZE
+             << "\n";
 #endif
 #if defined(HPX_HAVE_MALLOC)
         strm << "  HPX_HAVE_MALLOC=" << HPX_HAVE_MALLOC << "\n";
 #endif
 
-        if (get_runtime_ptr() == nullptr)
+        const char* prefix = util::hpx_prefix();
+        if (prefix == nullptr)
         {
             strm << "  HPX_PREFIX (configured)=unknown\n";
 #if !defined(__ANDROID__) && !defined(ANDROID) && !defined(__MIC)
@@ -179,7 +174,7 @@ namespace hpx
         }
         else
         {
-            strm << "  HPX_PREFIX (configured)=" << util::hpx_prefix() << "\n";
+            strm << "  HPX_PREFIX (configured)=" << prefix << "\n";
 #if !defined(__ANDROID__) && !defined(ANDROID) && !defined(__MIC)
             strm << "  HPX_PREFIX=" << util::find_prefix() << "\n";
 #endif
@@ -203,28 +198,23 @@ namespace hpx
 
     std::string build_string()
     {
-        return hpx::util::format("V{}{} (AGAS: V{}.{}), Git: {:.10}", //-V609
-            full_version_as_string(), HPX_VERSION_TAG,
-            HPX_AGAS_VERSION / 0x10, HPX_AGAS_VERSION % 0x10,
-            HPX_HAVE_GIT_COMMIT);
+        return hpx::util::format("V{}{} (AGAS: V{}.{}), Git: {:.10}",    //-V609
+            full_version_as_string(), HPX_VERSION_TAG, HPX_AGAS_VERSION / 0x10,
+            HPX_AGAS_VERSION % 0x10, HPX_HAVE_GIT_COMMIT);
     }
 
     std::string boost_version()
     {
         // BOOST_VERSION: 105800
-        return hpx::util::format("V{}.{}.{}",
-            BOOST_VERSION / 100000,
-            BOOST_VERSION / 100 % 1000,
-            BOOST_VERSION % 100);
+        return hpx::util::format("V{}.{}.{}", BOOST_VERSION / 100000,
+            BOOST_VERSION / 100 % 1000, BOOST_VERSION % 100);
     }
 
     std::string hwloc_version()
     {
         // HWLOC_API_VERSION: 0x00010700
-        return hpx::util::format("V{}.{}.{}",
-            HWLOC_API_VERSION / 0x10000,
-            HWLOC_API_VERSION / 0x100 % 0x100,
-            HWLOC_API_VERSION % 0x100);
+        return hpx::util::format("V{}.{}.{}", HWLOC_API_VERSION / 0x10000,
+            HWLOC_API_VERSION / 0x100 % 0x100, HWLOC_API_VERSION % 0x100);
     }
 
 #if defined(HPX_HAVE_MALLOC)
@@ -251,31 +241,25 @@ namespace hpx
 
     std::string complete_version()
     {
-        std::string version = hpx::util::format(
-            "Versions:\n"
-            "  HPX: {}\n"
-            "  Boost: {}\n"
-            "  Hwloc: {}\n"
+        std::string version = hpx::util::format("Versions:\n"
+                                                "  HPX: {}\n"
+                                                "  Boost: {}\n"
+                                                "  Hwloc: {}\n"
 #if defined(HPX_HAVE_PARCELPORT_MPI)
-            "  MPI: {}\n"
+                                                "  MPI: {}\n"
 #endif
-            "\n"
-            "Build:\n"
-            "  Type: {}\n"
-            "  Date: {}\n"
-            "  Platform: {}\n"
-            "  Compiler: {}\n"
-            "  Standard Library: {}\n",
-            build_string(),
-            boost_version(),
-            hwloc_version(),
+                                                "\n"
+                                                "Build:\n"
+                                                "  Type: {}\n"
+                                                "  Date: {}\n"
+                                                "  Platform: {}\n"
+                                                "  Compiler: {}\n"
+                                                "  Standard Library: {}\n",
+            build_string(), boost_version(), hwloc_version(),
 #if defined(HPX_HAVE_PARCELPORT_MPI)
             mpi_version(),
 #endif
-            build_type(),
-            build_date_time(),
-            boost_platform(),
-            boost_compiler(),
+            build_type(), build_date_time(), boost_platform(), boost_compiler(),
             boost_stdlib());
 
 #if defined(HPX_HAVE_MALLOC)
@@ -292,29 +276,6 @@ namespace hpx
 
     std::string build_date_time()
     {
-        return std::string(__DATE__)  + " " + __TIME__;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    std::string runtime_configuration_string(
-        util::command_line_handling const& cfg)
-    {
-        std::ostringstream strm;
-
-        // runtime mode
-        strm << "  {mode}: " << get_runtime_mode_name(cfg.rtcfg_.mode_) << "\n";
-
-        if (cfg.num_localities_ != 1)
-            strm << "  {localities}: " << cfg.num_localities_ << "\n";
-
-        // default scheduler used for this run
-        strm << "  {scheduler}: " << cfg.queuing_ << "\n";
-
-        // amount of threads and cores configured for this run
-        strm << "  {os-threads}: " << cfg.num_threads_ << "\n";
-        strm << "  {cores}: " << cfg.num_cores_ << "\n";
-
-        return strm.str();
+        return std::string(__DATE__) + " " + __TIME__;
     }
-}
-
+}    // namespace hpx
diff --git a/plugins/binary_filter/bzip2/CMakeLists.txt b/plugins/binary_filter/bzip2/CMakeLists.txt
index bca240c51c..02d485f2e0 100644
--- a/plugins/binary_filter/bzip2/CMakeLists.txt
+++ b/plugins/binary_filter/bzip2/CMakeLists.txt
@@ -19,23 +19,29 @@ if(HPX_WITH_COMPRESSION_BZIP2)
 
   hpx_debug("add_bzip2_module" "BZIP2_FOUND: ${BZIP2_FOUND}")
 
-  add_hpx_library(compress_bzip2
+  set(SOURCE_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/src")
+  set(HEADER_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/include")
+
+  add_hpx_library(compression_bzip2
     INTERNAL_FLAGS
     PLUGIN
     SOURCES
-      "${PROJECT_SOURCE_DIR}/plugins/binary_filter/bzip2/bzip2_serialization_filter.cpp"
+      "${SOURCE_ROOT}/bzip2_serialization_filter.cpp"
     HEADERS
-      "${PROJECT_SOURCE_DIR}/hpx/plugins/binary_filter/bzip2_serialization_filter.hpp"
-      "${PROJECT_SOURCE_DIR}/hpx/plugins/binary_filter/bzip2_serialization_filter_registration.hpp"
+      "${HEADER_ROOT}/hpx/include/compression_bzip2.hpp"
+      "${HEADER_ROOT}/hpx/plugins/binary_filter/bzip2_serialization_filter.hpp"
+      "${HEADER_ROOT}/hpx/plugins/binary_filter/bzip2_serialization_filter_registration.hpp"
     FOLDER "Core/Plugins/Compression"
     DEPENDENCIES ${BZIP2_LIBRARIES})
 
   if(NOT MSVC)
-    target_include_directories(compress_bzip2 SYSTEM PRIVATE ${BZIP2_INCLUDE_DIR})
+    target_include_directories(compression_bzip2 SYSTEM PRIVATE ${BZIP2_INCLUDE_DIR})
   endif()
 
-  target_link_libraries(compress_bzip2 PRIVATE hpx::boost::iostreams)
+  target_include_directories(compression_bzip2 PUBLIC
+    $<BUILD_INTERFACE:${HEADER_ROOT}>)
+  target_link_libraries(compression_bzip2 PUBLIC hpx::boost::iostreams)
 
-  add_hpx_pseudo_dependencies(plugins.binary_filter.bzip2 compress_bzip2)
+  add_hpx_pseudo_dependencies(plugins.binary_filter.bzip2 compression_bzip2)
   add_hpx_pseudo_dependencies(core plugins.binary_filter.bzip2)
 endif()
diff --git a/hpx/include/compression_bzip2.hpp b/plugins/binary_filter/bzip2/include/hpx/include/compression_bzip2.hpp
similarity index 51%
rename from hpx/include/compression_bzip2.hpp
rename to plugins/binary_filter/bzip2/include/hpx/include/compression_bzip2.hpp
index 747151c355..482a1dfb26 100644
--- a/hpx/include/compression_bzip2.hpp
+++ b/plugins/binary_filter/bzip2/include/hpx/include/compression_bzip2.hpp
@@ -10,5 +10,17 @@
 #include <hpx/config.hpp>
 #include <hpx/plugins/binary_filter/bzip2_serialization_filter.hpp>
 
+#if defined(HPX_HAVE_DEPRECATION_WARNINGS)
+  #if defined(HPX_MSVC)
+  #pragma message("The header hpx/include/compression_bzip2.hpp is deprecated, \
+    please include \
+    hpx/plugins/binary_filter/bzip2_serialization_filter.hpp instead")
+  #else
+  #warning "The header hpx/include/compression_bzip2.hpp is deprecated, \
+    please include \
+   hpx/plugins/binary_filter/bzip2_serialization_filter.hpp instead"
+  #endif
+#endif
+
 #endif
 
diff --git a/hpx/plugins/binary_filter/bzip2_serialization_filter.hpp b/plugins/binary_filter/bzip2/include/hpx/plugins/binary_filter/bzip2_serialization_filter.hpp
similarity index 100%
rename from hpx/plugins/binary_filter/bzip2_serialization_filter.hpp
rename to plugins/binary_filter/bzip2/include/hpx/plugins/binary_filter/bzip2_serialization_filter.hpp
diff --git a/hpx/plugins/binary_filter/bzip2_serialization_filter_registration.hpp b/plugins/binary_filter/bzip2/include/hpx/plugins/binary_filter/bzip2_serialization_filter_registration.hpp
similarity index 100%
rename from hpx/plugins/binary_filter/bzip2_serialization_filter_registration.hpp
rename to plugins/binary_filter/bzip2/include/hpx/plugins/binary_filter/bzip2_serialization_filter_registration.hpp
diff --git a/plugins/binary_filter/bzip2/bzip2_serialization_filter.cpp b/plugins/binary_filter/bzip2/src/bzip2_serialization_filter.cpp
similarity index 100%
rename from plugins/binary_filter/bzip2/bzip2_serialization_filter.cpp
rename to plugins/binary_filter/bzip2/src/bzip2_serialization_filter.cpp
diff --git a/plugins/binary_filter/snappy/CMakeLists.txt b/plugins/binary_filter/snappy/CMakeLists.txt
index a9557d5fd2..46449fd32c 100644
--- a/plugins/binary_filter/snappy/CMakeLists.txt
+++ b/plugins/binary_filter/snappy/CMakeLists.txt
@@ -12,28 +12,34 @@ if(HPX_WITH_COMPRESSION_SNAPPY)
     hpx_error("Snappy could not be found and HPX_WITH_COMPRESSION_SNAPPY=ON, please specify SNAPPY_ROOT to point to the correct location or set HPX_WITH_COMPRESSION_SNAPPY to OFF")
   endif()
 
+  set(SOURCE_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/src")
+  set(HEADER_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/include")
+
   hpx_debug("add_snappy_module" "SNAPPY_FOUND: ${SNAPPY_FOUND}")
-  add_hpx_library(compress_snappy
+  add_hpx_library(compression_snappy
     INTERNAL_FLAGS
     PLUGIN
     SOURCES
-      "${PROJECT_SOURCE_DIR}/plugins/binary_filter/snappy/snappy_serialization_filter.cpp"
+      "${SOURCE_ROOT}/snappy_serialization_filter.cpp"
     HEADERS
-      "${PROJECT_SOURCE_DIR}/hpx/plugins/binary_filter/snappy_serialization_filter.hpp"
-      "${PROJECT_SOURCE_DIR}/hpx/plugins/binary_filter/snappy_serialization_filter_registration.hpp"
+      "${HEADER_ROOT}/hpx/include/compression_snappy.hpp"
+      "${HEADER_ROOT}/hpx/plugins/binary_filter/snappy_serialization_filter.hpp"
+      "${HEADER_ROOT}/hpx/plugins/binary_filter/snappy_serialization_filter_registration.hpp"
     FOLDER "Core/Plugins/Compression"
     DEPENDENCIES ${SNAPPY_LIBRARY})
 
-  target_include_directories(compress_snappy SYSTEM PRIVATE ${SNAPPY_INCLUDE_DIR})
+  target_include_directories(compression_snappy SYSTEM PRIVATE ${SNAPPY_INCLUDE_DIR})
+  target_include_directories(compression_snappy PUBLIC
+    $<BUILD_INTERFACE:${HEADER_ROOT}>)
 
   # FIXME: target_link_directories only exists for CMake >= 3.13
   if(MSVC)
-    target_link_directories(compress_snappy PRIVATE ${SNAPPY_LIBRARY_DIR})
+    target_link_directories(compression_snappy PRIVATE ${SNAPPY_LIBRARY_DIR})
   endif()
 
-  target_link_libraries(compress_snappy PRIVATE hpx::boost::iostreams)
+  target_link_libraries(compression_snappy PUBLIC hpx::boost::iostreams)
 
-  add_hpx_pseudo_dependencies(plugins.binary_filter.snappy compress_snappy)
+  add_hpx_pseudo_dependencies(plugins.binary_filter.snappy compression_snappy)
   add_hpx_pseudo_dependencies(core plugins.binary_filter.snappy)
 endif()
 
diff --git a/hpx/include/compression_snappy.hpp b/plugins/binary_filter/snappy/include/hpx/include/compression_snappy.hpp
similarity index 50%
rename from hpx/include/compression_snappy.hpp
rename to plugins/binary_filter/snappy/include/hpx/include/compression_snappy.hpp
index dd979e7fe7..b5001c095f 100644
--- a/hpx/include/compression_snappy.hpp
+++ b/plugins/binary_filter/snappy/include/hpx/include/compression_snappy.hpp
@@ -10,5 +10,17 @@
 #include <hpx/config.hpp>
 #include <hpx/plugins/binary_filter/snappy_serialization_filter.hpp>
 
+#if defined(HPX_HAVE_DEPRECATION_WARNINGS)
+  #if defined(HPX_MSVC)
+  #pragma message("The header hpx/include/compression_snappy.hpp is deprecated, \
+    please include \
+    hpx/plugins/binary_filter/snappy_serialization_filter.hpp instead")
+  #else
+  #warning "The header hpx/include/compression_snappy.hpp is deprecated, \
+    please include \
+   hpx/plugins/binary_filter/snappy_serialization_filter.hpp instead"
+  #endif
+#endif
+
 #endif
 
diff --git a/hpx/plugins/binary_filter/snappy_serialization_filter.hpp b/plugins/binary_filter/snappy/include/hpx/plugins/binary_filter/snappy_serialization_filter.hpp
similarity index 100%
rename from hpx/plugins/binary_filter/snappy_serialization_filter.hpp
rename to plugins/binary_filter/snappy/include/hpx/plugins/binary_filter/snappy_serialization_filter.hpp
diff --git a/hpx/plugins/binary_filter/snappy_serialization_filter_registration.hpp b/plugins/binary_filter/snappy/include/hpx/plugins/binary_filter/snappy_serialization_filter_registration.hpp
similarity index 100%
rename from hpx/plugins/binary_filter/snappy_serialization_filter_registration.hpp
rename to plugins/binary_filter/snappy/include/hpx/plugins/binary_filter/snappy_serialization_filter_registration.hpp
diff --git a/plugins/binary_filter/snappy/snappy_serialization_filter.cpp b/plugins/binary_filter/snappy/src/snappy_serialization_filter.cpp
similarity index 100%
rename from plugins/binary_filter/snappy/snappy_serialization_filter.cpp
rename to plugins/binary_filter/snappy/src/snappy_serialization_filter.cpp
diff --git a/plugins/binary_filter/zlib/CMakeLists.txt b/plugins/binary_filter/zlib/CMakeLists.txt
index e684089314..dcce815680 100644
--- a/plugins/binary_filter/zlib/CMakeLists.txt
+++ b/plugins/binary_filter/zlib/CMakeLists.txt
@@ -21,26 +21,31 @@ if(HPX_WITH_COMPRESSION_ZLIB)
   endif()
 
   hpx_debug("add_zlib_module" "ZLIB_FOUND: ${ZLIB_FOUND}")
+  set(HEADER_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/include")
+  set(SOURCE_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/src")
 
   include(HPX_AddLibrary)
-  add_hpx_library(compress_zlib
+  add_hpx_library(compression_zlib
     INTERNAL_FLAGS
     PLUGIN
     SOURCES
-      "${PROJECT_SOURCE_DIR}/plugins/binary_filter/zlib/zlib_serialization_filter.cpp"
+      "${SOURCE_ROOT}/zlib_serialization_filter.cpp"
     HEADERS
-      "${PROJECT_SOURCE_DIR}/hpx/plugins/binary_filter/zlib_serialization_filter.hpp"
-      "${PROJECT_SOURCE_DIR}/hpx/plugins/binary_filter/zlib_serialization_filter_registration.hpp"
+      "${HEADER_ROOT}/hpx/include/compression_zlib.hpp"
+      "${HEADER_ROOT}/hpx/plugins/binary_filter/zlib_serialization_filter.hpp"
+      "${HEADER_ROOT}/hpx/plugins/binary_filter/zlib_serialization_filter_registration.hpp"
     FOLDER "Core/Plugins/Compression"
     DEPENDENCIES ${ZLIB_LIBRARIES})
 
   if(NOT MSVC)
-    target_include_directories(compress_zlib SYSTEM PRIVATE ${ZLIB_INCLUDE_DIRS})
+    target_include_directories(compression_zlib SYSTEM PRIVATE ${ZLIB_INCLUDE_DIRS})
   endif()
+  target_include_directories(compression_zlib PUBLIC
+    $<BUILD_INTERFACE:${HEADER_ROOT}>)
 
-  target_link_libraries(compress_zlib PRIVATE hpx::boost::iostreams)
+  target_link_libraries(compression_zlib PUBLIC hpx::boost::iostreams)
 
-  add_hpx_pseudo_dependencies(plugins.binary_filter.zlib compress_zlib)
+  add_hpx_pseudo_dependencies(plugins.binary_filter.zlib compression_zlib)
   add_hpx_pseudo_dependencies(core plugins.binary_filter.zlib)
 
 endif()
diff --git a/hpx/include/compression_zlib.hpp b/plugins/binary_filter/zlib/include/hpx/include/compression_zlib.hpp
similarity index 51%
rename from hpx/include/compression_zlib.hpp
rename to plugins/binary_filter/zlib/include/hpx/include/compression_zlib.hpp
index f9ff0389c9..35e6333e1b 100644
--- a/hpx/include/compression_zlib.hpp
+++ b/plugins/binary_filter/zlib/include/hpx/include/compression_zlib.hpp
@@ -10,5 +10,17 @@
 #include <hpx/config.hpp>
 #include <hpx/plugins/binary_filter/zlib_serialization_filter.hpp>
 
+#if defined(HPX_HAVE_DEPRECATION_WARNINGS)
+  #if defined(HPX_MSVC)
+  #pragma message("The header hpx/include/compression_zlib.hpp is deprecated, \
+    please include \
+    hpx/plugins/binary_filter/zlib_serialization_filter.hpp instead")
+  #else
+  #warning "The header hpx/include/compression_zlib.hpp is deprecated, \
+    please include \
+    hpx/plugins/binary_filter/zlib_serialization_filter.hpp instead"
+  #endif
+#endif
+
 #endif
 
diff --git a/hpx/plugins/binary_filter/zlib_serialization_filter.hpp b/plugins/binary_filter/zlib/include/hpx/plugins/binary_filter/zlib_serialization_filter.hpp
similarity index 100%
rename from hpx/plugins/binary_filter/zlib_serialization_filter.hpp
rename to plugins/binary_filter/zlib/include/hpx/plugins/binary_filter/zlib_serialization_filter.hpp
diff --git a/hpx/plugins/binary_filter/zlib_serialization_filter_registration.hpp b/plugins/binary_filter/zlib/include/hpx/plugins/binary_filter/zlib_serialization_filter_registration.hpp
similarity index 100%
rename from hpx/plugins/binary_filter/zlib_serialization_filter_registration.hpp
rename to plugins/binary_filter/zlib/include/hpx/plugins/binary_filter/zlib_serialization_filter_registration.hpp
diff --git a/plugins/binary_filter/zlib/zlib_serialization_filter.cpp b/plugins/binary_filter/zlib/src/zlib_serialization_filter.cpp
similarity index 100%
rename from plugins/binary_filter/zlib/zlib_serialization_filter.cpp
rename to plugins/binary_filter/zlib/src/zlib_serialization_filter.cpp
diff --git a/plugins/parcel/coalescing/coalescing_message_handler.cpp b/plugins/parcel/coalescing/coalescing_message_handler.cpp
index 49af7c87ca..b1c34cee95 100644
--- a/plugins/parcel/coalescing/coalescing_message_handler.cpp
+++ b/plugins/parcel/coalescing/coalescing_message_handler.cpp
@@ -16,13 +16,13 @@
 #include <hpx/runtime/parcelset/parcelport.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
+#include <hpx/util/from_string.hpp>
 #include <hpx/util/get_and_reset_value.hpp>
 
 #include <hpx/plugins/message_handler_factory.hpp>
 #include <hpx/plugins/parcel/coalescing_message_handler.hpp>
 #include <hpx/plugins/parcel/coalescing_counter_registry.hpp>
 
-#include <boost/lexical_cast.hpp>
 #include <boost/accumulators/accumulators.hpp>
 
 #include <chrono>
@@ -69,14 +69,14 @@ namespace hpx { namespace plugins { namespace parcel
     {
         std::size_t get_num_messages(std::size_t num_messages)
         {
-            return boost::lexical_cast<std::size_t>(hpx::get_config_entry(
+            return hpx::util::from_string<std::size_t>(hpx::get_config_entry(
                 "hpx.plugins.coalescing_message_handler.num_messages",
                 num_messages));
         }
 
         std::size_t get_interval(std::size_t interval)
         {
-            return boost::lexical_cast<std::size_t>(hpx::get_config_entry(
+            return hpx::util::from_string<std::size_t>(hpx::get_config_entry(
                 "hpx.plugins.coalescing_message_handler.interval", interval));
         }
 
@@ -185,11 +185,7 @@ namespace hpx { namespace plugins { namespace parcel
 
         switch(s) {
         case detail::message_buffer::first_message:
-            // start deadline timer to flush buffer
-            l.unlock();
-            timer_.start(interval);
-            break;
-
+            HPX_FALLTHROUGH;
         case detail::message_buffer::normal:
             // start deadline timer to flush buffer
             l.unlock();
diff --git a/plugins/parcel/coalescing/performance_counters.cpp b/plugins/parcel/coalescing/performance_counters.cpp
index 9a91594c24..b20d1ca72a 100644
--- a/plugins/parcel/coalescing/performance_counters.cpp
+++ b/plugins/parcel/coalescing/performance_counters.cpp
@@ -7,20 +7,19 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_NETWORKING) && defined(HPX_HAVE_PARCEL_COALESCING)
+#include <hpx/functional/function.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
 #include <hpx/performance_counters/manage_counter_type.hpp>
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/runtime/components/component_startup_shutdown.hpp>
 #include <hpx/runtime/naming/name.hpp>
-#include <hpx/functional/function.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
 
 #include <hpx/plugins/parcel/coalescing_counter_registry.hpp>
 
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
-
 #include <cstdint>
 #include <exception>
 #include <string>
@@ -449,9 +448,9 @@ namespace hpx { namespace plugins { namespace parcel
 
                 // split parameters, extract separate values
                 std::vector<std::string> params;
-                boost::algorithm::split(params, paths.parameters_,
-                    boost::algorithm::is_any_of(","),
-                    boost::algorithm::token_compress_off);
+                hpx::string_util::split(params, paths.parameters_,
+                    hpx::string_util::is_any_of(","),
+                    hpx::string_util::token_compress_mode::off);
 
                 std::int64_t min_boundary = 0;
                 std::int64_t max_boundary = 1000000;  // 1ms
@@ -468,11 +467,11 @@ namespace hpx { namespace plugins { namespace parcel
                 }
 
                 if (params.size() > 1 && !params[1].empty())
-                    min_boundary = util::safe_lexical_cast<std::int64_t>(params[1]);
+                    min_boundary = util::from_string<std::int64_t>(params[1]);
                 if (params.size() > 2 && !params[2].empty())
-                    max_boundary = util::safe_lexical_cast<std::int64_t>(params[2]);
+                    max_boundary = util::from_string<std::int64_t>(params[2]);
                 if (params.size() > 3 && !params[3].empty())
-                    num_buckets = util::safe_lexical_cast<std::int64_t>(params[3]);
+                    num_buckets = util::from_string<std::int64_t>(params[3]);
 
                 // ask registry
                 hpx::util::function_nonser<std::vector<std::int64_t>(bool)> f =
diff --git a/plugins/parcelport/libfabric/CMakeLists.txt b/plugins/parcelport/libfabric/CMakeLists.txt
index b767cc1d4f..1bbb7c7758 100644
--- a/plugins/parcelport/libfabric/CMakeLists.txt
+++ b/plugins/parcelport/libfabric/CMakeLists.txt
@@ -28,10 +28,8 @@ if (HPX_WITH_PARCELPORT_LIBFABRIC)
     set(_libfabric_libraries hpx::libfabric hpx::pmi)
   else()
     add_library(hpx::gni INTERFACE IMPORTED)
-    set_property(TARGET hpx::gni PROPERTY
-      INTERFACE_INCLUDE_DIRECTORIES ${LIBFABRIC_INCLUDE_DIR})
-    set_property(TARGET hpx::gni PROPERTY
-      INTERFACE_LINK_LIBRARIES ${GNI_LIB})
+    target_include_directories(hpx::gni INTERFACE ${LIBFABRIC_INCLUDE_DIR})
+    target_link_libraries(hpx::gni INTERFACE ${GNI_LIB})
     set(_deps hpx::gni hpx::pmi)
 
     set(_libfabric_C_srcs
@@ -69,19 +67,22 @@ if (HPX_WITH_PARCELPORT_LIBFABRIC)
     # FIXME : Could this be private
     DEPENDENCIES
       ${_libfabric_libraries}
-      hpx_config
       hpx_allocator_support
+      hpx_asio
       hpx_assertion
       hpx_cache
       hpx_concurrency
+      hpx_config
       hpx_coroutines
       hpx_errors
       hpx_execution
       hpx_hardware
       hpx_memory
+      hpx_performance_counters
       hpx_plugin
       hpx_program_options
       hpx_serialization
+      hpx_threading
       hpx_threadmanager
       hpx_timing
       hpx_topology
diff --git a/plugins/parcelport/libfabric/header.hpp b/plugins/parcelport/libfabric/header.hpp
index cced4bbb35..37f1c6eb1c 100644
--- a/plugins/parcelport/libfabric/header.hpp
+++ b/plugins/parcelport/libfabric/header.hpp
@@ -31,7 +31,7 @@ namespace libfabric
     {
         typedef serialization::serialization_chunk chunktype;
 
-        // if chunks are not piggybacked, we must send an rma handle for chunk acccess
+        // if chunks are not piggybacked, we must send an rma handle for chunk access
         // and state how many other rma chunks need to be retrieved (since this is
         // normally stored in the missing chunk info)
         struct chunk_header {
@@ -50,7 +50,7 @@ namespace libfabric
         };
 
         // data we send if both message and chunk data are -not- piggybacked
-        // to store the rma information for the message (that otherwise whould be in
+        // to store the rma information for the message (that otherwise would be in
         // the chunk data)
         struct message_chunk {
             chunktype message_rma;
diff --git a/plugins/parcelport/libfabric/locality.hpp b/plugins/parcelport/libfabric/locality.hpp
index 13555c04e2..eedd5c0469 100644
--- a/plugins/parcelport/libfabric/locality.hpp
+++ b/plugins/parcelport/libfabric/locality.hpp
@@ -10,6 +10,7 @@
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/serialization/array.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 //
 #include <utility>
 #include <cstring>
@@ -17,7 +18,7 @@
 #include <array>
 #include <rdma/fabric.h>
 
-// Different providers use different address formats that we must accomodate
+// Different providers use different address formats that we must accommodate
 // in our locality object.
 #ifdef HPX_PARCELPORT_LIBFABRIC_GNI
 # define HPX_PARCELPORT_LIBFABRIC_LOCALITY_SIZE 48
@@ -171,7 +172,7 @@ private:
     }
 
     friend std::ostream & operator<<(std::ostream & os, locality const & loc) {
-        boost::io::ios_flags_saver ifs(os);
+        hpx::util::ios_flags_saver ifs(os);
         for (uint32_t i=0; i<array_length; ++i) {
             os << loc.data_[i];
         }
diff --git a/plugins/parcelport/libfabric/parcelport_libfabric.cpp b/plugins/parcelport/libfabric/parcelport_libfabric.cpp
index fdbc9e0ff5..e5b82a9d6c 100644
--- a/plugins/parcelport/libfabric/parcelport_libfabric.cpp
+++ b/plugins/parcelport/libfabric/parcelport_libfabric.cpp
@@ -12,10 +12,10 @@
 #include <hpx/config.hpp>
 // util
 #include <hpx/synchronization/condition_variable.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/timing/high_resolution_timer.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 
 // The memory pool specialization need to be pulled in before encode_parcels
 #include <hpx/plugins/parcelport_factory.hpp>
@@ -294,7 +294,7 @@ namespace libfabric
     }
 
     // --------------------------------------------------------------------
-    // the root node has spacial handlig, this returns its Id
+    // the root node has spacial handling, this returns its Id
     parcelset::locality parcelport::
     agas_locality(util::runtime_configuration const & ini) const
     {
diff --git a/plugins/parcelport/libfabric/parcelport_libfabric.hpp b/plugins/parcelport/libfabric/parcelport_libfabric.hpp
index d57163d2fb..c30950b648 100644
--- a/plugins/parcelport/libfabric/parcelport_libfabric.hpp
+++ b/plugins/parcelport/libfabric/parcelport_libfabric.hpp
@@ -10,11 +10,11 @@
 // config
 #include <hpx/config.hpp>
 // util
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/format.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 #include <hpx/timing/high_resolution_timer.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 
 // The memory pool specialization need to be pulled in before encode_parcels
 #include <hpx/runtime.hpp>
diff --git a/plugins/parcelport/libfabric/receiver.cpp b/plugins/parcelport/libfabric/receiver.cpp
index 09102e335c..3c8cf53d31 100644
--- a/plugins/parcelport/libfabric/receiver.cpp
+++ b/plugins/parcelport/libfabric/receiver.cpp
@@ -17,7 +17,7 @@
 #include <hpx/runtime/parcelset/parcel_buffer.hpp>
 //
 #include <hpx/assertion.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 //
 #include <utility>
 #include <cstddef>
@@ -90,11 +90,11 @@ namespace libfabric
         static_assert(sizeof(std::uint64_t) == sizeof(std::size_t),
             "sizeof(std::uint64_t) != sizeof(std::size_t)");
 
-        // If we recieve a message of 8 bytes, we got a tag and need to handle
+        // If we receive a message of 8 bytes, we got a tag and need to handle
         // the tag completion...
         if (len <= sizeof(std::uint64_t))
         {
-            // @TODO: fixme immediate tag retreival
+            // @TODO: fixme immediate tag retrieval
             // Get the sender that has completed rma operations and signal to it
             // that it can now cleanup - all remote get operations are done.
             sender* snd = *reinterpret_cast<sender **>(header_region_->get_address());
@@ -117,7 +117,7 @@ namespace libfabric
                     // if the capacity overflowed, just delete this one
                     delete recv;
                 }
-                // Notify one possibly waiting reciever that one receive just finished
+                // Notify one possibly waiting receiver that one receive just finished
                 if (threads::threadmanager_is_at_least(state_running)
                     && hpx::threads::get_self_ptr())
                 {
diff --git a/plugins/parcelport/libfabric/receiver.hpp b/plugins/parcelport/libfabric/receiver.hpp
index 2dc34f0b98..224f604990 100644
--- a/plugins/parcelport/libfabric/receiver.hpp
+++ b/plugins/parcelport/libfabric/receiver.hpp
@@ -29,7 +29,7 @@ namespace libfabric
     // The receiver is responsible for handling incoming messages. For that purpose,
     // it posts receive buffers. Incoming messages can be of two kinds:
     //      1) An ACK message which has been sent from an rma_receiver, to signal
-    //         the sender about the succesful retreival of an incoming message.
+    //         the sender about the successful retrieval of an incoming message.
     //      2) An incoming parcel, that consists of an header and an eventually
     //         piggy backed message. If the message is not piggy backed or zero
     //         copy RMA chunks need to be read, a rma_receiver is created to
@@ -64,7 +64,7 @@ namespace libfabric
         // --------------------------------------------------------------------
         // the receiver posts a single receive buffer to the queue, attaching
         // itself as the context, so that when a message is received
-        // the owning reciever is called to handle processing of the buffer
+        // the owning receiver is called to handle processing of the buffer
         void pre_post_receive();
 
         // --------------------------------------------------------------------
diff --git a/plugins/parcelport/libfabric/rma_receiver.cpp b/plugins/parcelport/libfabric/rma_receiver.cpp
index 7f8c2d0f56..39e52899f4 100644
--- a/plugins/parcelport/libfabric/rma_receiver.cpp
+++ b/plugins/parcelport/libfabric/rma_receiver.cpp
@@ -12,7 +12,7 @@
 #include <hpx/runtime/parcelset/parcel_buffer.hpp>
 //
 #include <hpx/assertion.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 //
 #include <cstddef>
 #include <cstdint>
diff --git a/plugins/parcelport/libfabric/rma_receiver.hpp b/plugins/parcelport/libfabric/rma_receiver.hpp
index 484143dc31..2e6281d6b2 100644
--- a/plugins/parcelport/libfabric/rma_receiver.hpp
+++ b/plugins/parcelport/libfabric/rma_receiver.hpp
@@ -28,8 +28,8 @@ namespace libfabric
     struct parcelport;
 
 
-    // The rma_receiver is repsonsible for receiving the
-    // mising chunks of the message:
+    // The rma_receiver is responsible for receiving the
+    // missing chunks of the message:
     //      1) Non-piggy backed non-zero copy chunks (if existing)
     //      2) The zero copy chunks from serialization
     struct rma_receiver : public rma_base
@@ -55,7 +55,7 @@ namespace libfabric
 
         // --------------------------------------------------------------------
         // the main entry point when a message is received, this function
-        // will despatch to either read with or without rma depending on
+        // will dispatch to either read with or without rma depending on
         // whether there are zero copy chunks to handle
         void read_message(region_type* region, fi_addr_t const& src_addr);
 
diff --git a/plugins/parcelport/libfabric/sender.cpp b/plugins/parcelport/libfabric/sender.cpp
index d640a2c215..e1194b5f27 100644
--- a/plugins/parcelport/libfabric/sender.cpp
+++ b/plugins/parcelport/libfabric/sender.cpp
@@ -15,7 +15,7 @@
 #include <hpx/functional/unique_function.hpp>
 #include <hpx/thread_support/atomic_count.hpp>
 #include <hpx/timing/high_resolution_timer.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 //
 #include <rdma/fi_endpoint.h>
 //
diff --git a/plugins/parcelport/libfabric/sender.hpp b/plugins/parcelport/libfabric/sender.hpp
index ab8bf9f218..93e62cb2dd 100644
--- a/plugins/parcelport/libfabric/sender.hpp
+++ b/plugins/parcelport/libfabric/sender.hpp
@@ -109,7 +109,7 @@ namespace libfabric
         void handle_send_completion();
 
         // --------------------------------------------------------------------
-        // Triggered when the remote end has finished RMA opreations and
+        // Triggered when the remote end has finished RMA operations and
         // we can release resources
         void handle_message_completion_ack();
 
diff --git a/plugins/parcelport/mpi/CMakeLists.txt b/plugins/parcelport/mpi/CMakeLists.txt
index e22f1b51e2..e308d31a58 100644
--- a/plugins/parcelport/mpi/CMakeLists.txt
+++ b/plugins/parcelport/mpi/CMakeLists.txt
@@ -28,18 +28,21 @@ if(HPX_WITH_PARCELPORT_MPI)
       "${PROJECT_SOURCE_DIR}/hpx/plugins/parcelport/mpi/sender_connection.hpp"
       "${PROJECT_SOURCE_DIR}/hpx/plugins/parcelport/mpi/tag_provider.hpp"
     DEPENDENCIES
-      hpx_config
+      hpx_asio
       hpx_allocator_support
       hpx_cache
+      hpx_config
       hpx_concurrency
       hpx_coroutines
       hpx_execution
       hpx_filesystem
       hpx_hardware
       hpx_memory
+      hpx_performance_counters
       hpx_plugin
       hpx_program_options
       hpx_serialization
+      hpx_threading
       hpx_threadmanager
       hpx_timing
       hpx_topology
diff --git a/plugins/parcelport/mpi/mpi_environment.cpp b/plugins/parcelport/mpi/mpi_environment.cpp
index adf679b405..62ab751b41 100644
--- a/plugins/parcelport/mpi/mpi_environment.cpp
+++ b/plugins/parcelport/mpi/mpi_environment.cpp
@@ -12,11 +12,11 @@
 #include <hpx/plugins/parcelport/mpi/mpi.hpp>
 #endif
 
-#include <hpx/util/runtime_configuration.hpp>
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/util/get_entry_as.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/plugins/parcelport/mpi/mpi_environment.hpp>
 
-#include <boost/lexical_cast.hpp>
 #include <boost/tokenizer.hpp>
 
 #include <cstddef>
diff --git a/plugins/parcelport/mpi/parcelport_mpi.cpp b/plugins/parcelport/mpi/parcelport_mpi.cpp
index df4823c68e..5ca7fd9cf2 100644
--- a/plugins/parcelport/mpi/parcelport_mpi.cpp
+++ b/plugins/parcelport/mpi/parcelport_mpi.cpp
@@ -16,7 +16,7 @@
 
 #include <hpx/plugins/parcelport/mpi/mpi_environment.hpp>
 #include <hpx/plugins/parcelport_factory.hpp>
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 
 // parcelport
 #include <hpx/runtime.hpp>
@@ -31,11 +31,9 @@
 #include <hpx/plugins/parcelport/mpi/sender.hpp>
 #include <hpx/plugins/parcelport/mpi/receiver.hpp>
 
-#include <hpx/synchronization/detail/yield_k.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
-
-#include <boost/archive/basic_archive.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/util/get_entry_as.hpp>
 
 #include <atomic>
 #include <cstddef>
diff --git a/plugins/parcelport/parcelport_logging.hpp b/plugins/parcelport/parcelport_logging.hpp
index 50935d55f6..f06de7003b 100644
--- a/plugins/parcelport/parcelport_logging.hpp
+++ b/plugins/parcelport/parcelport_logging.hpp
@@ -17,7 +17,7 @@
 #include <hpx/config.hpp>
 #include <hpx/config/parcelport_defines.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 //
 #include <boost/preprocessor.hpp>
 #if defined(__linux) || defined(__linux__)
@@ -73,7 +73,7 @@
 // include files needed for boost::log
 // ------------------------------------------------------------------
 #ifdef HPX_PARCELPORT_LOGGING_INCLUDE_FILES
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <boost/log/expressions.hpp>
 #include <boost/log/expressions/formatter.hpp>
 #include <boost/log/expressions/formatters.hpp>
@@ -121,7 +121,7 @@ namespace hpx { namespace parcelset { namespace policies { namespace libfabric {
         }
 
         // ------------------------------------------------------------------
-        // helper fuction for printing CRC32
+        // helper function for printing CRC32
         // ------------------------------------------------------------------
         inline uint32_t crc32(const void* address, size_t length)
         {
@@ -131,7 +131,7 @@ namespace hpx { namespace parcelset { namespace policies { namespace libfabric {
         }
 
         // ------------------------------------------------------------------
-        // helper fuction for printing CRC32 and short memory dump
+        // helper function for printing CRC32 and short memory dump
         // ------------------------------------------------------------------
         inline std::string mem_crc32(
             const void* address, size_t length, const char* txt)
@@ -224,7 +224,7 @@ namespace hpx { namespace parcelset { namespace policies { namespace libfabric {
 
 // ------------------------------------------------------------------
 // Timed log macros : used during long loops to avoid excessive output
-// only prints the log messge every N seconds
+// only prints the log message every N seconds
 // ------------------------------------------------------------------
 #ifdef HPX_PARCELPORT_LOGGING_HAVE_TIMED_LOG
 
diff --git a/plugins/parcelport/readers_writers_mutex.hpp b/plugins/parcelport/readers_writers_mutex.hpp
index a18f7edc24..805f4914c2 100644
--- a/plugins/parcelport/readers_writers_mutex.hpp
+++ b/plugins/parcelport/readers_writers_mutex.hpp
@@ -12,7 +12,7 @@
 #define HPX_READERS_WRITERS_MUTEX_HPP
 
 #include <hpx/config.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <plugins/parcelport/parcelport_logging.hpp>
 
@@ -22,7 +22,7 @@
 # define RWL_DEBUG_MSG(x)
 #endif
 
-// Note that this implementaion uses 16bit counters so can handle 65536
+// Note that this implementation uses 16bit counters so can handle 65536
 // contentions on the lock without wraparound. It has not proven to be a
 // problem so far. (c.f. original description below)
 
diff --git a/plugins/parcelport/rma_memory_pool.hpp b/plugins/parcelport/rma_memory_pool.hpp
index 02f72b60b8..cf8cb90968 100644
--- a/plugins/parcelport/rma_memory_pool.hpp
+++ b/plugins/parcelport/rma_memory_pool.hpp
@@ -249,7 +249,7 @@ namespace parcelset
         }
 
         // ------------------------------------------------------------------------
-        // at shutdown we can disregrad any bocks still prepoted as we can't
+        // at shutdown we can disregard any bocks still prepoted as we can't
         // unpost them
         void decrement_used_count(uint32_t N) {
             in_use_ -= N;
diff --git a/plugins/parcelport/rma_memory_region.hpp b/plugins/parcelport/rma_memory_region.hpp
index 6a014c1d25..f3975b1397 100644
--- a/plugins/parcelport/rma_memory_region.hpp
+++ b/plugins/parcelport/rma_memory_region.hpp
@@ -217,8 +217,8 @@ namespace parcelset
         };
 
         // --------------------------------------------------------------------
-        // A user allocated region use memory allocted by the user.
-        // on destruction, the memory is unregisterd, but not deleted
+        // A user allocated region use memory allocated by the user.
+        // on destruction, the memory is unregistered, but not deleted
         inline void set_user_region() {
             flags_ |= BLOCK_USER;
         }
diff --git a/plugins/parcelport/tcp/CMakeLists.txt b/plugins/parcelport/tcp/CMakeLists.txt
index df05d2226e..d59a1e5811 100644
--- a/plugins/parcelport/tcp/CMakeLists.txt
+++ b/plugins/parcelport/tcp/CMakeLists.txt
@@ -19,22 +19,25 @@ if(HPX_WITH_PARCELPORT_TCP)
       "${PROJECT_SOURCE_DIR}/hpx/plugins/parcelport/tcp/receiver.hpp"
       "${PROJECT_SOURCE_DIR}/hpx/plugins/parcelport/tcp/sender.hpp"
     DEPENDENCIES
-      hpx_config
       hpx_allocator_support
+      hpx_asio
       hpx_assertion
       hpx_cache
       hpx_concurrency
+      hpx_config
       hpx_coroutines
       hpx_errors
       hpx_execution
       hpx_functional
       hpx_hardware
       hpx_memory
+      hpx_performance_counters
       hpx_plugin
       hpx_program_options
       hpx_serialization
-      hpx_timing
+      hpx_threading
       hpx_threadmanager
+      hpx_timing
       hpx_topology
       hpx_util
     INCLUDE_DIRS
diff --git a/plugins/parcelport/tcp/connection_handler_tcp.cpp b/plugins/parcelport/tcp/connection_handler_tcp.cpp
index 4654088feb..5320d0dedb 100644
--- a/plugins/parcelport/tcp/connection_handler_tcp.cpp
+++ b/plugins/parcelport/tcp/connection_handler_tcp.cpp
@@ -13,16 +13,16 @@
 #if defined(HPX_HAVE_NETWORKING)
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
+#include <hpx/functional/bind.hpp>
 #include <hpx/lcos/future.hpp>
 #include <hpx/plugins/parcelport/tcp/connection_handler.hpp>
 #include <hpx/plugins/parcelport/tcp/receiver.hpp>
 #include <hpx/plugins/parcelport/tcp/sender.hpp>
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/util/asio_util.hpp>
-#include <hpx/functional/bind.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/util/get_entry_as.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 
-#include <boost/io/ios_state.hpp>
 #include <boost/asio/ip/tcp.hpp>
 
 #include <thread>
diff --git a/plugins/parcelport/verbs/CMakeLists.txt b/plugins/parcelport/verbs/CMakeLists.txt
index 3aaba07853..e725660ac2 100644
--- a/plugins/parcelport/verbs/CMakeLists.txt
+++ b/plugins/parcelport/verbs/CMakeLists.txt
@@ -21,13 +21,15 @@ if (HPX_WITH_PARCELPORT_VERBS)
         "${PROJECT_SOURCE_DIR}/plugins/parcelport/verbs/locality.hpp"
         "${PROJECT_SOURCE_DIR}/plugins/parcelport/verbs/pinned_memory_vector.hpp"
     DEPENDENCIES
-      hpx_config
+      hpx_asio
       hpx_assertion
+      hpx_config
       hpx_format
-      hpx_preprocessor
-      hpx_plugin
-      hpx_timing
       hpx_threadmanager
+      hpx_timing
+      hpx_plugin
+      hpx_preprocessor
+      hpx_threading
       hpx::verbs
       hpx::boost
     INCLUDE_DIRS
diff --git a/plugins/parcelport/verbs/locality.hpp b/plugins/parcelport/verbs/locality.hpp
index 84143956db..7cdd11f63d 100644
--- a/plugins/parcelport/verbs/locality.hpp
+++ b/plugins/parcelport/verbs/locality.hpp
@@ -9,6 +9,7 @@
 
 #include <hpx/runtime/parcelset/locality.hpp>
 #include <hpx/serialization/serialize.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 //
 #include <cstdint>
 
@@ -62,7 +63,7 @@ namespace verbs
       }
 
       friend std::ostream & operator<<(std::ostream & os, locality const & loc) {
-        boost::io::ios_flags_saver ifs(os);
+        hpx::util::ios_flags_saver ifs(os);
         os << loc.ip_;
         return os;
       }
diff --git a/plugins/parcelport/verbs/parcelport_verbs.cpp b/plugins/parcelport/verbs/parcelport_verbs.cpp
index da6968f0cb..c0201c71bf 100644
--- a/plugins/parcelport/verbs/parcelport_verbs.cpp
+++ b/plugins/parcelport/verbs/parcelport_verbs.cpp
@@ -12,14 +12,16 @@
 #include <hpx/assertion.hpp>
 #include <hpx/format.hpp>
 #include <hpx/functional/bind_front.hpp>
+#include <hpx/functional/deferred_call.hpp>
 #include <hpx/synchronization/condition_variable.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/timing/high_resolution_timer.hpp>
-#include <hpx/util/command_line_handling.hpp>
-#include <hpx/functional/deferred_call.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/util/detail/pp/stringize.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/util/get_entry_as.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 
 // The memory pool specialization need to be pulled in before encode_parcels
 #include <hpx/runtime.hpp>
@@ -155,7 +157,7 @@ namespace verbs
                 util::section const * sec = ini.get_section("hpx.parcel.verbs");
                 if (nullptr != sec) {
                     std::string ibverbs_enabled(sec->get_entry("enable", "0"));
-                    if (boost::lexical_cast<int>(ibverbs_enabled)) {
+                    if (hpx::util::from_string<int>(ibverbs_enabled)) {
                         _ibverbs_device    =
                             sec->get_entry("device",    HPX_PARCELPORT_VERBS_DEVICE);
                         _ibverbs_interface =
diff --git a/plugins/parcelport/verbs/rdma/rdma_chunk_pool.hpp b/plugins/parcelport/verbs/rdma/rdma_chunk_pool.hpp
index 685b1bf36e..9035fba4e6 100644
--- a/plugins/parcelport/verbs/rdma/rdma_chunk_pool.hpp
+++ b/plugins/parcelport/verbs/rdma/rdma_chunk_pool.hpp
@@ -61,7 +61,7 @@
   alignment of all allocated chunks,
   and which extends and generalizes the framework provided by the simple segregated
   storage solution.
-  Also provides two UserAllocator classes which can be used in conjuction with \ref pool.
+  Also provides two UserAllocator classes which can be used in conjunction with \ref pool.
  */
 
 /*!
@@ -111,7 +111,7 @@ namespace verbs {
     };
 
 namespace details
-{  //! Implemention only.
+{  //! Implementation only.
 
     template<typename SizeType>
     class PODptr
diff --git a/plugins/parcelport/verbs/rdma/rdma_controller.cpp b/plugins/parcelport/verbs/rdma/rdma_controller.cpp
index ac723f6ae5..68c7c58e70 100644
--- a/plugins/parcelport/verbs/rdma/rdma_controller.cpp
+++ b/plugins/parcelport/verbs/rdma/rdma_controller.cpp
@@ -21,8 +21,6 @@
 #include <plugins/parcelport/verbs/rdma/verbs_completion_queue.hpp>
 #include <plugins/parcelport/verbs/rdma/verbs_device.hpp>
 //
-#include <boost/lexical_cast.hpp>
-//
 #include <poll.h>
 #include <errno.h>
 #include <iomanip>
@@ -562,7 +560,7 @@ int rdma_controller::handle_connect_request(
         }
         else {
             // we need to delete the connection we started and replace it with a new one
-            LOG_DEVEL_MSG("Priorty to new, Aborting old from "
+            LOG_DEVEL_MSG("Priority to new, Aborting old from "
                 << sockaddress(&local_addr_) << "to "
                 << ipaddress(remote_ip)
                 << "( " << sockaddress(&local_addr_) << ")");
diff --git a/plugins/parcelport/verbs/rdma/rdma_controller.hpp b/plugins/parcelport/verbs/rdma/rdma_controller.hpp
index 9c6621e814..6d22e0d54d 100644
--- a/plugins/parcelport/verbs/rdma/rdma_controller.hpp
+++ b/plugins/parcelport/verbs/rdma/rdma_controller.hpp
@@ -49,7 +49,7 @@ namespace verbs
         typedef hpx::parcelset::policies::verbs::unique_lock<mutex_type> unique_lock;
         typedef hpx::parcelset::policies::verbs::scoped_lock<mutex_type> scoped_lock;
 
-        // constructor gets infor from device and sets up all necessary
+        // constructor gets info from device and sets up all necessary
         // maps, queues and server endpoint etc
         rdma_controller(const char *device, const char *interface, int port);
 
diff --git a/plugins/parcelport/verbs/rdma/rdma_logging.hpp b/plugins/parcelport/verbs/rdma/rdma_logging.hpp
index 3bc94348ae..2c6af7bcb8 100644
--- a/plugins/parcelport/verbs/rdma/rdma_logging.hpp
+++ b/plugins/parcelport/verbs/rdma/rdma_logging.hpp
@@ -15,7 +15,7 @@
 //
 #include <hpx/config.hpp>
 #include <hpx/preprocessor/stringize.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/util/detail/pp/stringize.hpp>
 //
 #include <hpx/config/parcelport_defines.hpp>
diff --git a/plugins/parcelport/verbs/rdma/verbs_completion_queue.hpp b/plugins/parcelport/verbs/rdma/verbs_completion_queue.hpp
index 6d0745eef8..bae6cfea44 100644
--- a/plugins/parcelport/verbs/rdma/verbs_completion_queue.hpp
+++ b/plugins/parcelport/verbs/rdma/verbs_completion_queue.hpp
@@ -10,6 +10,8 @@
 #include <plugins/parcelport/verbs/rdma/rdma_error.hpp>
 #include <plugins/parcelport/parcelport_logging.hpp>
 //
+#include <hpx/util/to_string.hpp>
+//
 #include <inttypes.h>
 #include <infiniband/verbs.h>
 #include <string>
@@ -185,8 +187,7 @@ namespace verbs
                 str = "IBV_WC_RECV_RDMA_WITH_IMM";
                 break;
             default:
-                str = "Got an unknown opcode " + boost::lexical_cast
-                < std::string > (opcode);
+                str = "Got an unknown opcode " + hpx::util::to_string(opcode);
             }
 
             return str;
diff --git a/plugins/parcelport/verbs/rdma/verbs_endpoint.hpp b/plugins/parcelport/verbs/rdma/verbs_endpoint.hpp
index 6cfa8c2e81..a47aabf52e 100644
--- a/plugins/parcelport/verbs/rdma/verbs_endpoint.hpp
+++ b/plugins/parcelport/verbs/rdma/verbs_endpoint.hpp
@@ -272,7 +272,7 @@ namespace verbs
         // this poll for event function is used by the main server endpoint when
         // it is waiting for connection/disconnection requests etc
         // ack_event, deletes the cm_event data structure allocated by the CM,
-        // so we do not ack and alow the event handler routine to do it
+        // so we do not ack and allow the event handler routine to do it
         template<typename Func>
         int poll_for_event(Func &&f)
         {
@@ -476,7 +476,7 @@ namespace verbs
         int reject(rdma_cm_id *id)
         {
             //
-            // Debugging code to get ip address of soure/dest of event
+            // Debugging code to get ip address of source/dest of event
             // NB: The src and dest fields refer to the message - not the connect request
             // so we are actually receiving a request from dest (but src of the msg)
             //
diff --git a/plugins/parcelport/verbs/rdma/verbs_memory_region.hpp b/plugins/parcelport/verbs/rdma/verbs_memory_region.hpp
index 068aa24b9f..fe2e83d960 100644
--- a/plugins/parcelport/verbs/rdma/verbs_memory_region.hpp
+++ b/plugins/parcelport/verbs/rdma/verbs_memory_region.hpp
@@ -211,8 +211,8 @@ namespace verbs
         };
 
         // --------------------------------------------------------------------
-        // A user allocated region use memory allocted by the user.
-        // on destruction, the memory is unregisterd, but not deleted
+        // A user allocated region use memory allocated by the user.
+        // on destruction, the memory is unregistered, but not deleted
         inline void set_user_region() {
             flags_ |= BLOCK_USER;
         }
diff --git a/python/hpx/environment.py b/python/hpx/environment.py
deleted file mode 100644
index 69607825f5..0000000000
--- a/python/hpx/environment.py
+++ /dev/null
@@ -1,109 +0,0 @@
-#! /usr/bin/env python 
-#
-# Copyright (c) 2011 Bryce Lelbach
-# Copyright (c) 2019 Patrick Diehl
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-"""
-Module for generating strings which describe a C or C++ development environment.
-The identifier string takes the following form:::
-
-  processor  ::= [a-z0-9\\-.]+
-  kernel     ::= [a-z0-9\\-.]+
-  compiler   ::= [a-z0-9\\-.]+
-  identifier ::= processor '_' kernel '_' compiler
-"""
-
-from re import compile
-
-def make_component(raw, type):
-  """
-  Transliterate characters from an element returned by platform.uname() to
-  match the regex ``^[a-z0-9\-.]+$``. Returns ``"unknown-%s" % type`` if 
-  the transliterated string doesn't match the regex pattern. 
-  """ 
-  from string import lower
-
-  comp = compile(r'\s|_').sub('-', lower(raw))
-
-  if compile(r'^[a-z0-9\-.]+$').match(comp):
-    return comp
-  else:
-    return "unknown-%s" % type
-
-def make_compiler_component(driver):
-  """
-  Given the name of a compiler driver, generate a string describing the compiler
-  suite and version. Returns ``"unknown-compiler"`` if the compiler cannot be
-  identified.
-  """ 
-  from hpx.process import process
-
-  windows = 0
-
-  try:
-    from sys import getwindowsversion
-    # on windows, running cl.exe with no args returns what we want
-    windows = 1
-    proc = process("%s" % driver)
-  except ImportError as err:
-    # on POSIX, assume GNU-style long options
-    proc = process("%s --version" % driver)
-
-  proc.wait()
-  raw = proc.read() 
-
-  if (windows):
-    compiler = compile(r'Version ([0-9.]+)').match(raw) 
- 
-    if (compiler):
-      compiler = compiler.expand(r'msvc-\2')
-      if compile(r'^[a-z0-9\-.]+$').match(compiler):
-        return compiler
-      else:
-        return "msvc" 
-
-  # handle GNU GCC and Intel
-  compiler = compile(r'^(icc|icpc|gcc|g[+][+])[^ ]* [(][^)]+[)] ([0-9.]+)').match(raw)
-  
-  if (compiler):
-    unescaped = compiler.expand(r'\1-\2')
-    compiler = compile(r'[+]').sub("x", unescaped)
-
-    if compile(r'^[a-z0-9\-.]+$').match(compiler):
-      return compiler
-    else:
-      unescaped = compile(r'^(icc|icpc|gcc|g[+][+])').match(raw).expand(r'\1')
-      return compile(r'[+]').sub("x", unescaped)
- 
-  # handle Clang
-  compiler = compile(r'(clang) version ([0-9.]+)').match(raw)
-  
-  if (compiler):
-    compiler = compiler.expand(r'\1-\2')
-    if compile(r'^[a-z0-9\-.]+$').match(compiler):
-      return compiler
-    else:
-      return compile(r'^(clang)').match(raw).expand(r'\1')
-
-  return "unknown-compiler"
-
-def identify(driver):
-  """
-  Given the name of a compiler driver in the current path (or an absolute path
-  to a compiler driver), build a complete environment identifier using the
-  information provided by platform.uname().
-  """
-  from platform import uname
-  from hpx.path import absolute_path
-
-  (system, node, release, version, machine, processor) = uname()
-
-  return "%s_%s-%s_%s" % (make_component(machine, "processor"),
-                          make_component(system, "kernel"),
-                          make_component(release, "version"),
-                          make_compiler_component(absolute_path(driver))) 
-
diff --git a/python/hpx/path.py b/python/hpx/path.py
deleted file mode 100644
index 6db86c7879..0000000000
--- a/python/hpx/path.py
+++ /dev/null
@@ -1,20 +0,0 @@
-#! /usr/bin/env python 
-#
-# Copyright (c) 2011 Bryce Lelbach
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-def absolute_path(p):
-  """
-  Find the absolute location of a binary in the current path.
-  """
-  from os import pathsep, environ
-  from os.path import isfile, join, realpath
-  for dirname in environ['PATH'].split(pathsep):
-    candidate = join(dirname, p)
-    if isfile(candidate):
-      return realpath(candidate)
-  return realpath(p) 
-
diff --git a/python/hpx/process.py b/python/hpx/process.py
deleted file mode 100644
index fb677f72c4..0000000000
--- a/python/hpx/process.py
+++ /dev/null
@@ -1,318 +0,0 @@
-#! /usr/bin/env python
-#
-# Copyright (c) 2011-2012 Bryce Adelstein-Lelbach
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-# TODO: Rename to jobs?
-# TODO: More typechecking?
-# TODO: Match threading.Thread interface and/or subprocess interface better?
-# TODO: Better exception propagation
-
-from sys import float_info, platform
-from threading import Thread, Lock
-from time import sleep, time
-from subprocess import Popen, STDOUT, PIPE
-from shlex import split
-from signal import SIGKILL
-from os import kill
-from platform import system
-from queue import Queue, Empty
-from errno import ESRCH
-# TODO: implement for Windows
-
-OS_MAC = False
-OS_LIN = False
-
-if platform.startswith('darwin'):
-  OS_MAC = True
-  from select import kqueue, kevent
-  from select import KQ_FILTER_READ, KQ_EV_ADD, KQ_EV_DELETE, KQ_NOTE_LOWAT
-
-if platform.startswith('linux'):
-  OS_LIN = True
-  from select import epoll, EPOLLHUP
-
-def kill_process_tree(parent_pid, signal=SIGKILL):
-  def find_process_tree(pid):
-    cmd = ""
-
-    if OS_MAC:
-      cmd = "ps -o pid,ppid -ax | egrep ' %d$' | awk '{print $1}'" % pid
-    else: 
-      cmd = "ps -o pid --ppid %d --noheaders" % pid
-
-    ps_command = Popen(cmd, shell=True, stdout=PIPE)
-    ps_output = ps_command.stdout.read()
-    retcode = ps_command.wait()
-
-    if 0 == ps_command.wait():
-      list = [pid]
-
-      for child_pid in ps_output.split("\n")[:-1]:
-        list = list + find_process_tree(int(child_pid))
-
-      return list
-
-    else:
-      return [pid]
-
-  r = True
-
-  for pid in find_process_tree(parent_pid):
-    try:
-      kill(int(pid), signal)
-    except OSError as err:
-      if ESRCH != err.errno:
-        raise err
-      else:
-        r = False
-
-  return r
-
-class process(object):
-  _proc = None
-  _error = None
-  _groups = None
-  _timed_out = None
-
-  def __init__(self, cmd, group=None):
-    if StringType == type(cmd):
-      cmd = split(cmd)
-
-    self._proc = Popen(cmd, stderr=STDOUT, stdout=PIPE, shell=False)
-
-    self._error = None
-    self._groups = []
-    self._timed_out = False
-
-    if group is not None:
-      group.add_process(self)
-
-  def _call(self):
-    # annoyingly, KeyboardInterrupts are transported to threads, while most
-    # other Exceptions aren't in python
-    try:
-      self._proc.wait()
-    except Exception as err:
-      self._error = err
-
-  def _finish(self, thread):
-    # be forceful
-    if thread.is_alive():
-      # the thread may still be alive for a brief period after the process
-      # finishes (e.g. when it is notifying groups), so we ignore any errors
-      self.terminate()
-      thread.join()
-
-      self._timed_out = True
-
-    # if an exception happened, re-raise it here in the master thread
-    if self._error is not None:
-      raise self._error
-
-    return (self._timed_out, self._proc.returncode)
-
-  def terminate(self):
-    return kill_process_tree(self.pid())
-
-  def poll(self):
-    return self._proc.poll()
-
-  def pid(self):
-    return self._proc.pid
-
-  def fileno(self):
-    return self._proc.stdout.fileno()
-
-  def timed_out(self):
-    return self._timed_out
-
-  def wait(self, timeout=None):
-    if timeout is not None:
-      thread = Thread(target=self._call)
-      thread.start()
-
-      # wait for the thread and invoked process to finish
-      thread.join(timeout)
-
-      return self._finish(thread)
-
-    else:
-      return (self._timed_out, self._proc.wait())
-
-  def join(self, timeout=None):
-    return self.wait(timeout)
-
-  def read(self, timeout=None):
-    read_queue = Queue()
-
-    def enqueue_output():
-      for block in iter(self._proc.stdout.read, b''):
-        read_queue.put(block)
-
-      read_queue.put('')
-
-    thread = Thread(target=enqueue_output)
-    thread.daemon = True
-    thread.start()
-
-    output = ''
-
-    try:
-      started = time()
-
-      while timeout is None or not float_info.epsilon > timeout:
-        s = read_queue.get(timeout=timeout)
-
-        if s:
-          output += s
-        else:
-          return output
-
-        if not timeout is None:
-          timeout -= (time() - started)
-    except Empty:
-      return output
-
-# modelled after Boost.Thread's boost::thread_group class
-class process_group(object):
-  _lock = None
-  _members = None
-  _poller = None
-
-  def __init__(self, *cmds):
-    self._lock = Lock()
-    self._members = {}
-    if OS_MAC:
-      self._poller = kqueue()
-    if OS_LIN:
-      self._poller = epoll()
-
-    for cmd in cmds:
-      self.create_process(cmd)
-
-  def create_process(self, cmd):
-    return process(cmd, self)
-
-  def add_process(self, job):
-    with self._lock:
-      self._members[job.fileno()] = job
-      if OS_MAC:
-        self._poller.control([kevent(job._proc.stdout,
-          KQ_FILTER_READ, KQ_EV_ADD, KQ_NOTE_LOWAT, 0)], 0)
-      if OS_LIN:
-        self._poller.register(job._proc.stdout, EPOLLHUP)
-
-  def join_all(self, timeout=None, callback=None):
-    with self._lock:
-      not_done = self._members.copy()
-
-      started = time()
-
-      while timeout is None or not float_info.epsilon > timeout:
-          if OS_MAC:
-
-            if timeout == None:
-              timeout=-1.0
-
-            ready = self._poller.control(None,1,timeout)
-          if OS_LIN:
-            ready = self._poller.poll(timeout=-1.0 if timeout is None else timeout)
-
-          if not timeout is None:
-            timeout -= (time() - started)
-
-          if OS_MAC:
-            for fd in ready:
-              fd = fd.ident
-              self._poller.control([kevent(fd, KQ_FILTER_READ, KQ_EV_DELETE)], 0)
-              not_done.pop(fd)
-
-              if callable(callback):
-                callback(fd, self._members[fd])
-
-          if OS_LIN:
-            for fd, flags in ready:
-              self._poller.unregister(fd)
-              not_done.pop(fd)
-
-              if callable(callback):
-                callback(fd, self._members[fd])
-
-          if 0 == len(not_done):
-            return
-
-      # some of the jobs are not done, we'll have to forcefully stop them
-      for fd in not_done:
-        if self._members[fd].terminate():
-          self._members[fd]._timed_out = True
-
-        if callable(callback):
-          callback(fd, self._members[fd])
-
-  def read_all(self, timeout=None, callback=None):
-    output = {}
-
-    def read_callback(fd, job):
-      output[fd] = job.read(0.5)
-
-      if callable(callback):
-        callback(fd, job, output[fd])
-
-    self.join_all(timeout, read_callback)
-
-    return output
-
-  def terminate_all(self, callback=None):
-    with self._lock:
-      for (fd, job) in self._members.iteritems():
-        if job.terminate():
-          if callable(callback):
-            callback(fd, job)
-
-def join_all(*tasks, **keys):
-  def flatten(items):
-    result = []
-
-    for element in items:
-      if hasattr(element, "__iter__"):
-        result.extend(flatten(el))
-
-      else:
-        if not isinstance(element, process):
-          raise TypeError( "'%s' is not an instance of 'hpx.process'"
-                         % str(element))
-
-        result.append(element)
-
-    return result
-
-  tasks = flatten(tasks)
-
-  pg = process_group()
-
-  for task in tasks:
-    pg.add_process(task)
-
-  pg.join_all(keys['timeout'], keys['callback'])
-
-def read_all(*tasks, **keys):
-  output = {}
-
-  callback = keys['callback']
-
-  def read_callback(fd, job):
-    output[fd] = job.read()
-
-    if callable(callback):
-      callback(fd, job, output[fd])
-
-  keys['callback'] = read_callback
-
-  join_all(*tasks, **keys)
-
-  return output
-
diff --git a/python/scripts/hpx_environment.py b/python/scripts/hpx_environment.py
deleted file mode 100755
index eaa3a440a0..0000000000
--- a/python/scripts/hpx_environment.py
+++ /dev/null
@@ -1,37 +0,0 @@
-#! /usr/bin/env python 
-#
-# Copyright (c) 2011 Bryce Lelbach
-# Copyright (c) 2019 Patrick Diehl
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-from os.path import exists, join
-
-from sys import path, exit
-
-from optparse import OptionParser
-
-if exists(join(path[0], "../hpx")):
-  path.append(join(path[0], ".."))
-if exists(join(path[0], "../share/hpx/python/hpx")):
-  path.append(join(path[0], "../share/hpx/python"))
-
-from hpx.environment import identify
-
-usage = "Usage: %prog [options] compiler-driver" 
-
-parser = OptionParser(usage=usage)
-
-(options, driver) = parser.parse_args()
-
-if 0 == len(driver):
-  print ("No compiler driver specified.")
-  exit(1) 
-elif 1 != len(driver):
-  print ("More than one compiler driver specified.")
-  exit(1)
-
-print (identify(driver[0]))
-
diff --git a/python/scripts/hpx_invoke.py b/python/scripts/hpx_invoke.py
deleted file mode 100755
index 783f07bcf4..0000000000
--- a/python/scripts/hpx_invoke.py
+++ /dev/null
@@ -1,81 +0,0 @@
-#! /usr/bin/env python
-#
-# Copyright (c) 2009 Maciej Brodowicz
-# Copyright (c) 2011 Bryce Lelbach
-# Copyright (c) 2018 Patrick Diehl
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-from os.path import exists, join
-
-from datetime import datetime
-
-from string import digits
-
-from optparse import OptionParser
-
-import sys
-
-if exists(join(sys.path[0], "../hpx")):
-  sys.path.append(join(sys.path[0], ".."))
-if exists(join(sys.path[0], "../share/hpx/python/hpx")):
-  sys.path.append(join(sys.path[0], "../share/hpx/python"))
-
-from hpx.process import process
-
-def run(cmd, timeout=3600):
-  proc = process(cmd)
-  (timed_out, returncode) = proc.wait(timeout)
-
-  output = ''
-
-  while True:
-    s = proc.read()
-
-    if s:
-      output += s
-    else:
-      break
-
-  return (timed_out, returncode, output)
-
-def rstrip_last(s, chars):
-  if s[-1] in chars:
-    return s[:-1]
-  else:
-    return s
-
-# {{{ main
-usage = "Usage: %prog [options]" 
-
-parser = OptionParser(usage=usage)
-
-parser.add_option("--timeout",
-                  action="store", type="int",
-                  dest="timeout", default=3600,
-                  help="Program timeout (seconds)")
-
-parser.add_option("--program",
-                  action="store", type="string",
-                  dest="program",
-                  help="Program to invoke") 
-
-(options, cmd) = parser.parse_args()
-
-if None == options.program:
-  print ("No program specified")
-  exit(1)
-
-(timed_out, returncode, output) = run(options.program, options.timeout)
-
-if not 0 == len(output):
-  print (rstrip_last(output, '\n'))
-
-if timed_out:
-  print ("Program timed out")
-  
-exit(returncode)
-# }}}
-
diff --git a/python/scripts/hpx_optsweep.py b/python/scripts/hpx_optsweep.py
deleted file mode 100755
index 81cd43d196..0000000000
--- a/python/scripts/hpx_optsweep.py
+++ /dev/null
@@ -1,343 +0,0 @@
-#! /usr/bin/env python
-#
-# Copyright (c) 2009 Maciej Brodowicz
-# Copyright (c) 2011 Bryce Lelbach
-# Copyright (c) 2019 Patrick Diehl
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-"""
-Perform parameter sweep runs of an application.
-"""
-
-import sys, os, getopt, time, string
-import os.path as osp
-from re import compile
-from types import *
-from operator import *
-from datetime import datetime
-from pickle import dump
-
-if osp.exists(osp.join(sys.path[0], "../hpx")):
-  sys.path.append(osp.join(sys.path[0], ".."))
-if osp.exists(osp.join(sys.path[0], "../share/hpx/python/hpx")):
-  sys.path.append(osp.join(sys.path[0], "../share/hpx/python"))
-
-from hpx.process import process
-
-OPTSWEEP_VERSION = 0x10 # version (mostly for version tracking in pickle output)
-
-# print usage info and exit with an error code
-def usage(rc = 2):
-    print ('\nUsage:', sys.argv[0], '[options] application [const_options]',)
-    print ('''
-Options:
- -a name,list : specify range of values, identified by "name", for a single
-                option of the application;
-                "list" is a python expression producing list of values
- -n           : don\'t stream results to stdout
- -r number    : repeat each test "number" of times
- -o filename  : capture stdout and stderr to file "filename"
- -t filename  : save results to file "filename" in the pickle format
- -d number    : delay test start by "number" of seconds
- -x list      : exclude cases with argument tuples matching any item in the
-                "list" (python expression)
- -w seconds   : kill runs that take longer than "seconds" to complete (default
-                360). 
- -b command   : run preprocessing "command" before starting test sequence for
-                each configuration, applying option substitution
- -p command   : run postprocessing "command" after test sequence for each
-                configuration, applying option substitution
- -h           : prints this message
-''')
-    sys.exit(rc)
-
-
-# write string to each open file descriptor in the list
-def writeres(s, fdlist):
-  for x in fdlist:
-    x.write(s)
-    x.flush()
-    if x.fileno() != 1:
-      os.fsync(x.fileno())
-
-
-# select next option set to run
-def next(ixd, opts, optv):
-    if not ixd: return None
-    for k in opts:
-        ixd[k] += 1
-        if ixd[k] >= len(optv[k]): ixd[k] = 0
-        else: return ixd
-    return None
-        
-
-# run the application and optionally capture its output and error streams
-def run(cmd, outfl = None, timeout = 360):
-    start = datetime.now() 
-    proc = process(cmd)
-    (timed_out, returncode) = proc.wait(timeout)
-    now = datetime.now()
-
-    while outfl:
-        s = proc.read()
-        if s: writeres(s, outfl)
-        else: break
-
-    if timed_out: 
-      writeres('Command timed out.\n', outfl)
-
-    return (returncode, now - start)
-
-
-# wrapper for conversion of integer options
-def intopt(opta, optn):
-    try:
-        return int(opta)
-    except Exception as err:
-        print ('Error: invalid argument to option "'+optn+'":', opta, '('+str(err)+')')
-        usage()
-
-
-# human-readable version of current timestamp
-def timestr(t):
-    return t.strftime("%Y-%m-%d %H:%M:%S")
-
-
-# quote option arguments to protect blanks
-def quoteopts(olist, qchar = '"'):
-    s = ''
-    for o in olist:
-        if type(o) is not StringType: o = str(o)
-        for c in o:
-            if c not in nonquot:
-                s += ' '+qchar+o+qchar
-                break
-        else: s += ' '+o
-    return s
-
-
-# create separator with centered string
-def sepstr(sepch = '-', s = ''):
-    if s: s = ' '+s.strip()+' '
-    nl = (seplen-len(s))/2
-    nr = seplen-len(s)-nl
-    # make sure it still looks like separator for oversized lines
-    if nl < 3: nl = 3
-    if nr < 3: nr = 3
-    return nl*sepch+s+nr*sepch
-
-# substitute all option ids in string with formatting keys
-def optidsub(optids, s):
-    # first pass - option subsitution
-    for o in optids:
-      s = s.replace(o, '%('+o+')s')
-    return s
-
-
-# run pre- or postprocessor
-def runscript(cmdlst, options, ofhs, timeout):
-    for cmd in cmdlst:
-        scr = cmd%options
-        (rc, walltime) = run(scr, timeout)
-        if rc:
-            writeres('Warning: command: "'+scr+'" returned '+str(rc)+'\n', ofhs)
-
-    
-if __name__ == '__main__':
-    # parse command line
-    try:
-        opts, args = getopt.getopt(sys.argv[1:], 'a:b:d:hno:p:r:t:x:w:i:')
-    except getopt.GetoptError as err:
-        print ('Error:', str(err))
-        usage()
-
-    # option value lists, option names, # test repetitions, temporal pad
-    options, optnames, nrep, tpad = {}, [], 1, 0
-    # stdout usage flag, result file name, list of output file descriptors
-    stdoutf, ofile, rfile, rf, ofhs = True, None, None, None, []
-    # exclusion list, preprocessing command list, postprocessing command list
-    excl, before, after = [], [], []
-    # execution counters: app. runs, unique configs, errors, excluded configs
-    runs, configs, erruns, excnt = 0, 0, 0, 0
-    # separator length for pretty printing
-    seplen = 78
-    # timeout 
-    timeout = 360
-    # non-quotable characters
-    nonquot = string.ascii_letters+string.digits+'-+='
-
-    # process options
-    for o, a in opts:
-        if o == '-a':
-            wl = a.split(',', 1)
-            if len(wl) != 2:
-                print ('Error: malformed argument to "-a" option:', a)
-                usage()
-            try:
-                options[wl[0]] = eval(wl[1])
-            except Exception as err:
-                print ('Error: failed to evaluate "'+wl[1]+'", check syntax')
-                usage()
-            if type(options[wl[0]]) not in (ListType, TupleType):
-                options[wl[0]] = (options[wl[1]],)
-            if not len(options[wl[0]]):
-                print ('Error: empty value list for option "'+wl[0]+'"')
-                usage()
-            optnames.append(wl[0])
-            if len(options[wl[0]]) == 1:
-                print ('Warning: single value for option "'+wl[0]+'":', options[wl[0]])
-        elif o == '-n': stdoutf = False
-        elif o == '-d': tpad = intopt(a, o)
-        elif o == '-r': nrep = intopt(a, o)
-        elif o == '-o': ofile = a
-        elif o == '-t': rfile = a
-        elif o == '-w': timeout = intopt(a, o)
-        elif o == '-x':
-            try:
-                excl = map(tuple, eval(a))
-            except Exception as err:
-                print ('Error: invalid exclusion list: ', str(a))
-                usage()
-        elif o == '-b': before += [a]
-        elif o == '-p': after += [a]
-        elif o == '-h': usage(0)
-
-    if not args:
-        print ('Error: no test application specified')
-        usage()
-    if ofile:
-        try:
-            of = open(ofile, 'w')
-            ofhs.append(of)
-        except Exception as err:
-            print ('Error: failed to open output file "'+ofile+'"')
-            sys.exit(1)
-    if rfile:
-        try:
-            rf = open(rfile, 'w')
-        except Exception as err:
-            print ('Error: failed to open result file "'+rfile+'"')
-            sys.exit(1)
-    if stdoutf: ofhs.append(sys.stdout)
-
-    # form prototypes of application command line, pre- and postprocessor
-    cmdproto = map(lambda o: optidsub(optnames, o), args)
-    if before: before = map(lambda o: optidsub(optnames, o), before)
-    if after: after = map(lambda o: optidsub(optnames, o), after)
-
-    # initialize current option index dictionary
-    results = {}
-    optix = {}
-    for k in options: optix[k] = 0
-
-    start_date = datetime.now()
-
-    # beginning banner
-    writeres(sepstr('=')+'\n', ofhs)
-    writeres('Start date: '+timestr(start_date)+'\n', ofhs)
-    writeres('Command:'+quoteopts(sys.argv)+'\n', ofhs)
-
-    if rf:
-      results['data'] = {}
-      results['header'] = {}
-      results['schema'] = {}
-
-      results['schema']['keys'] = tuple(optnames)
-      results['schema']['values'] = ('wall_time','return_code')
-
-      results['header']['version'] = OPTSWEEP_VERSION
-      results['header']['start_date'] = start_date
-      results['header']['command'] = tuple(sys.argv)
-
-    try: 
-    # test loop
-      while optix != None:
-        configs += 1
-        # create current instance of generated options
-        vallst, optd = [], {}
-        for k in optnames:
-            val = options[k][optix[k]]
-            if type(val) is not StringType: val = str(val)
-            optd[k] = val
-            vallst += [optd[k]]
-        # check for exclusions
-        if tuple(vallst) in excl:
-            writeres(sepstr('=')+'\nSkipping:'+quoteopts(cmd)+'\n', ofhs)
-            optix = next(optix, optnames, options)
-            excnt += 1
-            continue
-        # run setup program
-        # TODO: add timeout options
-        if before: runscript(before, optd, ofhs)
-        # build command line
-        cmd = map(lambda x: x%optd, cmdproto)
- 
-        # second pass - eval
-        p = compile(r'eval\("([^"]*)"\)')
-
-        for e in range(len(cmd)):
-          while p.search(cmd[e]):
-            ss = p.search(cmd[e]).expand(r'\1')
-            cmd[e] = cmd[e].replace("eval(\"%s\")" % ss, str(eval(ss)))
-
-        writeres(sepstr('=')+'\nExecuting:'+quoteopts(cmd)+'\n', ofhs)
-        # run test requested number of times
-        for i in range(nrep):
-            start = datetime.now()
-            txt = 'BEGIN RUN '+str(i+1)+' @ '+timestr(datetime.now())
-            writeres(sepstr('-', txt)+'\n', ofhs)
-            (rc, walltime) = run(cmd, ofhs, timeout)
-            txt = 'END RUN '+str(i+1)+' @ '+timestr(datetime.now())
-            txt += ' (ELAPSED '+str(datetime.now()-start)+')'
-            runs += 1
-            if rc: erruns += 1
-            outs = sepstr('-', txt)
-            outs += '\nReturn code: '+str(rc)+'\n'+sepstr()+'\n'
-            writeres(outs, ofhs)
-            if rf:   
-              if not results['data'].has_key(tuple(vallst)):
-                results['data'][tuple(vallst)] = [(walltime, rc)]
-              else:
-                results['data'][tuple(vallst)].append((walltime, rc))
-            time.sleep(tpad)
-        # run postprocessor
-        # TODO: add timeout options
-        if after: runscript(after, optd, ofhs)
-     
-        optix = next(optix, optnames, options)
-        
-    except: 
-        from traceback import print_exc
-        print_exc()
-     
-    end_date = datetime.now()
-
-    # final banner
-    writeres('='*seplen+'\n', ofhs)
-    writeres('End date: '+timestr(end_date)+'\n', ofhs)
-    writeres('Configurations: '+str(configs)+'\n', ofhs)
-    writeres('Exclusions: '+str(excnt)+'\n', ofhs)
-    writeres('Total runs: '+str(runs)+'\n', ofhs)
-    writeres('Failed runs: '+str(erruns)+'\n', ofhs)
-    writeres('='*seplen+'\n', ofhs)
-
-    if rf:
-      results['header']['end_date'] = end_date
-      results['header']['configurations'] = configs 
-      results['header']['exclusions'] = excnt
-      results['header']['total_runs'] = runs
-      results['header']['failed_runs'] = erruns
-
-      # dump the results dictionary to the result file, using
-      # pickle protocol version 2 with binary output
-      dump(results, rf, 2)
-
-      rf.close()
-
-    # cleanup
-    for f in ofhs:
-        if f != sys.stdout: f.close()
-
diff --git a/python/scripts/hpx_run_test.py b/python/scripts/hpx_run_test.py
deleted file mode 100755
index 45fd216cf0..0000000000
--- a/python/scripts/hpx_run_test.py
+++ /dev/null
@@ -1,262 +0,0 @@
-#! /usr/bin/env python
-#
-# Copyright (c) 2012 Bryce Adelstein-Lelbach
-# Copyright (c) 2019 Patrick Diehl
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-# TODO: Fractional threads_per_locality
-
-# hpx_run_test.py is a script that is designed to manage the execution of HPX
-# tests. It is designed to:
-#
-# * Robustly clean up failed tests by killing them and all their subprocesses.
-# * Robustly enforce user-specified timeouts for tests with minimal overheads.
-# * Control the output of tests.
-#
-# hpx_run_test.py takes a number of command line arguments, described in
-# --help. Additionally, it takes a positional argument that describes
-# the test. This argument should be formatted as a python list. Its format is
-# described in --help.
-
-import sys, os, string
-import os.path as osp
-
-from optparse import OptionParser
-
-from errno import ENOENT
-
-import signal, re
-
-if osp.exists(osp.join(sys.path[0], "../hpx")):
-  sys.path.append(osp.join(sys.path[0], ".."))
-if osp.exists(osp.join(sys.path[0], "../share/hpx/python/hpx")):
-  sys.path.append(osp.join(sys.path[0], "../share/hpx/python"))
-
-from hpx.process import process, process_group
-
-signal_map = dict((-1 * k, v) for v, k in signal.__dict__.items() \
-                           if re.match("SIG[A-Z]*$", v))
-
-def exit_decode(exit_code):
-  # In Bash on Linux, programs exit with a code of -1 * signal when an unhandled
-  # signal occurs.
-  if exit_code < 0 and exit_code in signal_map:
-    return signal_map[exit_code]
-  else:
-    return exit_code
-
-def quote_options(options, quoting_char = '"'):
-  no_quote = string.letters + string.digits + '-+=/_.'
-  s = ''
-
-  for option in options:
-    if type(option) is not StringType:
-      option = str(option)
-    for c in option:
-      if c not in no_quote:
-        s += ' ' + quoting_char + option + quoting_char
-        break
-    else:
-      s += ' ' + option
-
-  return string.strip(s)
-
-class TestFailed(Exception):
-  pass
-
-if __name__ == '__main__':
-  # {{{ main
-  usage =         "Usage: %prog [options] [test specification]\n"
-  usage = usage + "The test specification should be a python list the following format:\n"
-  usage = usage + "  [ name, timeout, success, nodes, threads_per_node, args ]\n"
-  usage = usage + "The types of the list elements should be:\n"
-  usage = usage + "  [ string, float or None, bool, int, int, list ]\n"
-
-  parser = OptionParser(usage=usage)
-
-  parser.add_option("--suffix",
-                    action="store", type="string",
-                    dest="suffix", default="_test",
-                    help="Suffix added to test names [default: %default]")
-
-  parser.add_option("--launcher",
-                    action="store", type="string",
-                    dest="launcher", default="",
-                    help="Program used to launch the test [default: %default]")
-
-  parser.add_option("--args",
-                    action="store", type="string",
-                    dest="args", default="",
-                    help="Command line arguments to add tests [default: %default]")
-
-  parser.add_option("--log",
-                    action="store", type="string",
-                    dest="log", default="fail",
-                    help="Always log output (--log=always), never log "
-                        +"output (--log=never) or log output for tests "
-                        +"that fail (--log=fail) [default: %default]")
-
-  parser.add_option("--log-stdout",
-                    action="store_true", dest="log_stdout", default=False,
-                    help="Send logs to stdout (overrides --log-prefix)")
-
-  parser.add_option("--log-prefix",
-                    action="store", type="string",
-                    dest="log_prefix", default="./",
-                    help="Prefix for log files [default: %default]")
-
-  parser.add_option("--no-exit-code",
-                    action="store_false", dest="exit_code", default=True,
-                    help="Don't return a non-zero exit code when tests fail")
-
-  (options, files) = parser.parse_args()
-
-  if 'HPX_TEST_ARGUMENTS' in os.environ:
-    options.args += os.environ['HPX_TEST_ARGUMENTS']
-
-  if 'HPX_TEST_LAUNCHER' in os.environ:
-    options.launcher += os.environ['HPX_TEST_LAUNCHER']
-
-  if not (lambda x: "always" == x or "never" == x or "fail" == x)(options.log):
-    print( "Error: --log=" + quote_options([options.log]) + " is invalid\n")
-    parser.print_help()
-    sys.exit(1)
-
-  if 0 == len(files):
-    print ("Error: test specified\n")
-    parser.print_help()
-    sys.exit(1)
-
-  tests = []
-  all_passed = True
-
-  for f in files:
-    tests += eval(f)#eval(open(f).read())
-
-  for [name, timeout, success, nodes, threads_per_node, args] in tests:
-    print ("Running: " + name + " (Timeout:", timeout, "[s])",
-    sys.stdout.flush())
-
-    pg = process_group()
-    results = [] # [ cmd, cmd_passed, exit_code, timed_out, output ]
-    cmds = {}
-
-    if not osp.exists(name):
-      print ("-", "Failed (test not found)")
-
-      all_passed = False
-
-      if ("always" == options.log or "fail" == options.log):
-        f = None
-
-        if not options.log_stdout:
-          log = name + ".log"
-          f = open(log, "w+")
-          print ((" " * 2) + "Log:", log)
-        else:
-          f = sys.stdout
-
-        print >> f, ("#" * 80)
-        print >> f, "Test:", name
-        print >> f, "Result: Failed (test not found)"
-        print >> f, ("#" * 80)
-
-      continue
-
-    for node in range(nodes):
-      cmd = []
-
-      if (options.launcher):
-        cmd = [options.launcher]
-
-      cmd += [ name
-             , '-t' + str(threads_per_node)]
-
-      if nodes > 1:
-          cmd += [ '-l' + str(nodes)
-                 , '-' + str(node)]
-
-      if (options.args):
-        cmd += [options.args]
-
-      cmd += args
-
-      cmd = quote_options(cmd)
-
-      cmds[pg.create_process(cmd).fileno()] = cmd
-
-    def gather_results(fd, job, output):
-      cmd_passed = (job.poll() == 0 if success else job.poll() != 0) \
-           and not job.timed_out()
-
-      results.append([ cmds[job.fileno()]
-                     , cmd_passed
-                     , job.poll()
-                     , job.timed_out()
-                     , output])
-
-      if not cmd_passed:
-        raise TestFailed()
-
-    try:
-      pg.read_all(timeout, gather_results)
-    except TestFailed:
-      def read_callback(fd, job):
-        try:
-          gather_results(fd, job, job.read(0.5))
-        except TestFailed:
-          pass
-
-      pg.terminate_all(read_callback)
-
-    # all the commands are now done
-
-    test_passed = True
-
-    for result in results:
-      if not result[1]:
-        test_passed = False
-        break
-
-    all_passed = all_passed and test_passed
-
-    print ("-", ("Passed" if test_passed else "Failed"))
-
-    if "always" == options.log or ("fail" == options.log and not test_passed):
-      f = None
-
-      if not options.log_stdout:
-        log = name + ".log"
-        f = open(log, "w+")
-        print (" " * 2) + "Log:", log
-      else:
-        f = sys.stdout
-
-      print >> f, ("#" * 80)
-      print >> f, "Test:", name
-      print >> f, "Result:", ("Passed" if test_passed else "Failed")
-      print >> f, ("#" * 80)
-      print >> f, ""
-
-      for result in results:
-        print >> f, ("#" * 80)
-        print >> f, "Command:", result[0]
-        print >> f, "Result:", ("Passed" if result[1] else "Failed")
-        print >> f, "Exit code:", exit_decode(result[2])
-        print >> f, "Timed out:", result[3]
-        print >> f, ("#" * 80)
-
-        if result[4] is not None:
-          if 0 != len(result[4]):
-            print >> f, result[4],
-            print >> f, ("#" * 80)
-
-        print >> f, ""
-
-  if not all_passed and options.exit_code:
-    sys.exit(1)
-  # }}}
-
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 33e0fd131a..23a638dade 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -225,24 +225,7 @@ else()
   endif()
 endif()
 
-# Default unnamed config (not Debug/Release/etc) are in this var
-get_property(_temp_flags GLOBAL PROPERTY HPX_CMAKE_FLAGS_CXX_)
-target_compile_options(hpx PRIVATE ${_temp_flags})
-target_compile_definitions(hpx PUBLIC $<$<CONFIG:Debug>:HPX_DEBUG>)
-
-# message("Adding ${_temp_flags}")
-
-# Could potentially use CMAKE_CONFIGURATION_TYPES in case a user defined config exists
-foreach(_config "DEBUG" "RELEASE" "RELWITHDEBINFO" "MINSIZEREL")
-  get_property(_temp_flags GLOBAL PROPERTY HPX_CMAKE_FLAGS_CXX_${_config})
-  target_compile_options(hpx PRIVATE $<$<CONFIG:${_config}>:${_temp_flags}>)
-#  message("Adding $<$<CONFIG:${_config}>:${_temp_flags}>")
-endforeach()
-
-#if(HPX_WITH_STATIC_LINKING)
-#  add_dependencies(hpx static_component_data_hpp)
-#endif()
-
+target_link_libraries(hpx PUBLIC hpx_public_flags PRIVATE hpx_private_flags)
 target_link_libraries(hpx PUBLIC hpx::boost)
 
 # Set the basic search paths for the HPX headers
@@ -335,8 +318,8 @@ foreach(_module ${HPX_LIBS})
     endif(APPLE)
   endif(UNIX)
 
-  # add module binaries as PRIVATE dependencies to the core hpx library to
-  # avoid dependent applicatons have to link against those
+  # add module binaries as PRIVATE dependencies to the core hpx library to avoid
+  # dependent applications have to link against those
   target_link_libraries(hpx PRIVATE ${_module_target})
 
   # add module include directories as PUBLIC to core hpx library to enable
@@ -350,18 +333,13 @@ if((NOT HPX_WITH_STATIC_LINKING) AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux")
   set_target_properties(hpx PROPERTIES POSITION_INDEPENDENT_CODE ON)
 endif()
 
-target_compile_definitions(hpx PUBLIC HPX_ENABLE_ASSERT_HANDLER PRIVATE
-  HPX_COMPONENT_NAME=hpx HPX_EXPORTS)
+target_compile_definitions(hpx PRIVATE HPX_COMPONENT_NAME=hpx HPX_EXPORTS)
 
 ################################################################################
 # Emulation of SwapContext on Windows
 ################################################################################
-if(MSVC)
-  if(HPX_WITH_SWAP_CONTEXT_EMULATION)
-    set_property(TARGET hpx APPEND
-      PROPERTY LINK_FLAGS
-      "/EXPORT:switch_to_fiber")
-  endif()
+if(MSVC AND HPX_WITH_SWAP_CONTEXT_EMULATION)
+  target_link_options(hpx PRIVATE "/EXPORT:switch_to_fiber")
 endif()
 
 set(hpx_targets ${hpx_targets} hpx)
@@ -403,10 +381,10 @@ if(NOT HPX_WITH_STATIC_LINKING)
       $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>
       $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>
       $<INSTALL_INTERFACE:include>)
+  target_link_libraries(hpx_init PUBLIC hpx_public_flags PRIVATE hpx_private_flags)
   target_link_libraries(hpx_init PRIVATE hpx::boost)
 
-  target_compile_definitions(hpx_init PUBLIC HPX_ENABLE_ASSERT_HANDLER PRIVATE
-    HPX_APPLICATION_EXPORTS)
+  target_compile_definitions(hpx_init PRIVATE HPX_APPLICATION_EXPORTS)
 
   set_property(TARGET hpx_init PROPERTY FOLDER "Core")
   set(hpx_targets ${hpx_targets} hpx_init)
@@ -447,8 +425,7 @@ if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (
 
     set_target_properties(hpx_wrap PROPERTIES CMAKE_POSITION_INDEPENDENT_CODE ON)
 
-    target_compile_definitions(hpx_wrap PUBLIC HPX_ENABLE_ASSERT_HANDLER PRIVATE
-      HPX_APPLICATION_EXPORTS)
+    target_compile_definitions(hpx_wrap PRIVATE HPX_APPLICATION_EXPORTS)
 
     # Set the basic search paths for the generated HPX headers
     target_include_directories(hpx_wrap
@@ -456,6 +433,7 @@ if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (
         $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>
         $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>
         $<INSTALL_INTERFACE:include>)
+    target_link_libraries(hpx_wrap PUBLIC hpx_public_flags PRIVATE hpx_private_flags)
     target_link_libraries(hpx_wrap PUBLIC hpx)
     if("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux")
       target_link_libraries(hpx_wrap INTERFACE "-Wl,-wrap=main")
@@ -478,44 +456,51 @@ if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (
 
 endif()
 
-foreach(_keyword PUBLIC;PRIVATE)
-  get_property(HPX_TARGET_COMPILE_DEFINITIONS_VAR
-    GLOBAL PROPERTY HPX_TARGET_COMPILE_DEFINITIONS_${_keyword})
-  foreach(_flag ${HPX_TARGET_COMPILE_DEFINITIONS_VAR})
-    target_compile_definitions(hpx ${_keyword} ${_flag})
-    if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (APPLE)))
-      target_compile_definitions(hpx_wrap ${_keyword} ${_flag})
-    endif()
-    if(NOT HPX_WITH_STATIC_LINKING)
-      target_compile_definitions(hpx_init ${_keyword} ${_flag})
-    endif()
-    foreach(_module ${HPX_LIBS})
-      target_compile_definitions(hpx_${_module} ${_keyword} ${_flag})
-    endforeach()
-  endforeach()
-
-  get_property(HPX_TARGET_COMPILE_OPTIONS_VAR
-    GLOBAL PROPERTY HPX_TARGET_COMPILE_OPTIONS_${_keyword})
-  foreach(_flag ${HPX_TARGET_COMPILE_OPTIONS_VAR})
-    target_compile_options(hpx ${_keyword} ${_flag})
-    target_compile_options(hpx_internal_flags INTERFACE ${_flag})
-    if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (APPLE)))
-      target_compile_options(hpx_wrap ${_keyword} ${_flag})
-    endif()
-    if(NOT HPX_WITH_STATIC_LINKING)
-      target_compile_options(hpx_init ${_keyword} ${_flag})
-    endif()
-    foreach(_module ${HPX_LIBS})
-      target_compile_options(hpx_${_module} ${_keyword} ${_flag})
-    endforeach()
-  endforeach()
-endforeach()
-
 set(_optional)
 if(HPX_WITH_DEFAULT_TARGETS)
   set(_optional OPTIONAL)
 endif()
 
+set(_library_types "STATIC_LIBRARY;MODULE_LIBRARY;SHARED_LIBRARY;OBJECT_LIBRARY;INTERFACE_LIBRARY")
+set(_is_executable "$<STREQUAL:$<TARGET_PROPERTY:TYPE>,EXECUTABLE>")
+set(_is_library "$<IN_LIST:$<TARGET_PROPERTY:TYPE>,${_library_types}>")
+
+# hpx_interface contains additional interface options to be passed to dependent
+# targets. We create this as a separate target to easily filter out the
+# generator expressions that can't be handled by the pkgconfig file generation.
+add_library(hpx_interface INTERFACE)
+target_link_libraries(hpx_interface INTERFACE $<${_is_executable}:$<TARGET_NAME_IF_EXISTS:hpx_init>>)
+target_link_libraries(hpx_interface INTERFACE $<${_is_executable}:$<TARGET_NAME_IF_EXISTS:HPX::hpx_init>>)
+if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (APPLE)))
+  # hpx_wrap is not correctly expanded to HPX::wrap in HPXTargets.cmake when
+  # wrapped in a generator expression. We instead choose hpx_wrap or
+  # HPX::hpx_wrap depending on which one is available.
+  target_link_libraries(hpx_interface INTERFACE $<${_is_executable}:$<TARGET_NAME_IF_EXISTS:hpx_wrap>>)
+  target_link_libraries(hpx_interface INTERFACE $<${_is_executable}:$<TARGET_NAME_IF_EXISTS:HPX::hpx_wrap>>)
+endif()
+target_compile_definitions(hpx_interface INTERFACE "$<${_is_executable}:HPX_APPLICATION_NAME_DEFAULT=$<TARGET_PROPERTY:NAME>>")
+target_compile_definitions(hpx_interface INTERFACE "$<${_is_executable}:HPX_PREFIX_DEFAULT=\"${HPX_PREFIX}\">")
+target_compile_definitions(hpx_interface INTERFACE "$<${_is_executable}:HPX_APPLICATION_EXPORTS>")
+target_compile_definitions(hpx_interface INTERFACE "$<${_is_library}:HPX_LIBRARY_EXPORTS>")
+target_link_libraries(hpx INTERFACE hpx_interface)
+
+# HPX::component is to be linked privately to all HPX components
+# NOTE: The _is_library guard only prevents simple mistakes of linking
+# HPX::component to executables. It does not prevent linking it to libraries
+# that are not components.
+add_library(component INTERFACE)
+target_compile_definitions(component INTERFACE "$<${_is_library}:HPX_COMPONENT_NAME_DEFAULT=hpx_$<TARGET_PROPERTY:NAME>>")
+target_compile_definitions(component INTERFACE "$<${_is_library}:HPX_COMPONENT_EXPORTS>")
+
+# HPX::plugin is to be linked privately to all HPX plugins
+# NOTE: The _is_library guard only prevents simple mistakes of linking
+# HPX::component to executables. It does not prevent linking it to libraries
+# that are not components.
+add_library(plugin INTERFACE)
+target_compile_definitions(plugin INTERFACE "$<${_is_library}:HPX_PLUGIN_NAME_DEFAULT=hpx_$<TARGET_PROPERTY:NAME>>")
+
+set(hpx_targets ${hpx_targets} hpx_interface plugin component)
+
 install(
   TARGETS ${hpx_targets}
   EXPORT HPXTargets
@@ -553,14 +538,12 @@ foreach(target ${hpx_targets})
 endforeach()
 
 # Add particular targets for the pkgconfig setup
-add_library(hpx_application INTERFACE)
+add_library(hpx_pkgconfig_application INTERFACE)
 if(HPX_WITH_DYNAMIC_HPX_MAIN AND (("${CMAKE_SYSTEM_NAME}" STREQUAL "Linux") OR (APPLE)))
-  target_link_libraries(hpx_application INTERFACE hpx_wrap)
+  target_link_libraries(hpx_pkgconfig_application INTERFACE hpx_wrap)
 endif()
-target_compile_definitions(hpx_application INTERFACE HPX_APPLICATION_EXPORTS)
-add_library(hpx::application ALIAS hpx_application)
+target_compile_definitions(hpx_pkgconfig_application INTERFACE HPX_APPLICATION_EXPORTS)
 
-add_library(hpx_component INTERFACE)
-target_compile_definitions(hpx_component INTERFACE HPX_COMPONENT_EXPORTS)
-target_link_libraries(hpx_component INTERFACE hpx)
-add_library(hpx::component ALIAS hpx_component)
+add_library(hpx_pkgconfig_component INTERFACE)
+target_compile_definitions(hpx_pkgconfig_component INTERFACE HPX_COMPONENT_EXPORTS)
+target_link_libraries(hpx_pkgconfig_component INTERFACE hpx)
diff --git a/src/custom_exception_info.cpp b/src/custom_exception_info.cpp
index f6bc4eae8c..b820e0f7fd 100644
--- a/src/custom_exception_info.cpp
+++ b/src/custom_exception_info.cpp
@@ -7,6 +7,7 @@
 
 #include <hpx/config.hpp>
 #include <hpx/assertion.hpp>
+#include <hpx/async.hpp>
 #include <hpx/basic_execution/register_locks.hpp>
 #include <hpx/custom_exception_info.hpp>
 #include <hpx/errors.hpp>
@@ -17,11 +18,12 @@
 #include <hpx/runtime/get_locality_id.hpp>
 #include <hpx/runtime/get_worker_thread_num.hpp>
 #include <hpx/runtime/naming/name.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/state.hpp>
+#include <hpx/threading.hpp>
 #include <hpx/util/backtrace.hpp>
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/util/debugging.hpp>
 #include <hpx/version.hpp>
 
@@ -165,6 +167,47 @@ namespace hpx
     }
 }
 
+namespace hpx { namespace util {
+    // This is a local helper used to get the backtrace on a new new stack if
+    // possible.
+    std::string trace_on_new_stack(
+        std::size_t frames_no = HPX_HAVE_THREAD_BACKTRACE_DEPTH)
+    {
+#if defined(HPX_HAVE_STACKTRACES)
+        if(frames_no == 0)
+        {
+            return std::string();
+        }
+
+        backtrace bt(frames_no);
+
+        auto* self = threads::get_self_ptr();
+        if (nullptr == self ||
+            self->get_thread_id() == threads::invalid_thread_id)
+        {
+            return bt.trace();
+        }
+
+        lcos::local::futures_factory<std::string()> p([&bt]() { return bt.trace(); });
+
+        error_code ec(lightweight);
+        threads::thread_id_type tid = p.apply("hpx::util::trace_on_new_stack",
+            launch::fork, threads::thread_priority_default,
+            threads::thread_stacksize_medium, threads::thread_schedule_hint(),
+            ec);
+        if (ec)
+            return "<couldn't retrieve stack backtrace>";
+
+        // make sure this thread is executed last
+        hpx::this_thread::yield_to(thread::id(std::move(tid)));
+
+        return p.get_future().get(ec);
+#else
+        return "";
+#endif
+    }
+}}
+
 namespace hpx { namespace detail
 {
     void pre_exception_handler()
@@ -203,35 +246,37 @@ namespace hpx { namespace detail
         std::abort();
     }
 
-    template <typename Exception>
-    HPX_EXPORT std::exception_ptr construct_exception(Exception const& e,
+    HPX_EXPORT hpx::exception_info construct_exception_info(
         std::string const& func, std::string const& file, long line,
         std::string const& back_trace, std::uint32_t node,
         std::string const& hostname, std::int64_t pid, std::size_t shepherd,
         std::size_t thread_id, std::string const& thread_name,
         std::string const& env, std::string const& config,
         std::string const& state_name, std::string const& auxinfo)
+    {
+        return hpx::exception_info().set(
+            hpx::detail::throw_stacktrace(back_trace),
+            hpx::detail::throw_locality(node),
+            hpx::detail::throw_hostname(hostname), hpx::detail::throw_pid(pid),
+            hpx::detail::throw_shepherd(shepherd),
+            hpx::detail::throw_thread_id(thread_id),
+            hpx::detail::throw_thread_name(thread_name),
+            hpx::detail::throw_function(func), hpx::detail::throw_file(file),
+            hpx::detail::throw_line(line), hpx::detail::throw_env(env),
+            hpx::detail::throw_config(config),
+            hpx::detail::throw_state(state_name),
+            hpx::detail::throw_auxinfo(auxinfo));
+    }
+
+    template <typename Exception>
+    HPX_EXPORT std::exception_ptr construct_exception(
+        Exception const& e, hpx::exception_info info)
     {
         // create a std::exception_ptr object encapsulating the Exception to
         // be thrown and annotate it with all the local information we have
         try
         {
-            throw_with_info(e,
-                std::move(hpx::exception_info().set(
-                    hpx::detail::throw_stacktrace(back_trace),
-                    hpx::detail::throw_locality(node),
-                    hpx::detail::throw_hostname(hostname),
-                    hpx::detail::throw_pid(pid),
-                    hpx::detail::throw_shepherd(shepherd),
-                    hpx::detail::throw_thread_id(thread_id),
-                    hpx::detail::throw_thread_name(thread_name),
-                    hpx::detail::throw_function(func),
-                    hpx::detail::throw_file(file),
-                    hpx::detail::throw_line(line),
-                    hpx::detail::throw_env(env),
-                    hpx::detail::throw_config(config),
-                    hpx::detail::throw_state(state_name),
-                    hpx::detail::throw_auxinfo(auxinfo))));
+            throw_with_info(e, std::move(info));
         }
         catch (...)
         {
@@ -244,133 +289,37 @@ namespace hpx { namespace detail
     }
 
     template HPX_EXPORT std::exception_ptr construct_exception(
-        hpx::exception const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        hpx::exception const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        boost::system::system_error const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        boost::system::system_error const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::exception const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::exception const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        hpx::detail::std_exception const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        hpx::detail::std_exception const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::bad_exception const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::bad_exception const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        hpx::detail::bad_exception const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        hpx::detail::bad_exception const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::bad_typeid const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::bad_typeid const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        hpx::detail::bad_typeid const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        hpx::detail::bad_typeid const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::bad_cast const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::bad_cast const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        hpx::detail::bad_cast const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        hpx::detail::bad_cast const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::bad_alloc const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::bad_alloc const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        hpx::detail::bad_alloc const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        hpx::detail::bad_alloc const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::logic_error const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::logic_error const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::runtime_error const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::runtime_error const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::out_of_range const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::out_of_range const&, hpx::exception_info info);
     template HPX_EXPORT std::exception_ptr construct_exception(
-        std::invalid_argument const&,
-        std::string const& func, std::string const& file, long line,
-        std::string const& back_trace, std::uint32_t node,
-        std::string const& hostname, std::int64_t pid, std::size_t shepherd,
-        std::size_t thread_id, std::string const& thread_name,
-        std::string const& env, std::string const& config,
-        std::string const& state_name, std::string const& auxinfo);
+        std::invalid_argument const&, hpx::exception_info info);
 
     ///////////////////////////////////////////////////////////////////////////
     //  Figure out the size of the given environment
diff --git a/src/hpx_init.cpp b/src/hpx_init.cpp
index a59b343608..dc465e0a96 100644
--- a/src/hpx_init.cpp
+++ b/src/hpx_init.cpp
@@ -12,8 +12,9 @@
 #include <hpx/apply.hpp>
 #include <hpx/assertion.hpp>
 #include <hpx/async.hpp>
+#include <hpx/basic_execution/register_locks.hpp>
+#include <hpx/coroutines/detail/context_impl.hpp>
 #include <hpx/custom_exception_info.hpp>
-#include <hpx/datastructures/tuple.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/filesystem.hpp>
 #include <hpx/format.hpp>
@@ -28,22 +29,28 @@
 #include <hpx/runtime/config_entry.hpp>
 #include <hpx/runtime/find_localities.hpp>
 #include <hpx/resource_partitioner/detail/create_partitioner.hpp>
+#include <hpx/resource_partitioner/partitioner.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
+#include <hpx/schedulers.hpp>
 #include <hpx/runtime_handlers.hpp>
 #include <hpx/runtime_impl.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/string_util/classification.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
-#include <hpx/util/external_timer.hpp>
+#include <hpx/type_support/pack.hpp>
 #include <hpx/util/bind_action.hpp>
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
 #include <hpx/util/debugging.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/util/init_logging.hpp>
 #include <hpx/util/query_counters.hpp>
+#include <hpx/util/register_locks_globally.hpp>
 
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/lexical_cast.hpp>
+#if defined(HPX_HAVE_NETWORKING) && defined(HPX_HAVE_PARCELPORT_MPI)
+#include <hpx/plugins/parcelport/mpi/mpi_environment.hpp>
+#endif
 
 #include <hpx/program_options/options_description.hpp>
 #include <hpx/program_options/parsers.hpp>
@@ -100,11 +107,10 @@ HPX_PLAIN_ACTION_ID(hpx::detail::list_component_type,
 typedef
     hpx::util::detail::bound_action<
         list_component_type_action
-      , hpx::util::tuple<
-            hpx::naming::id_type
-          , hpx::util::detail::placeholder<1>
-          , hpx::util::detail::placeholder<2>
-        >
+      , hpx::util::index_pack<0, 1, 2>
+      , hpx::naming::id_type
+      , hpx::util::detail::placeholder<1>
+      , hpx::util::detail::placeholder<2>
     >
     bound_list_component_type_action;
 
@@ -332,6 +338,69 @@ namespace hpx
             std::reference_wrapper<hpx::runtime const> rt_;
         };
 
+        ///////////////////////////////////////////////////////////////////////
+        void activate_global_options(util::command_line_handling& cms,
+            int argc, char** argv)
+        {
+#if defined(__linux) || defined(linux) || defined(__linux__) ||                \
+    defined(__FreeBSD__)
+            threads::coroutines::detail::posix::use_guard_pages =
+                cms.rtcfg_.use_stack_guard_pages();
+#endif
+#ifdef HPX_HAVE_VERIFY_LOCKS
+            if (cms.rtcfg_.enable_lock_detection())
+            {
+                util::enable_lock_detection();
+            }
+            else
+            {
+                util::disable_lock_detection();
+            }
+#endif
+#ifdef HPX_HAVE_VERIFY_LOCKS_GLOBALLY
+            if (cms.rtcfg_.enable_global_lock_detection())
+            {
+                util::enable_global_lock_detection();
+            }
+            else
+            {
+                util::disable_global_lock_detection();
+            }
+#endif
+#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
+            threads::policies::set_minimal_deadlock_detection_enabled(
+                cms.rtcfg_.enable_minimal_deadlock_detection());
+#endif
+#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
+            util::detail::spinlock_break_on_deadlock =
+                cms.rtcfg_.enable_spinlock_deadlock_detection();
+            util::detail::spinlock_deadlock_detection_limit =
+                cms.rtcfg_.get_spinlock_deadlock_detection_limit();
+#endif
+
+            // initialize logging
+            util::detail::init_logging(
+                cms.rtcfg_, cms.rtcfg_.mode_ == runtime_mode_console);
+
+#if defined(HPX_HAVE_NETWORKING)
+#if defined(HPX_HAVE_PARCELPORT_MPI)
+            // getting localities from MPI environment (support mpirun)
+            if (util::detail::check_mpi_environment(cms.rtcfg_))
+            {
+                util::mpi_environment::init(&argc, &argv, cms);
+                cms.num_localities_ =
+                    static_cast<std::size_t>(util::mpi_environment::size());
+            }
+#endif
+
+            if (cms.num_localities_ != 1 || cms.node_ != 0 ||
+                cms.rtcfg_.enable_networking())
+            {
+                parcelset::parcelhandler::init(&argc, &argv, cms);
+            }
+#endif
+        }
+
         ///////////////////////////////////////////////////////////////////////
         void handle_list_and_print_options(hpx::runtime& rt,
             hpx::program_options::variables_map& vm,
@@ -402,9 +471,9 @@ namespace hpx
                     if (counter_format == "csv-short"){
                         for (std::size_t i = 0; i != counters.size() ; ++i) {
                             std::vector<std::string> entry;
-                            boost::algorithm::split(entry, counters[i],
-                                boost::algorithm::is_any_of(","),
-                                boost::algorithm::token_compress_on);
+                            hpx::string_util::split(entry, counters[i],
+                                hpx::string_util::is_any_of(","),
+                                hpx::string_util::token_compress_mode::on);
 
                             if (entry.size() != 2)
                             {
@@ -556,14 +625,15 @@ namespace hpx
             util::command_line_handling& cfg,
             startup_function_type startup, shutdown_function_type shutdown)
         {
-            if (blocking) {
+            if (blocking)
+            {
                 return run(*rt, cfg.hpx_main_f_, cfg.vm_, cfg.rtcfg_.mode_,
                     std::move(startup), std::move(shutdown));
             }
 
             // non-blocking version
-            start(*rt, cfg.hpx_main_f_, cfg.vm_, cfg.rtcfg_.mode_, std::move(startup),
-                std::move(shutdown));
+            start(*rt, cfg.hpx_main_f_, cfg.vm_, cfg.rtcfg_.mode_,
+                std::move(startup), std::move(shutdown));
 
             // pointer to runtime is stored in TLS
             hpx::runtime* p = rt.release();
@@ -572,15 +642,8 @@ namespace hpx
             return 0;
         }
 
-        ///////////////////////////////////////////////////////////////////////
-        HPX_EXPORT int run_or_start(
-            util::function_nonser<
-                int(hpx::program_options::variables_map& vm)
-            > const& f,
-            hpx::program_options::options_description const& desc_cmdline,
-            int argc, char** argv, std::vector<std::string> && ini_config,
-            startup_function_type startup, shutdown_function_type shutdown,
-            hpx::runtime_mode mode, bool blocking)
+        ////////////////////////////////////////////////////////////////////////
+        void init_environment()
         {
             HPX_UNUSED(hpx::filesystem::initial_path());
 
@@ -605,6 +668,10 @@ namespace hpx
 #endif
             hpx::threads::detail::set_get_default_pool(
                 &detail::get_default_pool);
+            hpx::threads::detail::set_get_default_timer_service(
+                &hpx::detail::get_default_timer_service);
+            hpx::threads::detail::set_get_locality_id(
+                &get_locality_id);
 
 #if defined(HPX_NATIVE_MIC) || defined(__bgq__) || defined(__bgqion__)
             unsetenv("LANG");
@@ -622,29 +689,52 @@ namespace hpx
             unsetenv("LC_IDENTIFICATION");
             unsetenv("LC_ALL");
 #endif
+        }
+
+        // make sure the runtime system is not active yet
+        int ensure_no_runtime_is_up()
+        {
+            // make sure the runtime system is not active yet
+            if (get_runtime_ptr() != nullptr)
+            {
+#if (HPX_HAVE_DYNAMIC_HPX_MAIN != 0) &&                                        \
+    (defined(__linux) || defined(__linux__) || defined(linux) ||               \
+        defined(__APPLE__))
+                // make sure the runtime system is not initialized
+                // after its activation from int main()
+                if(hpx_start::include_libhpx_wrap)
+                {
+                    std::cerr << "hpx is already initialized from main.\n"
+                        "Note: Delete hpx_main.hpp to initialize hpx system "
+                        "using hpx::init. Exiting...\n";
+                    return -1;
+                }
+#endif
+                std::cerr << "hpx::init: can't initialize runtime system "
+                    "more than once! Exiting...\n";
+                return -1;
+            }
+            return 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        HPX_EXPORT int run_or_start(
+            util::function_nonser<
+                int(hpx::program_options::variables_map& vm)
+            > const& f,
+            hpx::program_options::options_description const& desc_cmdline,
+            int argc, char** argv, std::vector<std::string> && ini_config,
+            startup_function_type startup, shutdown_function_type shutdown,
+            hpx::runtime_mode mode, bool blocking)
+        {
+            init_environment();
 
             int result = 0;
             try {
                 // make sure the runtime system is not active yet
-                if (get_runtime_ptr() != nullptr)
+                if ((result = ensure_no_runtime_is_up()) != 0)
                 {
-                #if (HPX_HAVE_DYNAMIC_HPX_MAIN != 0) && \
-                (defined(__linux) || defined(__linux__) || defined(linux) || \
-                defined(__APPLE__))
-                    // make sure the runtime system is not initialized
-                    // after its activation from int main()
-                    if(hpx_start::include_libhpx_wrap)
-                    {
-                        std::cerr << "hpx is already initialized from main.\n"
-                            "Note: Delete hpx_main.hpp to initialize hpx system "
-                            "using hpx::init. Exiting...\n";
-                        return -1;
-                    }
-                #endif
-
-                    std::cerr << "hpx::init: can't initialize runtime system "
-                        "more than once! Exiting...\n";
-                    return -1;
+                    return result;
                 }
 
                 // scope exception handling to resource partitioner initialization
@@ -658,6 +748,9 @@ namespace hpx
                         desc_cmdline, argc, argv, std::move(ini_config),
                         resource::mode_default, mode, false, &result);
 
+                    activate_global_options(rp.get_command_line_switches(),
+                        argc, argv);
+
                     // check whether HPX should be exited at this point
                     // (parse_result is returning a result > 0, if the program options
                     // contain --hpx:help or --hpx:version, on error result is < 0)
@@ -698,21 +791,72 @@ namespace hpx
             return result;
         }
 
+        ////////////////////////////////////////////////////////////////////////
         template <typename T>
         inline T
         get_option(std::string const& config, T default_ = T())
         {
             if (!config.empty()) {
                 try {
-                    return boost::lexical_cast<T>(
+                    return hpx::util::from_string<T>(
                         get_runtime().get_config().get_entry(config, default_));
                 }
-                catch (boost::bad_lexical_cast const&) {
+                catch (hpx::util::bad_lexical_cast const&) {
                     ;   // do nothing
                 }
             }
             return default_;
         }
+
+        ////////////////////////////////////////////////////////////////////////////
+        HPX_EXPORT int run_or_start(resource::partitioner& rp,
+            startup_function_type startup, shutdown_function_type shutdown,
+            bool blocking)
+        {
+            init_environment();
+
+            // propagate any non-zero return values that were generated by the
+            // command line handling
+            int result = rp.parse_result();
+            if (result != 0)
+            {
+                if (result > 0)
+                    result = 0;
+                return result;
+            }
+
+            try
+            {
+                // make sure the runtime system is not active yet
+                if ((result = ensure_no_runtime_is_up()) != 0)
+                {
+                    return result;
+                }
+
+                // Setup all internal parameters of the resource_partitioner
+                rp.configure_pools();
+
+                // Initialize and start the HPX runtime.
+                LPROGRESS_ << "run_local: create runtime";
+
+                // Build and configure this runtime instance.
+                typedef hpx::runtime_impl runtime_type;
+
+                util::command_line_handling& cms =
+                    rp.get_command_line_switches();
+
+                std::unique_ptr<hpx::runtime> rt(new runtime_type(cms.rtcfg_));
+                result = run_or_start(blocking, std::move(rt), cms,
+                    std::move(startup), std::move(shutdown));
+            }
+            catch (detail::command_line_error const& e)
+            {
+                std::cerr << "hpx::init: std::exception caught: " << e.what()
+                          << "\n";
+                return -1;
+            }
+            return result;
+        }
     }
 
     ///////////////////////////////////////////////////////////////////////////
diff --git a/src/hpx_wrap.cpp b/src/hpx_wrap.cpp
index 8232c92691..6f87e5d4db 100644
--- a/src/hpx_wrap.cpp
+++ b/src/hpx_wrap.cpp
@@ -26,7 +26,7 @@ namespace hpx_start
 
 #include <hpx/hpx_finalize.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/runtime/runtime_mode.hpp>
+#include <hpx/runtime_configuration/runtime_mode.hpp>
 #include <hpx/functional/function.hpp>
 
 #include <string>
diff --git a/src/lcos/base_lco_with_value_3.cpp b/src/lcos/base_lco_with_value_3.cpp
index b0422e5bfc..349c276d7e 100644
--- a/src/lcos/base_lco_with_value_3.cpp
+++ b/src/lcos/base_lco_with_value_3.cpp
@@ -9,7 +9,7 @@
 #include <hpx/lcos/base_lco_with_value.hpp>
 #include <hpx/runtime/applier/apply.hpp>
 #include <hpx/serialization/vector.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
 
 #include <cstdint>
 #include <string>
diff --git a/src/lcos/detail/future_data.cpp b/src/lcos/detail/future_data.cpp
index bd2bf9eef2..24d4eabd47 100644
--- a/src/lcos/detail/future_data.cpp
+++ b/src/lcos/detail/future_data.cpp
@@ -17,9 +17,9 @@
 #include <hpx/memory/intrusive_ptr.hpp>
 #include <hpx/runtime/components/client_base.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/util/annotated_function.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
+#include <hpx/threading.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <cstddef>
 #include <exception>
diff --git a/src/lcos/future.cpp b/src/lcos/future.cpp
index 0733616263..0ef430ac6e 100644
--- a/src/lcos/future.cpp
+++ b/src/lcos/future.cpp
@@ -5,6 +5,7 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/lcos/future.hpp>
+#include <hpx/serialization/output_archive.hpp>
 #include <hpx/runtime/serialization/detail/preprocess_futures.hpp>
 
 namespace hpx { namespace lcos { namespace detail {
diff --git a/src/performance_counters/server/component_instance_counter.cpp b/src/performance_counters/server/component_instance_counter.cpp
deleted file mode 100644
index cea09290d7..0000000000
--- a/src/performance_counters/server/component_instance_counter.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-//  Copyright (c) 2007-2019 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/performance_counters/counter_creators.hpp>
-#include <hpx/performance_counters/counters.hpp>
-#include <hpx/runtime/agas/addressing_service.hpp>
-#include <hpx/runtime/agas/interface.hpp>
-#include <hpx/runtime/components/component_type.hpp>
-#include <hpx/functional/bind_front.hpp>
-#include <hpx/functional/function.hpp>
-
-#include <cstdint>
-#include <sstream>
-#include <utility>
-
-///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace performance_counters { namespace detail
-{
-    ///////////////////////////////////////////////////////////////////////////
-    // Extract the current number of instances for the given component type
-    static std::int64_t get_instance_count(components::component_type type)
-    {
-        return hpx::components::instance_count(type);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    /// Creation function for instance counter
-    naming::gid_type component_instance_counter_creator(
-        counter_info const& info, error_code& ec)
-    {
-        switch (info.type_) {
-        case counter_raw:
-            {
-                counter_path_elements paths;
-                get_counter_path_elements(info.fullname_, paths, ec);
-                if (ec) return naming::invalid_gid;
-
-                if (paths.parentinstance_is_basename_) {
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "component_instance_counter_creator",
-                        "invalid instance counter name (instance name must not "
-                        "be a valid base counter name)");
-                    return naming::invalid_gid;
-                }
-
-                if (paths.parameters_.empty()) {
-                    std::stringstream strm;
-                    strm << "invalid instance counter parameter: must specify "
-                            "a component type\n"
-                            "known component types:\n";
-
-                    components::enumerate_instance_counts(
-                        [&strm](components::component_type type) -> bool
-                        {
-                            strm << "  "
-                                 << agas::get_component_type_name(type)
-                                 << "\n";
-                            return true;
-                        });
-
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "component_instance_counter_creator", strm.str());
-
-                    return naming::invalid_gid;
-                }
-
-                // ask AGAS to resolve the component type
-                components::component_type type =
-                    naming::get_agas_client().get_component_id(paths.parameters_);
-
-                if (type == components::component_invalid) {
-                    HPX_THROWS_IF(ec, bad_parameter,
-                        "component_instance_counter_creator",
-                        "invalid component type as counter parameter: " +
-                        paths.parameters_);
-                    return naming::invalid_gid;
-                }
-
-                hpx::util::function_nonser<std::int64_t()> f =
-                    util::bind_front(&get_instance_count, type);
-                return create_raw_counter(info, std::move(f), ec);
-            }
-            break;
-
-        default:
-            HPX_THROWS_IF(ec, bad_parameter, "component_instance_counter_creator",
-                "invalid counter type requested");
-            return naming::invalid_gid;
-        }
-    }
-}}}
-
diff --git a/src/pre_main.cpp b/src/pre_main.cpp
index 9a166f398b..046a05e065 100644
--- a/src/pre_main.cpp
+++ b/src/pre_main.cpp
@@ -25,7 +25,7 @@
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/runtime/threads/threadmanager_counters.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 
 #include <cstddef>
 #include <string>
diff --git a/src/runtime.cpp b/src/runtime.cpp
index 880ef87b2c..61242f6f59 100644
--- a/src/runtime.cpp
+++ b/src/runtime.cpp
@@ -27,14 +27,15 @@
 #include <hpx/runtime/parcelset/parcelhandler.hpp>
 #include <hpx/runtime/thread_hooks.hpp>
 #include <hpx/coroutines/coroutine.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/topology/topology.hpp>
 #include <hpx/state.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
 #include <hpx/util/backtrace.hpp>
-#include <hpx/util/command_line_handling.hpp>
+#include <hpx/command_line_handling.hpp>
 #include <hpx/util/debugging.hpp>
+#include <hpx/util/from_string.hpp>
 #include <hpx/util/query_counters.hpp>
 #include <hpx/util/thread_mapper.hpp>
 #include <hpx/version.hpp>
@@ -204,34 +205,6 @@ namespace hpx
 
 
     ///////////////////////////////////////////////////////////////////////////
-    namespace strings
-    {
-        char const* const runtime_mode_names[] =
-        {
-            "invalid",    // -1
-            "console",    // 0
-            "worker",     // 1
-            "connect",    // 2
-            "default",    // 3
-        };
-    }
-
-    char const* get_runtime_mode_name(runtime_mode state)
-    {
-        if (state < runtime_mode_invalid || state >= runtime_mode_last)
-            return "invalid (value out of bounds)";
-        return strings::runtime_mode_names[state+1];
-    }
-
-    runtime_mode get_runtime_mode_from_name(std::string const& mode)
-    {
-        for (std::size_t i = 0; i < runtime_mode_last; ++i) {
-            if (mode == strings::runtime_mode_names[i])
-                return static_cast<runtime_mode>(i-1);
-        }
-        return runtime_mode_invalid;
-    }
-
     namespace strings
     {
         char const* const runtime_state_names[] =
@@ -312,7 +285,7 @@ namespace hpx
     namespace {
         std::uint64_t& runtime_uptime()
         {
-            static HPX_NATIVE_TLS std::uint64_t uptime;
+            static thread_local std::uint64_t uptime;
             return uptime;
         }
     }
@@ -398,10 +371,10 @@ namespace hpx
             active_counters_->evaluate_counters(reset, description, ec);
     }
 
-    void runtime::stop_evaluating_counters()
+    void runtime::stop_evaluating_counters(bool terminate)
     {
         if (active_counters_.get())
-            active_counters_->stop_evaluating_counters();
+            active_counters_->stop_evaluating_counters(terminate);
     }
 
 #if defined(HPX_HAVE_NETWORKING)
@@ -871,7 +844,7 @@ namespace hpx
 
     runtime*& get_runtime_ptr()
     {
-        static HPX_NATIVE_TLS runtime* runtime_;
+        static thread_local runtime* runtime_;
         return runtime_;
     }
 
@@ -883,7 +856,7 @@ namespace hpx
     std::string get_thread_name()
     {
         std::string& thread_name = detail::thread_name();
-        if (thread_name.empty()) return "<unkown>";
+        if (thread_name.empty()) return "<unknown>";
         return thread_name;
     }
 
@@ -1038,6 +1011,47 @@ namespace hpx
         }
     }
 
+    namespace util {
+        ///////////////////////////////////////////////////////////////////////////
+        // retrieve the command line arguments for the current locality
+        bool retrieve_commandline_arguments(
+            hpx::program_options::options_description const& app_options,
+            hpx::program_options::variables_map& vm)
+        {
+            // The command line for this application instance is available from
+            // this configuration section:
+            //
+            //     [hpx]
+            //     cmd_line=....
+            //
+            std::string cmdline;
+            std::size_t node = std::size_t(-1);
+
+            hpx::util::section& cfg = hpx::get_runtime().get_config();
+            if (cfg.has_entry("hpx.cmd_line"))
+                cmdline = cfg.get_entry("hpx.cmd_line");
+            if (cfg.has_entry("hpx.locality"))
+                node = hpx::util::from_string<std::size_t>(
+                    cfg.get_entry("hpx.locality"));
+
+            return parse_commandline(
+                cfg, app_options, cmdline, vm, node, allow_unregistered);
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // retrieve the command line arguments for the current locality
+        bool retrieve_commandline_arguments(
+            std::string const& appname, hpx::program_options::variables_map& vm)
+        {
+            using hpx::program_options::options_description;
+
+            options_description desc_commandline(
+                "Usage: " + appname + " [options]");
+
+            return retrieve_commandline_arguments(desc_commandline, vm);
+        }
+    }    // namespace util
+
     ///////////////////////////////////////////////////////////////////////////
     // Helpers
     naming::id_type find_here(error_code& ec)
@@ -1256,16 +1270,6 @@ namespace hpx
             threads::detail::current_concurrency, ec);
     }
 
-    std::size_t get_worker_thread_num()
-    {
-        return get_worker_thread_num(throws);
-    }
-
-    std::size_t get_worker_thread_num(error_code& ec)
-    {
-        return threads::detail::get_thread_num_tss();
-    }
-
     std::size_t get_num_worker_threads()
     {
         runtime* rt = get_runtime_ptr();
@@ -1598,10 +1602,11 @@ namespace hpx
 #endif
 
     // helper function to stop evaluating counters during shutdown
-    void stop_evaluating_counters()
+    void stop_evaluating_counters(bool terminate)
     {
         runtime* rt = get_runtime_ptr();
-        if (nullptr != rt) rt->stop_evaluating_counters();
+        if (nullptr != rt)
+            rt->stop_evaluating_counters(terminate);
     }
 
     ///////////////////////////////////////////////////////////////////////////
diff --git a/src/runtime/actions/base_action.cpp b/src/runtime/actions/base_action.cpp
index a41f67adb2..eda4bb8f7f 100644
--- a/src/runtime/actions/base_action.cpp
+++ b/src/runtime/actions/base_action.cpp
@@ -7,8 +7,6 @@
 #include <hpx/config.hpp>
 
 #if defined(HPX_HAVE_NETWORKING)
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-
 #include <hpx/runtime/actions/base_action.hpp>
 #include <hpx/runtime/get_locality_id.hpp>
 #include <hpx/serialization/serialize.hpp>
diff --git a/src/runtime/agas/addressing_service.cpp b/src/runtime/agas/addressing_service.cpp
index f30760c0e0..1db4e317cc 100644
--- a/src/runtime/agas/addressing_service.cpp
+++ b/src/runtime/agas/addressing_service.cpp
@@ -49,9 +49,9 @@
 #include <hpx/traits/action_was_object_migrated.hpp>
 #include <hpx/traits/component_supports_migration.hpp>
 #include <hpx/type_support/unused.hpp>
+#include <hpx/util/get_entry_as.hpp>
 #include <hpx/util/insert_checked.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -3018,7 +3018,7 @@ namespace hpx
     {
         return f.then(
             hpx::launch::sync,
-            [sequence_nr, HPX_CAPTURE_MOVE(base_name)](
+            [sequence_nr, base_name = std::move(base_name)](
                 hpx::future<hpx::id_type> && f
             ) mutable -> hpx::future<bool>
             {
diff --git a/src/runtime/agas/big_boot_barrier.cpp b/src/runtime/agas/big_boot_barrier.cpp
index 41c91e5ee4..43e9bace0f 100644
--- a/src/runtime/agas/big_boot_barrier.cpp
+++ b/src/runtime/agas/big_boot_barrier.cpp
@@ -12,6 +12,8 @@
 
 #if defined(HPX_HAVE_NETWORKING)
 #include <hpx/assertion.hpp>
+#include <hpx/format.hpp>
+#include <hpx/functional/bind_front.hpp>
 #include <hpx/runtime.hpp>
 #include <hpx/runtime/actions/action_support.hpp>
 #include <hpx/runtime/actions/plain_action.hpp>
@@ -33,14 +35,15 @@
 #include <hpx/runtime/parcelset/put_parcel.hpp>
 #include <hpx/serialization/detail/polymorphic_id_factory.hpp>
 #include <hpx/serialization/vector.hpp>
+#include <hpx/static_reinit/reinitializable_static.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
 #include <hpx/topology/topology.hpp>
+#include <hpx/util/from_string.hpp>
 #include <hpx/functional/bind_front.hpp>
-#include <hpx/synchronization/detail/yield_k.hpp>
 #include <hpx/format.hpp>
 #include <hpx/static_reinit/reinitializable_static.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -775,7 +778,7 @@ void big_boot_barrier::wait_hosted(
     if(locality_str != "-1")
     {
         suggested_prefix = naming::get_gid_from_locality_id(
-            util::safe_lexical_cast<std::uint32_t>(locality_str, -1));
+            util::from_string<std::uint32_t>(locality_str, -1));
     }
 
     // pre-load all unassigned ids
diff --git a/src/runtime/applier/applier.cpp b/src/runtime/applier/applier.cpp
index 8661116f58..1c9e6c7eb2 100644
--- a/src/runtime/applier/applier.cpp
+++ b/src/runtime/applier/applier.cpp
@@ -18,9 +18,9 @@
 #include <hpx/runtime/naming/resolver_client.hpp>
 #include <hpx/runtime/parcelset/parcel.hpp>
 #include <hpx/runtime/parcelset/parcelhandler.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
 #include <cstddef>
 #include <cstdint>
diff --git a/src/runtime/components/component_registry.cpp b/src/runtime/components/component_registry.cpp
index 1bbd6335d9..725d5ecbe5 100644
--- a/src/runtime/components/component_registry.cpp
+++ b/src/runtime/components/component_registry.cpp
@@ -6,18 +6,15 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
 #include <hpx/runtime/components/component_registry.hpp>
 
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/runtime/components/component_type.hpp>
-#include <hpx/util/find_prefix.hpp>
+#include <hpx/prefix/find_prefix.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
 
 #include <algorithm>
 #include <string>
@@ -63,7 +60,7 @@ namespace hpx { namespace components { namespace detail
 
         if (more) {
             std::vector<std::string> data;
-            boost::split(data, more, boost::is_any_of("\n"));
+            hpx::string_util::split(data, more, hpx::string_util::is_any_of("\n"));
             std::copy(data.begin(), data.end(), std::back_inserter(fillini));
         }
     }
diff --git a/src/runtime/components/server/console_error_sink_server.cpp b/src/runtime/components/server/console_error_sink_server.cpp
index cf7693b278..fedd02a870 100644
--- a/src/runtime/components/server/console_error_sink_server.cpp
+++ b/src/runtime/components/server/console_error_sink_server.cpp
@@ -8,7 +8,7 @@
 #include <hpx/config.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/custom_exception_info.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
 #include <hpx/lcos/base_lco_with_value.hpp>
 #include <hpx/runtime/actions/continuation.hpp>
 #include <hpx/runtime/actions/basic_action.hpp>
diff --git a/src/runtime/components/server/console_logging_server.cpp b/src/runtime/components/server/console_logging_server.cpp
index 2923d438de..12514de9cb 100644
--- a/src/runtime/components/server/console_logging_server.cpp
+++ b/src/runtime/components/server/console_logging_server.cpp
@@ -17,7 +17,7 @@
 #include <hpx/runtime/actions/transfer_continuation_action.hpp>
 #include <hpx/runtime/components/server/console_logging.hpp>
 #include <hpx/type_support/static.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
 
 #include <cstddef>
 #include <mutex>
diff --git a/src/runtime/components/server/destroy_component.cpp b/src/runtime/components/server/destroy_component.cpp
index b81d2a4e22..187a23feed 100644
--- a/src/runtime/components/server/destroy_component.cpp
+++ b/src/runtime/components/server/destroy_component.cpp
@@ -31,7 +31,7 @@ namespace hpx { namespace components { namespace server
         {
             // Check if component was migrated, we are not interested in
             // pinning the object as it is supposed to be destroyed anyways
-            // that is, noone else has a handle to it anymore
+            // that is, no one else has a handle to it anymore
             auto r = agas::was_object_migrated(gid,
                 [](){ return pinned_ptr(); });
 
diff --git a/src/runtime/components/server/runtime_support_server.cpp b/src/runtime/components/server/runtime_support_server.cpp
index 6c14b582ed..2d02076cf5 100644
--- a/src/runtime/components/server/runtime_support_server.cpp
+++ b/src/runtime/components/server/runtime_support_server.cpp
@@ -13,8 +13,10 @@
 #include <hpx/runtime.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
 #include <hpx/timing.hpp>
-#include <hpx/util/find_prefix.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/prefix/find_prefix.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
+#include <hpx/string_util/case_conv.hpp>
 
 #include <hpx/lcos/wait_all.hpp>
 #include <hpx/performance_counters/counters.hpp>
@@ -27,7 +29,7 @@
 #include <hpx/runtime/components/server/create_component.hpp>
 #include <hpx/runtime/components/server/memory.hpp>
 #include <hpx/runtime/components/server/runtime_support.hpp>
-#include <hpx/runtime/components/static_factory_data.hpp>
+#include <hpx/runtime_configuration/static_factory_data.hpp>
 #include <hpx/runtime/components/stubs/runtime_support.hpp>
 #include <hpx/runtime/find_localities.hpp>
 #include <hpx/runtime/naming/resolver_client.hpp>
@@ -42,9 +44,9 @@
 #include <hpx/local_lcos/packaged_task.hpp>
 
 #include <hpx/assertion.hpp>
-#include <hpx/util/command_line_handling.hpp>
-#include <hpx/util/parse_command_line.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
+#include <hpx/command_line_handling/command_line_handling.hpp>
+#include <hpx/command_line_handling/parse_command_line.hpp>
 
 #include <hpx/plugins/message_handler_factory_base.hpp>
 #include <hpx/plugins/binary_filter_factory_base.hpp>
@@ -53,8 +55,6 @@
 #include <hpx/plugins/parcelport/mpi/mpi_environment.hpp>
 #endif
 
-#include <boost/algorithm/string/case_conv.hpp>
-#include <boost/lexical_cast.hpp>
 #include <boost/tokenizer.hpp>
 
 #include <algorithm>
@@ -134,7 +134,7 @@ HPX_DEFINE_GET_COMPONENT_TYPE_STATIC(
 namespace hpx
 {
     // helper function to stop evaluating counters during shutdown
-    void stop_evaluating_counters();
+    void stop_evaluating_counters(bool terminate = false);
 }
 
 namespace hpx { namespace components
@@ -387,8 +387,7 @@ namespace hpx { namespace components { namespace server
                 tm.cleanup_terminated(true);
                 return tm.get_thread_count() >
                     std::int64_t(1) + tm.get_background_thread_count();
-            }, "runtime_support::dijkstra_termination", hpx::threads::pending,
-            false); // Don't allow timed suspension
+            }, "runtime_support::dijkstra_termination", false);
 
         // Now this locality has become passive, thus we can send the token
         // to the next locality.
@@ -426,8 +425,7 @@ namespace hpx { namespace components { namespace server
                     tm.cleanup_terminated(true);
                     return tm.get_thread_count() >
                         std::int64_t(1) + tm.get_background_thread_count();
-                }, "runtime_support::dijkstra_termination",
-                hpx::threads::pending, false); // Don't allow timed suspension
+                }, "runtime_support::dijkstra_termination", false);
 
             return 0;
         }
@@ -487,8 +485,7 @@ namespace hpx { namespace components { namespace server
                 tm.cleanup_terminated(true);
                 return tm.get_thread_count() >
                     std::int64_t(1) + tm.get_background_thread_count();
-            }, "runtime_support::dijkstra_termination", hpx::threads::pending,
-            false); // Don't allow timed suspension
+            }, "runtime_support::dijkstra_termination", false);
 
         // Now this locality has become passive, thus we can send the token
         // to the next locality.
@@ -567,8 +564,7 @@ namespace hpx { namespace components { namespace server
                     tm.cleanup_terminated(true);
                     return tm.get_thread_count() >
                         std::int64_t(1) + tm.get_background_thread_count();
-                }, "runtime_support::dijkstra_termination",
-                hpx::threads::pending, false); // Don't allow timed suspension
+                }, "runtime_support::dijkstra_termination", false);
 
             return 0;
         }
@@ -640,7 +636,7 @@ namespace hpx { namespace components { namespace server
 
         agas_client.start_shutdown();
 
-        stop_evaluating_counters();
+        stop_evaluating_counters(true);
 
         // wake up suspended pus
         threads::threadmanager& tm = appl.get_thread_manager();
@@ -842,8 +838,7 @@ namespace hpx { namespace components { namespace server
 
                         return tm.get_thread_count() >
                             std::int64_t(1) + tm.get_background_thread_count();
-                    }, "runtime_support::stop", hpx::threads::pending,
-                    false); // Don't allow timed suspension
+                    }, "runtime_support::stop", false);
 
                 // If it took longer than expected, kill all suspended threads as
                 // well.
@@ -866,9 +861,7 @@ namespace hpx { namespace components { namespace server
                             return tm.get_thread_count() >
                                 std::int64_t(1) +
                                 tm.get_background_thread_count();
-                        }, "runtime_support::dijkstra_termination",
-                        hpx::threads::pending,
-                        false); // Don't allow timed suspension
+                        }, "runtime_support::dijkstra_termination", false);
                 }
 
                 // Drop the locality from the partition table.
@@ -1136,7 +1129,7 @@ namespace hpx { namespace components { namespace server
                     get_runtime_mode_from_name(runtime_mode));
 
                 if (vm.count("hpx:print-bind")) {
-                    std::size_t num_threads = boost::lexical_cast<std::size_t>(
+                    std::size_t num_threads = hpx::util::from_string<std::size_t>(
                         ini.get_entry("hpx.os_threads", 1));
                     detail::handle_print_bind(vm, num_threads);
                 }
@@ -1574,7 +1567,7 @@ namespace hpx { namespace components { namespace server
             bool isenabled = true;
             if (sect.has_entry("enabled")) {
                 std::string tmp = sect.get_entry("enabled");
-                boost::algorithm::to_lower (tmp);
+                hpx::string_util::to_lower (tmp);
                 if (tmp == "no" || tmp == "false" || tmp == "0") {
                     LRT_(info) << "component factory disabled: " << instance;
                     isenabled = false;     // this component has been disabled
@@ -1585,7 +1578,7 @@ namespace hpx { namespace components { namespace server
             bool isdefault = false;
             if (sect.has_entry("isdefault")) {
                 std::string tmp = sect.get_entry("isdefault");
-                boost::algorithm::to_lower (tmp);
+                hpx::string_util::to_lower (tmp);
                 if (tmp == "true")
                     isdefault = true;
             }
@@ -2017,7 +2010,7 @@ namespace hpx { namespace components { namespace server
             bool isenabled = true;
             if (sect.has_entry("enabled")) {
                 std::string tmp = sect.get_entry("enabled");
-                boost::algorithm::to_lower (tmp);
+                hpx::string_util::to_lower (tmp);
                 if (tmp == "no" || tmp == "false" || tmp == "0") {
                     LRT_(info) << "plugin factory disabled: " << instance;
                     isenabled = false;     // this component has been disabled
diff --git a/src/runtime/components/stubs/runtime_support_stubs.cpp b/src/runtime/components/stubs/runtime_support_stubs.cpp
index 2ac941534e..3ef1d4c24d 100644
--- a/src/runtime/components/stubs/runtime_support_stubs.cpp
+++ b/src/runtime/components/stubs/runtime_support_stubs.cpp
@@ -16,7 +16,7 @@
 #include <hpx/runtime/launch_policy.hpp>
 #include <hpx/runtime/naming/name.hpp>
 #include <hpx/performance_counters/counters.hpp>
-#include <hpx/util/ini.hpp>
+#include <hpx/runtime_configuration/ini.hpp>
 #include <hpx/runtime.hpp>
 #include <hpx/traits/component_supports_migration.hpp>
 #include <hpx/traits/action_was_object_migrated.hpp>
diff --git a/src/runtime/naming/address.cpp b/src/runtime/naming/address.cpp
index 382ee2652b..e15d107653 100644
--- a/src/runtime/naming/address.cpp
+++ b/src/runtime/naming/address.cpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2013 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -9,8 +9,7 @@
 #include <hpx/errors.hpp>
 #include <hpx/runtime/components/component_type.hpp>
 #include <hpx/serialization/serialize.hpp>
-
-#include <boost/io/ios_state.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 
 #include <iomanip>
 #include <iostream>
@@ -38,7 +37,7 @@ namespace hpx { namespace naming
 
     std::ostream& operator<<(std::ostream& os, address const& addr)
     {
-        boost::io::ios_flags_saver ifs(os);
+        hpx::util::ios_flags_saver ifs(os);
         os << "(" << addr.locality_ << ":"
            << components::get_component_type_name(addr.type_)
            << ":" << std::showbase << std::hex << addr.address_ << ")";
diff --git a/src/runtime/naming/name.cpp b/src/runtime/naming/name.cpp
index 20263c427b..5f1e3d1203 100644
--- a/src/runtime/naming/name.cpp
+++ b/src/runtime/naming/name.cpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2019 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //  Copyright (c) 2011      Bryce Lelbach
 //
 //  SPDX-License-Identifier: BSL-1.0
@@ -28,8 +28,7 @@
 #include <hpx/state.hpp>
 #include <hpx/thread_support/assert_owns_lock.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
-
-#include <boost/io/ios_state.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 
 #include <cstdint>
 #include <functional>
@@ -182,13 +181,10 @@ namespace hpx { namespace naming
                     // This request might come in too late and the thread manager
                     // was already stopped. We ignore the request if that's the
                     // case.
-                    if (e.get_error() != invalid_status)
-                    {
-                        throw;    // rethrow if not invalid_status
-                    }
-                    else if (!threads::threadmanager_is(hpx::state_stopping))
+                    if (e.get_error() != invalid_status ||
+                        !threads::threadmanager_is(hpx::state_stopping))
                     {
-                        throw;    // rethrow if not stopping
+                        throw;
                     }
                 }
             }
@@ -688,7 +684,7 @@ namespace hpx { namespace naming
 
     std::ostream& operator<<(std::ostream& os, gid_type const& id)
     {
-        boost::io::ios_flags_saver ifs(os);
+        hpx::util::ios_flags_saver ifs(os);
         if (id != naming::invalid_gid)
         {
             os << std::hex
diff --git a/src/runtime/parcelset/locality.cpp b/src/runtime/parcelset/locality.cpp
index 734ee989d8..6fddbe394f 100644
--- a/src/runtime/parcelset/locality.cpp
+++ b/src/runtime/parcelset/locality.cpp
@@ -1,5 +1,5 @@
 //  Copyright (c)      2014 Thomas Heller
-//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -13,8 +13,7 @@
 #include <hpx/runtime/parcelset/parcelhandler.hpp>
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/serialization/string.hpp>
-
-#include <boost/io/ios_state.hpp>
+#include <hpx/util/ios_flags_saver.hpp>
 
 #include <string>
 
@@ -54,7 +53,7 @@ namespace hpx { namespace parcelset
 
     std::ostream& operator<< (std::ostream& os, endpoints_type const& endpoints)
     {
-        boost::io::ios_flags_saver ifs(os);
+        hpx::util::ios_flags_saver ifs(os);
         os << "[ ";
         for (endpoints_type::value_type const& loc : endpoints)
         {
diff --git a/src/runtime/parcelset/parcel.cpp b/src/runtime/parcelset/parcel.cpp
index feeda73910..dd1b592e91 100644
--- a/src/runtime/parcelset/parcel.cpp
+++ b/src/runtime/parcelset/parcel.cpp
@@ -25,7 +25,7 @@
 #include <hpx/serialization/input_archive.hpp>
 #include <hpx/serialization/output_archive.hpp>
 #include <hpx/timing/high_resolution_timer.hpp>
-#include <hpx/util/external_timer.hpp>
+#include <hpx/threading_base/external_timer.hpp>
 
 #include <hpx/thread_support/atomic_count.hpp>
 
diff --git a/src/runtime/parcelset/parcelhandler.cpp b/src/runtime/parcelset/parcelhandler.cpp
index eb4b148fbf..dc25c136e9 100644
--- a/src/runtime/parcelset/parcelhandler.cpp
+++ b/src/runtime/parcelset/parcelhandler.cpp
@@ -11,10 +11,15 @@
 
 #if defined(HPX_HAVE_NETWORKING)
 #include <hpx/assertion.hpp>
+#include <hpx/concurrency/itt_notify.hpp>
 #include <hpx/config/asio.hpp>
 #include <hpx/errors.hpp>
-#include <hpx/synchronization/counting_semaphore.hpp>
+#include <hpx/format.hpp>
+#include <hpx/functional/bind.hpp>
+#include <hpx/functional/bind_front.hpp>
+#include <hpx/functional/deferred_call.hpp>
 #include <hpx/local_lcos/promise.hpp>
+#include <hpx/logging.hpp>
 #include <hpx/performance_counters/counter_creators.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/manage_counter_type.hpp>
@@ -27,24 +32,20 @@
 #include <hpx/runtime/parcelset/parcelhandler.hpp>
 #include <hpx/runtime/parcelset/policies/message_handler.hpp>
 #include <hpx/runtime/parcelset/static_parcelports.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/state.hpp>
-#include <hpx/util/external_timer.hpp>
-#include <hpx/functional/bind.hpp>
-#include <hpx/functional/bind_front.hpp>
-#include <hpx/functional/deferred_call.hpp>
-#include <hpx/format.hpp>
-#include <hpx/util/io_service_pool.hpp>
-#include <hpx/concurrency/itt_notify.hpp>
-#include <hpx/logging.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/synchronization/counting_semaphore.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
+#include <hpx/threading_base/external_timer.hpp>
+#include <hpx/util/from_string.hpp>
+#include <hpx/util/get_entry_as.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/string_util.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 
 #include <hpx/plugins/parcelport_factory_base.hpp>
 
-#include <boost/algorithm/string.hpp>
 #include <boost/asio/error.hpp>
 #include <boost/assign/std/vector.hpp>
 #include <boost/predef/other/endian.h>
@@ -109,7 +110,7 @@ namespace hpx { namespace parcelset
       , use_alternative_parcelports_(false)
       , enable_parcel_handling_(true)
       , load_message_handlers_(util::get_entry_as<int>(cfg,
-                                   "hpx.parcel.message_handlers", "0") != 0)
+                                   "hpx.parcel.message_handlers", 0) != 0)
       , count_routed_(0)
       , write_handler_(&default_write_handler)
       , is_networking_enabled_(hpx::is_networking_enabled())
@@ -172,7 +173,7 @@ namespace hpx { namespace parcelset
         std::string cfgkey("hpx.parcel." + ppname + ".enable");
         std::string enabled = get_config_entry(cfgkey, "0");
         strm << ", "
-             << (hpx::util::safe_lexical_cast<int>(enabled, 0) ? "" : "not ")
+             << (hpx::util::from_string<int>(enabled, 0) ? "" : "not ")
              << "enabled";
 
         if (bootstrap)
@@ -1569,7 +1570,7 @@ namespace hpx { namespace parcelset
 #endif
     }
 
-    std::vector<std::string> parcelhandler::load_runtime_configuration()
+    std::vector<std::string> load_runtime_configuration()
     {
         // TODO: properly hide this in plugins ...
         std::vector<std::string> ini_defs;
@@ -1607,7 +1608,8 @@ namespace hpx { namespace parcelset
 #endif
             ;
 
-        for (plugins::parcelport_factory_base* f : get_parcelport_factories())
+        for (plugins::parcelport_factory_base* f :
+            parcelhandler::get_parcelport_factories())
         {
             f->get_plugin_info(ini_defs);
         }
diff --git a/src/runtime/parcelset/parcelport.cpp b/src/runtime/parcelset/parcelport.cpp
index 3edaa6b3f7..abec17498f 100644
--- a/src/runtime/parcelset/parcelport.cpp
+++ b/src/runtime/parcelset/parcelport.cpp
@@ -13,13 +13,13 @@
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/runtime/applier/applier.hpp>
 #include <hpx/runtime/parcelset/parcelport.hpp>
-#include <hpx/runtime/threads/thread.hpp>
-#include <hpx/util/io_service_pool.hpp>
-#include <hpx/util/runtime_configuration.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/threading.hpp>
+#include <hpx/util/get_entry_as.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 #include <hpx/errors.hpp>
 #if defined(HPX_HAVE_APEX)
-#include <hpx/util/external_timer.hpp>
+#include <hpx/threading_base/external_timer.hpp>
 #endif
 #include <hpx/assertion.hpp>
 
@@ -43,14 +43,14 @@ namespace hpx { namespace parcelset
         allow_zero_copy_optimizations_(true),
         async_serialization_(false),
         priority_(hpx::util::get_entry_as<int>(ini,
-            "hpx.parcel." + type + ".priority", "0")),
+            "hpx.parcel." + type + ".priority", 0)),
         type_(type)
     {
         std::string key("hpx.parcel.");
         key += type;
 
         if (hpx::util::get_entry_as<int>(
-                ini, key + ".array_optimization", "1") == 0)
+                ini, key + ".array_optimization", 1) == 0)
         {
             allow_array_optimizations_ = false;
             allow_zero_copy_optimizations_ = false;
@@ -58,14 +58,14 @@ namespace hpx { namespace parcelset
         else
         {
             if (hpx::util::get_entry_as<int>(
-                    ini, key + ".zero_copy_optimization", "1") == 0)
+                    ini, key + ".zero_copy_optimization", 1) == 0)
             {
                 allow_zero_copy_optimizations_ = false;
             }
         }
 
         if (hpx::util::get_entry_as<int>(
-                ini, key + ".async_serialization", "0") != 0)
+                ini, key + ".async_serialization", 0) != 0)
         {
             async_serialization_ = true;
         }
diff --git a/src/runtime/thread_pool_helpers.cpp b/src/runtime/thread_pool_helpers.cpp
index 44f2660939..b896e6ae86 100644
--- a/src/runtime/thread_pool_helpers.cpp
+++ b/src/runtime/thread_pool_helpers.cpp
@@ -11,6 +11,7 @@
 #include <hpx/threadmanager.hpp>
 
 #include <cstddef>
+#include <cstdint>
 #include <memory>
 #include <mutex>
 #include <stdexcept>
@@ -60,4 +61,23 @@ namespace hpx { namespace resource
     {
         return get_thread_pool(get_pool_name(pool_index));
     }
-}}    // namespace hpx
+}}    // namespace hpx::resource
+
+namespace hpx { namespace threads {
+    std::int64_t get_thread_count(thread_state_enum state)
+    {
+        return get_thread_manager().get_thread_count(state);
+    }
+
+    std::int64_t get_thread_count(
+        thread_priority priority, thread_state_enum state)
+    {
+        return get_thread_manager().get_thread_count(state, priority);
+    }
+
+    bool enumerate_threads(util::function_nonser<bool(thread_id_type)> const& f,
+        thread_state_enum state)
+    {
+        return get_thread_manager().enumerate_threads(f, state);
+    }
+}}    // namespace hpx::threads
diff --git a/src/runtime/threads/executors/current_executor.cpp b/src/runtime/threads/executors/current_executor.cpp
index 646da1fe7a..61ae137471 100644
--- a/src/runtime/threads/executors/current_executor.cpp
+++ b/src/runtime/threads/executors/current_executor.cpp
@@ -12,11 +12,10 @@
 #include <hpx/errors.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/memory/intrusive_ptr.hpp>
-#include <hpx/runtime/threads/detail/create_thread.hpp>
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
-#include <hpx/runtime/threads/detail/thread_num_tss.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
+#include <hpx/threading_base/create_thread.hpp>
+#include <hpx/threading_base/set_thread_state.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
 #include <hpx/state.hpp>
 #include <hpx/timing/steady_clock.hpp>
 
@@ -133,7 +132,7 @@ namespace hpx { namespace threads { namespace executors { namespace detail
         case threads::detail::min_concurrency:
         case threads::detail::max_concurrency:
         case threads::detail::current_concurrency:
-            return hpx::get_os_thread_count();
+            return scheduler_base_->get_parent_pool()->get_os_thread_count();
 
         default:
             break;
@@ -179,3 +178,29 @@ namespace hpx { namespace threads { namespace executors
             ->get_state();
     }
 }}}
+
+namespace hpx { namespace threads {
+    executors::current_executor get_executor(
+        thread_id_type const& id, error_code& ec)
+    {
+        if (HPX_UNLIKELY(!id))
+        {
+            HPX_THROWS_IF(ec, null_thread_id, "hpx::threads::get_executor",
+                "null thread id encountered");
+            return executors::current_executor(nullptr);
+        }
+
+        if (&ec != &throws)
+            ec = make_success_code();
+
+        return executors::current_executor(
+            get_thread_id_data(id)->get_scheduler_base());
+    }
+}}
+
+namespace hpx { namespace this_thread {
+    threads::executors::current_executor get_executor(error_code& ec)
+    {
+        return threads::get_executor(threads::get_self_id(), ec);
+    }
+}}
diff --git a/src/runtime/threads/executors/default_executor.cpp b/src/runtime/threads/executors/default_executor.cpp
index 00cc24a0ac..66e60dc52f 100644
--- a/src/runtime/threads/executors/default_executor.cpp
+++ b/src/runtime/threads/executors/default_executor.cpp
@@ -9,9 +9,11 @@
 #include <hpx/assertion.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/runtime_fwd.hpp>
+#include <hpx/threading_base/register_thread.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
 
 #include <chrono>
@@ -76,7 +78,11 @@ namespace hpx { namespace threads { namespace executors { namespace detail
         if (&ec != &throws)
             ec = make_success_code();
 
-        return get_thread_count() - get_thread_count(terminated);
+        threads::thread_pool_base* pool = threads::detail::get_self_or_default_pool();
+        HPX_ASSERT(pool);
+        threads::policies::scheduler_base* scheduler = pool->get_scheduler();
+        HPX_ASSERT(scheduler);
+        return scheduler->get_thread_count() - scheduler->get_thread_count(terminated);
     }
 
     // Reset internal (round robin) thread distribution scheme
@@ -97,11 +103,13 @@ namespace hpx { namespace threads { namespace executors { namespace detail
     std::size_t default_executor::get_policy_element(
         threads::detail::executor_parameter p, error_code& ec) const
     {
+        thread_pool_base* pool = threads::detail::get_self_or_default_pool();
+        HPX_ASSERT(pool);
         switch(p) {
         case threads::detail::min_concurrency:
         case threads::detail::max_concurrency:
         case threads::detail::current_concurrency:
-            return hpx::get_os_thread_count();
+            return pool->get_os_thread_count();
 
         default:
             break;
diff --git a/src/runtime/threads/executors/embedded_thread_pool_executors.cpp b/src/runtime/threads/executors/embedded_thread_pool_executors.cpp
index 672c976fbd..9621cf295e 100644
--- a/src/runtime/threads/executors/embedded_thread_pool_executors.cpp
+++ b/src/runtime/threads/executors/embedded_thread_pool_executors.cpp
@@ -8,27 +8,28 @@
 
 #include <hpx/runtime/threads/resource_manager.hpp>
 #if defined(HPX_HAVE_LOCAL_SCHEDULER)
-#include <hpx/runtime/threads/policies/local_queue_scheduler.hpp>
+#include <hpx/schedulers/local_queue_scheduler.hpp>
 #endif
 #if defined(HPX_HAVE_STATIC_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_queue_scheduler.hpp>
+#include <hpx/schedulers/static_queue_scheduler.hpp>
 #endif
-#include <hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/local_priority_queue_scheduler.hpp>
 #if defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/static_priority_queue_scheduler.hpp>
 #endif
 #include <hpx/assertion.hpp>
 #include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/functional/unique_function.hpp>
-#include <hpx/runtime/threads/detail/create_thread.hpp>
-#include <hpx/runtime/threads/detail/scheduling_loop.hpp>
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
+#include <hpx/threading_base/create_thread.hpp>
+#include <hpx/thread_pools/scheduling_loop.hpp>
+#include <hpx/threading_base/set_thread_state.hpp>
 #include <hpx/runtime/threads/executors/manage_thread_executor.hpp>
+#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <atomic>
 #include <chrono>
diff --git a/src/runtime/threads/executors/service_executor.cpp b/src/runtime/threads/executors/service_executor.cpp
index 755cff1342..f23b4dd956 100644
--- a/src/runtime/threads/executors/service_executor.cpp
+++ b/src/runtime/threads/executors/service_executor.cpp
@@ -12,11 +12,11 @@
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/errors.hpp>
 #include <hpx/functional/bind_front.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/io_service_pool.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 
 #include <boost/asio/basic_waitable_timer.hpp>
 
diff --git a/src/runtime/threads/executors/this_thread_executors.cpp b/src/runtime/threads/executors/this_thread_executors.cpp
index a2d1a48ce0..8e20c1c5aa 100644
--- a/src/runtime/threads/executors/this_thread_executors.cpp
+++ b/src/runtime/threads/executors/this_thread_executors.cpp
@@ -9,24 +9,27 @@
 #if defined(HPX_HAVE_STATIC_SCHEDULER) || defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
 
 #if defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
-#  include <hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp>
+#  include <hpx/schedulers/static_priority_queue_scheduler.hpp>
 #endif
 #if defined(HPX_HAVE_STATIC_SCHEDULER)
-#  include <hpx/runtime/threads/policies/static_queue_scheduler.hpp>
+#  include <hpx/schedulers/static_queue_scheduler.hpp>
 #endif
 
 #include <hpx/assertion.hpp>
-#include <hpx/runtime/threads/detail/create_thread.hpp>
-#include <hpx/runtime/threads/detail/scheduling_loop.hpp>
-#include <hpx/runtime/threads/detail/set_thread_state.hpp>
-#include <hpx/runtime/threads/detail/thread_num_tss.hpp>
+#include <hpx/functional/deferred_call.hpp>
+#include <hpx/threading_base/create_thread.hpp>
+#include <hpx/thread_pools/scheduling_loop.hpp>
+#include <hpx/threading_base/set_thread_state.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
 #include <hpx/runtime/threads/executors/manage_thread_executor.hpp>
+#include <hpx/runtime/threads/thread_helpers.hpp>
 #include <hpx/affinity/affinity_data.hpp>
 #include <hpx/runtime/threads/resource_manager.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
+#include <hpx/functional/deferred_call.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <atomic>
 #include <chrono>
diff --git a/src/runtime/threads/executors/thread_pool_attached_executors.cpp b/src/runtime/threads/executors/thread_pool_attached_executors.cpp
index 12e6b72014..0959b51251 100644
--- a/src/runtime/threads/executors/thread_pool_attached_executors.cpp
+++ b/src/runtime/threads/executors/thread_pool_attached_executors.cpp
@@ -8,21 +8,23 @@
 
 #include <hpx/errors.hpp>
 #if defined(HPX_HAVE_LOCAL_SCHEDULER)
-#  include <hpx/runtime/threads/policies/local_queue_scheduler.hpp>
+#  include <hpx/schedulers/local_queue_scheduler.hpp>
 #endif
-#include <hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/local_priority_queue_scheduler.hpp>
 #if defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
-#  include <hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp>
+#  include <hpx/schedulers/static_priority_queue_scheduler.hpp>
 #endif
 #if defined(HPX_HAVE_STATIC_SCHEDULER)
-#  include <hpx/runtime/threads/policies/static_queue_scheduler.hpp>
+#  include <hpx/schedulers/static_queue_scheduler.hpp>
 #endif
 #include <hpx/assertion.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
+#include <hpx/threading_base/thread_description.hpp>
 #include <hpx/functional/unique_function.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/runtime/thread_pool_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
+#include <hpx/threading_base/thread_num_tss.hpp>
 
 #include <chrono>
 #include <cstddef>
@@ -71,11 +73,11 @@ namespace hpx { namespace threads { namespace executors { namespace detail
         if (stacksize == threads::thread_stacksize_default)
             stacksize = stacksize_;
 
+        schedulehint.mode = threads::thread_schedule_hint_mode_thread;
+        schedulehint.hint =
+            static_cast<std::int16_t>(threads::detail::get_thread_num_tss());
         register_thread_nullary(std::move(f), desc, initial_state, run_now,
-            priority_,
-            threads::thread_schedule_hint(
-                static_cast<std::int16_t>(get_next_thread_num())),
-            stacksize, ec);
+            priority_, schedulehint, stacksize, ec);
     }
 
     // Schedule given function for execution in this executor no sooner
@@ -125,7 +127,11 @@ namespace hpx { namespace threads { namespace executors { namespace detail
         if (&ec != &throws)
             ec = make_success_code();
 
-        return get_thread_count() - get_thread_count(terminated);
+        threads::thread_pool_base* pool = threads::detail::get_self_or_default_pool();
+        HPX_ASSERT(pool);
+        threads::policies::scheduler_base* scheduler = pool->get_scheduler();
+        HPX_ASSERT(scheduler);
+        return scheduler->get_thread_count() - scheduler->get_thread_count(terminated);
     }
 
     // Reset internal (round robin) thread distribution scheme
@@ -140,11 +146,14 @@ namespace hpx { namespace threads { namespace executors { namespace detail
     std::size_t thread_pool_attached_executor<Scheduler>::get_policy_element(
         threads::detail::executor_parameter p, error_code& ec) const
     {
+        thread_pool_base* pool = threads::detail::get_self_or_default_pool();
+        HPX_ASSERT(pool);
+
         switch(p) {
         case threads::detail::min_concurrency:
         case threads::detail::max_concurrency:
         case threads::detail::current_concurrency:
-            return hpx::get_os_thread_count();
+            return pool->get_os_thread_count();
 
         default:
             break;
diff --git a/src/runtime/threads/executors/thread_pool_os_executors.cpp b/src/runtime/threads/executors/thread_pool_os_executors.cpp
index 7d4ef33dc1..12a38feed0 100644
--- a/src/runtime/threads/executors/thread_pool_os_executors.cpp
+++ b/src/runtime/threads/executors/thread_pool_os_executors.cpp
@@ -5,17 +5,17 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/runtime/threads/executors/thread_pool_os_executors.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 
 #if defined(HPX_HAVE_LOCAL_SCHEDULER)
-#include <hpx/runtime/threads/policies/local_queue_scheduler.hpp>
+#include <hpx/schedulers/local_queue_scheduler.hpp>
 #endif
 #if defined(HPX_HAVE_STATIC_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_queue_scheduler.hpp>
+#include <hpx/schedulers/static_queue_scheduler.hpp>
 #endif
-#include <hpx/runtime/threads/policies/local_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/local_priority_queue_scheduler.hpp>
 #if defined(HPX_HAVE_STATIC_PRIORITY_SCHEDULER)
-#include <hpx/runtime/threads/policies/static_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/static_priority_queue_scheduler.hpp>
 #endif
 #include <hpx/assertion.hpp>
 #include <hpx/datastructures/optional.hpp>
@@ -23,8 +23,8 @@
 #include <hpx/functional/unique_function.hpp>
 #include <hpx/coroutines/thread_enums.hpp>
 #include <hpx/timing/steady_clock.hpp>
-#include <hpx/util/thread_description.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/threading_base/thread_description.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <atomic>
 #include <chrono>
diff --git a/src/runtime/threads/policies/deadlock_detection.cpp b/src/runtime/threads/policies/deadlock_detection.cpp
new file mode 100644
index 0000000000..ec3534a1fd
--- /dev/null
+++ b/src/runtime/threads/policies/deadlock_detection.cpp
@@ -0,0 +1,25 @@
+//  Copyright (c) 2005-2017 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Adelstein-Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/deadlock_detection.hpp>
+
+namespace hpx { namespace threads { namespace policies {
+#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
+    static bool minimal_deadlock_detection_enabled = false;
+
+    void set_minimal_deadlock_detection_enabled(bool enabled)
+    {
+        minimal_deadlock_detection_enabled = enabled;
+    }
+
+    bool get_minimal_deadlock_detection_enabled()
+    {
+        return minimal_deadlock_detection_enabled;
+    }
+#endif
+}}}    // namespace hpx::threads::policies
diff --git a/src/runtime/threads/policies/maintain_queue_wait_times.cpp b/src/runtime/threads/policies/maintain_queue_wait_times.cpp
new file mode 100644
index 0000000000..185a4e5436
--- /dev/null
+++ b/src/runtime/threads/policies/maintain_queue_wait_times.cpp
@@ -0,0 +1,25 @@
+//  Copyright (c) 2005-2017 Hartmut Kaiser
+//  Copyright (c)      2011 Bryce Adelstein-Lelbach
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/config.hpp>
+#include <hpx/schedulers/maintain_queue_wait_times.hpp>
+
+namespace hpx { namespace threads { namespace policies {
+#ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
+    static bool maintain_queue_wait_times_enabled = false;
+
+    void set_maintain_queue_wait_times_enabled(bool enabled)
+    {
+        maintain_queue_wait_times_enabled = enabled;
+    }
+
+    bool get_maintain_queue_wait_times_enabled()
+    {
+        return maintain_queue_wait_times_enabled;
+    }
+#endif
+}}}    // namespace hpx::threads::policies
diff --git a/src/runtime/threads/register_thread.cpp b/src/runtime/threads/register_thread.cpp
deleted file mode 100644
index 91d710f993..0000000000
--- a/src/runtime/threads/register_thread.cpp
+++ /dev/null
@@ -1,52 +0,0 @@
-//  Copyright (c) 2007-2016 Hartmut Kaiser
-//  Copyright (c)      2011 Bryce Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/assertion.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/register_thread.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
-#include <hpx/util/thread_description.hpp>
-
-#include <cstddef>
-#include <limits>
-#include <string>
-#include <utility>
-
-namespace hpx { namespace threads { namespace detail {
-    static get_default_pool_type get_default_pool;
-
-    void set_get_default_pool(get_default_pool_type f)
-    {
-        get_default_pool = f;
-    }
-
-    HPX_EXPORT thread_pool_base* get_self_or_default_pool()
-    {
-        thread_pool_base* pool = nullptr;
-        auto thrd_data = get_self_id_data();
-        if (thrd_data)
-        {
-            pool = thrd_data->get_scheduler_base()->get_parent_pool();
-        }
-        else if (detail::get_default_pool)
-        {
-            pool = detail::get_default_pool();
-            HPX_ASSERT(pool);
-        }
-        else
-        {
-            HPX_THROW_EXCEPTION(invalid_status,
-                "hpx::threads::get_self_or_default_pool",
-                "Attempting to register a thread outside the HPX runtime and "
-                "no default pool handler is installed. Did you mean to run "
-                "this on an HPX thread?");
-        }
-
-        return pool;
-    }
-}}}    // namespace hpx::threads::detail
diff --git a/src/runtime/threads/resource_manager.cpp b/src/runtime/threads/resource_manager.cpp
index 025b3c7d2e..1d6692d7bd 100644
--- a/src/runtime/threads/resource_manager.cpp
+++ b/src/runtime/threads/resource_manager.cpp
@@ -10,8 +10,9 @@
 #include <hpx/errors.hpp>
 #include <hpx/runtime/threads/resource_manager.hpp>
 #include <hpx/runtime/threads/thread_executor.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/static_reinit/reinitializable_static.hpp>
+#include <hpx/topology.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -34,7 +35,7 @@ namespace hpx { namespace threads
     resource_manager::resource_manager()
       : next_cookie_(0),
         punits_(get_os_thread_count()),
-        topology_(get_topology())
+        topology_(create_topology())
     {}
 
     // Request an initial resource allocation
@@ -335,7 +336,7 @@ namespace hpx { namespace threads
 
 #if defined(HPX_DEBUG)
                 // epsilon allows forgiveness of reasonable round-off errors
-                HPX_CONSTEXPR_OR_CONST double epsilon = 1e-7;
+                constexpr double epsilon = 1e-7;
 #endif
                 allocation_data_map_type scaled_static_allocation_data;
                 scaled_static_allocation_data[new_allocation] =
diff --git a/src/runtime/threads/scheduler_specific_ptr.cpp b/src/runtime/threads/scheduler_specific_ptr.cpp
deleted file mode 100644
index 8ede93418e..0000000000
--- a/src/runtime/threads/scheduler_specific_ptr.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//  Copyright (c) 2007-2016 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/errors.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/coroutines/detail/tss.hpp>
-#include <hpx/runtime/threads/scheduler_specific_ptr.hpp>
-
-#include <exception>
-#include <memory>
-
-namespace hpx { namespace threads { namespace detail
-{
-    void* get_tss_data(void const* key)
-    {
-#if defined(HPX_HAVE_SCHEDULER_LOCAL_STORAGE)
-        hpx::threads::thread_id_type self_id = hpx::threads::get_self_id();
-        if (!self_id)
-        {
-            throw coroutines::null_thread_id_exception();
-            return 0;
-        }
-        return self_id->get_scheduler_base()->get_tss_data(key);
-#endif
-        return nullptr;
-    }
-
-    void set_tss_data(void const* key,
-        std::shared_ptr<coroutines::detail::tss_cleanup_function> const& func,
-        void* tss_data, bool cleanup_existing)
-    {
-#if defined(HPX_HAVE_SCHEDULER_LOCAL_STORAGE)
-        hpx::threads::thread_id_type self_id = hpx::threads::get_self_id();
-        if (!self_id)
-        {
-            throw coroutines::null_thread_id_exception();
-            return;
-        }
-        self_id->get_scheduler_base()->set_tss_data(key, func, tss_data,
-            cleanup_existing);
-#endif
-    }
-}}}
diff --git a/src/runtime/threads/thread_data.cpp b/src/runtime/threads/thread_data.cpp
deleted file mode 100644
index e44c0b639f..0000000000
--- a/src/runtime/threads/thread_data.cpp
+++ /dev/null
@@ -1,365 +0,0 @@
-//  Copyright (c) 2007-2016 Hartmut Kaiser
-//  Copyright (c) 2008-2009 Chirag Dekate, Anshul Tandon
-//  Copyright (c) 2011      Bryce Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/assertion.hpp>
-#include <hpx/basic_execution/register_locks.hpp>
-#include <hpx/coroutines/detail/coroutine_accessor.hpp>
-#include <hpx/errors.hpp>
-#include <hpx/functional/function.hpp>
-#include <hpx/logging.hpp>
-#include <hpx/runtime/naming/address.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/thread_support/unlock_guard.hpp>
-#if defined(HPX_HAVE_APEX)
-#include <hpx/util/external_timer.hpp>
-#endif
-
-#include <cstddef>
-#include <cstdint>
-#include <memory>
-
-////////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace threads {
-
-    thread_data::thread_data(thread_init_data& init_data, void* queue,
-        thread_state_enum newstate, bool is_stackless)
-        : current_state_(thread_state(newstate, wait_signaled))
-#ifdef HPX_HAVE_THREAD_DESCRIPTION
-        , description_(init_data.description)
-        , lco_description_()
-#endif
-#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
-        , parent_locality_id_(init_data.parent_locality_id)
-        , parent_thread_id_(init_data.parent_id)
-        , parent_thread_phase_(init_data.parent_phase)
-#endif
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-        , marked_state_(unknown)
-#endif
-#ifdef HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION
-        , backtrace_(nullptr
-#endif
-        , priority_(init_data.priority)
-        , requested_interrupt_(false)
-        , enabled_interrupt_(true)
-        , ran_exit_funcs_(false)
-        , scheduler_base_(init_data.scheduler_base)
-        , stacksize_(init_data.stacksize)
-        , queue_(queue)
-        , is_stackless_(is_stackless)
-    {
-        LTM_(debug) << "thread::thread(" << this << "), description("
-                    << get_description() << ")";
-
-#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
-        // store the thread id of the parent thread, mainly for debugging
-        // purposes
-        if (parent_thread_id_)
-        {
-            thread_self* self = get_self_ptr();
-            if (self)
-            {
-                parent_thread_id_ = threads::get_self_id();
-                parent_thread_phase_ = self->get_thread_phase();
-            }
-        }
-        if (0 == parent_locality_id_)
-            parent_locality_id_ = get_locality_id();
-#endif
-#if defined(HPX_HAVE_APEX)
-        set_timer_data(init_data.timer_data);
-#endif
-    }
-
-    thread_data::~thread_data()
-    {
-        free_thread_exit_callbacks();
-    }
-
-    void thread_data::run_thread_exit_callbacks()
-    {
-        mutex_type::scoped_lock l(this);
-
-        while (!exit_funcs_.empty())
-        {
-            {
-                hpx::util::unlock_guard<mutex_type::scoped_lock> ul(l);
-                if (!exit_funcs_.front().empty())
-                    exit_funcs_.front()();
-            }
-            exit_funcs_.pop_front();
-        }
-        ran_exit_funcs_ = true;
-    }
-
-    bool thread_data::add_thread_exit_callback(
-        util::function_nonser<void()> const& f)
-    {
-        mutex_type::scoped_lock l(this);
-
-        if (ran_exit_funcs_ || get_state().state() == terminated)
-        {
-            return false;
-        }
-
-        exit_funcs_.push_front(f);
-
-        return true;
-    }
-
-    void thread_data::free_thread_exit_callbacks()
-    {
-        mutex_type::scoped_lock l(this);
-
-        // Exit functions should have been executed.
-        HPX_ASSERT(exit_funcs_.empty() || ran_exit_funcs_);
-
-        exit_funcs_.clear();
-    }
-
-    bool thread_data::interruption_point(bool throw_on_interrupt)
-    {
-        // We do not protect enabled_interrupt_ and requested_interrupt_
-        // from concurrent access here (which creates a benign data race) in
-        // order to avoid infinite recursion. This function is called by
-        // this_thread::suspend which causes problems if the lock would call
-        // suspend itself.
-        if (enabled_interrupt_ && requested_interrupt_)
-        {
-            // Verify that there are no more registered locks for this
-            // OS-thread. This will throw if there are still any locks
-            // held.
-            util::force_error_on_lock();
-
-            // now interrupt this thread
-            if (throw_on_interrupt)
-                throw hpx::thread_interrupted();
-
-            return true;
-        }
-        return false;
-    }
-
-    void thread_data::rebind_base(
-        thread_init_data& init_data, thread_state_enum newstate)
-    {
-        LTM_(debug) << "~thread(" << this << "), description("    //-V128
-                    << get_description() << "), phase("
-                    << get_thread_phase() << "), rebind";
-
-        free_thread_exit_callbacks();
-
-        current_state_.store(thread_state(newstate, wait_signaled));
-
-#ifdef HPX_HAVE_THREAD_DESCRIPTION
-        description_ = (init_data.description);
-        lco_description_ = util::thread_description();
-#endif
-#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
-        parent_locality_id_ = init_data.parent_locality_id;
-        parent_thread_id_ = init_data.parent_id;
-        parent_thread_phase_ = init_data.parent_phase;
-#endif
-#ifdef HPX_HAVE_THREAD_MINIMAL_DEADLOCK_DETECTION
-        set_marked_state(unknown);
-#endif
-#ifdef HPX_HAVE_THREAD_BACKTRACE_ON_SUSPENSION
-        backtrace_ = nullptr;
-#endif
-        priority_ = init_data.priority;
-        requested_interrupt_ = false;
-        enabled_interrupt_ = true;
-        ran_exit_funcs_ = false;
-        exit_funcs_.clear();
-        scheduler_base_ = init_data.scheduler_base;
-
-        HPX_ASSERT(init_data.stacksize == get_stack_size());
-
-        LTM_(debug) << "thread::thread(" << this << "), description("
-                    << get_description() << "), rebind";
-
-#ifdef HPX_HAVE_THREAD_PARENT_REFERENCE
-        // store the thread id of the parent thread, mainly for debugging
-        // purposes
-        if (nullptr == parent_thread_id_)
-        {
-            thread_self* self = get_self_ptr();
-            if (self)
-            {
-                parent_thread_id_ = threads::get_self_id();
-                parent_thread_phase_ = self->get_thread_phase();
-            }
-        }
-        if (0 == parent_locality_id_)
-            parent_locality_id_ = get_locality_id();
-#endif
-#if defined(HPX_HAVE_APEX)
-        set_timer_data(init_data.timer_data);
-#endif
-        HPX_ASSERT(init_data.stacksize != 0);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    thread_self& get_self()
-    {
-        thread_self* p = get_self_ptr();
-        if (HPX_UNLIKELY(p == nullptr))
-        {
-            HPX_THROW_EXCEPTION(null_thread_id, "threads::get_self",
-                "null thread id encountered (is this executed on a "
-                "HPX-thread?)");
-        }
-        return *p;
-    }
-
-    thread_self* get_self_ptr()
-    {
-        return thread_self::get_self();
-    }
-
-    namespace detail {
-
-        void set_self_ptr(thread_self * self)
-        {
-            thread_self::set_self(self);
-        }
-    }     // namespace detail
-
-    thread_self::impl_type* get_ctx_ptr()
-    {
-        using hpx::threads::coroutines::detail::coroutine_accessor;
-        return coroutine_accessor::get_impl(get_self());
-    }
-
-    thread_self* get_self_ptr_checked(error_code& ec)
-    {
-        thread_self* p = thread_self::get_self();
-
-        if (HPX_UNLIKELY(p == nullptr))
-        {
-            HPX_THROWS_IF(ec, null_thread_id,
-                "threads::get_self_ptr_checked",
-                "null thread id encountered (is this executed on a "
-                "HPX-thread?)");
-            return nullptr;
-        }
-
-        if (&ec != &throws)
-            ec = make_success_code();
-
-        return p;
-    }
-
-    thread_id_type get_self_id()
-    {
-        thread_self* self = get_self_ptr();
-        if (HPX_LIKELY(nullptr != self))
-            return self->get_thread_id();
-
-        return threads::invalid_thread_id;
-    }
-
-    thread_data* get_self_id_data()
-    {
-        thread_self* self = get_self_ptr();
-        if (HPX_LIKELY(nullptr != self))
-            return get_thread_id_data(self->get_thread_id());
-
-        return nullptr;
-    }
-
-    std::size_t get_self_stacksize()
-    {
-        thread_data* thrd_data = get_self_id_data();
-        return thrd_data ? thrd_data->get_stack_size() : 0;
-    }
-
-#ifndef HPX_HAVE_THREAD_PARENT_REFERENCE
-    thread_id_type get_parent_id()
-    {
-        return threads::invalid_thread_id;
-    }
-
-    std::size_t get_parent_phase()
-    {
-        return 0;
-    }
-
-    std::uint32_t get_parent_locality_id()
-    {
-        return naming::invalid_locality_id;
-    }
-#else
-    thread_id_type get_parent_id()
-    {
-        thread_data* thrd_data = get_self_id_data();
-        if (HPX_LIKELY(nullptr != thrd_data))
-        {
-            return thrd_data->get_parent_thread_id();
-        }
-        return threads::invalid_thread_id;
-    }
-
-    std::size_t get_parent_phase()
-    {
-        thread_data* thrd_data = get_self_id_data();
-        if (HPX_LIKELY(nullptr != thrd_data))
-        {
-            return thrd_data->get_parent_thread_phase();
-        }
-        return 0;
-    }
-
-    std::uint32_t get_parent_locality_id()
-    {
-        thread_data* thrd_data = get_self_id_data();
-        if (HPX_LIKELY(nullptr != thrd_data))
-        {
-            return thrd_data->get_parent_locality_id();
-        }
-        return naming::invalid_locality_id;
-    }
-#endif
-
-    naming::address::address_type get_self_component_id()
-    {
-#ifndef HPX_HAVE_THREAD_TARGET_ADDRESS
-            return 0;
-#else
-        thread_data* thrd_data = get_self_id_data();
-        if (HPX_LIKELY(nullptr != thrd_data))
-        {
-            return thrd_data->get_component_id();
-        }
-        return 0;
-#endif
-    }
-
-#if defined(HPX_HAVE_APEX)
-    std::shared_ptr<hpx::util::external_timer::task_wrapper>
-        get_self_timer_data()
-    {
-        thread_data* thrd_data = get_self_id_data();
-        if (HPX_LIKELY(nullptr != thrd_data))
-        {
-            return thrd_data->get_timer_data();
-        }
-        return nullptr;
-    }
-    void set_self_timer_data(
-        std::shared_ptr<hpx::util::external_timer::task_wrapper> data)
-    {
-        thread_data* thrd_data = get_self_id_data();
-        if (HPX_LIKELY(nullptr != thrd_data))
-        {
-            thrd_data->set_timer_data(data);
-        }
-        return;
-    }
-#endif
-}}    // namespace hpx::threads
diff --git a/src/runtime/threads/thread_pool_suspension_helpers.cpp b/src/runtime/threads/thread_pool_suspension_helpers.cpp
index 2e0b7ac072..b0eafa8c01 100644
--- a/src/runtime/threads/thread_pool_suspension_helpers.cpp
+++ b/src/runtime/threads/thread_pool_suspension_helpers.cpp
@@ -7,9 +7,9 @@
 #include <hpx/apply.hpp>
 #include <hpx/async.hpp>
 #include <hpx/lcos/future.hpp>
-#include <hpx/runtime/threads/policies/scheduler_base.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/scheduler_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/runtime/threads/thread_pool_suspension_helpers.hpp>
 
 #include <cstddef>
@@ -25,8 +25,8 @@ namespace hpx { namespace threads {
                 "cannot call resume_processing_unit from outside HPX, use"
                 "resume_processing_unit_cb instead");
         }
-        else if (!(pool.get_scheduler_mode() &
-                     threads::policies::enable_elasticity))
+        else if (!pool.get_scheduler()->has_scheduler_mode(
+                  policies::enable_elasticity))
         {
             return hpx::make_exceptional_future<void>(
                 HPX_GET_EXCEPTION(invalid_status, "resume_processing_unit",
@@ -43,7 +43,7 @@ namespace hpx { namespace threads {
         std::function<void(void)> callback, std::size_t virt_core,
         error_code& ec)
     {
-        if (!(pool.get_scheduler_mode() & threads::policies::enable_elasticity))
+        if (!pool.get_scheduler()->has_scheduler_mode(policies::enable_elasticity))
         {
             HPX_THROWS_IF(ec, invalid_status, "resume_processing_unit_cb",
                 "this thread pool does not support suspending "
@@ -52,7 +52,7 @@ namespace hpx { namespace threads {
         }
 
         auto resume_direct_wrapper = [&pool, virt_core,
-                                         HPX_CAPTURE_MOVE(callback)]() {
+                                         callback = std::move(callback)]() {
             pool.resume_processing_unit_direct(virt_core, throws);
             callback();
         };
@@ -76,15 +76,14 @@ namespace hpx { namespace threads {
                 "cannot call suspend_processing_unit from outside HPX, use"
                 "suspend_processing_unit_cb instead");
         }
-        else if (!(pool.get_scheduler_mode() &
-                     threads::policies::enable_elasticity))
+        else if (!pool.get_scheduler()->has_scheduler_mode(policies::enable_elasticity))
         {
             return hpx::make_exceptional_future<void>(
                 HPX_GET_EXCEPTION(invalid_status, "suspend_processing_unit",
                     "this thread pool does not support suspending "
                     "processing units"));
         }
-        else if (!pool.get_scheduler()->has_work_stealing() &&
+        else if (!pool.get_scheduler()->has_scheduler_mode(policies::enable_stealing) &&
             hpx::this_thread::get_pool() == &pool)
         {
             return hpx::make_exceptional_future<void>(
@@ -102,7 +101,7 @@ namespace hpx { namespace threads {
         std::function<void(void)> callback, std::size_t virt_core,
         error_code& ec)
     {
-        if (!(pool.get_scheduler_mode() & threads::policies::enable_elasticity))
+        if (!pool.get_scheduler()->has_scheduler_mode(policies::enable_elasticity))
         {
             HPX_THROWS_IF(ec, invalid_status, "suspend_processing_unit_cb",
                 "this thread pool does not support suspending processing "
@@ -111,14 +110,14 @@ namespace hpx { namespace threads {
         }
 
         auto suspend_direct_wrapper = [&pool, virt_core,
-                                          HPX_CAPTURE_MOVE(callback)]() {
+                                          callback = std::move(callback)]() {
             pool.suspend_processing_unit_direct(virt_core, throws);
             callback();
         };
 
         if (threads::get_self_ptr())
         {
-            if (!pool.get_scheduler()->has_work_stealing() &&
+            if (!pool.get_scheduler()->has_scheduler_mode(policies::enable_stealing) &&
                 hpx::this_thread::get_pool() == &pool)
             {
                 HPX_THROW_EXCEPTION(invalid_status,
@@ -154,7 +153,7 @@ namespace hpx { namespace threads {
         std::function<void(void)> callback, error_code& ec)
     {
         auto resume_direct_wrapper = [&pool,
-                                         HPX_CAPTURE_MOVE(callback)]() -> void {
+                                         callback = std::move(callback)]() -> void {
             pool.resume_direct(throws);
             callback();
         };
@@ -201,7 +200,7 @@ namespace hpx { namespace threads {
             return;
         }
 
-        auto suspend_direct_wrapper = [&pool, HPX_CAPTURE_MOVE(callback)]() {
+        auto suspend_direct_wrapper = [&pool, callback = std::move(callback)]() {
             pool.suspend_direct(throws);
             callback();
         };
diff --git a/src/runtime/threads/threadmanager_counters.cpp b/src/runtime/threads/threadmanager_counters.cpp
index cf347f4758..f5cd9cd59e 100644
--- a/src/runtime/threads/threadmanager_counters.cpp
+++ b/src/runtime/threads/threadmanager_counters.cpp
@@ -16,24 +16,15 @@
 #include <hpx/performance_counters/counter_creators.hpp>
 #include <hpx/performance_counters/counters.hpp>
 #include <hpx/performance_counters/manage_counter_type.hpp>
+#include <hpx/runtime/thread_pool_helpers.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/runtime/threads/threadmanager_counters.hpp>
+#include <hpx/schedulers/maintain_queue_wait_times.hpp>
 
 #include <cstddef>
 #include <cstdint>
 #include <utility>
 
-#ifdef HPX_HAVE_THREAD_QUEUE_WAITTIME
-///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace threads { namespace policies {
-    ///////////////////////////////////////////////////////////////////////////
-    // We control whether to collect queue wait times using this global bool.
-    // It will be set by any of the related performance counters. Once set it
-    // stays set, thus no race conditions will occur.
-    HPX_EXPORT bool maintain_queue_wait_times = false;
-}}}
-#endif
-
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace threads {
     namespace detail {
@@ -47,7 +38,7 @@ namespace hpx { namespace threads {
                 tm, total_func, pool_func, info, ec);
 
             if (!ec)
-                policies::maintain_queue_wait_times = true;
+                policies::set_maintain_queue_wait_times_enabled(true);
 
             return gid;
         }
diff --git a/src/runtime_handlers.cpp b/src/runtime_handlers.cpp
index ce3664acd6..c2596c08e5 100644
--- a/src/runtime_handlers.cpp
+++ b/src/runtime_handlers.cpp
@@ -15,8 +15,8 @@
 #include <hpx/runtime.hpp>
 #include <hpx/runtime/config_entry.hpp>
 #include <hpx/runtime/get_num_localities.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_pool_base.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_pool_base.hpp>
 #include <hpx/runtime_handlers.hpp>
 #include <hpx/threadmanager.hpp>
 #include <hpx/util/backtrace.hpp>
@@ -52,7 +52,7 @@ namespace hpx { namespace detail {
 #if defined(HPX_HAVE_APEX)
     bool enable_parent_task_handler()
     {
-        return hpx::get_initial_num_localities() == 1;
+        return !hpx::is_networking_enabled();
     }
 #endif
 
@@ -118,4 +118,17 @@ namespace hpx { namespace detail {
 
         return &rt->get_thread_manager().default_pool();
     }
+
+    boost::asio::io_service* get_default_timer_service()
+    {
+        hpx::runtime* rt = get_runtime_ptr();
+        if (rt == nullptr)
+        {
+            HPX_THROW_EXCEPTION(invalid_status,
+                "hpx::detail::get_default_timer_service",
+                "The runtime system is not active");
+        }
+
+        return &get_thread_pool("timer-pool")->get_io_service();
+    }
 }}    // namespace hpx::detail
diff --git a/src/runtime_impl.cpp b/src/runtime_impl.cpp
index 6956f265d7..dc9acd958a 100644
--- a/src/runtime_impl.cpp
+++ b/src/runtime_impl.cpp
@@ -26,15 +26,15 @@
 #include <hpx/runtime/shutdown_function.hpp>
 #include <hpx/runtime/startup_function.hpp>
 #include <hpx/coroutines/detail/context_impl.hpp>
-#include <hpx/runtime/threads/scoped_background_timer.hpp>
+#include <hpx/thread_pools/detail/scoped_background_timer.hpp>
 #include <hpx/runtime/threads/threadmanager.hpp>
 #include <hpx/runtime_impl.hpp>
 #include <hpx/state.hpp>
 #include <hpx/thread_support/set_thread_name.hpp>
-#include <hpx/util/external_timer.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
+#include <hpx/threading_base/external_timer.hpp>
+#include <hpx/util/from_string.hpp>
 #include <hpx/util/thread_mapper.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <condition_variable>
 #include <cstddef>
@@ -488,7 +488,7 @@ namespace hpx
     {
         std::string localities = cfg.get_entry("hpx.localities", "1");
         std::size_t num_localities =
-            util::safe_lexical_cast<std::size_t>(localities, 1);
+            util::from_string<std::size_t>(localities, 1);
         if (num_localities > 1)
         {
             std::string locality = cfg.get_entry("hpx.locality", "");
diff --git a/src/util/activate_counters.cpp b/src/util/activate_counters.cpp
index c63338465f..d07ad39c50 100644
--- a/src/util/activate_counters.cpp
+++ b/src/util/activate_counters.cpp
@@ -15,10 +15,10 @@
 #include <hpx/runtime/actions/continuation.hpp>
 #include <hpx/runtime/agas/interface.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
 #include <hpx/util/activate_counters.hpp>
-#include <hpx/util/external_timer.hpp>
+#include <hpx/threading_base/external_timer.hpp>
 #include <hpx/util/unwrap.hpp>
 
 #include <cstddef>
diff --git a/src/util/backtrace/backtrace.cpp b/src/util/backtrace/backtrace.cpp
index bf54d6e33f..0f4dbec683 100644
--- a/src/util/backtrace/backtrace.cpp
+++ b/src/util/backtrace/backtrace.cpp
@@ -13,21 +13,16 @@
 
 #if defined(HPX_HAVE_STACKTRACES)
 
-#define HPX_BACKTRACE_SOURCE
-#include <hpx/async.hpp>
-#include <hpx/runtime/threads/thread.hpp>
+#include <hpx/util/backtrace/backtrace.hpp>
 
 #include <boost/config.hpp>
 
-#include <hpx/util/backtrace/backtrace.hpp>
-#include <hpx/functional/bind_front.hpp>
-
-#if (defined(__linux) || defined(__APPLE__) || defined(__sun)) \
-     && (!defined(__ANDROID__) || !defined(ANDROID))
+#if (defined(__linux) || defined(__APPLE__) || defined(__sun)) &&              \
+    (!defined(__ANDROID__) || !defined(ANDROID))
 #define BOOST_HAVE_EXECINFO
 #define BOOST_HAVE_DLFCN
 #if defined(__GNUC__) && !defined(__clang__)
-#  define BOOST_HAVE_UNWIND
+#define BOOST_HAVE_UNWIND
 #endif
 #endif
 
@@ -62,371 +57,375 @@
 
 #if defined(HPX_MSVC)
 #include <windows.h>
-#include <winbase.h>
-#include <stdlib.h>
+
 #include <dbghelp.h>
+#include <stdlib.h>
+#include <winbase.h>
 #endif
 
-namespace hpx { namespace util {
-
-    namespace stack_trace
-    {
+namespace hpx { namespace util { namespace stack_trace {
 #if defined(BOOST_HAVE_EXECINFO) && defined(BOOST_HAVE_UNWIND)
-        struct trace_data
-        {
-            trace_data(void **array,std::size_t size)
-              : array_(array), size_(size), cfa_(0), count_(std::size_t(-1))
-            {}
-
-            void **array_;      // storage for the stack trace
-            std::size_t size_;  // number of frames
-            std::uint64_t cfa_;  // canonical frame address
-            std::size_t count_;
-        };
-
-        _Unwind_Reason_Code trace_callback(_Unwind_Context* ctx,void* ptr);
-        _Unwind_Reason_Code trace_callback(_Unwind_Context* ctx,void* ptr)
+    struct trace_data
+    {
+        trace_data(void** array, std::size_t size)
+          : array_(array)
+          , size_(size)
+          , cfa_(0)
+          , count_(std::size_t(-1))
         {
-            if (!ptr)
-                return _URC_NO_REASON;
+        }
 
-            trace_data& d = *(reinterpret_cast<trace_data*>(ptr));
+        void** array_;         // storage for the stack trace
+        std::size_t size_;     // number of frames
+        std::uint64_t cfa_;    // canonical frame address
+        std::size_t count_;
+    };
 
-            // First call.
-            if (std::size_t(-1) != d.count_)
-            {
-                // Get the instruction pointer for this frame.
-                d.array_[d.count_] = reinterpret_cast<void *>(_Unwind_GetIP(ctx));
+    _Unwind_Reason_Code trace_callback(_Unwind_Context* ctx, void* ptr);
+    _Unwind_Reason_Code trace_callback(_Unwind_Context* ctx, void* ptr)
+    {
+        if (!ptr)
+            return _URC_NO_REASON;
 
-                // Get the CFA.
-                std::uint64_t cfa = _Unwind_GetCFA(ctx);
+        trace_data& d = *(reinterpret_cast<trace_data*>(ptr));
 
-                // Check if we're at the end of the stack.
-                if ((0 < d.count_) &&
-                    (d.array_[d.count_ - 1] == d.array_[d.count_]) &&
-                    (cfa == d.cfa_))
-                {
-                    return _URC_END_OF_STACK;
-                }
+        // First call.
+        if (std::size_t(-1) != d.count_)
+        {
+            // Get the instruction pointer for this frame.
+            d.array_[d.count_] = reinterpret_cast<void*>(_Unwind_GetIP(ctx));
 
-                d.cfa_ = cfa;
-            }
+            // Get the CFA.
+            std::uint64_t cfa = _Unwind_GetCFA(ctx);
 
-            if (++d.count_ == d.size_)
+            // Check if we're at the end of the stack.
+            if ((0 < d.count_) &&
+                (d.array_[d.count_ - 1] == d.array_[d.count_]) &&
+                (cfa == d.cfa_))
+            {
                 return _URC_END_OF_STACK;
+            }
 
-            return _URC_NO_REASON;
+            d.cfa_ = cfa;
         }
 
-        HPX_API_EXPORT std::size_t trace(void **array,std::size_t n)
-        {
-            trace_data d(array,n);
+        if (++d.count_ == d.size_)
+            return _URC_END_OF_STACK;
 
-            if (1 <= n)
-                _Unwind_Backtrace(trace_callback, reinterpret_cast<void*>(&d));
+        return _URC_NO_REASON;
+    }
 
-            if ((1 < d.count_) && d.array_[d.count_ - 1])
-                --d.count_;
+    HPX_API_EXPORT std::size_t trace(void** array, std::size_t n)
+    {
+        trace_data d(array, n);
 
-            return (std::size_t(-1) != d.count_) ? d.count_ : 0;
-        }
+        if (1 <= n)
+            _Unwind_Backtrace(trace_callback, reinterpret_cast<void*>(&d));
+
+        if ((1 < d.count_) && d.array_[d.count_ - 1])
+            --d.count_;
+
+        return (std::size_t(-1) != d.count_) ? d.count_ : 0;
+    }
 
 #elif defined(BOOST_HAVE_EXECINFO)
 
-        HPX_API_EXPORT std::size_t trace(void **array,std::size_t n)
-        {
-            return :: backtrace(array,n);
-        }
+    HPX_API_EXPORT std::size_t trace(void** array, std::size_t n)
+    {
+        return ::backtrace(array, n);
+    }
 
 #elif defined(HPX_MSVC)
 
-        HPX_API_EXPORT std::size_t trace(void **array,std::size_t n)
-        {
+    HPX_API_EXPORT std::size_t trace(void** array, std::size_t n)
+    {
 #if _WIN32_WINNT < 0x0600
-            // for Windows XP/Windows Server 2003
-            if(n>=63)
-                n=62;
+        // for Windows XP/Windows Server 2003
+        if (n >= 63)
+            n = 62;
 #endif
-            return RtlCaptureStackBackTrace(ULONG(0),ULONG(n),array,nullptr);
-        }
+        return RtlCaptureStackBackTrace(ULONG(0), ULONG(n), array, nullptr);
+    }
 
 #else
 
-        HPX_API_EXPORT std::size_t trace(void ** /*array*/,std::size_t /*n*/)
-        {
-            return 0;
-        }
+    HPX_API_EXPORT std::size_t trace(void** /*array*/, std::size_t /*n*/)
+    {
+        return 0;
+    }
 
 #endif
 
 #if defined(BOOST_HAVE_DLFCN) && defined(BOOST_HAVE_ABI_CXA_DEMANGLE)
 
-        HPX_API_EXPORT std::string get_symbol(void *ptr)
+    HPX_API_EXPORT std::string get_symbol(void* ptr)
+    {
+        if (!ptr)
+            return std::string();
+        std::ostringstream res;
+        res.imbue(std::locale::classic());
+        res << std::left << std::setw(sizeof(void*) * 2) << std::setfill(' ')
+            << ptr << ": ";
+        Dl_info info = {nullptr, nullptr, nullptr, nullptr};
+        if (dladdr(ptr, &info) == 0)
         {
-            if(!ptr)
-                return std::string();
-            std::ostringstream res;
-            res.imbue(std::locale::classic());
-            res << std::left << std::setw(sizeof(void*)*2) << std::setfill(' ')
-                << ptr <<": ";
-            Dl_info info = {nullptr, nullptr, nullptr, nullptr};
-            if(dladdr(ptr,&info) == 0) {
-                res << "???";
-            }
-            else {
-                if(info.dli_sname) {
-                    int status = 0;
-                    char *demangled =
-                        abi::__cxa_demangle(info.dli_sname,nullptr,nullptr,&status);
-                    if(demangled) {
-                        res << demangled;
-                        free(demangled);
-                    }
-                    else {
-                        res << info.dli_sname;
-                    }
+            res << "???";
+        }
+        else
+        {
+            if (info.dli_sname)
+            {
+                int status = 0;
+                char* demangled = abi::__cxa_demangle(
+                    info.dli_sname, nullptr, nullptr, &status);
+                if (demangled)
+                {
+                    res << demangled;
+                    free(demangled);
                 }
-                else {
-                    res << "???";
+                else
+                {
+                    res << info.dli_sname;
                 }
+            }
+            else
+            {
+                res << "???";
+            }
 
-                std::ptrdiff_t offset = reinterpret_cast<char *>(ptr)
-                    - reinterpret_cast<char *>(info.dli_saddr);
-                res << std::hex <<" + 0x" << offset ;
+            std::ptrdiff_t offset = reinterpret_cast<char*>(ptr) -
+                reinterpret_cast<char*>(info.dli_saddr);
+            res << std::hex << " + 0x" << offset;
 
-                if(info.dli_fname)
-                    res << " in " << info.dli_fname;
-            }
-           return res.str();
+            if (info.dli_fname)
+                res << " in " << info.dli_fname;
         }
+        return res.str();
+    }
 
-        HPX_API_EXPORT std::string get_symbols(void *const *addresses,
-            std::size_t size)
+    HPX_API_EXPORT std::string get_symbols(
+        void* const* addresses, std::size_t size)
+    {
+        std::string res =
+            std::to_string(size) + ((1 == size) ? " frame:" : " frames:");
+        for (std::size_t i = 0; i < size; i++)
         {
-            std::string res = std::to_string(size)
-                + ((1==size)?" frame:":" frames:");
-            for(std::size_t i=0;i<size;i++) {
-                std::string tmp = get_symbol(addresses[i]);
-                if(!tmp.empty()) {
-                    res+='\n';
-                    res+=tmp;
-                }
+            std::string tmp = get_symbol(addresses[i]);
+            if (!tmp.empty())
+            {
+                res += '\n';
+                res += tmp;
             }
-            return res;
         }
-        HPX_API_EXPORT void write_symbols(void *const *addresses,
-            std::size_t size,std::ostream &out)
+        return res;
+    }
+    HPX_API_EXPORT void write_symbols(
+        void* const* addresses, std::size_t size, std::ostream& out)
+    {
+        out << size << ((1 == size) ? " frame:" : " frames:");
+        for (std::size_t i = 0; i < size; i++)
         {
-            out << size << ((1==size)?" frame:":" frames:");
-            for(std::size_t i=0;i<size;i++) {
-                std::string tmp = get_symbol(addresses[i]);
-                if(!tmp.empty()) {
-                    out << '\n' << tmp;
-                }
+            std::string tmp = get_symbol(addresses[i]);
+            if (!tmp.empty())
+            {
+                out << '\n' << tmp;
             }
-            out << std::flush;
         }
+        out << std::flush;
+    }
 
 #elif defined(BOOST_HAVE_EXECINFO)
 
-        HPX_API_EXPORT std::string get_symbol(void *address)
+    HPX_API_EXPORT std::string get_symbol(void* address)
+    {
+        char** ptr = backtrace_symbols(&address, 1);
+        try
         {
-            char ** ptr = backtrace_symbols(&address,1);
-            try {
-                if(ptr == nullptr)
-                    return std::string();
-                std::string res = ptr[0];
-                free(ptr);
-                ptr = nullptr;
-                return res;
-            }
-            catch(...) {
-                free(ptr);
-                throw;
-            }
+            if (ptr == nullptr)
+                return std::string();
+            std::string res = ptr[0];
+            free(ptr);
+            ptr = nullptr;
+            return res;
         }
+        catch (...)
+        {
+            free(ptr);
+            throw;
+        }
+    }
 
-        HPX_API_EXPORT std::string get_symbols(void * const *address,
-            std::size_t size)
+    HPX_API_EXPORT std::string get_symbols(
+        void* const* address, std::size_t size)
+    {
+        char** ptr = backtrace_symbols(address, size);
+        try
         {
-            char ** ptr = backtrace_symbols(address,size);
-            try {
-                if(ptr==nullptr)
-                    return std::string();
-                std::string res = std::to_string(size)
-                    + ((1==size)?" frame:":" frames:");
-                for(std::size_t i=0;i<size;i++) {
-                    res+='\n';
-                    res+=ptr[i];
-                }
-                free(ptr);
-                ptr = nullptr;
-                return res;
-            }
-            catch(...) {
-                free(ptr);
-                throw;
+            if (ptr == nullptr)
+                return std::string();
+            std::string res =
+                std::to_string(size) + ((1 == size) ? " frame:" : " frames:");
+            for (std::size_t i = 0; i < size; i++)
+            {
+                res += '\n';
+                res += ptr[i];
             }
+            free(ptr);
+            ptr = nullptr;
+            return res;
         }
+        catch (...)
+        {
+            free(ptr);
+            throw;
+        }
+    }
 
-        HPX_API_EXPORT void write_symbols(void *const *addresses,std::size_t size,
-            std::ostream &out)
+    HPX_API_EXPORT void write_symbols(
+        void* const* addresses, std::size_t size, std::ostream& out)
+    {
+        char** ptr = backtrace_symbols(addresses, size);
+        out << size << ((1 == size) ? " frame:" : " frames:");
+        try
         {
-            char ** ptr = backtrace_symbols(addresses,size);
-            out << size << ((1==size)?" frame:":" frames:");
-            try {
-                if(ptr==nullptr)
-                    return;
-                for(std::size_t i=0;i<size;i++)
-                    out << '\n' << ptr[i];
-                free(ptr);
-                ptr = nullptr;
-                out << std::flush;
-            }
-            catch(...) {
-                free(ptr);
-                throw;
-            }
+            if (ptr == nullptr)
+                return;
+            for (std::size_t i = 0; i < size; i++)
+                out << '\n' << ptr[i];
+            free(ptr);
+            ptr = nullptr;
+            out << std::flush;
         }
+        catch (...)
+        {
+            free(ptr);
+            throw;
+        }
+    }
 
 #elif defined(HPX_MSVC)
 
-        namespace {
-            HANDLE hProcess = nullptr;
-            bool syms_ready = false;
+    namespace {
+        HANDLE hProcess = nullptr;
+        bool syms_ready = false;
 
-            void init()
+        void init()
+        {
+            if (hProcess == nullptr)
             {
-                if(hProcess == nullptr) {
-                    hProcess = GetCurrentProcess();
-                    SymSetOptions(SYMOPT_DEFERRED_LOADS);
-
-                    if (SymInitialize(hProcess, nullptr, TRUE))
-                    {
-                        syms_ready = true;
-                    }
+                hProcess = GetCurrentProcess();
+                SymSetOptions(SYMOPT_DEFERRED_LOADS);
+
+                if (SymInitialize(hProcess, nullptr, TRUE))
+                {
+                    syms_ready = true;
                 }
             }
         }
+    }    // namespace
 
-        HPX_API_EXPORT std::string get_symbol(void *ptr)
+    HPX_API_EXPORT std::string get_symbol(void* ptr)
+    {
+        if (ptr == nullptr)
+            return std::string();
+        init();
+        std::ostringstream ss;
+        ss << std::left << std::setw(sizeof(void*) * 2) << std::setfill(' ')
+           << ptr;
+        if (syms_ready)
         {
-            if(ptr==nullptr)
-                return std::string();
-            init();
-            std::ostringstream ss;
-            ss << std::left << std::setw(sizeof(void*)*2) << std::setfill(' ') << ptr;
-            if(syms_ready) {
-                DWORD64  dwDisplacement = 0;
-                DWORD64  dwAddress = (DWORD64)ptr;
+            DWORD64 dwDisplacement = 0;
+            DWORD64 dwAddress = (DWORD64) ptr;
 
-                std::vector<char> buffer(sizeof(SYMBOL_INFO) + MAX_SYM_NAME);
-                PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)&buffer.front();
+            std::vector<char> buffer(sizeof(SYMBOL_INFO) + MAX_SYM_NAME);
+            PSYMBOL_INFO pSymbol = (PSYMBOL_INFO) &buffer.front();
 
-                pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
-                pSymbol->MaxNameLen = MAX_SYM_NAME;
+            pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
+            pSymbol->MaxNameLen = MAX_SYM_NAME;
 
-                if (SymFromAddr(hProcess, dwAddress, &dwDisplacement, pSymbol))
-                {
-                    ss <<": " << pSymbol->Name << std::hex << " +0x" << dwDisplacement;
-                }
-                else
-                {
-                    ss << ": ???";
-                }
+            if (SymFromAddr(hProcess, dwAddress, &dwDisplacement, pSymbol))
+            {
+                ss << ": " << pSymbol->Name << std::hex << " +0x"
+                   << dwDisplacement;
+            }
+            else
+            {
+                ss << ": ???";
             }
-            return ss.str();
         }
+        return ss.str();
+    }
 
-        HPX_API_EXPORT std::string get_symbols(void *const *addresses,
-            std::size_t size)
+    HPX_API_EXPORT std::string get_symbols(
+        void* const* addresses, std::size_t size)
+    {
+        std::string res =
+            std::to_string(size) + ((1 == size) ? " frame:" : " frames:");
+        for (std::size_t i = 0; i < size; i++)
         {
-            std::string res = std::to_string(size)
-                + ((1==size)?" frame:":" frames:");
-            for(std::size_t i=0;i<size;i++) {
-                std::string tmp = get_symbol(addresses[i]);
-                if(!tmp.empty()) {
-                    res+='\n';
-                    res+=tmp;
-                }
+            std::string tmp = get_symbol(addresses[i]);
+            if (!tmp.empty())
+            {
+                res += '\n';
+                res += tmp;
             }
-            return res;
         }
+        return res;
+    }
 
-        HPX_API_EXPORT void write_symbols(void *const *addresses,
-            std::size_t size,std::ostream &out)
+    HPX_API_EXPORT void write_symbols(
+        void* const* addresses, std::size_t size, std::ostream& out)
+    {
+        out << size << ((1 == size) ? " frame:" : " frames:");    //-V128
+        for (std::size_t i = 0; i < size; i++)
         {
-            out << size << ((1==size)?" frame:":" frames:"); //-V128
-            for(std::size_t i=0;i<size;i++) {
-                std::string tmp = get_symbol(addresses[i]);
-                if(!tmp.empty()) {
-                    out << '\n' << tmp;
-                }
+            std::string tmp = get_symbol(addresses[i]);
+            if (!tmp.empty())
+            {
+                out << '\n' << tmp;
             }
-            out << std::flush;
         }
+        out << std::flush;
+    }
 
 #else
 
-        HPX_API_EXPORT std::string get_symbol(void *ptr)
-        {
-            if(!ptr)
-                return std::string();
-            std::ostringstream res;
-            res.imbue(std::locale::classic());
-            res << std::left << std::setw(sizeof(void*)*2) << std::setfill(' ') << ptr;
-            return res.str();
-        }
+    HPX_API_EXPORT std::string get_symbol(void* ptr)
+    {
+        if (!ptr)
+            return std::string();
+        std::ostringstream res;
+        res.imbue(std::locale::classic());
+        res << std::left << std::setw(sizeof(void*) * 2) << std::setfill(' ')
+            << ptr;
+        return res.str();
+    }
 
-        HPX_API_EXPORT std::string get_symbols(void *const *ptrs,std::size_t size)
-        {
-            if(!ptrs)
-                return std::string();
-            std::ostringstream res;
-            res.imbue(std::locale::classic());
-            write_symbols(ptrs,size,res);
-            return res.str();
-        }
+    HPX_API_EXPORT std::string get_symbols(void* const* ptrs, std::size_t size)
+    {
+        if (!ptrs)
+            return std::string();
+        std::ostringstream res;
+        res.imbue(std::locale::classic());
+        write_symbols(ptrs, size, res);
+        return res.str();
+    }
 
-        HPX_API_EXPORT void write_symbols(void *const *addresses,
-            std::size_t size,std::ostream &out)
+    HPX_API_EXPORT void write_symbols(
+        void* const* addresses, std::size_t size, std::ostream& out)
+    {
+        out << size << ((1 == size) ? " frame:" : " frames:");    //-V128
+        for (std::size_t i = 0; i < size; i++)
         {
-            out << size << ((1 == size)?" frame:":" frames:"); //-V128
-            for(std::size_t i=0;i<size;i++) {
-                if(addresses[i]!=nullptr)
-                    out << '\n' << std::left << std::setw(sizeof(void*)*2)
+            if (addresses[i] != nullptr)
+                out << '\n'
+                    << std::left << std::setw(sizeof(void*) * 2)
                     << std::setfill(' ') << addresses[i];
-            }
-            out << std::flush;
         }
-
-#endif
-    } // stack_trace
-
-    std::string backtrace::trace_on_new_stack() const
-    {
-        if(frames_.empty())
-            return std::string();
-        if (nullptr == threads::get_self_ptr())
-            return trace();
-
-        lcos::local::futures_factory<std::string()> p(util::bind_front(
-            stack_trace::get_symbols, &frames_.front(), frames_.size()));
-
-        error_code ec(lightweight);
-        threads::thread_id_type tid = p.apply("backtrace",
-            launch::fork, threads::thread_priority_default,
-            threads::thread_stacksize_medium,
-            threads::thread_schedule_hint(),
-            ec);
-        if (ec) return "<couldn't retrieve stack backtrace>";
-
-        // make sure this thread is executed last
-        hpx::this_thread::yield_to(thread::id(std::move(tid)));
-
-        return p.get_future().get(ec);
+        out << std::flush;
     }
-}} // hpx::util
 
 #endif
+}}}    // namespace hpx::util::stack_trace
 
+#endif
diff --git a/src/util/debug/thread_stacktrace.cpp b/src/util/debug/thread_stacktrace.cpp
index 18670cef33..1a0f758fe1 100644
--- a/src/util/debug/thread_stacktrace.cpp
+++ b/src/util/debug/thread_stacktrace.cpp
@@ -6,7 +6,8 @@
 
 #include <hpx/config.hpp>
 #include <hpx/util/debug/thread_stacktrace.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/runtime/thread_pool_helpers.hpp>
 
 #include <iomanip>
 #include <sstream>
diff --git a/src/util/debugging.cpp b/src/util/debugging.cpp
index 2fd1da9597..013cda94d5 100644
--- a/src/util/debugging.cpp
+++ b/src/util/debugging.cpp
@@ -6,44 +6,14 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/debugging/attach_debugger.hpp>
 #include <hpx/runtime/config_entry.hpp>
 #include <hpx/util/debugging.hpp>
 
-#include <iostream>
 #include <string>
 
-#if defined(HPX_HAVE_UNISTD_H)
-#include <unistd.h>
-#endif
-
-#if defined(HPX_WINDOWS)
-#include <Windows.h>
-#endif    // HPX_WINDOWS
-
-#if defined(_POSIX_VERSION)
-#include <boost/asio/ip/host_name.hpp>
-#endif
-
 namespace hpx {
 namespace util {
-    void attach_debugger()
-    {
-#if defined(_POSIX_VERSION)
-        volatile int i = 0;
-        std::cerr << "PID: " << getpid() << " on "
-                  << boost::asio::ip::host_name()
-                  << " ready for attaching debugger. Once attached set i = 1 "
-                     "and continue"
-                  << std::endl;
-        while (i == 0)
-        {
-            sleep(1);
-        }
-#elif defined(HPX_WINDOWS)
-        DebugBreak();
-#endif
-    }
-
     void may_attach_debugger(std::string const& category)
     {
         if (get_config_entry("hpx.attach_debugger", "") == category)
diff --git a/src/util/detail/yield_k.cpp b/src/util/detail/yield_k.cpp
new file mode 100644
index 0000000000..5e621408f3
--- /dev/null
+++ b/src/util/detail/yield_k.cpp
@@ -0,0 +1,26 @@
+////////////////////////////////////////////////////////////////////////////////
+//  Copyright (c) 2013 Thomas Heller
+//  Copyright (c) 2008 Peter Dimov
+//  Copyright (c) 2018 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+////////////////////////////////////////////////////////////////////////////////
+
+#include <hpx/config.hpp>
+
+#include <cstddef>
+
+#ifdef HPX_HAVE_SPINLOCK_DEADLOCK_DETECTION
+namespace hpx { namespace util { namespace detail
+{
+    ///////////////////////////////////////////////////////////////////////////
+    // We globally control whether to do spinlock deadlock detection in
+    // spin-locks using this global bool variable. It will be set once by the
+    // runtime configuration startup code
+    HPX_EXPORT bool spinlock_break_on_deadlock = false;
+    HPX_EXPORT std::size_t spinlock_deadlock_detection_limit =
+        HPX_SPINLOCK_DEADLOCK_DETECTION_LIMIT;
+}}}
+#endif
diff --git a/src/util/external_timer.cpp b/src/util/external_timer.cpp
deleted file mode 100644
index 6074095b3a..0000000000
--- a/src/util/external_timer.cpp
+++ /dev/null
@@ -1,137 +0,0 @@
-//  Copyright (c) 2007-2013 Kevin Huck
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#include <hpx/config.hpp>
-#include <hpx/assertion.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/util/external_timer.hpp>
-
-#include <cstddef>
-#include <cstdint>
-#include <memory>
-
-namespace hpx { namespace util {
-
-#ifdef HPX_HAVE_APEX
-
-    static enable_parent_task_handler_type enable_parent_task_handler;
-
-    void set_enable_parent_task_handler(enable_parent_task_handler_type f)
-    {
-        enable_parent_task_handler = f;
-    }
-
-    namespace external_timer {
-
-    std::shared_ptr<task_wrapper> new_task(
-        thread_description const& description,
-        std::uint32_t parent_locality_id,
-        threads::thread_id_type const& parent_task)
-    {
-        std::shared_ptr<task_wrapper> parent_wrapper = nullptr;
-        // Parent pointers aren't reliable in distributed runs.
-        if (parent_task != nullptr && enable_parent_task_handler &&
-            enable_parent_task_handler())
-        {
-            parent_wrapper = get_thread_id_data(parent_task)->get_timer_data();
-        }
-
-        if (description.kind() == thread_description::data_type_description)
-        {
-            return new_task(description.get_description(), UINTMAX_MAX,
-                parent_wrapper);
-        }
-        else
-        {
-            HPX_ASSERT(
-                description.kind() == thread_description::data_type_address);
-            return new_task(description.get_address(), UINTMAX_MAX,
-                parent_wrapper);
-        }
-    }
-
-    /* register the function pointers */
-    void register_external_timer(registration_t &registration) {
-        switch (registration.type) {
-            case init_flag: {
-                init_function = registration.record.init;
-                break;
-            }
-            case finalize_flag: {
-                finalize_function = registration.record.finalize;
-                break;
-            }
-            case register_thread_flag: {
-                register_thread_function = registration.record.register_thread;
-                break;
-            }
-            case new_task_string_flag: {
-                new_task_string_function = registration.record.new_task_string;
-                break;
-            }
-            case new_task_address_flag: {
-                new_task_address_function =
-                    registration.record.new_task_address;
-                break;
-            }
-            case update_task_string_flag: {
-                update_task_string_function =
-                    registration.record.update_task_string;
-                break;
-            }
-            case update_task_address_flag: {
-                update_task_address_function =
-                    registration.record.update_task_address;
-                break;
-            }
-            case sample_value_flag: {
-                sample_value_function = registration.record.sample_value;
-                break;
-            }
-            case send_flag: {
-                send_function = registration.record.send;
-                break;
-            }
-            case recv_flag: {
-                recv_function = registration.record.recv;
-                break;
-            }
-            case start_flag: {
-                start_function = registration.record.start;
-                break;
-            }
-            case stop_flag: {
-                stop_function = registration.record.stop;
-                break;
-            }
-            case yield_flag: {
-                yield_function = registration.record.yield;
-                break;
-            }
-        }
-    }
-
-    /* Instantiate the function pointers. */
-    init_t *init_function{nullptr};
-    finalize_t *finalize_function{nullptr};
-    register_thread_t *register_thread_function{nullptr};
-    new_task_string_t *new_task_string_function{nullptr};
-    new_task_address_t *new_task_address_function{nullptr};
-    sample_value_t *sample_value_function{nullptr};
-    send_t *send_function{nullptr};
-    recv_t *recv_function{nullptr};
-    update_task_string_t *update_task_string_function{nullptr};
-    update_task_address_t *update_task_address_function{nullptr};
-    start_t *start_function{nullptr};
-    stop_t *stop_function{nullptr};
-    yield_t *yield_function{nullptr};
-
-    } // namespace hpx::util::external_timer
-
-#endif
-
-}}    // namespace hpx::util
diff --git a/src/util/ini.cpp b/src/util/ini.cpp
deleted file mode 100644
index 14fbd321d6..0000000000
--- a/src/util/ini.cpp
+++ /dev/null
@@ -1,996 +0,0 @@
-//  Copyright (c) 2005-2007 Andre Merzky
-//  Copyright (c) 2005-2018 Hartmut Kaiser
-//  Copyright (c)      2011 Bryce Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-// make inspect happy: hpxinspect:nodeprecatedname:boost::is_any_of
-
-#include <hpx/config.hpp>
-
-// System Header Files
-#include <cerrno>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-
-#include <fstream>
-#include <iostream>
-#include <list>
-#include <mutex>
-#include <regex>
-#include <string>
-#include <vector>
-#include <utility>
-
-#include <hpx/assertion.hpp>
-#include <hpx/basic_execution/register_locks.hpp>
-#include <hpx/errors.hpp>
-#include <hpx/serialization/map.hpp>
-#include <hpx/serialization/serialize.hpp>
-#include <hpx/thread_support/unlock_guard.hpp>
-#include <hpx/util/ini.hpp>
-
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/replace.hpp>
-
-#ifdef __APPLE__
-#include <crt_externs.h>
-#define environ (*_NSGetEnviron())
-#elif !defined(HPX_WINDOWS)
-extern char **environ;
-#endif
-
-///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
-
-///////////////////////////////////////////////////////////////////////////////
-// example ini line: line # comment
-const char pattern_comment[] =  "^([^#]*)(#.*)$";
-///////////////////////////////////////////////////////////////////////////////
-
-namespace detail
-{
-    ///////////////////////////////////////////////////////////////////////////
-    inline std::string
-    trim_whitespace (std::string const &s)
-    {
-        typedef std::string::size_type size_type;
-
-        size_type first = s.find_first_not_of (" \t\r\n");
-        if (std::string::npos == first)
-            return (std::string ());
-
-        size_type last = s.find_last_not_of (" \t\r\n");
-        return s.substr (first, last - first + 1);
-    }
-} // namespace
-
-///////////////////////////////////////////////////////////////////////////////
-section::section ()
-  : root_(this_())
-{
-}
-
-section::section (std::string const& filename, section* root)
-  : root_(nullptr != root ? root : this_()), name_(filename)
-{
-    read(filename);
-}
-
-section::section (const section & in)
-  : root_(this_()), name_(in.get_name()), parent_name_(in.get_parent_name())
-{
-    entry_map const& e = in.get_entries();
-    entry_map::const_iterator end = e.end();
-    for (entry_map::const_iterator i = e.begin (); i != end; ++i)
-        add_entry(i->first, i->second);
-
-    section_map s = in.get_sections();
-    section_map::iterator send = s.end();
-    for (section_map::iterator si = s.begin(); si != send; ++si)
-        add_section(si->first, si->second, get_root());
-}
-
-section& section::operator=(section const& rhs)
-{
-    if (this != &rhs) {
-        std::unique_lock<mutex_type> l(mtx_);
-
-        root_ = this;
-        parent_name_ = rhs.get_parent_name();
-        name_ = rhs.get_name();
-
-        entry_map const& e = rhs.get_entries();
-        entry_map::const_iterator end = e.end();
-        for (entry_map::const_iterator i = e.begin (); i != end; ++i)
-            add_entry(l, i->first, i->first, i->second);
-
-        section_map s = rhs.get_sections();
-        section_map::iterator send = s.end();
-        for (section_map::iterator si = s.begin(); si != send; ++si)
-            add_section(l, si->first, si->second, get_root());
-    }
-    return *this;
-}
-
-section& section::clone_from(section const& rhs, section* root)
-{
-    if (this != &rhs) {
-        std::unique_lock<mutex_type> l(mtx_);
-
-        root_ = root ? root : this;
-        parent_name_ = rhs.get_parent_name();
-        name_ = rhs.get_name();
-
-        entry_map const& e = rhs.get_entries();
-        entry_map::const_iterator end = e.end();
-        for (entry_map::const_iterator i = e.begin (); i != end; ++i)
-            add_entry(l, i->first, i->first, i->second);
-
-        section_map s = rhs.get_sections();
-        section_map::iterator send = s.end();
-        for (section_map::iterator si = s.begin(); si != send; ++si)
-            add_section(l, si->first, si->second, get_root());
-    }
-    return *this;
-}
-
-void section::read (std::string const& filename)
-{
-#if defined(__AIX__) && defined(__GNUC__)
-    // NEVER ask why... seems to be some weird stdlib initialization problem
-    // If you don't call getline() here the while(getline...) loop below will
-    // crash with a bad_cast exception. Stupid AIX...
-    std::string l1;
-    std::ifstream i1;
-    i1.open(filename.c_str(), std::ios::in);
-    std::getline(i1, l1);
-    i1.close();
-#endif
-
-    // build ini - open file and parse each line
-    std::ifstream input(filename.c_str (), std::ios::in);
-    if (!input.is_open())
-        line_msg("Cannot open file: ", filename);
-
-    // read file
-    std::string line;
-    std::vector <std::string> lines;
-    while (std::getline(input, line))
-        lines.push_back (line);
-
-    // parse file
-    parse(filename, lines, false);
-}
-
-bool force_entry(std::string& str)
-{
-    std::string::size_type p = str.find_last_of('!');
-    if (p != std::string::npos && str.find_first_not_of(" \t", p+1) == std::string::npos)
-    {
-        str = str.substr(0, p);   // remove forcing modifier ('!')
-        return true;
-    }
-    return false;
-}
-
-// parse file
-void section::parse (std::string const& sourcename,
-    std::vector<std::string> const& lines, bool verify_existing,
-    bool weed_out_comments, bool replace_existing)
-{
-    int linenum = 0;
-    section* current = this;
-
-    std::regex regex_comment (pattern_comment, std::regex_constants::icase);
-
-    std::vector<std::string>::const_iterator end = lines.end();
-    for (std::vector<std::string>::const_iterator it = lines.begin();
-         it != end; ++it)
-    {
-        ++linenum;
-
-        // remove trailing new lines and white spaces
-        std::string line(detail::trim_whitespace (*it));
-
-        // skip if empty line
-        if (line.empty())
-            continue;
-
-        // weed out comments
-        if (weed_out_comments)
-        {
-            std::smatch what_comment;
-            if (std::regex_match (line, what_comment, regex_comment))
-            {
-                HPX_ASSERT(3 == what_comment.size());
-
-                line = detail::trim_whitespace (what_comment[1]);
-                if (line.empty())
-                    continue;
-            }
-        }
-        // no comments anymore: line is either section, key=val,
-        // or garbage/empty
-
-        // Check if we have a section.
-        // Example: [sec.ssec]
-        if (line.front() == '[' && line.back() == ']')
-        {
-            current = this;    // start adding sections at the root
-
-            // got the section name. It might be hierarchical, so split it up, and
-            // for each elem, check if we have it.  If not, create it, and add
-            std::string sec_name(line.substr(1, line.size() - 2));
-            std::string::size_type pos = 0;
-            for (std::string::size_type pos1 = sec_name.find_first_of('.');
-                 std::string::npos != pos1;
-                 pos1 = sec_name.find_first_of ('.', pos = pos1 + 1))
-            {
-                current = current->add_section_if_new(
-                    sec_name.substr(pos, pos1 - pos));
-            }
-
-            current = current->add_section_if_new(sec_name.substr(pos));
-            continue;
-        }
-
-        // Check if we have a key=val entry...
-        std::string::size_type assign_pos = line.find('=');
-        if (assign_pos != std::string::npos)
-        {
-            std::string sec_key =
-                detail::trim_whitespace(line.substr(0, assign_pos));
-            std::string value = detail::trim_whitespace(
-                line.substr(assign_pos + 1, line.size() - assign_pos - 1));
-
-            section* s = current;    // save the section we're in
-            current = this;          // start adding sections at the root
-
-            std::string::size_type pos = 0;
-            // Check if we have a qualified key name
-            // Example: hpx.commandline.allow_unknown
-            for (std::string::size_type dot_pos = sec_key.find_first_of('.');
-                 std::string::npos != dot_pos;
-                 dot_pos = sec_key.find_first_of('.', pos = dot_pos + 1))
-            {
-                current = current->add_section_if_new(
-                    sec_key.substr(pos, dot_pos - pos));
-            }
-            // if we don't have section qualifiers, restor current...
-            if (current == this)
-            {
-                current = s;
-            }
-
-            std::string key = sec_key.substr(pos);
-
-            // add key/val to this section
-            std::unique_lock<mutex_type> l(current->mtx_);
-
-            if (!force_entry(key) && verify_existing && !current->has_entry(l, key))
-            {
-                line_msg ("Attempt to initialize unknown entry: ", sourcename,
-                    linenum, line);
-            }
-
-            if (replace_existing || !current->has_entry(l, key))
-            {
-                current->add_entry(l, key, key, value);
-            }
-
-            // restore the old section
-            current = s;
-        }
-        else
-        {
-            // Hmm, is not a section, is not an entry, is not empty - must be
-            // an error!
-            line_msg ("Cannot parse line at: ", sourcename, linenum, line);
-        }
-    }
-}
-
-///////////////////////////////////////////////////////////////////////////////
-void section::add_section (std::unique_lock<mutex_type>& l,
-    std::string const& sec_name, section& sec, section* root)
-{
-    // setting name and root
-    sec.name_ = sec_name;
-    sec.parent_name_ = get_full_name();
-
-    section& newsec = sections_[sec_name];
-    newsec.clone_from(sec, (nullptr != root) ? root : get_root());
-}
-
-///////////////////////////////////////////////////////////////////////////
-section* section::add_section_if_new(std::unique_lock<mutex_type>& l,
-    std::string const& sec_name)
-{
-    // do we know this one?
-    if (!has_section(l, sec_name))
-    {
-        // no - add it!
-        section sec;
-        add_section(l, sec_name, sec, get_root());
-    }
-
-    return get_section(l, sec_name);
-}
-
-bool section::has_section (std::unique_lock<mutex_type>& l,
-    std::string const& sec_name) const
-{
-    std::string::size_type i = sec_name.find('.');
-    if (i != std::string::npos)
-    {
-        std::string cor_sec_name = sec_name.substr (0, i);
-
-        section_map::const_iterator it = sections_.find(cor_sec_name);
-        if (it != sections_.end())
-        {
-            std::string sub_sec_name = sec_name.substr(i+1);
-            hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-            return (*it).second.has_section(sub_sec_name);
-        }
-        return false;
-    }
-    return sections_.find(sec_name) != sections_.end();
-}
-
-section* section::get_section (std::unique_lock<mutex_type>& l,
-    std::string const& sec_name)
-{
-    std::string::size_type i  = sec_name.find ('.');
-    if (i != std::string::npos)
-    {
-        std::string cor_sec_name = sec_name.substr (0, i);
-        section_map::iterator it = sections_.find(cor_sec_name);
-        if (it != sections_.end())
-        {
-            std::string sub_sec_name = sec_name.substr(i+1);
-            hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-            return (*it).second.get_section(sub_sec_name);
-        }
-
-        std::string name(get_name());
-        if (name.empty())
-            name = "<root>";
-
-        HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
-            "No such section (" + sec_name + ") in section: " + name);
-        return nullptr;
-    }
-
-    section_map::iterator it = sections_.find(sec_name);
-    if (it != sections_.end())
-        return &((*it).second);
-
-    HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
-        "No such section (" + sec_name + ") in section: " + get_name());
-    return nullptr;
-}
-
-section const* section::get_section (std::unique_lock<mutex_type>& l,
-    std::string const& sec_name) const
-{
-    std::string::size_type i  = sec_name.find ('.');
-    if (i != std::string::npos)
-    {
-        std::string cor_sec_name = sec_name.substr (0,  i);
-        section_map::const_iterator it = sections_.find(cor_sec_name);
-        if (it != sections_.end())
-        {
-            std::string sub_sec_name = sec_name.substr(i+1);
-            hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-            return (*it).second.get_section(sub_sec_name);
-        }
-
-        std::string name(get_name());
-        if (name.empty())
-            name = "<root>";
-
-        HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
-            "No such section (" + sec_name + ") in section: " + name);
-        return nullptr;
-    }
-
-    section_map::const_iterator it = sections_.find(sec_name);
-    if (it != sections_.end())
-        return &((*it).second);
-
-    HPX_THROW_EXCEPTION(bad_parameter, "section::get_section",
-        "No such section (" + sec_name + ") in section: " + get_name());
-    return nullptr;
-}
-
-void section::add_entry (std::unique_lock<mutex_type>& l,
-    std::string const& fullkey, std::string const& key, std::string val)
-{
-    // first expand the full property name in the value (avoids infinite recursion)
-    expand_only(l, val, std::string::size_type(-1), get_full_name() + "." + key);
-
-    std::string::size_type i = key.find_last_of('.');
-    if (i != std::string::npos)
-    {
-        section* current = root_;
-
-        // make sure all sections in key exist
-        std::string sec_name = key.substr(0, i);
-
-        std::string::size_type pos = 0;
-        for (std::string::size_type pos1 = sec_name.find_first_of('.');
-             std::string::npos != pos1;
-             pos1 = sec_name.find_first_of('.', pos = pos1 + 1))
-        {
-            current = current->add_section_if_new(l,
-                sec_name.substr(pos, pos1 - pos));
-        }
-
-        current = current->add_section_if_new(l, sec_name.substr(pos));
-
-        // now add this entry to the section
-        current->add_entry(l, fullkey, key.substr(i+1), val);
-    }
-    else
-    {
-        entry_map::iterator it = entries_.find(key);
-        if (it != entries_.end())
-        {
-            auto& e = it->second;
-            e.first = std::move(val);
-            if (!e.second.empty())
-            {
-                std::string value = e.first;
-                entry_changed_func f = e.second;
-
-                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-                f(fullkey, value);
-            }
-        }
-        else
-        {
-            // just add this entry to the section
-            entries_[key] = entry_type(val, entry_changed_func());
-        }
-    }
-}
-
-void section::add_entry (std::unique_lock<mutex_type>& l,
-    std::string const& fullkey, std::string const& key, entry_type const& val)
-{
-    std::string::size_type i = key.find_last_of('.');
-    if (i != std::string::npos)
-    {
-        section* current = root_;
-
-        // make sure all sections in key exist
-        std::string sec_name = key.substr(0, i);
-
-        std::string::size_type pos = 0;
-        for (std::string::size_type pos1 = sec_name.find_first_of('.');
-             std::string::npos != pos1;
-             pos1 = sec_name.find_first_of('.', pos = pos1 + 1))
-        {
-            current = current->add_section_if_new(l,
-                sec_name.substr(pos, pos1 - pos));
-        }
-
-        current = current->add_section_if_new(l, sec_name.substr(pos));
-
-        // now add this entry to the section
-        current->add_entry(l, fullkey, key.substr(i+1), val);
-    }
-    else
-    {
-        entry_map::iterator it = entries_.find(key);
-        if (it != entries_.end())
-        {
-            it->second = val;
-            if (!it->second.second.empty())
-            {
-                std::string value = it->second.first;
-                entry_changed_func f = it->second.second;
-
-                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-                f(fullkey, value);
-            }
-        }
-        else
-        {
-            // just add this entry to the section
-            std::pair<entry_map::iterator, bool> p = entries_.insert(
-                entry_map::value_type(key, val));
-            HPX_ASSERT(p.second);
-
-            if (!p.first->second.second.empty())
-            {
-                std::string key = p.first->first;
-                std::string value = p.first->second.first;
-                entry_changed_func f = p.first->second.second;
-
-                hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-                f(key, value);
-            }
-        }
-    }
-}
-
-///////////////////////////////////////////////////////////////////////////////
-template <typename F1, typename F2>
-class compose_callback_impl
-{
-public:
-    template <typename A1, typename A2>
-    compose_callback_impl(A1 && f1, A2 && f2)
-      : f1_(std::forward<A1>(f1))
-      , f2_(std::forward<A2>(f2))
-    {}
-
-    void operator()(std::string const& k, std::string const& v) const
-    {
-        f1_(k, v);
-        f2_(k, v);
-    }
-
-private:
-    F1 f1_;
-    F2 f2_;
-};
-
-template <typename F1, typename F2>
-static HPX_FORCEINLINE
-util::function_nonser<void(std::string const&, std::string const&)>
-compose_callback(F1 && f1, F2 && f2)
-{
-    if (!f1)
-        return std::forward<F2>(f2);
-    else if (!f2)
-        return std::forward<F1>(f1);
-
-    // otherwise create a combined callback
-    typedef compose_callback_impl<
-        typename util::decay<F1>::type, typename util::decay<F2>::type
-    > result_type;
-    return result_type(std::forward<F1>(f1), std::forward<F2>(f2));
-}
-
-void section::add_notification_callback(std::unique_lock<mutex_type>& l,
-    std::string const& key, entry_changed_func const& callback)
-{
-    std::string::size_type i = key.find_last_of('.');
-    if (i != std::string::npos)
-    {
-        section* current = root_;
-
-        // make sure all sections in key exist
-        std::string sec_name = key.substr(0, i);
-
-        std::string::size_type pos = 0;
-        for (std::string::size_type pos1 = sec_name.find_first_of('.');
-             std::string::npos != pos1;
-             pos1 = sec_name.find_first_of('.', pos = pos1 + 1))
-        {
-            current = current->add_section_if_new(l,
-                sec_name.substr(pos, pos1 - pos));
-        }
-
-        current = current->add_section_if_new(l, sec_name.substr(pos));
-
-        // now add this entry to the section
-        current->add_notification_callback(l, key.substr(i+1), callback);
-    }
-    else
-    {
-        // just add this entry to the section
-        entry_map::iterator it = entries_.find(key);
-        if (it != entries_.end())
-        {
-            it->second.second = compose_callback(callback, it->second.second);
-        }
-        else
-        {
-            entries_[key] = entry_type("", callback);
-        }
-    }
-}
-
-bool section::has_entry (std::unique_lock<mutex_type>& l, std::string const& key) const
-{
-    std::string::size_type i = key.find('.');
-    if (i != std::string::npos)
-    {
-        std::string sub_sec = key.substr(0, i);
-        std::string sub_key = key.substr(i+1, key.size() - i);
-        if (has_section(l, sub_sec))
-        {
-            section_map::const_iterator cit = sections_.find(sub_sec);
-            HPX_ASSERT(cit != sections_.end());
-            hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-            return (*cit).second.has_entry(sub_key);
-        }
-        return false;
-    }
-    return entries_.find(key) != entries_.end();
-}
-
-std::string section::get_entry (std::unique_lock<mutex_type>& l,
-    std::string const& key) const
-{
-    std::string::size_type i = key.find('.');
-    if (i != std::string::npos)
-    {
-        std::string sub_sec = key.substr(0, i);
-        std::string sub_key = key.substr(i+1, key.size() - i);
-        if (has_section(l, sub_sec))
-        {
-            section_map::const_iterator cit = sections_.find(sub_sec);
-            HPX_ASSERT(cit != sections_.end());
-            hpx::util::unlock_guard<std::unique_lock<mutex_type>> ul(l);
-            return (*cit).second.get_entry(sub_key);
-        }
-
-        HPX_THROW_EXCEPTION(bad_parameter, "section::get_entry",
-            "No such key (" + key + ") in section: " + get_name());
-        return "";
-    }
-
-    if (entries_.find(key) != entries_.end())
-    {
-        entry_map::const_iterator cit = entries_.find(key);
-        HPX_ASSERT(cit != entries_.end());
-        return expand(l, (*cit).second.first);
-    }
-
-    HPX_THROW_EXCEPTION(bad_parameter, "section::get_entry",
-        "No such section (" + key + ") in section: " + get_name());
-    return "";
-}
-
-std::string section::get_entry (std::unique_lock<mutex_type>& l,
-    std::string const& key, std::string const& default_val) const
-{
-    typedef std::vector<std::string> string_vector;
-
-    string_vector split_key;
-    boost::split(split_key, key, boost::is_any_of("."));
-
-    std::string sk = split_key.back();
-    split_key.pop_back();
-
-    section const* cur_section = this;
-    for (string_vector::const_iterator iter = split_key.begin(),
-         end = split_key.end(); iter != end; ++iter)
-    {
-        section_map::const_iterator next = cur_section->sections_.find(*iter);
-        if (cur_section->sections_.end() == next)
-            return expand(l, default_val);
-        cur_section = &next->second;
-    }
-
-    entry_map::const_iterator entry = cur_section->entries_.find(sk);
-    if (cur_section->entries_.end() == entry)
-        return expand(l, default_val);
-
-    return expand(l, entry->second.first);
-}
-
-inline void indent (int ind, std::ostream& strm)
-{
-    for (int i = 0; i < ind; ++i)
-        strm << "  ";
-}
-
-void section::dump(int ind, std::ostream& strm) const
-{
-    std::unique_lock<mutex_type> l(mtx_);
-
-    bool header = false;
-    if (0 == ind)
-        header = true;
-
-    ++ind;
-    if (header)
-    {
-        if(get_root() == this) {
-            strm << "============================\n";
-        }
-        else {
-            strm << "============================[\n"
-                 << get_name() << "\n" << "]\n";
-        }
-    }
-
-    entry_map::const_iterator eend = entries_.end();
-    for (entry_map::const_iterator i = entries_.begin(); i != eend; ++i)
-    {
-        indent (ind, strm);
-
-        const std::string expansion = expand(l, i->second.first);
-
-        // Check if the expanded entry is different from the actual entry.
-        if (expansion != i->second.first)
-            // If the expansion is different from the real entry, then print
-            // it out.
-            strm << "'" << i->first << "' : '" << i->second.first << "' -> '"
-                 << expansion << "'\n";
-        else
-            strm << "'" << i->first << "' : '" << i->second.first << "'\n";
-    }
-
-    section_map::const_iterator send = sections_.end();
-    for (section_map::const_iterator i  = sections_.begin(); i != send; ++i)
-    {
-        indent (ind, strm);
-        strm << "[" << i->first << "]\n";
-        (*i).second.dump (ind, strm);
-    }
-
-    if (header)
-        strm << "============================\n";
-
-    strm << std::flush;
-}
-
-void section::merge(std::string const& filename)
-{
-    section tmp(filename, root_);
-    merge(tmp);
-}
-
-void section::merge(section& second)
-{
-    std::unique_lock<mutex_type> l(mtx_);
-
-    // merge entries: keep own entries, and add other entries
-    entry_map const& s_entries = second.get_entries();
-    entry_map::const_iterator end = s_entries.end();
-    for (entry_map::const_iterator i = s_entries.begin(); i != end; ++i)
-        entries_[i->first] = i->second;
-
-    // merge subsection known in first section
-    section_map::iterator send = sections_.end();
-    for (section_map::iterator i = sections_.begin(); i != send; ++i)
-    {
-        // is there something to merge with?
-        if (second.has_section(l, i->first))
-            i->second.merge (second.sections_[i->first]);
-    }
-
-    // merge subsection known in second section
-    section_map s = second.get_sections();
-    section_map::iterator secend = s.end();
-    for (section_map::iterator i = s.begin (); i != secend; ++i)
-    {
-        // if THIS knows the section, we already merged it above
-        if (!has_section(l, i->first))
-        {
-            // it is not known here, so we can't merge, but have to add it.
-            add_section (l, i->first, i->second, get_root());
-        }
-    }
-}
-
-/////////////////////////////////////////////////////////////////////////////////
-void section::line_msg(std::string msg, std::string const& file,
-    int lnum, std::string const& line)
-{
-    msg += " " + file;
-    if (lnum > 0)
-        msg += ": line " + std::to_string(lnum);
-    if (!line.empty())
-        msg += " (offending entry: " + line + ")";
-
-    HPX_THROW_EXCEPTION(no_success, "section::line_msg", msg);
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// find the matching closing brace starting from 'begin', escaped braces will
-// be un-escaped
-inline std::string::size_type
-find_next(char const* ch, std::string& value,
-    std::string::size_type begin = static_cast<std::string::size_type>(-1))
-{
-    std::string::size_type end = value.find_first_of(ch, begin+1);
-    while (end != std::string::npos) {
-        if (end != 0 && value[end-1] != '\\')
-            break;
-        value.replace(end-1, 2, ch);
-        end = value.find_first_of(ch, end);
-    }
-    return end;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-void section::expand(std::unique_lock<mutex_type>& l, std::string& value,
-    std::string::size_type begin) const
-{
-    std::string::size_type p = value.find_first_of('$', begin+1);
-    while (p != std::string::npos && value.size()-1 != p)
-    {
-        if ('[' == value[p+1])
-            expand_bracket(l, value, p);
-        else if ('{' == value[p+1])
-            expand_brace(l, value, p);
-        p = value.find_first_of('$', p+1);
-    }
-}
-
-void section::expand_bracket(std::unique_lock<mutex_type>& l, std::string& value,
-    std::string::size_type begin) const
-{
-    // expand all keys embedded inside this key
-    expand(l, value, begin);
-
-    // now expand the key itself
-    std::string::size_type end = find_next("]", value, begin+1);
-    if (end != std::string::npos)
-    {
-        std::string to_expand = value.substr(begin+2, end-begin-2);
-        std::string::size_type colon = find_next(":", to_expand);
-        if (colon == std::string::npos) {
-            value.replace(begin, end-begin+1, root_->get_entry(l, to_expand,
-                std::string("")));
-        }
-        else {
-            value.replace(begin, end-begin+1,
-                root_->get_entry(l, to_expand.substr(0, colon),
-                to_expand.substr(colon+1)));
-        }
-    }
-}
-
-void section::expand_brace(std::unique_lock<mutex_type>& l, std::string& value,
-    std::string::size_type begin) const
-{
-    // expand all keys embedded inside this key
-    expand(l, value, begin);
-
-    // now expand the key itself
-    std::string::size_type end = find_next("}", value, begin+1);
-    if (end != std::string::npos)
-    {
-        std::string to_expand = value.substr(begin+2, end-begin-2);
-        std::string::size_type colon = find_next(":", to_expand);
-        if (colon == std::string::npos) {
-            char* env = getenv(to_expand.c_str());
-            value.replace(begin, end-begin+1, nullptr != env ? env : "");
-        }
-        else {
-            char* env = getenv(to_expand.substr(0, colon).c_str());
-            value.replace(begin, end-begin+1,
-                nullptr != env ? std::string(env) : to_expand.substr(colon+1));
-        }
-    }
-}
-
-std::string section::expand (std::unique_lock<mutex_type>& l, std::string value) const
-{
-    expand(l, value, std::string::size_type(-1));
-    return value;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-void section::expand_only(std::unique_lock<mutex_type>& l, std::string& value,
-    std::string::size_type begin, std::string const& expand_this) const
-{
-    std::string::size_type p = value.find_first_of('$', begin+1);
-    while (p != std::string::npos && value.size()-1 != p) {
-        if ('[' == value[p+1])
-            expand_bracket_only(l, value, p, expand_this);
-        else if ('{' == value[p+1])
-            expand_brace_only(l, value, p, expand_this);
-        p = value.find_first_of('$', p+1);
-    }
-}
-
-void section::expand_bracket_only(std::unique_lock<mutex_type>& l,
-    std::string& value, std::string::size_type begin,
-    std::string const& expand_this) const
-{
-    // expand all keys embedded inside this key
-    expand_only(l, value, begin, expand_this);
-
-    // now expand the key itself
-    std::string::size_type end = find_next("]", value, begin+1);
-    if (end != std::string::npos)
-    {
-        std::string to_expand = value.substr(begin+2, end-begin-2);
-        std::string::size_type colon = find_next(":", to_expand);
-        if (colon == std::string::npos) {
-            if (to_expand == expand_this) {
-                value.replace(begin, end-begin+1,
-                    root_->get_entry(l, to_expand, std::string("")));
-            }
-        }
-        else if (to_expand.substr(0, colon) == expand_this) {
-            value.replace(begin, end-begin+1,
-                root_->get_entry(l, to_expand.substr(0, colon),
-                to_expand.substr(colon+1)));
-        }
-    }
-}
-
-void section::expand_brace_only(std::unique_lock<mutex_type>& l,
-    std::string& value, std::string::size_type begin,
-    std::string const& expand_this) const
-{
-    // expand all keys embedded inside this key
-    expand_only(l, value, begin, expand_this);
-
-    // now expand the key itself
-    std::string::size_type end = find_next("}", value, begin+1);
-    if (end != std::string::npos)
-    {
-        std::string to_expand = value.substr(begin+2, end-begin-2);
-        std::string::size_type colon = find_next(":", to_expand);
-        if (colon == std::string::npos) {
-            char* env = getenv(to_expand.c_str());
-            value.replace(begin, end-begin+1, nullptr != env ? env : "");
-        }
-        else {
-            char* env = getenv(to_expand.substr(0, colon).c_str());
-            value.replace(begin, end-begin+1,
-                nullptr != env ? std::string(env) : to_expand.substr(colon+1));
-        }
-    }
-}
-
-std::string section::expand_only(std::unique_lock<mutex_type>& l,
-    std::string value, std::string const& expand_this) const
-{
-    expand_only(l, value, std::string::size_type(-1), expand_this);
-    return value;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// explicit instantiation for the correct archive types
-HPX_EXPORT void serialize(serialization::output_archive& ar,
-    section::entry_type const& data, unsigned int version)
-{
-    ar << data.first;
-    // do not handle callback function
-}
-
-HPX_EXPORT void serialize(serialization::input_archive& ar,
-    section::entry_type& data, unsigned int version)
-{
-    ar >> data.first;
-    // do not handle callback function
-}
-
-///////////////////////////////////////////////////////////////////////////////
-template <typename Archive>
-void section::save(Archive& ar, const unsigned int version) const
-{
-    ar << name_;
-    ar << parent_name_;
-    ar << entries_;
-    ar << sections_;
-}
-
-template <typename Archive>
-void section::load(Archive& ar, const unsigned int version)
-{
-    ar >> name_;
-    ar >> parent_name_;
-    ar >> entries_;
-    ar >> sections_;
-
-    set_root(this, true);     // make this the current root
-}
-
-// explicit instantiation for the correct archive types
-template HPX_EXPORT void
-section::save(serialization::output_archive&, const unsigned int version) const;
-
-template HPX_EXPORT void
-section::load(serialization::input_archive&, const unsigned int version);
-
-}}  // namespace hpx::util
-
diff --git a/src/util/init_logging.cpp b/src/util/init_logging.cpp
index e7c45aecbf..68d16e2a5f 100644
--- a/src/util/init_logging.cpp
+++ b/src/util/init_logging.cpp
@@ -10,26 +10,27 @@
 #if defined(HPX_HAVE_LOGGING)
 #include <hpx/logging.hpp>
 #include <hpx/logging/format/named_write.hpp>
-#include <hpx/logging/format/destination/defaults.hpp>
-#include <hpx/runtime/naming_fwd.hpp>
+#include <hpx/logging/manipulator.hpp>
+#include <hpx/naming_base.hpp>
+#include <hpx/runtime/components/console_logging.hpp>
 #include <hpx/runtime/get_locality_id.hpp>
 #include <hpx/runtime/naming/resolver_client.hpp>
-#include <hpx/runtime/components/console_logging.hpp>
-#include <hpx/runtime/threads/threadmanager.hpp>
+#include <hpx/runtime/naming_fwd.hpp>
 #include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/runtime/threads/threadmanager.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/type_support/static.hpp>
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/util/get_entry_as.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 #include <hpx/util/init_logging.hpp>
 
-#include <boost/version.hpp>
 #include <boost/config.hpp>
-#include <boost/lexical_cast.hpp>
+#include <boost/version.hpp>
 
 #include <cstddef>
 #include <cstdint>
 #include <cstdlib>
-#include <iomanip>
-#include <sstream>
+#include <ostream>
 #include <string>
 #include <vector>
 
@@ -43,216 +44,198 @@
 #endif
 
 ///////////////////////////////////////////////////////////////////////////////
-namespace hpx { namespace util
-{
+namespace hpx { namespace util {
     typedef logging::writer::named_write logger_writer_type;
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: shepherd
-    struct shepherd_thread_id
-      : hpx::util::logging::formatter::class_<shepherd_thread_id>
+    struct shepherd_thread_id : logging::formatter::manipulator
     {
-        shepherd_thread_id()
-        {}
+        shepherd_thread_id() {}
 
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
             error_code ec(lightweight);
             std::size_t thread_num = hpx::get_worker_thread_num(ec);
 
             if (std::size_t(-1) != thread_num)
             {
-                std::stringstream out;
-                out << std::hex << std::setw(sizeof(std::size_t)*2)
-                    << std::setfill('0')
-                    << thread_num;
-                str.prepend_string(out.str());
+                util::format_to(to, "{:016x}", thread_num);
             }
             else
             {
-                str.prepend_string(std::string(sizeof(std::size_t)*2, '-'));
+                to << std::string(16, '-');
             }
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: locality prefix
-    struct locality_prefix
-      : hpx::util::logging::formatter::class_<locality_prefix>
+    struct locality_prefix : logging::formatter::manipulator
     {
-        locality_prefix()
-        {}
+        locality_prefix() {}
 
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
             std::uint32_t locality_id = hpx::get_locality_id();
 
-            if (naming::invalid_locality_id != locality_id) {
-                std::stringstream out;
-                out << std::hex << std::setw(sizeof(std::uint32_t)*2)
-                    << std::setfill('0') << locality_id;
-                str.prepend_string(out.str());
+            if (naming::invalid_locality_id != locality_id)
+            {
+                util::format_to(to, "{:08x}", locality_id);
             }
-            else {
+            else
+            {
                 // called from outside a HPX thread
-                str.prepend_string(std::string(sizeof(std::uint32_t)*2, '-'));
+                to << std::string(8, '-');
             }
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: HPX thread id
-    struct thread_id
-      : hpx::util::logging::formatter::class_<thread_id>
+    struct thread_id : logging::formatter::manipulator
     {
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
             threads::thread_self* self = threads::get_self_ptr();
-            if (nullptr != self) {
+            if (nullptr != self)
+            {
                 // called from inside a HPX thread
                 threads::thread_id_type id = threads::get_self_id();
-                if (id != threads::invalid_thread_id) {
-                    std::stringstream out;
-                    out << std::hex << std::setw(sizeof(void*)*2)
-                        << std::setfill('0')
-                        << reinterpret_cast<std::ptrdiff_t>(id.get());
-                    str.prepend_string(out.str());
+                if (id != threads::invalid_thread_id)
+                {
+                    std::ptrdiff_t value =
+                        reinterpret_cast<std::ptrdiff_t>(id.get());
+                    util::format_to(to, "{:016x}", value);
                     return;
                 }
             }
 
             // called from outside a HPX thread or invalid thread id
-            str.prepend_string(std::string(sizeof(void*)*2, '-'));
+            to << std::string(16, '-');
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: HPX thread phase
-    struct thread_phase
-      : hpx::util::logging::formatter::class_<thread_phase>
+    struct thread_phase : logging::formatter::manipulator
     {
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
             threads::thread_self* self = threads::get_self_ptr();
-            if (nullptr != self) {
+            if (nullptr != self)
+            {
                 // called from inside a HPX thread
                 std::size_t phase = self->get_thread_phase();
-                if (0 != phase) {
-                    std::stringstream out;
-                    out << std::hex << std::setw(sizeof(std::uint32_t))
-                        << std::setfill('0') << self->get_thread_phase();
-                    str.prepend_string(out.str());
+                if (0 != phase)
+                {
+                    util::format_to(to, "{:04x}", self->get_thread_phase());
                     return;
                 }
             }
 
             // called from outside a HPX thread or no phase given
-            str.prepend_string(std::string(sizeof(std::uint32_t), '-'));
+            to << std::string(4, '-');
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: locality prefix of parent thread
-    struct parent_thread_locality
-      : hpx::util::logging::formatter::class_<parent_thread_locality>
+    struct parent_thread_locality : logging::formatter::manipulator
     {
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
-            std::uint32_t parent_locality_id = threads::get_parent_locality_id();
-            if (naming::invalid_locality_id != parent_locality_id) {
+            std::uint32_t parent_locality_id =
+                threads::get_parent_locality_id();
+            if (naming::invalid_locality_id != parent_locality_id)
+            {
                 // called from inside a HPX thread
-                std::stringstream out;
-                out << std::hex << std::setw(sizeof(std::uint32_t)*2)
-                    << std::setfill('0') << parent_locality_id;
-                str.prepend_string(out.str());
+                util::format_to(to, "{:08x}", parent_locality_id);
             }
-            else {
+            else
+            {
                 // called from outside a HPX thread
-                str.prepend_string(std::string(sizeof(std::uint32_t)*2, '-'));
+                to << std::string(8, '-');
             }
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: HPX parent thread id
-    struct parent_thread_id
-      : hpx::util::logging::formatter::class_<parent_thread_id>
+    struct parent_thread_id : logging::formatter::manipulator
     {
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
             threads::thread_id_type parent_id = threads::get_parent_id();
-            if (nullptr != parent_id && threads::invalid_thread_id != parent_id) {
+            if (nullptr != parent_id && threads::invalid_thread_id != parent_id)
+            {
                 // called from inside a HPX thread
-                std::stringstream out;
-                out << std::hex << std::setw(sizeof(void*)*2)
-                    << std::setfill('0')
-                    << reinterpret_cast<std::ptrdiff_t>(parent_id.get());
-                str.prepend_string(out.str());
+                std::ptrdiff_t value =
+                    reinterpret_cast<std::ptrdiff_t>(parent_id.get());
+                util::format_to(to, "{:016x}", value);
             }
-            else {
+            else
+            {
                 // called from outside a HPX thread
-                str.prepend_string(std::string(sizeof(void*)*2, '-'));
+                to << std::string(16, '-');
             }
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: HPX parent thread phase
-    struct parent_thread_phase
-      : hpx::util::logging::formatter::class_<parent_thread_phase>
+    struct parent_thread_phase : logging::formatter::manipulator
     {
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
             std::size_t parent_phase = threads::get_parent_phase();
-            if (0 != parent_phase) {
+            if (0 != parent_phase)
+            {
                 // called from inside a HPX thread
-                std::stringstream out;
-                out << std::hex << std::setw(sizeof(std::uint32_t))
-                    << std::setfill('0') << parent_phase;
-                str.prepend_string(out.str());
+                util::format_to(to, "{:04x}", parent_phase);
             }
-            else {
+            else
+            {
                 // called from outside a HPX thread
-                str.prepend_string(std::string(sizeof(std::uint32_t), '-'));
+                to << std::string(4, '-');
             }
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom formatter: HPX component id of current thread
-    struct thread_component_id
-      : hpx::util::logging::formatter::class_<thread_component_id>
+    struct thread_component_id : logging::formatter::manipulator
     {
-        void operator()(param str) const
+        void operator()(std::ostream& to) const override
         {
             std::uint64_t component_id = threads::get_self_component_id();
-            if (0 != component_id) {
+            if (0 != component_id)
+            {
                 // called from inside a HPX thread
-                std::stringstream out;
-                out << std::hex << std::setw(sizeof(std::uint64_t)*2)
-                    << std::setfill('0')
-                    << component_id;
-                str.prepend_string(out.str());
+                util::format_to(to, "{:016x}", component_id);
             }
-            else {
+            else
+            {
                 // called from outside a HPX thread
-                str.prepend_string(std::string(sizeof(std::uint64_t)*2, '-'));
+                to << std::string(16, '-');
             }
         }
     };
 
     ///////////////////////////////////////////////////////////////////////////
     // custom log destination: send generated strings to console
-    struct console : hpx::util::logging::destination::is_generic
+    struct console : logging::destination::manipulator
     {
-        console(std::size_t level, logging_destination dest)
-          : level_(level), dest_(dest)
-        {}
+        console(logging::level level, logging_destination dest)
+          : level_(level)
+          , dest_(dest)
+        {
+        }
 
-        template<typename MsgType>
-        void operator()(MsgType const& msg) const
+        void operator()(logging::message const& msg) override
         {
-            components::console_logging(dest_, level_, msg);
+            components::console_logging(
+                dest_, static_cast<std::size_t>(level_), msg.full_string());
         }
 
         bool operator==(console const& rhs) const
@@ -260,22 +243,23 @@ namespace hpx { namespace util
             return dest_ == rhs.dest_;
         }
 
-        std::size_t level_;
+        logging::level level_;
         logging_destination dest_;
     };
 
 #if defined(ANDROID) || defined(__ANDROID__)
     // default log destination for Android
-    struct android_log : hpx::util::logging::destination::is_generic
+    struct android_log : logging::destination::manipulator
     {
         android_log(char const* tag_)
           : tag(tag_)
-        {}
+        {
+        }
 
-        template<typename MsgType>
-        void operator()(MsgType const& msg) const
+        void operator()(logging::message const& msg) override
         {
-            __android_log_write(ANDROID_LOG_DEBUG, tag.c_str(), msg.c_str());
+            __android_log_write(
+                ANDROID_LOG_DEBUG, tag.c_str(), msg.full_string().c_str());
         }
 
         bool operator==(android_log const& rhs) const
@@ -287,88 +271,93 @@ namespace hpx { namespace util
     };
 #endif
 
-    namespace detail
-    {
+    namespace detail {
         // unescape config entry
-        std::string unescape(std::string const &value)
+        static std::string unescape(std::string const& value)
         {
             std::string result;
             std::string::size_type pos = 0;
-            std::string::size_type pos1 = value.find_first_of ('\\', 0);
-            if (std::string::npos != pos1) {
-                do {
-                    switch (value[pos1+1]) {
+            std::string::size_type pos1 = value.find_first_of('\\', 0);
+            if (std::string::npos != pos1)
+            {
+                do
+                {
+                    switch (value[pos1 + 1])
+                    {
                     case '\\':
                     case '\"':
                     case '?':
-                        result = result + value.substr(pos, pos1-pos);
-                        pos1 = value.find_first_of ('\\', (pos = pos1+1)+1);
+                        result = result + value.substr(pos, pos1 - pos);
+                        pos1 = value.find_first_of('\\', (pos = pos1 + 1) + 1);
                         break;
 
                     case 'n':
-                        result = result + value.substr(pos, pos1-pos) + "\n";
-                        pos1 = value.find_first_of ('\\', pos = pos1+1);
+                        result = result + value.substr(pos, pos1 - pos) + "\n";
+                        pos1 = value.find_first_of('\\', pos = pos1 + 1);
                         ++pos;
                         break;
 
                     default:
-                        result = result + value.substr(pos, pos1-pos+1);
-                        pos1 = value.find_first_of ('\\', pos = pos1+1);
+                        result = result + value.substr(pos, pos1 - pos + 1);
+                        pos1 = value.find_first_of('\\', pos = pos1 + 1);
                     }
 
                 } while (pos1 != std::string::npos);
                 result = result + value.substr(pos);
             }
-            else {
-            // the string doesn't contain any escaped character sequences
+            else
+            {
+                // the string doesn't contain any escaped character sequences
                 result = value;
             }
             return result;
         }
 
-        template <typename Writer>
-        void define_formatters(Writer& writer)
+        static void define_formatters(logger_writer_type& writer)
         {
-            writer.replace_formatter("osthread", shepherd_thread_id());
-            writer.replace_formatter("locality", locality_prefix());
-            writer.replace_formatter("hpxthread", thread_id());
-            writer.replace_formatter("hpxphase", thread_phase());
-            writer.replace_formatter("hpxparent", parent_thread_id());
-            writer.replace_formatter("hpxparentphase", parent_thread_phase());
-            writer.replace_formatter("parentloc", parent_thread_locality());
-            writer.replace_formatter("hpxcomponent", thread_component_id());
+            writer.set_formatter("osthread", shepherd_thread_id());
+            writer.set_formatter("locality", locality_prefix());
+            writer.set_formatter("hpxthread", thread_id());
+            writer.set_formatter("hpxphase", thread_phase());
+            writer.set_formatter("hpxparent", parent_thread_id());
+            writer.set_formatter("hpxparentphase", parent_thread_phase());
+            writer.set_formatter("parentloc", parent_thread_locality());
+            writer.set_formatter("hpxcomponent", thread_component_id());
         }
-    }
+    }    // namespace detail
 
     // initialize logging for AGAS
     void init_agas_log(util::section const& ini, bool isconsole)
     {
         std::string loglevel, logdest, logformat;
 
-        if (ini.has_section("hpx.logging.agas")) {
+        if (ini.has_section("hpx.logging.agas"))
+        {
             util::section const* logini = ini.get_section("hpx.logging.agas");
             HPX_ASSERT(nullptr != logini);
 
             std::string empty;
             loglevel = logini->get_entry("level", empty);
-            if (!loglevel.empty()) {
+            if (!loglevel.empty())
+            {
                 logdest = logini->get_entry("destination", empty);
-                logformat = detail::unescape(logini->get_entry("format", empty));
+                logformat =
+                    detail::unescape(logini->get_entry("format", empty));
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
-           logger_writer_type& writer = agas_logger()->writer();
+            logger_writer_type& writer = agas_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = isconsole ? "android_log" : "console";
-            agas_logger()->writer().add_destination("android_log",
+            agas_logger()->writer().set_destination("android_log",
                 android_log("hpx.agas"));
 #else
             if (logdest.empty())      // ensure minimal defaults
@@ -377,7 +366,7 @@ namespace hpx { namespace util
             if (logformat.empty())
                 logformat = "|\\n";
 
-            writer.add_destination("console", console(lvl, destination_agas)); //-V106
+            writer.set_destination("console", console(lvl, destination_agas)); //-V106
             writer.write(logformat, logdest);
             detail::define_formatters(writer);
 
@@ -403,18 +392,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
            logger_writer_type& writer = parcel_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = isconsole ? "android_log" : "console";
-            parcel_logger()->writer().add_destination("android_log",
+            parcel_logger()->writer().set_destination("android_log",
                 android_log("hpx.parcel"));
 #else
             if (logdest.empty())      // ensure minimal defaults
@@ -423,7 +412,7 @@ namespace hpx { namespace util
             if (logformat.empty())
                 logformat = "|\\n";
 
-            writer.add_destination("console",
+            writer.set_destination("console",
                 console(lvl, destination_parcel)); //-V106
             writer.write(logformat, logdest);
             detail::define_formatters(writer);
@@ -450,11 +439,11 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
            logger_writer_type& writer = timing_logger()->writer();
 
@@ -462,7 +451,7 @@ namespace hpx { namespace util
             if (logdest.empty())      // ensure minimal defaults
                 logdest = isconsole ? "android_log" : "console";
 
-            writer.add_destination("android_log",
+            writer.set_destination("android_log",
                 android_log("hpx.timing"));
 #else
             if (logdest.empty())      // ensure minimal defaults
@@ -471,7 +460,7 @@ namespace hpx { namespace util
             if (logformat.empty())
                 logformat = "|\\n";
 
-            writer.add_destination("console", console(lvl, destination_timing)); //-V106
+            writer.set_destination("console", console(lvl, destination_timing)); //-V106
             writer.write(logformat, logdest);
             detail::define_formatters(writer);
 
@@ -496,7 +485,7 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel, true);
 
@@ -507,8 +496,8 @@ namespace hpx { namespace util
         if (logdest.empty())      // ensure minimal defaults
             logdest = isconsole ? "android_log" : "console";
 
-        writer.add_destination("android_log", android_log("hpx"));
-        error_writer.add_destination("android_log", android_log("hpx"));
+        writer.set_destination("android_log", android_log("hpx"));
+        error_writer.set_destination("android_log", android_log("hpx"));
 #else
         if (logdest.empty())      // ensure minimal defaults
             logdest = isconsole ? "cerr" : "console";
@@ -516,9 +505,9 @@ namespace hpx { namespace util
         if (logformat.empty())
             logformat = "|\\n";
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
-            writer.add_destination("console", console(lvl, destination_hpx)); //-V106
+            writer.set_destination("console", console(lvl, destination_hpx)); //-V106
             writer.write(logformat, logdest);
             detail::define_formatters(writer);
 
@@ -526,7 +515,7 @@ namespace hpx { namespace util
             hpx_logger()->set_enabled(lvl);
 
             // errors are logged to the given destination and to cerr
-            error_writer.add_destination("console",
+            error_writer.set_destination("console",
                 console(lvl, destination_hpx)); //-V106
 #if !defined(ANDROID) && !defined(__ANDROID__)
             if (logdest != "cerr")
@@ -540,7 +529,7 @@ namespace hpx { namespace util
         else {
             // errors are always logged to cerr
             if (!isconsole) {
-                error_writer.add_destination("console",
+                error_writer.set_destination("console",
                     console(lvl, destination_hpx)); //-V106
                 error_writer.write(logformat, "console");
             }
@@ -575,18 +564,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = app_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = isconsole ? "android_log" : "console";
-            writer.add_destination("android_log", android_log("hpx.application"));
+            writer.set_destination("android_log", android_log("hpx.application"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = isconsole ? "cerr" : "console";
@@ -594,7 +583,7 @@ namespace hpx { namespace util
             if (logformat.empty())
                 logformat = "|\\n";
 
-            writer.add_destination("console", console(lvl, destination_app)); //-V106
+            writer.set_destination("console", console(lvl, destination_app)); //-V106
             writer.write(logformat, logdest);
             detail::define_formatters(writer);
 
@@ -620,18 +609,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = debuglog_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = isconsole ? "android_log" : "console";
-            writer.add_destination("android_log", android_log("hpx.debuglog"));
+            writer.set_destination("android_log", android_log("hpx.debuglog"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = isconsole ? "cerr" : "console";
@@ -639,7 +628,7 @@ namespace hpx { namespace util
             if (logformat.empty())
                 logformat = "|\\n";
 
-            writer.add_destination("console",
+            writer.set_destination("console",
                 console(lvl, destination_debuglog)); //-V106
             writer.write(logformat, logdest);
             detail::define_formatters(writer);
@@ -666,18 +655,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel, true);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = agas_console_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "android_log";
-            writer.add_destination("android_log", android_log("hpx.agas"));
+            writer.set_destination("android_log", android_log("hpx.agas"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "cerr";
@@ -710,18 +699,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel, true);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = parcel_console_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "android_log";
-            writer.add_destination("android_log", android_log("hpx.parcel"));
+            writer.set_destination("android_log", android_log("hpx.parcel"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "cerr";
@@ -753,18 +742,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel, true);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = timing_console_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "android_log";
-            writer.add_destination("android_log", android_log("hpx.timing"));
+            writer.set_destination("android_log", android_log("hpx.timing"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "cerr";
@@ -796,18 +785,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel, true);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = hpx_console_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "android_log";
-            writer.add_destination("android_log", android_log("hpx"));
+            writer.set_destination("android_log", android_log("hpx"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "cerr";
@@ -840,18 +829,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel, true);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = app_console_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "android_log";
-            writer.add_destination("android_log", android_log("hpx.application"));
+            writer.set_destination("android_log", android_log("hpx.application"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "cerr";
@@ -884,18 +873,18 @@ namespace hpx { namespace util
             }
         }
 
-        unsigned lvl = hpx::util::logging::level::disable_all;
+        auto lvl = hpx::util::logging::level::disable_all;
         if (!loglevel.empty())
             lvl = detail::get_log_level(loglevel, true);
 
-        if (unsigned(hpx::util::logging::level::disable_all) != lvl)
+        if (hpx::util::logging::level::disable_all != lvl)
         {
             logger_writer_type& writer = debuglog_console_logger()->writer();
 
 #if defined(ANDROID) || defined(__ANDROID__)
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "android_log";
-            writer.add_destination("android_log", android_log("hpx.debuglog"));
+            writer.set_destination("android_log", android_log("hpx.debuglog"));
 #else
             if (logdest.empty())      // ensure minimal defaults
                 logdest = "cerr";
@@ -914,162 +903,6 @@ namespace hpx { namespace util
 ///////////////////////////////////////////////////////////////////////////////
 namespace hpx { namespace util { namespace detail
 {
-    ///////////////////////////////////////////////////////////////////////////
-    // the logging_configuration type will be instantiated exactly once
-    struct logging_configuration
-    {
-        logging_configuration();
-        std::vector<std::string> prefill_;
-    };
-
-// define the format for the generated time stamps
-#define HPX_TIMEFORMAT "$hh:$mm.$ss.$mili"
-
-    logging_configuration::logging_configuration()
-    {
-        try {
-            // add default logging configuration as defaults to the ini data
-            // this will be overwritten by related entries in the read hpx.ini
-            prefill_ = {
-                // general logging
-                "[hpx.logging]",
-                "level = ${HPX_LOGLEVEL:0}",
-                "destination = ${HPX_LOGDESTINATION:console}",
-                "format = ${HPX_LOGFORMAT:"
-                    "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
-                    "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
-                    HPX_TIMEFORMAT ") [%idx%]|\\n}",
-
-                // general console logging
-                "[hpx.logging.console]",
-                "level = ${HPX_LOGLEVEL:$[hpx.logging.level]}",
-#if defined(ANDROID) || defined(__ANDROID__)
-                "destination = ${HPX_CONSOLE_LOGDESTINATION:android_log}",
-#else
-                "destination = ${HPX_CONSOLE_LOGDESTINATION:"
-                    "file(hpx.$[system.pid].log)}",
-#endif
-                "format = ${HPX_CONSOLE_LOGFORMAT:|}",
-
-                // logging related to timing
-                "[hpx.logging.timing]",
-                "level = ${HPX_TIMING_LOGLEVEL:-1}",
-                "destination = ${HPX_TIMING_LOGDESTINATION:console}",
-                "format = ${HPX_TIMING_LOGFORMAT:"
-                    "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
-                    "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
-                    HPX_TIMEFORMAT ") [%idx%] [TIM] |\\n}",
-
-                // console logging related to timing
-                "[hpx.logging.console.timing]",
-                "level = ${HPX_TIMING_LOGLEVEL:$[hpx.logging.timing.level]}",
-#if defined(ANDROID) || defined(__ANDROID__)
-                "destination = ${HPX_CONSOLE_TIMING_LOGDESTINATION:android_log}",
-#else
-                "destination = ${HPX_CONSOLE_TIMING_LOGDESTINATION:"
-                    "file(hpx.timing.$[system.pid].log)}",
-#endif
-                "format = ${HPX_CONSOLE_TIMING_LOGFORMAT:|}",
-
-                // logging related to AGAS
-                "[hpx.logging.agas]",
-                "level = ${HPX_AGAS_LOGLEVEL:-1}",
-//                     "destination = ${HPX_AGAS_LOGDESTINATION:console}",
-                "destination = ${HPX_AGAS_LOGDESTINATION:"
-                    "file(hpx.agas.$[system.pid].log)}",
-                "format = ${HPX_AGAS_LOGFORMAT:"
-                    "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
-                    "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
-                    HPX_TIMEFORMAT ") [%idx%][AGAS] |\\n}",
-
-                // console logging related to AGAS
-                "[hpx.logging.console.agas]",
-                "level = ${HPX_AGAS_LOGLEVEL:$[hpx.logging.agas.level]}",
-#if defined(ANDROID) || defined(__ANDROID__)
-                "destination = ${HPX_CONSOLE_AGAS_LOGDESTINATION:android_log}",
-#else
-                "destination = ${HPX_CONSOLE_AGAS_LOGDESTINATION:"
-                    "file(hpx.agas.$[system.pid].log)}",
-#endif
-                "format = ${HPX_CONSOLE_AGAS_LOGFORMAT:|}",
-
-                // logging related to the parcel transport
-                "[hpx.logging.parcel]",
-                "level = ${HPX_PARCEL_LOGLEVEL:-1}",
-                "destination = ${HPX_PARCEL_LOGDESTINATION:"
-                    "file(hpx.parcel.$[system.pid].log)}",
-                "format = ${HPX_PARCEL_LOGFORMAT:"
-                    "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
-                    "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
-                    HPX_TIMEFORMAT ") [%idx%][  PT] |\\n}",
-
-                // console logging related to the parcel transport
-                "[hpx.logging.console.parcel]",
-                "level = ${HPX_PARCEL_LOGLEVEL:$[hpx.logging.parcel.level]}",
-#if defined(ANDROID) || defined(__ANDROID__)
-                "destination = ${HPX_CONSOLE_PARCEL_LOGDESTINATION:android_log}",
-#else
-                "destination = ${HPX_CONSOLE_PARCEL_LOGDESTINATION:"
-                    "file(hpx.parcel.$[system.pid].log)}",
-#endif
-                "format = ${HPX_CONSOLE_PARCEL_LOGFORMAT:|}",
-
-                // logging related to applications
-                "[hpx.logging.application]",
-                "level = ${HPX_APP_LOGLEVEL:-1}",
-                "destination = ${HPX_APP_LOGDESTINATION:console}",
-                "format = ${HPX_APP_LOGFORMAT:"
-                    "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
-                    "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
-                    HPX_TIMEFORMAT ") [%idx%] [APP] |\\n}",
-
-                // console logging related to applications
-                "[hpx.logging.console.application]",
-                "level = ${HPX_APP_LOGLEVEL:$[hpx.logging.application.level]}",
-#if defined(ANDROID) || defined(__ANDROID__)
-                "destination = ${HPX_CONSOLE_APP_LOGDESTINATION:android_log}",
-#else
-                "destination = ${HPX_CONSOLE_APP_LOGDESTINATION:"
-                    "file(hpx.application.$[system.pid].log)}",
-#endif
-                "format = ${HPX_CONSOLE_APP_LOGFORMAT:|}",
-
-                // logging of debug channel
-                "[hpx.logging.debuglog]",
-                "level = ${HPX_DEB_LOGLEVEL:-1}",
-                "destination = ${HPX_DEB_LOGDESTINATION:console}",
-                "format = ${HPX_DEB_LOGFORMAT:"
-                    "(T%locality%/%hpxthread%.%hpxphase%/%hpxcomponent%) "
-                    "P%parentloc%/%hpxparent%.%hpxparentphase% %time%("
-                    HPX_TIMEFORMAT ") [%idx%] [DEB] |\\n}",
-
-                "[hpx.logging.console.debuglog]",
-                "level = ${HPX_DEB_LOGLEVEL:$[hpx.logging.debuglog.level]}",
-#if defined(ANDROID) || defined(__ANDROID__)
-                "destination = ${HPX_CONSOLE_DEB_LOGDESTINATION:android_log}",
-#else
-                "destination = ${HPX_CONSOLE_DEB_LOGDESTINATION:"
-                    "file(hpx.debuglog.$[system.pid].log)}",
-#endif
-                "format = ${HPX_CONSOLE_DEB_LOGFORMAT:|}"
-            };
-        }
-        catch (std::exception const&) {
-            // just in case something goes wrong
-            std::cerr << "caught std::exception during initialization"
-                      << std::endl;
-        }
-    }
-
-#undef HPX_TIMEFORMAT
-
-    struct init_logging_tag {};
-    std::vector<std::string> const& get_logging_data()
-    {
-        static_<logging_configuration, init_logging_tag> init;
-        return init.get().prefill_;
-    }
-
     ///////////////////////////////////////////////////////////////////////////
     void init_logging(runtime_configuration& ini, bool isconsole)
     {
@@ -1097,10 +930,10 @@ namespace hpx { namespace util { namespace detail
 
 #else  // HPX_HAVE_LOGGING
 
-#include <hpx/util/runtime_configuration.hpp>
+#include <hpx/runtime_configuration/runtime_configuration.hpp>
 #include <hpx/logging.hpp>
+#include <hpx/util/get_entry_as.hpp>
 #include <hpx/util/init_logging.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
 
 #include <iostream>
 #include <string>
@@ -1108,12 +941,6 @@ namespace hpx { namespace util { namespace detail
 
 namespace hpx { namespace util { namespace detail
 {
-    std::vector<std::string> const& get_logging_data()
-    {
-        static std::vector<std::string> dummy_data;
-        return dummy_data;
-    }
-
     void init_logging(runtime_configuration& ini, bool)
     {
         // warn if logging is requested
diff --git a/src/util/integer/int128.cpp b/src/util/integer/int128.cpp
index 4fdd900565..1dd5454e07 100644
--- a/src/util/integer/int128.cpp
+++ b/src/util/integer/int128.cpp
@@ -34,6 +34,7 @@ namespace hpx { namespace util { namespace integer
 
         while (!!ii && i) {
             ii = ii.div (radix, r);
+            // NOLINTNEXTLINE(bugprone-narrowing-conversions)
             sz[--i] = r.toInt() + ((r.toInt() > 9) ? 'A' - 10 : '0');
         };
 
diff --git a/src/util/integer/uint128.cpp b/src/util/integer/uint128.cpp
index 2ba08c247f..9320942be4 100644
--- a/src/util/integer/uint128.cpp
+++ b/src/util/integer/uint128.cpp
@@ -34,6 +34,7 @@ namespace hpx { namespace util { namespace integer
 
         while (!!ii && i) {
             ii = ii.div (radix, r);
+            // NOLINTNEXTLINE(bugprone-narrowing-conversions)
             sz[--i] = r.toUint() + ((r.toUint() > 9) ? 'A' - 10 : '0');
         };
 
diff --git a/src/util/interval_timer.cpp b/src/util/interval_timer.cpp
index 68712a5474..88e5298d98 100644
--- a/src/util/interval_timer.cpp
+++ b/src/util/interval_timer.cpp
@@ -9,7 +9,7 @@
 #include <hpx/errors.hpp>
 #include <hpx/runtime/applier/applier.hpp>
 #include <hpx/runtime/shutdown_function.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/functional/bind_front.hpp>
 #include <hpx/functional/deferred_call.hpp>
 #include <hpx/util/interval_timer.hpp>
@@ -27,7 +27,8 @@ namespace hpx { namespace util { namespace detail
     ///////////////////////////////////////////////////////////////////////////
     interval_timer::interval_timer()
       : microsecs_(0)
-      , id_(nullptr)
+      , id_()
+      , timerid_()
       , pre_shutdown_(false)
       , is_started_(false)
       , first_start_(true)
@@ -36,22 +37,35 @@ namespace hpx { namespace util { namespace detail
     {}
 
     interval_timer::interval_timer(util::function_nonser<bool()> const& f,
-            std::int64_t microsecs, std::string const& description,
-            bool pre_shutdown)
-      : f_(f), on_term_(),
-        microsecs_(microsecs), id_(nullptr), description_(description),
-        pre_shutdown_(pre_shutdown), is_started_(false), first_start_(true),
-        is_terminated_(false), is_stopped_(false)
+        std::int64_t microsecs, std::string const& description,
+        bool pre_shutdown)
+      : f_(f)
+      , on_term_()
+      , microsecs_(microsecs)
+      , id_()
+      , timerid_()
+      , description_(description)
+      , pre_shutdown_(pre_shutdown)
+      , is_started_(false)
+      , first_start_(true)
+      , is_terminated_(false)
+      , is_stopped_(false)
     {}
 
     interval_timer::interval_timer(util::function_nonser<bool()> const& f,
-            util::function_nonser<void()> const& on_term,
-            std::int64_t microsecs, std::string const& description,
-            bool pre_shutdown)
-      : f_(f), on_term_(on_term),
-        microsecs_(microsecs), id_(nullptr), description_(description),
-        pre_shutdown_(pre_shutdown), is_started_(false), first_start_(true),
-        is_terminated_(false), is_stopped_(false)
+        util::function_nonser<void()> const& on_term, std::int64_t microsecs,
+        std::string const& description, bool pre_shutdown)
+      : f_(f)
+      , on_term_(on_term)
+      , microsecs_(microsecs)
+      , id_()
+      , timerid_()
+      , description_(description)
+      , pre_shutdown_(pre_shutdown)
+      , is_started_(false)
+      , first_start_(true)
+      , is_terminated_(false)
+      , is_stopped_(false)
     {}
 
     bool interval_timer::start(bool evaluate_)
@@ -118,8 +132,14 @@ namespace hpx { namespace util { namespace detail
         return true;
     }
 
-    bool interval_timer::stop()
+    bool interval_timer::stop(bool terminate_timer)
     {
+        if (terminate_timer)
+        {
+            terminate();
+            return true;
+        }
+
         std::lock_guard<mutex_type> l(mtx_);
         is_stopped_ = true;
         return stop_locked();
@@ -127,10 +147,20 @@ namespace hpx { namespace util { namespace detail
 
     bool interval_timer::stop_locked()
     {
-        if (is_started_) {
+        if (is_started_)
+        {
             is_started_ = false;
 
-            if (id_) {
+            if (timerid_)
+            {
+                error_code ec(lightweight);    // avoid throwing on error
+                threads::set_thread_state(timerid_, threads::pending,
+                    threads::wait_abort, threads::thread_priority_boost, true,
+                    ec);
+                timerid_.reset();
+            }
+            if (id_)
+            {
                 error_code ec(lightweight);    // avoid throwing on error
                 threads::set_thread_state(id_, threads::pending,
                     threads::wait_abort, threads::thread_priority_boost, true,
@@ -141,13 +171,15 @@ namespace hpx { namespace util { namespace detail
         }
 
         HPX_ASSERT(id_ == nullptr);
+        HPX_ASSERT(timerid_ == nullptr);
         return false;
     }
 
     void interval_timer::terminate()
     {
         std::unique_lock<mutex_type> l(mtx_);
-        if (!is_terminated_) {
+        if (!is_terminated_)
+        {
             is_terminated_ = true;
             stop_locked();
 
@@ -204,6 +236,7 @@ namespace hpx { namespace util { namespace detail
             }
 
             id_.reset();
+            timerid_.reset();
             is_started_ = false;
 
             bool result = false;
@@ -214,7 +247,8 @@ namespace hpx { namespace util { namespace detail
             }
 
             // some other thread might already have started the timer
-            if (nullptr == id_ && result) {
+            if (nullptr == id_ && result)
+            {
                 HPX_ASSERT(!is_started_);
                 schedule_thread(l);        // wait and repeat
             }
@@ -266,9 +300,9 @@ namespace hpx { namespace util { namespace detail
         }
 
         // schedule this thread to be run after the given amount of seconds
-        threads::set_thread_state(id, std::chrono::microseconds(microsecs_),
-            threads::pending, threads::wait_signaled,
-            threads::thread_priority_boost, true, ec);
+        threads::thread_id_type timerid = threads::set_thread_state(id,
+            std::chrono::microseconds(microsecs_), threads::pending,
+            threads::wait_signaled, threads::thread_priority_boost, true, ec);
 
         if (ec) {
             is_terminated_ = true;
@@ -282,6 +316,7 @@ namespace hpx { namespace util { namespace detail
         }
 
         id_ = id;
+        timerid_ = timerid;
         is_started_ = true;
     }
 }}}
diff --git a/src/util/one_size_heap_list.cpp b/src/util/one_size_heap_list.cpp
index a9a6b8cba0..b60ddbd014 100644
--- a/src/util/one_size_heap_list.cpp
+++ b/src/util/one_size_heap_list.cpp
@@ -15,9 +15,9 @@
 #if defined(HPX_DEBUG)
 #include <hpx/logging.hpp>
 #endif
-#include <hpx/runtime/threads/register_thread.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
+#include <hpx/threading_base/register_thread.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
+#include <hpx/runtime/threads/thread_data.hpp>
 #include <hpx/util/wrapper_heap_base.hpp>
 
 #include <cstddef>
diff --git a/src/util/pool_timer.cpp b/src/util/pool_timer.cpp
index 319b513933..21ddfd8d20 100644
--- a/src/util/pool_timer.cpp
+++ b/src/util/pool_timer.cpp
@@ -16,7 +16,7 @@
 #include <hpx/thread_support/unlock_guard.hpp>
 #include <hpx/timing/steady_clock.hpp>
 #include <hpx/functional/deferred_call.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 #include <hpx/util/pool_timer.hpp>
 
 #include <boost/asio/basic_waitable_timer.hpp>
diff --git a/src/util/query_counters.cpp b/src/util/query_counters.cpp
index a86b94cc12..3db53bb2a3 100644
--- a/src/util/query_counters.cpp
+++ b/src/util/query_counters.cpp
@@ -16,10 +16,10 @@
 #include <hpx/runtime/config_entry.hpp>
 #include <hpx/runtime/get_thread_name.hpp>
 #include <hpx/runtime/launch_policy.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/thread_support/unlock_guard.hpp>
 #include <hpx/timing/high_resolution_clock.hpp>
-#include <hpx/util/external_timer.hpp>
+#include <hpx/threading_base/external_timer.hpp>
 #include <hpx/util/query_counters.hpp>
 
 #include <cstddef>
@@ -105,9 +105,9 @@ namespace hpx { namespace util
         timer_.start();
     }
 
-    void query_counters::stop_evaluating_counters()
+    void query_counters::stop_evaluating_counters(bool terminate)
     {
-        timer_.stop();
+        timer_.stop(terminate);
         counters_.stop(launch::sync);
     }
 
@@ -319,7 +319,7 @@ namespace hpx { namespace util
 
     template <typename Stream, typename Value>
     void query_counters::print_values(Stream* output,
-        std::vector<Value> && values, std::vector<std::size_t> && indicies,
+        std::vector<Value> && values, std::vector<std::size_t> && indices,
         std::vector<performance_counters::counter_info> const& infos)
     {
         if (format_ == "csv" || format_ == "csv-short")
@@ -338,7 +338,7 @@ namespace hpx { namespace util
         else
         {
             std::size_t idx = 0;
-            for (std::size_t i : indicies)
+            for (std::size_t i : indices)
             {
                 print_value(output, infos[i].fullname_, values[idx],
                     infos[i].unit_of_measure_);
@@ -430,8 +430,8 @@ namespace hpx { namespace util
         error_code& ec)
     {
         // Query the performance counters.
-        std::vector<std::size_t> indicies;
-        indicies.reserve(infos.size());
+        std::vector<std::size_t> indices;
+        indices.reserve(infos.size());
 
         for (std::size_t i = 0; i != infos.size(); ++i)
         {
@@ -441,10 +441,10 @@ namespace hpx { namespace util
                 continue;
             }
 
-            indicies.push_back(i);
+            indices.push_back(i);
         }
 
-        if (indicies.empty())
+        if (indices.empty())
             return false;
 
         std::ostringstream output;
@@ -454,13 +454,13 @@ namespace hpx { namespace util
         std::vector<performance_counters::counter_value> values =
              counters_.get_counter_values(launch::sync, reset, ec);
 
-        HPX_ASSERT(values.size() == indicies.size());
+        HPX_ASSERT(values.size() == indices.size());
 
         // Output the performance counter value.
         if (!no_output)
             print_headers(output, infos);
         print_values(no_output ? nullptr : &output, std::move(values),
-            std::move(indicies), infos);
+            std::move(indices), infos);
 
         if (!no_output)
         {
@@ -484,8 +484,8 @@ namespace hpx { namespace util
         error_code& ec)
     {
         // Query the performance counters.
-        std::vector<std::size_t> indicies;
-        indicies.reserve(infos.size());
+        std::vector<std::size_t> indices;
+        indices.reserve(infos.size());
 
         for (std::size_t i = 0; i != infos.size(); ++i)
         {
@@ -495,10 +495,10 @@ namespace hpx { namespace util
                 continue;
             }
 
-            indicies.push_back(i);
+            indices.push_back(i);
         }
 
-        if (indicies.empty())
+        if (indices.empty())
             return false;
 
         std::ostringstream output;
@@ -508,13 +508,13 @@ namespace hpx { namespace util
         std::vector<performance_counters::counter_values_array> values =
              counters_.get_counter_values_array(launch::sync, reset, ec);
 
-        HPX_ASSERT(values.size() == indicies.size());
+        HPX_ASSERT(values.size() == indices.size());
 
         // Output the performance counter value.
         if (!no_output)
             print_headers(output, infos);
         print_values(no_output ? nullptr : &output, std::move(values),
-            std::move(indicies), infos);
+            std::move(indices), infos);
 
         if (!no_output)
         {
diff --git a/src/util/regex_from_pattern.cpp b/src/util/regex_from_pattern.cpp
index eb02b838a6..08496a2a6e 100644
--- a/src/util/regex_from_pattern.cpp
+++ b/src/util/regex_from_pattern.cpp
@@ -88,6 +88,7 @@ namespace hpx { namespace util
                 break;
 
             // escape regex special characters
+            // NOLINTNEXTLINE(bugprone-branch-clone)
             case '+':
                 HPX_FALLTHROUGH;
             case '.':
diff --git a/src/util/register_locks_globally.cpp b/src/util/register_locks_globally.cpp
index d29a574a82..a9bd76685e 100644
--- a/src/util/register_locks_globally.cpp
+++ b/src/util/register_locks_globally.cpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2014 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -6,7 +6,7 @@
 
 #include <hpx/errors.hpp>
 #include <hpx/logging.hpp>
-#include <hpx/runtime/threads/thread_data_fwd.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/synchronization/spinlock.hpp>
 #include <hpx/type_support/static.hpp>
 #include <hpx/util/register_locks_globally.hpp>
@@ -79,6 +79,11 @@ namespace hpx { namespace util
         detail::register_locks_globally::lock_detection_enabled_ = true;
     }
 
+    void disable_global_lock_detection()
+    {
+        detail::register_locks_globally::lock_detection_enabled_ = false;
+    }
+
     ///////////////////////////////////////////////////////////////////////////
     bool register_lock_globally(void const* lock)
     {
diff --git a/src/util/sed_transform.cpp b/src/util/sed_transform.cpp
deleted file mode 100644
index 14570eedd4..0000000000
--- a/src/util/sed_transform.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-////////////////////////////////////////////////////////////////////////////////
-//  Copyright (c) 2011 Bryce Adelstein-Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-////////////////////////////////////////////////////////////////////////////////
-
-#include <hpx/errors.hpp>
-#include <hpx/util/sed_transform.hpp>
-
-#include <memory>
-#include <regex>
-#include <string>
-
-namespace hpx { namespace util
-{
-
-bool parse_sed_expression(
-    std::string const& input
-  , std::string& search
-  , std::string& replace
-    )
-{
-    if (input.size() <= 2)
-        return false;
-
-    // s/search/replace/
-    // ^^
-    if ('s' != input.at(0) || '/' != input.at(1))
-        return false;
-
-    std::string::size_type const search_begin = 2;
-    std::string::size_type search_end = search_begin;
-
-    // s/search/replace/
-    //   ^^^^^^
-    while (true)
-    {
-        // See if we're at the end of the string.
-        if ((input.size() - 1) < search_end)
-            return false;
-
-        // If this is an escape, then don't check the next character.
-        if ('\\' == input.at(search_end++))
-        {
-            // See if we're at the end of the string.
-            if ((input.size() - 1) < ++search_end)
-                return false;
-        }
-
-        if ('/' == input.at(search_end))
-        {
-            --search_end;
-            break;
-        }
-    }
-
-    // s/search/replace/
-    //         ^
-    if ('/' != input.at(search_end + 1))
-        return false;
-
-    std::string::size_type const replace_begin = search_end + 2;
-    std::string::size_type replace_end = input.size() - 1;
-
-    // s/search/replace/
-    //                 ^ (optional)
-    if ('/' == input.at(replace_end))
-        --replace_end;
-
-    search = input.substr(search_begin, (search_end - search_begin) + 1);
-    replace = input.substr(replace_begin, (replace_end - replace_begin) + 1);
-
-    return true;
-}
-
-struct sed_transform::command
-{
-    command(
-        std::string const& search
-      , std::string const& replace
-        )
-      : search_(search)
-      , replace_(replace)
-    {}
-
-    std::regex search_;
-    std::string replace_;
-};
-
-sed_transform::sed_transform(
-    std::string const& search
-  , std::string const& replace
-    )
-  : command_(std::make_shared<command>(search, replace))
-{}
-
-sed_transform::sed_transform(
-    std::string const& expression
-    )
-{
-    std::string search, replace;
-
-    if (parse_sed_expression(expression, search, replace))
-        command_ = std::make_shared<command>(search, replace);
-}
-
-std::string sed_transform::operator()(
-    std::string const& input
-    ) const
-{
-    if (!command_)
-        return input;
-
-    return std::regex_replace(input
-                              , command_->search_
-                              , command_->replace_
-                              , std::regex_constants::match_default
-                              | std::regex_constants::format_sed);
-}
-
-}}
-
-
diff --git a/src/util/serialize_exception.cpp b/src/util/serialize_exception.cpp
index 6603618309..feff1e5049 100644
--- a/src/util/serialize_exception.cpp
+++ b/src/util/serialize_exception.cpp
@@ -1,4 +1,4 @@
-//  Copyright (c) 2007-2017 Hartmut Kaiser
+//  Copyright (c) 2007-2020 Hartmut Kaiser
 //
 //  SPDX-License-Identifier: BSL-1.0
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -10,9 +10,10 @@
 #include <hpx/serialization/serialize.hpp>
 #include <hpx/util/serialize_exception.hpp>
 
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
 #include <boost/exception/diagnostic_information.hpp>
 #include <boost/exception/exception.hpp>
-#include <boost/version.hpp>
+#endif
 
 #include <cstddef>
 #include <cstdint>
@@ -43,7 +44,7 @@ namespace hpx { namespace serialization
         std::string throw_function_;
         std::string throw_file_;
         std::string throw_back_trace_;
-        int throw_line_ = 0;
+        long throw_line_ = 0;
         std::string throw_env_;
         std::string throw_config_;
         std::string throw_state_;
@@ -181,10 +182,12 @@ namespace hpx { namespace serialization
             type = hpx::util::std_exception;
             what = e.what();
         }
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
         catch (boost::exception const& e) {
             type = hpx::util::boost_exception;
             what = boost::diagnostic_information(e);
         }
+#endif
         catch (...) {
             type = hpx::util::unknown_exception;
             what = "unknown exception";
@@ -240,120 +243,128 @@ namespace hpx { namespace serialization
             ar & err_value & err_message;
         }
 
-        switch (type) {
+        switch (type)
+        {
         default:
         case hpx::util::std_exception:
         case hpx::util::unknown_exception:
             e = hpx::detail::construct_exception(
-                    hpx::detail::std_exception(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+                hpx::detail::std_exception(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         // standard exceptions
         case hpx::util::std_runtime_error:
-            e = hpx::detail::construct_exception(
-                    std::runtime_error(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+            e = hpx::detail::construct_exception(std::runtime_error(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         case hpx::util::std_invalid_argument:
-            e = hpx::detail::construct_exception(
-                    std::invalid_argument(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+            e = hpx::detail::construct_exception(std::invalid_argument(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         case hpx::util::std_out_of_range:
-            e = hpx::detail::construct_exception(
-                    std::out_of_range(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+            e = hpx::detail::construct_exception(std::out_of_range(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         case hpx::util::std_logic_error:
-            e = hpx::detail::construct_exception(
-                    std::logic_error(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+            e = hpx::detail::construct_exception(std::logic_error(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         case hpx::util::std_bad_alloc:
-            e = hpx::detail::construct_exception(
-                    hpx::detail::bad_alloc(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+            e = hpx::detail::construct_exception(hpx::detail::bad_alloc(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         case hpx::util::std_bad_cast:
-            e = hpx::detail::construct_exception(
-                    hpx::detail::bad_cast(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+            e = hpx::detail::construct_exception(hpx::detail::bad_cast(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         case hpx::util::std_bad_typeid:
             e = hpx::detail::construct_exception(hpx::detail::bad_typeid(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
         case hpx::util::std_bad_exception:
             e = hpx::detail::construct_exception(
-                    hpx::detail::bad_exception(what),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+                hpx::detail::bad_exception(what),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
+#if BOOST_ASIO_HAS_BOOST_THROW_EXCEPTION != 0
         // boost exceptions
         case hpx::util::boost_exception:
             HPX_ASSERT(false);    // shouldn't happen
             break;
+#endif
 
         // boost::system::system_error
         case hpx::util::boost_system_error:
             e = hpx::detail::construct_exception(
-                    boost::system::system_error(err_value,
+                boost::system::system_error(err_value,
 #if BOOST_VERSION < 106600 && !defined(BOOST_SYSTEM_NO_DEPRECATED)
-                        boost::system::get_system_category()
+                    boost::system::get_system_category()
 #else
-                        boost::system::system_category()
+                    boost::system::system_category()
 #endif
-                      , err_message
-                    )
-                  , throw_function_, throw_file_, throw_line_, throw_back_trace_,
+                        ,
+                    err_message),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         // hpx::exception
         case hpx::util::hpx_exception:
             e = hpx::detail::construct_exception(
-                    hpx::exception(static_cast<hpx::error>(err_value),
-                        what, hpx::rethrow),
-                    throw_function_, throw_file_, throw_line_, throw_back_trace_,
+                hpx::exception(
+                    static_cast<hpx::error>(err_value), what, hpx::rethrow),
+                hpx::detail::construct_exception_info(throw_function_,
+                    throw_file_, throw_line_, throw_back_trace_,
                     throw_locality_, throw_hostname_, throw_pid_,
                     throw_shepherd_, throw_thread_id_, throw_thread_name_,
-                    throw_env_, throw_config_, throw_state_, throw_auxinfo_);
+                    throw_env_, throw_config_, throw_state_, throw_auxinfo_));
             break;
 
         // hpx::thread_interrupted
diff --git a/src/util/thread_aware_timer.cpp b/src/util/thread_aware_timer.cpp
index 27f9a8c07e..4fe4c185a3 100644
--- a/src/util/thread_aware_timer.cpp
+++ b/src/util/thread_aware_timer.cpp
@@ -7,7 +7,7 @@
 #include <hpx/config.hpp>
 #include <hpx/runtime_fwd.hpp>
 #include <hpx/functional/bind_front.hpp>
-#include <hpx/util/io_service_pool.hpp>
+#include <hpx/io_service/io_service_pool.hpp>
 #include <hpx/util/thread_aware_timer.hpp>
 
 #include <cstdint>
diff --git a/src/util/thread_description.cpp b/src/util/thread_description.cpp
deleted file mode 100644
index f23d33df21..0000000000
--- a/src/util/thread_description.cpp
+++ /dev/null
@@ -1,81 +0,0 @@
-//  Copyright (c) 2016-2017 Hartmut Kaiser
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-#include <hpx/assertion.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
-#include <hpx/util/safe_lexical_cast.hpp>
-#include <hpx/util/thread_description.hpp>
-
-#include <iostream>
-#include <sstream>
-#include <string>
-
-namespace hpx { namespace util
-{
-    std::ostream& operator<<(std::ostream& os, thread_description const& d)
-    {
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-        if (d.kind() == thread_description::data_type_description)
-        {
-            os << d.get_description();
-        }
-        else
-        {
-            HPX_ASSERT(d.kind() == thread_description::data_type_address);
-            os << d.get_address(); //-V128
-        }
-#else
-        os << "<unknown>";
-#endif
-        return os;
-    }
-
-    std::string as_string(thread_description const& desc)
-    {
-#if defined(HPX_HAVE_THREAD_DESCRIPTION)
-        if (desc.kind() == util::thread_description::data_type_description)
-            return desc ? desc.get_description() : "<unknown>";
-
-        std::stringstream strm;
-        strm << "address: 0x" << std::hex
-             << util::safe_lexical_cast<std::string>(desc.get_address());
-        return strm.str();
-#else
-        return "<unknown>";
-#endif
-    }
-
-    /* The priority of description is altname, id::name, id::address */
-    void thread_description::init_from_alternative_name(char const* altname)
-    {
-#if defined(HPX_HAVE_THREAD_DESCRIPTION) && !defined(HPX_HAVE_THREAD_DESCRIPTION_FULL)
-        if (altname != nullptr) {
-            type_ = data_type_description;
-            data_.desc_ = altname;
-            return;
-        }
-        hpx::threads::thread_id_type id = hpx::threads::get_self_id();
-        if (id)
-        {
-            // get the current task description
-            thread_description desc = hpx::threads::get_thread_description(id);
-            type_ = desc.kind();
-            // if the current task has a description, use it.
-            if (type_ == data_type_description)
-            {
-                data_.desc_ = desc.get_description();
-            }
-            else
-            {
-                // otherwise, use the address of the task.
-                HPX_ASSERT(type_ == data_type_address);
-                data_.addr_ = desc.get_address();
-            }
-        }
-#endif
-    }
-}}
diff --git a/tests/headers/CMakeLists.txt b/tests/headers/CMakeLists.txt
index 375c5d8d8c..37383fdb29 100644
--- a/tests/headers/CMakeLists.txt
+++ b/tests/headers/CMakeLists.txt
@@ -5,7 +5,7 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 # collect a list of all header files in the source tree
-file(GLOB_RECURSE headers ${DO_CONFIGURE_DEPENDS} "${PROJECT_SOURCE_DIR}/hpx/*hpp")
+file(GLOB_RECURSE headers CONFIGURE_DEPENDS "${PROJECT_SOURCE_DIR}/hpx/*hpp")
 
 # These files can't be included at the same time.
 set(exclude_from_all_headers)
@@ -13,9 +13,11 @@ set(exclude_from_all_headers)
 # These files are either known to expose incomplete types or are known to
 # require special handling to avoid circular #include dependencies.
 set(exclude_from_headers
+  "${PROJECT_SOURCE_DIR}/hpx/include/compression.hpp"
+  "${PROJECT_SOURCE_DIR}/hpx/include/compression_registration.hpp"
+  "${PROJECT_SOURCE_DIR}/hpx/lcos/local/futures_factory.hpp"
   "${PROJECT_SOURCE_DIR}/hpx/parallel/executors/timed_execution_fwd.hpp"
   "${PROJECT_SOURCE_DIR}/hpx/parallel/executors/parallel_executor.hpp"
-  "${PROJECT_SOURCE_DIR}/hpx/lcos/local/futures_factory.hpp"
   "${PROJECT_SOURCE_DIR}/hpx/runtime/threads/thread_data_stackful.hpp"
   "${PROJECT_SOURCE_DIR}/hpx/runtime/threads/thread_data_stackless.hpp"
 )
diff --git a/tests/performance/local/agas_cache_timings.cpp b/tests/performance/local/agas_cache_timings.cpp
index 86a5126530..d7bcee7d4a 100644
--- a/tests/performance/local/agas_cache_timings.cpp
+++ b/tests/performance/local/agas_cache_timings.cpp
@@ -64,7 +64,7 @@ public:
     std::uint64_t get_count() const
     {
         hpx::naming::gid_type const size = key_.second - key_.first;
-        HPX_TEST(size.get_msb() == 0);
+        HPX_TEST_EQ(size.get_msb(), std::uint64_t(0));
         return size.get_lsb();
     }
 
diff --git a/tests/performance/local/async_overheads.cpp b/tests/performance/local/async_overheads.cpp
index 3a5a6698af..6709c58506 100644
--- a/tests/performance/local/async_overheads.cpp
+++ b/tests/performance/local/async_overheads.cpp
@@ -84,11 +84,11 @@ int hpx_main(hpx::program_options::variables_map& vm)
 
         std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-        seqential_time_per_task = (end - start) / 1e9 / num_tasks;
+        seqential_time_per_task =
+            static_cast<double>(end - start) / 1e9 / num_tasks;
         std::cout << "Elapsed sequential time: "
-                  << (end - start) / 1e9 << " [s], ("
-                  << seqential_time_per_task << " [s])"
-                  << std::endl;
+                  << static_cast<double>(end - start) / 1e9 << " [s], ("
+                  << seqential_time_per_task << " [s])" << std::endl;
         hpx::util::print_cdash_timing("AsyncSequential", seqential_time_per_task);
     }
 
@@ -102,11 +102,11 @@ int hpx_main(hpx::program_options::variables_map& vm)
 
         std::uint64_t end = hpx::util::high_resolution_clock::now();
 
-        hierarchical_time_per_task = (end - start) / 1e9 / num_tasks;
+        hierarchical_time_per_task =
+            static_cast<double>(end - start) / 1e9 / num_tasks;
         std::cout << "Elapsed hierarchical time: "
-                  << (end - start) / 1e9 << " [s], ("
-                  << hierarchical_time_per_task << " [s])"
-                  << std::endl;
+                  << static_cast<double>(end - start) / 1e9 << " [s], ("
+                  << hierarchical_time_per_task << " [s])" << std::endl;
         hpx::util::print_cdash_timing("AsyncHierarchical", hierarchical_time_per_task);
     }
 
diff --git a/tests/performance/local/boost_tls_overhead.cpp b/tests/performance/local/boost_tls_overhead.cpp
deleted file mode 100644
index 301ea579c9..0000000000
--- a/tests/performance/local/boost_tls_overhead.cpp
+++ /dev/null
@@ -1,133 +0,0 @@
-//  Copyright (c) 2011 Bryce Adelstein-Lelbach
-//
-//  SPDX-License-Identifier: BSL-1.0
-//  Distributed under the Boost Software License, Version 1.0. (See accompanying
-//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-#include <hpx/config.hpp>
-
-#include <hpx/concurrency/barrier.hpp>
-#include <hpx/format.hpp>
-#include <hpx/timing.hpp>
-
-#include <boost/config.hpp>
-#include <boost/thread/tss.hpp>
-#include <hpx/program_options.hpp>
-
-#include <cstdint>
-#include <functional>
-#include <iostream>
-#include <thread>
-#include <vector>
-
-using hpx::program_options::variables_map;
-using hpx::program_options::options_description;
-using hpx::program_options::value;
-using hpx::program_options::store;
-using hpx::program_options::command_line_parser;
-using hpx::program_options::notify;
-
-using hpx::util::high_resolution_timer;
-
-///////////////////////////////////////////////////////////////////////////////
-// thread local globals
-static boost::thread_specific_ptr<double> global_scratch;
-
-///////////////////////////////////////////////////////////////////////////////
-inline void worker(
-    hpx::util::barrier& b
-  , std::uint64_t updates
-    )
-{
-    b.wait();
-
-    for (double i = 0.; i < updates; ++i)
-    {
-        global_scratch.reset(new double);
-
-        *global_scratch += 1. / (2. * i * (*global_scratch) + 1.);
-
-        global_scratch.reset();
-    }
-}
-
-///////////////////////////////////////////////////////////////////////////////
-int main(
-    int argc
-  , char** argv
-    )
-{
-    ///////////////////////////////////////////////////////////////////////////
-    // parse command line
-    variables_map vm;
-
-    options_description cmdline("Usage: " HPX_APPLICATION_STRING " [options]");
-
-    unsigned threads = 1;
-    std::uint64_t updates = 1 << 22;
-
-    cmdline.add_options()
-        ( "help,h"
-        , "print out program usage (this message)")
-
-        ( "threads,t"
-        , value<unsigned>(&threads)->default_value(1),
-         "number of OS-threads")
-
-        ( "updates,u"
-        , value<std::uint64_t>(&updates)->default_value(1 << 22)
-        , "updates made to the TLS variable per OS-thread")
-
-        ( "csv"
-        , "output results as csv (format: updates,OS-threads,duration)")
-        ;
-    ;
-
-    store(command_line_parser(argc, argv).options(cmdline).run(), vm);
-
-    notify(vm);
-
-    ///////////////////////////////////////////////////////////////////////////
-    // print help screen
-    if (vm.count("help"))
-    {
-        std::cout << cmdline;
-        return 0;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // run the test
-    std::vector<std::thread> workers;
-
-    hpx::util::barrier b(threads);
-
-    high_resolution_timer t;
-
-    for (unsigned i = 0; i != threads; ++i)
-        workers.push_back(std::thread(worker, std::ref(b), updates));
-
-    for (std::thread& thread : workers)
-    {
-        if (thread.joinable())
-            thread.join();
-    }
-
-    const double duration = t.elapsed();
-
-    ///////////////////////////////////////////////////////////////////////////
-    // output results
-    if (vm.count("csv"))
-        hpx::util::format_to(std::cout,
-            "{1},{2},{3}\n",
-            updates,
-            threads,
-            duration);
-    else
-        hpx::util::format_to(std::cout,
-            "ran {1} updates per OS-thread on {2} "
-            "OS-threads in {3} seconds\n",
-            updates,
-            threads,
-            duration);
-}
-
diff --git a/tests/performance/local/coroutines_call_overhead.cpp b/tests/performance/local/coroutines_call_overhead.cpp
index 4871c14039..66a176ef0a 100644
--- a/tests/performance/local/coroutines_call_overhead.cpp
+++ b/tests/performance/local/coroutines_call_overhead.cpp
@@ -9,9 +9,8 @@
 #include <hpx/hpx_init.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/format.hpp>
-
-#include <boost/algorithm/string/split.hpp>
-#include <boost/algorithm/string/classification.hpp>
+#include <hpx/string_util/split.hpp>
+#include <hpx/string_util/classification.hpp>
 
 #include <chrono>
 #include <cstdint>
@@ -243,11 +242,11 @@ int hpx_main(
             for (std::uint64_t i = 0; i < raw_counters.size(); ++i)
             {
                 std::vector<std::string> entry;
-                boost::algorithm::split(entry, raw_counters[i],
-                    boost::algorithm::is_any_of(","),
-                    boost::algorithm::token_compress_on);
+                hpx::string_util::split(entry, raw_counters[i],
+                    hpx::string_util::is_any_of(","),
+                    hpx::string_util::token_compress_mode::on);
 
-                HPX_TEST(entry.size() == 2);
+                HPX_TEST_EQ(entry.size(), 2);
 
                 counter_shortnames.push_back(entry[0]);
                 counters.push_back(entry[1]);
@@ -289,7 +288,7 @@ int main(
         ( "seed"
         , value<std::uint64_t>(&seed)->default_value(0)
         , "seed for the pseudo random number generator (if 0, a seed is "
-          "choosen based on the current system time)")
+          "chosen based on the current system time)")
 
 /*
         ( "counter"
diff --git a/tests/performance/local/foreach_scaling.cpp b/tests/performance/local/foreach_scaling.cpp
index eb556a7e01..400ce2f551 100644
--- a/tests/performance/local/foreach_scaling.cpp
+++ b/tests/performance/local/foreach_scaling.cpp
@@ -11,7 +11,7 @@
 #include <hpx/include/parallel_executor_parameters.hpp>
 #include <hpx/timing.hpp>
 
-#include <hpx/parallel/executors/parallel_executor_aggregated.hpp>
+#include <hpx/execution/executors/parallel_executor_aggregated.hpp>
 
 #include "worker_timed.hpp"
 
diff --git a/tests/performance/local/future_overhead.cpp b/tests/performance/local/future_overhead.cpp
index d011e9c8dd..c6c46508cf 100644
--- a/tests/performance/local/future_overhead.cpp
+++ b/tests/performance/local/future_overhead.cpp
@@ -18,8 +18,8 @@
 #include <hpx/runtime/actions/plain_action.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
-#include <hpx/util/annotated_function.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <hpx/include/parallel_execution.hpp>
 #include <hpx/runtime/threads/executors/limiting_executor.hpp>
diff --git a/tests/performance/local/hpx_heterogeneous_timed_task_spawn.cpp b/tests/performance/local/hpx_heterogeneous_timed_task_spawn.cpp
index 361273b5c8..29288dd39d 100644
--- a/tests/performance/local/hpx_heterogeneous_timed_task_spawn.cpp
+++ b/tests/performance/local/hpx_heterogeneous_timed_task_spawn.cpp
@@ -9,6 +9,7 @@
 #include <hpx/functional/bind.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/iostreams.hpp>
+#include <hpx/include/threadmanager.hpp>
 #include <hpx/timing.hpp>
 
 #include <cstdint>
@@ -184,16 +185,9 @@ int hpx_main(
             payloads.push_back(payload);
         }
 
-#if defined(HPX_HAVE_CXX11_STD_SHUFFLE)
         std::random_device random_device;
         std::mt19937 generator(random_device());
         std::shuffle(payloads.begin(), payloads.end(), std::move(generator));
-#else
-        // Randomly shuffle the entire sequence to deal with drift.
-        using hpx::util::placeholders::_1;
-        std::random_shuffle(payloads.begin(), payloads.end(),
-            hpx::util::bind(&shuffler, std::ref(prng), _1));
-#endif
 
         ///////////////////////////////////////////////////////////////////////
         // Validate the payloads.
@@ -261,7 +255,7 @@ int main(
         ( "seed"
         , value<std::uint64_t>(&seed)->default_value(0)
         , "seed for the pseudo random number generator (if 0, a seed is "
-          "choosen based on the current system time)")
+          "chosen based on the current system time)")
 
         ( "no-header"
         , "do not print out the csv header row")
diff --git a/tests/performance/local/hpx_homogeneous_timed_task_spawn_executors.cpp b/tests/performance/local/hpx_homogeneous_timed_task_spawn_executors.cpp
index bfe2381fa5..d438393d68 100644
--- a/tests/performance/local/hpx_homogeneous_timed_task_spawn_executors.cpp
+++ b/tests/performance/local/hpx_homogeneous_timed_task_spawn_executors.cpp
@@ -105,7 +105,7 @@ int hpx_main(
             // be bound to the remaining number of cores
             if ((i + 1) * num_cores_per_executor > num_os_threads)
             {
-                HPX_TEST(i == std::size_t(num_executors) - 1);
+                HPX_TEST_EQ(i, std::size_t(num_executors) - 1);
                 num_cores_per_executor = num_os_threads - i * num_cores_per_executor;
             }
             executors.push_back(local_priority_queue_executor(num_cores_per_executor));
diff --git a/tests/performance/local/htts_v2/htts2.hpp b/tests/performance/local/htts_v2/htts2.hpp
index 3e36db5c7d..75be21bfbe 100644
--- a/tests/performance/local/htts_v2/htts2.hpp
+++ b/tests/performance/local/htts_v2/htts2.hpp
@@ -7,11 +7,8 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedname:BOOST_ASSERT
-
 #include <hpx/config.hpp>
-
-#include <boost/assert.hpp>
+#include <hpx/assertion.hpp>
 
 #include <chrono>
 #include <cmath>
@@ -44,7 +41,7 @@ struct clocksource
         duration d = std::chrono::duration_cast<duration>(
             base_clock::now().time_since_epoch());
         rep t = d.count();
-        BOOST_ASSERT(t >= 0);
+        HPX_ASSERT(t >= 0);
         return t;
     }
 
diff --git a/tests/performance/local/htts_v2/htts2_hpx.cpp b/tests/performance/local/htts_v2/htts2_hpx.cpp
index 512d58a999..83a9600c70 100644
--- a/tests/performance/local/htts_v2/htts2_hpx.cpp
+++ b/tests/performance/local/htts_v2/htts2_hpx.cpp
@@ -10,7 +10,7 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/synchronization/barrier.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/format.hpp>
 
@@ -169,7 +169,7 @@ struct hpx_driver : htts2::driver
         ///////////////////////////////////////////////////////////////////////
         // Compute + Cooldown Phase
 
-        // The use of an atomic and live waiting here does not add any noticable
+        // The use of an atomic and live waiting here does not add any noticeable
         // overhead, as compared to the more complicated continuation-style
         // detection method that checks the threadmanager internal counters
         // (I've measured). Using this technique is preferable as it is more
diff --git a/tests/performance/local/native_tls_overhead.cpp b/tests/performance/local/native_tls_overhead.cpp
index 31df8577ee..b1062a1d69 100644
--- a/tests/performance/local/native_tls_overhead.cpp
+++ b/tests/performance/local/native_tls_overhead.cpp
@@ -8,11 +8,8 @@
 
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/format.hpp>
-#include <hpx/timing.hpp>
-
-#include <boost/config.hpp>
-#include <boost/thread/tss.hpp>
 #include <hpx/program_options.hpp>
+#include <hpx/timing.hpp>
 
 #include <cstdint>
 #include <functional>
@@ -20,26 +17,6 @@
 #include <thread>
 #include <vector>
 
-#if defined(__has_feature)
-#  if __has_feature(cxx_thread_local)
-#    define HPX_NATIVE_TLS thread_local
-#  endif
-#elif defined(HPX_HAVE_CXX11_THREAD_LOCAL)
-#  define HPX_NATIVE_TLS thread_local
-#endif
-
-#if !defined(HPX_NATIVE_TLS)
-#  if defined(_GLIBCXX_HAVE_TLS)
-#    define HPX_NATIVE_TLS __thread
-#  elif defined(HPX_WINDOWS)
-#    define HPX_NATIVE_TLS __declspec(thread)
-#  elif defined(__FreeBSD__) || (defined(__APPLE__) && defined(__MACH__))
-#    define HPX_NATIVE_TLS __thread
-#  else
-#    error Unsupported platform.
-#  endif
-#endif
-
 using hpx::program_options::variables_map;
 using hpx::program_options::options_description;
 using hpx::program_options::value;
@@ -51,7 +28,7 @@ using hpx::util::high_resolution_timer;
 
 ///////////////////////////////////////////////////////////////////////////////
 // thread local globals
-static HPX_NATIVE_TLS double* global_scratch;
+static thread_local double* global_scratch;
 
 ///////////////////////////////////////////////////////////////////////////////
 inline void worker(
diff --git a/tests/performance/local/nonconcurrent_fifo_overhead.cpp b/tests/performance/local/nonconcurrent_fifo_overhead.cpp
index 413af34776..c3908d3036 100644
--- a/tests/performance/local/nonconcurrent_fifo_overhead.cpp
+++ b/tests/performance/local/nonconcurrent_fifo_overhead.cpp
@@ -6,18 +6,12 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 ////////////////////////////////////////////////////////////////////////////////
 
-// hpxinspect:nodeprecatedname:BOOST_ASSERT
-
-// Makes HPX use BOOST_ASSERT, so that I can use high_resolution_timer without
-// depending on the rest of HPX.
-#define HPX_USE_BOOST_ASSERT
-
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/format.hpp>
+#include <hpx/program_options.hpp>
 #include <hpx/timing.hpp>
 
 #include <boost/lockfree/queue.hpp>
-#include <hpx/program_options.hpp>
 
 #include <chrono>
 #include <cstdint>
diff --git a/tests/performance/local/nonconcurrent_lifo_overhead.cpp b/tests/performance/local/nonconcurrent_lifo_overhead.cpp
index e8eb4971b4..c41185bb06 100644
--- a/tests/performance/local/nonconcurrent_lifo_overhead.cpp
+++ b/tests/performance/local/nonconcurrent_lifo_overhead.cpp
@@ -6,16 +6,12 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 ////////////////////////////////////////////////////////////////////////////////
 
-// Makes HPX use BOOST_ASSERT, so that I can use high_resolution_timer without
-// depending on the rest of HPX.
-#define HPX_USE_BOOST_ASSERT
-
 #include <hpx/concurrency/barrier.hpp>
 #include <hpx/format.hpp>
+#include <hpx/program_options.hpp>
 #include <hpx/timing.hpp>
 
 #include <boost/lockfree/stack.hpp>
-#include <hpx/program_options.hpp>
 
 #include <chrono>
 #include <cstdint>
diff --git a/tests/performance/local/openmp_parallel_region.cpp b/tests/performance/local/openmp_parallel_region.cpp
index fcc4e4b4be..fe0fd7b199 100644
--- a/tests/performance/local/openmp_parallel_region.cpp
+++ b/tests/performance/local/openmp_parallel_region.cpp
@@ -11,7 +11,7 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_start.hpp>
 #include <hpx/timing.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <hpx/program_options.hpp>
 #include <omp.h>
diff --git a/tests/performance/local/parent_vs_child_stealing.cpp b/tests/performance/local/parent_vs_child_stealing.cpp
index b86bbb15bb..a8385d3ddb 100644
--- a/tests/performance/local/parent_vs_child_stealing.cpp
+++ b/tests/performance/local/parent_vs_child_stealing.cpp
@@ -45,7 +45,7 @@ double measure_one(Policy policy)
     hpx::wait_all(threads);
 
     std::uint64_t stop = hpx::util::high_resolution_clock::now();
-    return (stop - start) / 1e9;
+    return static_cast<double>(stop - start) / 1e9;
 }
 
 template <typename Policy>
diff --git a/tests/performance/local/partitioned_vector_foreach.cpp b/tests/performance/local/partitioned_vector_foreach.cpp
index 0f2590f430..5b464ff385 100644
--- a/tests/performance/local/partitioned_vector_foreach.cpp
+++ b/tests/performance/local/partitioned_vector_foreach.cpp
@@ -160,7 +160,7 @@ int main(int argc, char* argv[])
 
         ("test_count"
         , hpx::program_options::value<int>()->default_value(100)
-        , "number of tests to be averaged (defalt: 100)")
+        , "number of tests to be averaged (default: 100)")
 
         ("chunk_size"
         , hpx::program_options::value<int>()->default_value(0)
diff --git a/tests/performance/local/print_heterogeneous_payloads.cpp b/tests/performance/local/print_heterogeneous_payloads.cpp
index 3e248f53fc..332224b7da 100644
--- a/tests/performance/local/print_heterogeneous_payloads.cpp
+++ b/tests/performance/local/print_heterogeneous_payloads.cpp
@@ -5,12 +5,7 @@
 //  Distributed under the Boost Software License, Version 1.0. (See accompanying
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-// hpxinspect:nodeprecatedinclude:boost/bind.hpp
-// hpxinspect:nodeprecatedname:boost::bind
-
 #include <hpx/config/defines.hpp>   // avoid issues with Intel14/libstdc++4.4 nullptr
-
-#include <boost/bind.hpp>
 #include <hpx/program_options.hpp>
 
 #include <cstddef>
@@ -139,14 +134,9 @@ int app_main(
     }
 
     // Randomly shuffle the entire sequence to deal with drift.
-#if defined(HPX_HAVE_CXX11_STD_SHUFFLE)
     std::random_device random_device;
     std::mt19937 generator(random_device());
     std::shuffle(payloads.begin(), payloads.end(), std::move(generator));
-#else
-    std::random_shuffle(payloads.begin(), payloads.end(),
-        boost::bind(&shuffler, std::ref(prng), _1));
-#endif
 
     ///////////////////////////////////////////////////////////////////////
     // Validate the payloads.
@@ -199,7 +189,7 @@ int main(
         ( "seed"
         , value<std::uint64_t>(&seed)->default_value(0)
         , "seed for the pseudo random number generator (if 0, a seed is "
-          "choosen based on the current system time)")
+          "chosen based on the current system time)")
         ;
 
     store(command_line_parser(argc, argv).options(cmdline).run(), vm);
diff --git a/tests/performance/local/qthreads_heterogeneous_timed_task_spawn.cpp b/tests/performance/local/qthreads_heterogeneous_timed_task_spawn.cpp
index ddd4a53d6b..9f40e482d5 100644
--- a/tests/performance/local/qthreads_heterogeneous_timed_task_spawn.cpp
+++ b/tests/performance/local/qthreads_heterogeneous_timed_task_spawn.cpp
@@ -218,15 +218,9 @@ int qthreads_main(
         }
 
         // Randomly shuffle the entire sequence to deal with drift.
-#if defined(HPX_HAVE_CXX11_STD_SHUFFLE)
         std::random_device random_device;
         std::mt19937 generator(random_device());
         std::shuffle(payloads.begin(), payloads.end(), std::move(generator));
-#else
-        using hpx::util::placeholders::_1;
-        std::random_shuffle(payloads.begin(), payloads.end(),
-            hpx::util::bind(&shuffler, std::ref(prng), _1));
-#endif
 
         ///////////////////////////////////////////////////////////////////////
         // Validate the payloads.
@@ -308,7 +302,7 @@ int main(
         ( "seed"
         , value<std::uint64_t>(&seed)->default_value(0)
         , "seed for the pseudo random number generator (if 0, a seed is "
-          "choosen based on the current system time)")
+          "chosen based on the current system time)")
 
         ( "no-header"
         , "do not print out the csv header row")
diff --git a/tests/performance/local/resume_suspend.cpp b/tests/performance/local/resume_suspend.cpp
index d8c39d6d8f..7484a83876 100644
--- a/tests/performance/local/resume_suspend.cpp
+++ b/tests/performance/local/resume_suspend.cpp
@@ -10,7 +10,7 @@
 
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_start.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 
diff --git a/tests/performance/local/start_stop.cpp b/tests/performance/local/start_stop.cpp
index 42a89a1573..7f204cb8e4 100644
--- a/tests/performance/local/start_stop.cpp
+++ b/tests/performance/local/start_stop.cpp
@@ -9,7 +9,7 @@
 
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_start.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 
diff --git a/tests/performance/local/stream.cpp b/tests/performance/local/stream.cpp
index 26b3de4886..a81a57e465 100644
--- a/tests/performance/local/stream.cpp
+++ b/tests/performance/local/stream.cpp
@@ -400,7 +400,7 @@ int hpx_main(hpx::program_options::variables_map& vm)
 
     std::cout
         << "-------------------------------------------------------------\n"
-        << "Modified STREAM bechmark based on\nHPX version: "
+        << "Modified STREAM benchmark based on\nHPX version: "
             << hpx::build_string() << "\n"
         << "-------------------------------------------------------------\n"
         << "This system uses " << sizeof(STREAM_TYPE)
diff --git a/tests/performance/local/timed_task_spawn.cpp b/tests/performance/local/timed_task_spawn.cpp
index 2989d25ce9..37fbecd20f 100644
--- a/tests/performance/local/timed_task_spawn.cpp
+++ b/tests/performance/local/timed_task_spawn.cpp
@@ -16,9 +16,9 @@
 #include <hpx/format.hpp>
 #include <hpx/functional/bind.hpp>
 #include <hpx/testing.hpp>
+#include <hpx/string_util/classification.hpp>
+#include <hpx/string_util/split.hpp>
 
-#include <boost/algorithm/string/classification.hpp>
-#include <boost/algorithm/string/split.hpp>
 #include <boost/integer/common_factor.hpp>
 
 #include <chrono>
@@ -414,11 +414,11 @@ int hpx_main(variables_map& vm)
             for (auto& raw_counter : raw_counters)
             {
                 std::vector<std::string> entry;
-                boost::algorithm::split(entry, raw_counter,
-                    boost::algorithm::is_any_of(","),
-                    boost::algorithm::token_compress_on);
+                hpx::string_util::split(entry, raw_counter,
+                    hpx::string_util::is_any_of(","),
+                    hpx::string_util::token_compress_mode::on);
 
-                HPX_TEST(entry.size() == 2);
+                HPX_TEST_EQ(entry.size(), 2);
 
                 counter_shortnames.push_back(entry[0]);
                 counters.push_back(entry[1]);
diff --git a/tests/performance/network/network_storage/instructions.md b/tests/performance/network/network_storage/instructions.md
index 6e908dd45d..7c597fba61 100644
--- a/tests/performance/network/network_storage/instructions.md
+++ b/tests/performance/network/network_storage/instructions.md
@@ -14,18 +14,18 @@ The network storage benchmark comes with several files
 ##################################################
 
 ------------------------------
-network_storage.cpp 
+network_storage.cpp
 ------------------------------
 This is the code for the test.
 
 ------------------------------
-network_storage.bat.in 
+network_storage.bat.in
 ------------------------------
 This is a windows batch file template which will be filled in using cmake substitution
 and then copied to your build/scripts directory.
-The generated script can be invoked to run the benchmark in serial or parallel. 
-It spawns each task on the same node so although you may run 4 copies, 
-they are competing for resources. 
+The generated script can be invoked to run the benchmark in serial or parallel.
+It spawns each task on the same node so although you may run 4 copies,
+they are competing for resources.
 The windows version is good for testing and debugging on a single node.
 adding or removing /B for the launch command in the script
 controls whether each task is launched in a new console window or not
@@ -38,11 +38,11 @@ slurm-test-HPX-storage.sh.in
 This is a bash script template which will be filled in using cmake substitution
 and then copied to your build/scripts directory.
 When executed, the script will loop over a number of parameter combinations
-and for each create a directory with a name generated from the paramaters, such as
+and for each create a directory with a name generated from the parameters, such as
   hpx-N0002-T02048-t04-ibverbs
 and inside the dir there will be a "submit-job.bash" script which contains a single
-slurm job submission. You can manually submit just one job using "sbatch submit-job.bash", 
-or in the root of the scripts folder there will be generated another script 
+slurm job submission. You can manually submit just one job using "sbatch submit-job.bash",
+or in the root of the scripts folder there will be generated another script
 which is called "run_jobs.bash". When this script is run, it will loop over
 the jobs that were created by the first script and submit them all, you
 can then sit back and wait until they complete.
@@ -50,7 +50,7 @@ Each job will write its results into "slurm.out" (and errors to slurm.err)
 in the same subdirectory in which each individual job submission script was created.
 
 The network_storage executable will produce several lines of output, but one line
-contains the condensed information needed by the plotting script. 
+contains the condensed information needed by the plotting script.
 This line begins with the text "CSVData" to indicate comma separated data values.
 Whilst jobs are running or when they have completed, you can execute a command
 from the test root dir, such as
@@ -62,8 +62,8 @@ Where you use a file name applicable to your current experiment.
 The generated file will be suitable for use by the plotting script.
 
 Important Note:
-By default, the slurm jobs generated by the script have the 'exclusive' flag set. 
-This is because the jobs are intended to test BW of the network and it is 
+By default, the slurm jobs generated by the script have the 'exclusive' flag set.
+This is because the jobs are intended to test BW of the network and it is
 often desirable  to have only a single job running at a time.
 The 'exclusive' flag only works (under slurm) if all jobs have the same name
 so in your queue you will see many identical jobs and it will take a long time to drain.
@@ -76,7 +76,7 @@ plot-results.py
 This is a python script which takes results generated by the test program
 as described above and plots a number of graphs for different parameter studies.
 The results.csv file generated contains BW measurements, timing ,thread, parcelport,
-block size, etc information for the plots. 
+block size, etc information for the plots.
 The python script parses the results and generates arrays (maps) of the data which
 can be plotted in various ways. The scripts can be invoked as
   plot-results.py results.csv
@@ -99,7 +99,7 @@ gdb --args /home/biddisco/build/hvtkm/bin/network_storage --localMB=64 --transfe
 
 mpi launch
 mpiexec -n 2 -host greina14,greina15 bin/network_storage --localMB=1024 --transferKB=16384 --iterations=10 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.tcp.enable=0 -Ihpx.parcel.mpi.enable=1 -Ihpx.parcel.verbs.enable=0 -Ihpx.parcel.bootstrap=mpi --hpx:threads=12
- 
+
 test TCP greina14
 bin/network_storage --localMB=1024 --transferKB=16384 --hpx:localities=2 -Ihpx.parcel.tcp.enable=1 --hpx:agas=148.187.83.44:7910 --hpx:hpx=148.187.83.44:7910 -Ihpx.parcel.tcp.enable=1 -Ihpx.parcel.mpi.enable=0 -Ihpx.parcel.verbs.enable=0 -Ihpx.parcel.bootstrap=tcp --iterations=10  --hpx:threads=12
 
diff --git a/tests/performance/network/network_storage/network_storage.cpp b/tests/performance/network/network_storage/network_storage.cpp
index 33fc1a66af..14e6c79dfb 100644
--- a/tests/performance/network/network_storage/network_storage.cpp
+++ b/tests/performance/network/network_storage/network_storage.cpp
@@ -12,8 +12,6 @@
 #include <hpx/synchronization/detail/sliding_semaphore.hpp>
 #include <hpx/testing.hpp>
 
-#include <boost/assert.hpp>
-
 #include <algorithm>
 #include <array>
 #include <atomic>
@@ -248,13 +246,13 @@ public:
 
   pointer allocate(size_type n, void const* hint = nullptr)
   {
-    HPX_TEST(n == size_);
+    HPX_TEST_EQ(n, size_);
     return static_cast<T*>(pointer_);
   }
 
   void deallocate(pointer p, size_type n)
   {
-    HPX_TEST(p == pointer_ && n == size_);
+    HPX_TEST_EQ(p == pointer_ && n, size_);
   }
 
 private:
diff --git a/tests/performance/network/pingpong_performance.cpp b/tests/performance/network/pingpong_performance.cpp
index faf3034ebb..027d342e2f 100644
--- a/tests/performance/network/pingpong_performance.cpp
+++ b/tests/performance/network/pingpong_performance.cpp
@@ -43,9 +43,9 @@ int hpx_main(hpx::program_options::variables_map& vm)
     //Create instance of the actions
     pingpong_get_element_action act;
     std::vector<hpx::future<std::complex<double>>> vec;
-    std::vector<std::complex<double>> recieved;
+    std::vector<std::complex<double>> received;
     vec.reserve(n);
-    recieved.reserve(n);
+    received.reserve(n);
     //Find the other locality
     std::vector<hpx::naming::id_type> dummy = hpx::find_remote_localities();
     hpx::naming::id_type other_locality = dummy[0];
@@ -57,16 +57,16 @@ int hpx_main(hpx::program_options::variables_map& vm)
     }
 
     hpx::when_all(vec).then(
-        [&recieved, n](hpx::future<std::vector<hpx::future<std::complex<double>>>> dummy)
+        [&received, n](hpx::future<std::vector<hpx::future<std::complex<double>>>> dummy)
         {
             std::vector<hpx::future<std::complex<double>>> number = dummy.get();
             for (std::size_t i = 0; i < n; ++i)
             {
-                recieved.push_back(number[i].get());
+                received.push_back(number[i].get());
             }
             hpx::evaluate_active_counters(false, " All Futures Done");
-            hpx::cout << "Now Done With Lambda and the last recieved value is "
-                      <<recieved[n-1]<< "\n" << hpx::flush;
+            hpx::cout << "Now Done With Lambda and the last received value is "
+                      <<received[n-1]<< "\n" << hpx::flush;
         }
     ).get();
     return hpx::finalize();
diff --git a/tests/regressions/CMakeLists.txt b/tests/regressions/CMakeLists.txt
index 5a70ab8bfc..7a6bc5c73b 100644
--- a/tests/regressions/CMakeLists.txt
+++ b/tests/regressions/CMakeLists.txt
@@ -12,7 +12,6 @@ set(subdirs
     block_matrix
     component
     lcos
-    performance_counters
     threads
     traits
     util
@@ -25,7 +24,6 @@ foreach(subdir ${subdirs})
 endforeach()
 
 set(tests
-    dynamic_counters_loaded_1508
     id_type_ref_counting_1032
     multiple_init
     multiple_init_2918
@@ -35,7 +33,6 @@ set(tests
 
 set(id_type_ref_counting_1032_PARAMETERS THREADS_PER_LOCALITY 1)
 set(unhandled_exception_582_PARAMETERS THREADS_PER_LOCALITY 1)
-set(dynamic_counters_loaded_1508_FLAGS DEPENDENCIES memory_component)
 
 foreach(test ${tests})
   set(sources
diff --git a/tests/regressions/actions/components/CMakeLists.txt b/tests/regressions/actions/components/CMakeLists.txt
index 5fed2bc4b9..6b9a70b37a 100644
--- a/tests/regressions/actions/components/CMakeLists.txt
+++ b/tests/regressions/actions/components/CMakeLists.txt
@@ -5,6 +5,7 @@
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 add_hpx_component(action_move_semantics
+  INTERNAL_FLAGS
   FOLDER "Tests/Regressions/Actions"
   EXCLUDE_FROM_ALL
   AUTOGLOB)
diff --git a/tests/regressions/block_matrix/CMakeLists.txt b/tests/regressions/block_matrix/CMakeLists.txt
index 110b8dff2a..f508a4d014 100644
--- a/tests/regressions/block_matrix/CMakeLists.txt
+++ b/tests/regressions/block_matrix/CMakeLists.txt
@@ -4,23 +4,19 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-if(HPX_WITH_CXX11_DEFAULTED_FUNCTIONS)
+set(tests block_matrix)
 
-  set(tests block_matrix)
+set(sources
+    algorithms.cc block_matrix.cc main.cc matrix.cc matrix_hpx.cc tests.cc)
 
-  set(sources
-      algorithms.cc block_matrix.cc main.cc matrix.cc matrix_hpx.cc tests.cc)
+source_group("Source Files" FILES ${sources})
 
-  source_group("Source Files" FILES ${sources})
+add_hpx_executable(block_matrix_test
+                   INTERNAL_FLAGS
+                   SOURCES ${sources}
+                   ${block_matrix_FLAGS}
+                   EXCLUDE_FROM_ALL
+                   HPX_PREFIX ${HPX_BUILD_PREFIX}
+                   FOLDER "Tests/Regressions/Block-Matrix")
 
-  add_hpx_executable(block_matrix_test
-    INTERNAL_FLAGS
-    SOURCES ${sources}
-    ${block_matrix_FLAGS}
-    EXCLUDE_FROM_ALL
-    HPX_PREFIX ${HPX_BUILD_PREFIX}
-    FOLDER "Tests/Regressions/Block-Matrix")
-
-  add_hpx_regression_test("block_matrix" block_matrix ${block_matrix_PARAMETERS})
-
-endif()
+add_hpx_regression_test("block_matrix" block_matrix ${block_matrix_PARAMETERS})
diff --git a/tests/regressions/block_matrix/tests.cc b/tests/regressions/block_matrix/tests.cc
index e72bc653c4..e9330bf55d 100644
--- a/tests/regressions/block_matrix/tests.cc
+++ b/tests/regressions/block_matrix/tests.cc
@@ -27,60 +27,60 @@ void test_dense()
 {
   hpx::id_type here = hpx::find_here();
   std::cout << "test_dense: running on " << here << std::endl;
-  
+
   const double alpha = 2.0, beta = 3.0;
   std::cout << "alpha=" << alpha << ", beta=" << beta << std::endl;
-  
+
   const ptrdiff_t NI=4, NJ=3, NK=2;
   std::cout << "NI=" << NI << ", NJ=" << NJ << ", NK=" << NK << std::endl;
-  
+
   vector_t x(NJ);
-  for (ptrdiff_t j=0; j<NJ; ++j) x(j) = j + 1;
+  for (ptrdiff_t j=0; j<NJ; ++j) x(j) = static_cast<double>(j + 1);
   std::cout << "x=" << x << std::endl;
   vector_t y(NI);
-  for (ptrdiff_t i=0; i<NI; ++i) y(i) = i + 2;
+  for (ptrdiff_t i=0; i<NI; ++i) y(i) = static_cast<double>(i + 2);
   std::cout << "y=" << y << std::endl;
   vector_t z(NI);
-  for (ptrdiff_t i=0; i<NI; ++i) z(i) = i + 3;
+  for (ptrdiff_t i=0; i<NI; ++i) z(i) = static_cast<double>(i + 3);
   std::cout << "z=" << z << std::endl;
-  
+
   matrix_t a(NI,NJ);
   for (ptrdiff_t i=0, n=0; i<NI; ++i)
     for (ptrdiff_t j=0; j<NJ; ++j)
-      a(i,j) = n++ + 4;
+      a(i,j) = static_cast<double>(n++ + 4);
   std::cout << "a=" << a << std::endl;
   matrix_t b(NI,NK);
   for (ptrdiff_t i=0, n=0; i<NI; ++i)
     for (ptrdiff_t k=0; k<NK; ++k)
-      b(i,k) = n++ + 5;
+      b(i,k) = static_cast<double>(n++ + 5);
   std::cout << "b=" << b << std::endl;
   matrix_t c(NK,NJ);
   for (ptrdiff_t k=0, n=0; k<NK; ++k)
     for (ptrdiff_t j=0; j<NJ; ++j)
-      c(k,j) = n++ + 6;
+      c(k,j) = static_cast<double>(n++ + 6);
   std::cout << "c=" << c << std::endl;
-  
+
   std::cout << std::endl;
-  
-  
-  
+
+
+
   vector_t yy(NI), zz(NI);
   matrix_t aa(NI,NJ);
-  
+
   copy(z, zz);
   axpy(alpha, y, zz);
   std::cout << "axpy: alpha y + z = " << zz << std::endl;
   axpy(-1.0, vector_t({7,10,13,16}), zz);
   std::cout << "   (error = " << nrm2(zz) << ")" << std::endl;
   HPX_TEST_EQ(nrm2(zz), 0.0);
-  
+
   copy(y, yy);
   gemv(false, alpha, a, x, beta, yy);
   std::cout << "gemv: alpha a x + beta y = " << yy << std::endl;
   axpy(-1.0, vector_t({70,109,148,187}), yy);
   std::cout << "   (error = " << nrm2(yy) << ")" << std::endl;
   HPX_TEST_EQ(nrm2(yy), 0.0);
-  
+
   copy(false, a, aa);
   gemm(false, false, alpha, b, c, beta, aa);
   std::cout << "gemm: alpha b c + beta a = " << aa << std::endl;
@@ -90,7 +90,7 @@ void test_dense()
        aa);
   std::cout << "   (error = " << nrm2(aa) << ")" << std::endl;
   HPX_TEST_EQ(nrm2(aa), 0.0);
-  
+
   std::cout << std::endl;
 }
 
@@ -102,13 +102,13 @@ void test_blocked()
   std::vector<hpx::id_type> locs = hpx::find_all_localities();
   hpx::id_type here = hpx::find_here();
   std::cout << "test_blocked: running on " << here << std::endl;
-  
+
   const double alpha = 2.0, beta = 3.0;
   std::cout << "alpha=" << alpha << ", beta=" << beta << std::endl;
-  
+
   const ptrdiff_t NI=10, NJ=6, NK=6;
   std::cout << "NI=" << NI << ", NJ=" << NJ << ", NK=" << NK << std::endl;
-  
+
   const ptrdiff_t BI = 3;
   const ptrdiff_t istr0[BI] = {1, 4, 9};
   const ptrdiff_t istr1[BI] = {2, 6, 10};
@@ -116,7 +116,7 @@ void test_blocked()
   for (std::ptrdiff_t i=0; i<BI; ++i) ilocs[i] = locs[i % nlocs];
   auto istr = std::make_shared<structure_t>(NI, BI, istr0, istr1, ilocs);
   std::cout << "istr=" << *istr << std::endl;
-  
+
   const ptrdiff_t BJ = 2;
   const ptrdiff_t jstr0[BJ] = {0, 4};
   const ptrdiff_t jstr1[BJ] = {2, 5};
@@ -124,7 +124,7 @@ void test_blocked()
   for (std::ptrdiff_t j=0; j<BJ; ++j) jlocs[j] = locs[(j+1) % nlocs];
   auto jstr = std::make_shared<structure_t>(NJ, BJ, jstr0, jstr1, jlocs);
   std::cout << "jstr=" << *jstr << std::endl;
-  
+
   const ptrdiff_t BK = 1;
   const ptrdiff_t kstr0[BK] = {1};
   const ptrdiff_t kstr1[BK] = {3};
@@ -132,72 +132,72 @@ void test_blocked()
   for (std::ptrdiff_t k=0; k<BK; ++k) klocs[k] = locs[(k+2) % nlocs];
   auto kstr = std::make_shared<structure_t>(NK, BK, kstr0, kstr1, klocs);
   std::cout << "kstr=" << *kstr << std::endl;
-  
+
   block_vector_t x(jstr);
   for (ptrdiff_t j=0, n=0; j<NJ; ++j) {
     if (x.str->find(j) >= 0) {
-      x.set_elt(j, n++ + 1);
+      x.set_elt(j, static_cast<double>(n++ + 1));
     }
   }
   std::cout << "x=" << x << std::endl;
-  
+
   block_vector_t y(istr);
   for (ptrdiff_t i=0, n=0; i<NI; ++i)
     if (y.str->find(i) >= 0)
-      y.set_elt(i, n++ + 2);
+      y.set_elt(i, static_cast<double>(n++ + 2));
   std::cout << "y=" << y << std::endl;
-  
+
   block_vector_t z(istr);
   for (ptrdiff_t i=0, n=0; i<NI; ++i)
     if (z.str->find(i) >= 0)
-      z.set_elt(i, n++ + 3);
+      z.set_elt(i, static_cast<double>(n++ + 3));
   std::cout << "z=" << z << std::endl;
-  
+
   block_matrix_t a(istr,jstr);
   for (ptrdiff_t i=0, n=0; i<NI; ++i)
     if (a.istr->find(i) >= 0)
       for (ptrdiff_t j=0; j<NJ; ++j)
         if (a.jstr->find(j) >= 0)
-          a.set_elt(i,j, n++ + 4);
+          a.set_elt(i,j, static_cast<double>(n++ + 4));
   std::cout << "a=" << a << std::endl;
-  
+
   block_matrix_t b(istr,kstr);
   for (ptrdiff_t i=0, n=0; i<NI; ++i)
     if (b.istr->find(i) >= 0)
       for (ptrdiff_t k=0; k<NK; ++k)
         if (b.jstr->find(k) >= 0)
-          b.set_elt(i,k, n++ + 5);
+          b.set_elt(i,k, static_cast<double>(n++ + 5));
   std::cout << "b=" << b << std::endl;
-  
+
   block_matrix_t c(kstr,jstr);
   for (ptrdiff_t k=0, n=0; k<NK; ++k)
     if (c.istr->find(k) >= 0)
       for (ptrdiff_t j=0; j<NJ; ++j)
         if (c.jstr->find(j) >= 0)
-          c.set_elt(k,j, n++ + 6);
+          c.set_elt(k,j, static_cast<double>(n++ + 6));
   std::cout << "c=" << c << std::endl;
-  
+
   std::cout << std::endl;
-  
-  
-  
+
+
+
   block_vector_t yy(istr), zz(istr);
   block_matrix_t aa(istr,jstr);
-  
+
   copy(z, zz);
   axpy(alpha, y, zz);
   std::cout << "axpy: alpha y + z = " << zz << std::endl;
   axpy(-1.0, block_vector_t(zz.str, {{1,{7}}, {4,{10,13}}, {9,{16}}}), zz);
   std::cout << "   (error = " << nrm2(zz) << ")" << std::endl;
   HPX_TEST_EQ(nrm2(zz), 0.0);
-  
+
   copy(y, yy);
   gemv(false, alpha, a, x, beta, yy);
   std::cout << "gemv: alpha a x + beta y = " << yy << std::endl;
   axpy(-1.0, block_vector_t(yy.str, {{1,{70}}, {4,{109,148}}, {9,{187}}}), yy);
   std::cout << "   (error = " << nrm2(yy) << ")" << std::endl;
   HPX_TEST_EQ(nrm2(yy), 0.0);
-  
+
   copy(false, a, aa);
   gemm(false, false, alpha, b, c, beta, aa);
   std::cout << "gemm: alpha b c + beta a = " << aa << std::endl;
@@ -216,7 +216,7 @@ void test_blocked()
        aa);
   std::cout << "   (error = " << nrm2(aa) << ")" << std::endl;
   HPX_TEST_EQ(nrm2(aa), 0.0);
-  
+
   std::cout << std::endl;
 }
 
diff --git a/tests/regressions/component/CMakeLists.txt b/tests/regressions/component/CMakeLists.txt
index 485d6ffc3e..0724c904a1 100644
--- a/tests/regressions/component/CMakeLists.txt
+++ b/tests/regressions/component/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (c) 2007-2017 Hartmut Kaiser
+# Copyright (c) 2007-2020 Hartmut Kaiser
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -10,16 +10,18 @@ set(tests
     create_n_components_2323
     moveonly_constructor_arguments_1405
     new_2848
+    new_4369
     returned_client_2150
    )
 
 if(HPX_WITH_NETWORKING)
   set(tests ${tests}
-      create_remote_component_2334
+    create_remote_component_2334
   )
   set(bulk_new_3054_PARAMETERS LOCALITIES 2)
   set(create_remote_component_2334_PARAMETERS LOCALITIES 2)
   set(new_2848_PARAMETERS LOCALITIES 2)
+  set(new_4349_PARAMETERS LOCALITIES 4)
 endif()
 
 foreach(test ${tests})
diff --git a/tests/regressions/component/new_2848.cpp b/tests/regressions/component/new_2848.cpp
index de7e9131c7..aece60d6cc 100644
--- a/tests/regressions/component/new_2848.cpp
+++ b/tests/regressions/component/new_2848.cpp
@@ -57,33 +57,33 @@ void test_create_single_instance()
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         hpx::id_type id = hpx::new_<test_server>(loc, 42).get();
-        HPX_TEST(hpx::async<call_action>(id).get() == loc);
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         test_client t1 = hpx::new_<test_client>(loc, 42);
-        HPX_TEST(t1.call() == loc);
+        HPX_TEST_EQ(t1.call(), loc);
     }
 
     // make sure distribution policy is properly used
     hpx::id_type id = hpx::new_<test_server>(hpx::default_layout, 42).get();
-    HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+    HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
 
     test_client t2 = hpx::new_<test_client>(hpx::default_layout, 42);
-    HPX_TEST(t2.call() == hpx::find_here());
+    HPX_TEST_EQ(t2.call(), hpx::find_here());
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         hpx::id_type id =
             hpx::new_<test_server>(hpx::default_layout(loc), 42).get();
-        HPX_TEST(hpx::async<call_action>(id).get() == loc);
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         test_client t3 = hpx::new_<test_client>(hpx::default_layout(loc), 42);
-        HPX_TEST(t3.call() == loc);
+        HPX_TEST_EQ(t3.call(), loc);
     }
 }
 
@@ -99,7 +99,7 @@ void test_create_multiple_instances()
 
         for (hpx::id_type const& id: ids)
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == loc);
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
         }
     }
 
@@ -111,7 +111,7 @@ void test_create_multiple_instances()
 
         for (test_client const& c: ids)
         {
-            HPX_TEST(c.call() == loc);
+            HPX_TEST_EQ(c.call(), loc);
         }
     }
 
@@ -121,7 +121,7 @@ void test_create_multiple_instances()
     HPX_TEST_EQ(ids.size(), std::size_t(10));
     for (hpx::id_type const& id: ids)
     {
-        HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
     }
 
     std::vector<test_client> clients =
@@ -129,7 +129,7 @@ void test_create_multiple_instances()
     HPX_TEST_EQ(clients.size(), std::size_t(10));
     for (test_client const& c: clients)
     {
-        HPX_TEST(c.call() == hpx::find_here());
+        HPX_TEST_EQ(c.call(), hpx::find_here());
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
@@ -140,7 +140,7 @@ void test_create_multiple_instances()
 
         for (hpx::id_type const& id: ids)
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == loc);
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
         }
     }
 
@@ -152,7 +152,7 @@ void test_create_multiple_instances()
 
         for (test_client const& c: ids)
         {
-            HPX_TEST(c.call() == loc);
+            HPX_TEST_EQ(c.call(), loc);
         }
     }
 }
diff --git a/tests/regressions/component/new_4369.cpp b/tests/regressions/component/new_4369.cpp
new file mode 100644
index 0000000000..f9f534791b
--- /dev/null
+++ b/tests/regressions/component/new_4369.cpp
@@ -0,0 +1,68 @@
+//  Copyright (c) 2020 Dominic Marcello
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/hpx_init.hpp>
+#include <hpx/include/components.hpp>
+
+#include <string>
+#include <vector>
+
+class tree : public hpx::components::component_base<tree>
+{
+    std::vector<hpx::id_type> children;
+
+public:
+    tree(int depth, int next_proc, int branch_factor)
+    {
+        auto locs = hpx::find_all_localities();
+
+        if (depth > 0)
+        {
+            std::vector<hpx::future<hpx::id_type>> futs(branch_factor);
+            for (int ci = 0; ci < branch_factor; ci++)
+            {
+                const auto loc = locs[next_proc++ % locs.size()];
+                futs[ci] = hpx::async([loc, depth, next_proc, branch_factor]() {
+                    return hpx::new_<tree>(
+                        loc, depth - 1, next_proc, branch_factor)
+                        .get();
+                });
+            }
+            for (int ci = 0; ci < branch_factor; ci++)
+            {
+                children.push_back(futs[ci].get());
+            }
+        }
+    };
+};
+
+HPX_REGISTER_COMPONENT(hpx::components::component<tree>, tree);
+
+int hpx_main(int argc, char* argv[])
+{
+    int d;
+    if (argc > 1)
+    {
+        d = atoi(argv[1]);
+    }
+    else
+    {
+        d = 3;
+    }
+    constexpr int bf = 8;
+    {
+        printf("Creating %i components\n", int(pow(bf, d)));
+        hpx::new_<tree>(hpx::find_here(), d, 1, bf).get();
+        printf("Done\n");
+    }
+    return hpx::finalize();
+}
+
+int main(int argc, char* argv[])
+{
+    std::vector<std::string> cfg = {"hpx.commandline.allow_unknown=1"};
+    hpx::init(argc, argv, cfg);
+}
diff --git a/tests/regressions/lcos/CMakeLists.txt b/tests/regressions/lcos/CMakeLists.txt
index e24d6733d4..c24620cc9d 100644
--- a/tests/regressions/lcos/CMakeLists.txt
+++ b/tests/regressions/lcos/CMakeLists.txt
@@ -16,6 +16,7 @@ set(tests
     channel_not_empty_2890
     channel_register_as_2722
     dataflow_791
+    dataflow_4436
     dataflow_action_2008
     dataflow_const_functor_773
     dataflow_future_swap2
diff --git a/tests/regressions/lcos/channel_2916.cpp b/tests/regressions/lcos/channel_2916.cpp
index 39d4cc881c..08ab2233ee 100644
--- a/tests/regressions/lcos/channel_2916.cpp
+++ b/tests/regressions/lcos/channel_2916.cpp
@@ -61,7 +61,7 @@ int hpx_main()
     // pending as the first thread exiting the loop did not request an item
     // off the channel anymore.
     std::size_t remaining_count = free_resources.close(true);
-    HPX_TEST(remaining_count <= count.load());
+    HPX_TEST_LTE(remaining_count, count.load());
 
     return hpx::finalize();
 }
diff --git a/tests/regressions/lcos/dataflow_4436.cpp b/tests/regressions/lcos/dataflow_4436.cpp
new file mode 100644
index 0000000000..420db61f25
--- /dev/null
+++ b/tests/regressions/lcos/dataflow_4436.cpp
@@ -0,0 +1,64 @@
+//  Copyright (c) 2020 albestro
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/hpx.hpp>
+#include <hpx/hpx_init.hpp>
+#include <hpx/testing.hpp>
+#include <hpx/traits/pack_traversal_rebind_container.hpp>
+
+#include <cstddef>
+#include <numeric>
+#include <vector>
+
+namespace custom {
+
+    template <typename T>
+    struct vector : public std::vector<T>
+    {
+        vector() = default;
+    };
+
+}    // namespace custom
+
+namespace hpx { namespace traits {
+
+    template <typename NewType, typename OldType>
+    struct pack_traversal_rebind_container<NewType, custom::vector<OldType>>
+    {
+        static custom::vector<NewType> call(custom::vector<OldType> const&)
+        {
+            // Create a new version of the container for the new data type
+            return custom::vector<NewType>();
+        }
+    };
+}}    // namespace hpx::traits
+
+int start(int argc, char** argv)
+{
+    custom::vector<hpx::future<int>> values_futures;
+
+    for (int i = 1; i <= 3; ++i)
+    {
+        values_futures.emplace_back(hpx::make_ready_future(i));
+    }
+
+    auto f = hpx::dataflow(hpx::util::unwrapping(
+        [](const auto&& values) {
+            return std::accumulate(values.begin(), values.end(), 0);
+        }),
+        values_futures);
+
+    HPX_TEST_EQ(f.get(), 6);
+
+    return hpx::finalize();
+}
+
+int main(int argc, char** argv)
+{
+    HPX_TEST_EQ(hpx::init(start, argc, argv), 0);
+
+    return hpx::util::report_errors();
+}
diff --git a/tests/regressions/lcos/dataflow_791.cpp b/tests/regressions/lcos/dataflow_791.cpp
index 28cf484d1e..3c948c522e 100644
--- a/tests/regressions/lcos/dataflow_791.cpp
+++ b/tests/regressions/lcos/dataflow_791.cpp
@@ -84,7 +84,7 @@ int hpx_main (int argc, char *argv[])
     originalA.resize(size*size); //-V106
     for(int i = 0; i < size * size; i++)
         originalA[i] = A[i];
-    printf("init done, time = %f\n", (t2-t1)/1000000.0);
+    printf("init done, time = %f\n", static_cast<double>(t2 - t1) / 1000000.0);
 
     t1 = get_tick_count();
     if(numBlocks == 1)
@@ -94,7 +94,8 @@ int hpx_main (int argc, char *argv[])
     else
         printf("Error: numBlocks must be greater than 0.\n");
     t2 = get_tick_count();
-    printf("Time for LU-decomposition in secs: %f \n", (t2-t1)/1000000.0);
+    printf("Time for LU-decomposition in secs: %f \n",
+        static_cast<double>(t2 - t1) / 1000000.0);
 
     checkResult( originalA );
 
diff --git a/tests/regressions/lcos/future_2667.cpp b/tests/regressions/lcos/future_2667.cpp
index 636e051281..856b02d821 100644
--- a/tests/regressions/lcos/future_2667.cpp
+++ b/tests/regressions/lcos/future_2667.cpp
@@ -39,7 +39,7 @@ int main()
     hpx::future<void> fut2 = std::move(fut);
     fut2.get();
 
-    HPX_TEST(t.elapsed() > 1.0);
+    HPX_TEST_LT(1.0, t.elapsed());
     HPX_TEST(was_run.load());
 
     return hpx::util::report_errors();
diff --git a/tests/regressions/lcos/future_serialization_1898.cpp b/tests/regressions/lcos/future_serialization_1898.cpp
index 9d7fbb66f7..2ae4ab79b9 100644
--- a/tests/regressions/lcos/future_serialization_1898.cpp
+++ b/tests/regressions/lcos/future_serialization_1898.cpp
@@ -41,9 +41,9 @@ int main()
 {
     hpx::id_type loc = hpx::find_here();
     {
-        HPX_TEST(test_server::alive == 0);
+        HPX_TEST_EQ(test_server::alive, 0);
         hpx::id_type gid = hpx::new_<test_server>(loc).get();
-        HPX_TEST(test_server::alive == 1);
+        HPX_TEST_EQ(test_server::alive, 1);
 //         HPX_TEST(!hpx::naming::detail::gid_was_split(gid.get_gid()));
 
         auto remote_localities = hpx::find_remote_localities();
@@ -53,7 +53,7 @@ int main()
                 hpx::future<hpx::id_type> test_fid = hpx::make_ready_future(gid);
                 hpx::future<hpx::id_type> fid
                     = hpx::async(test_action(), loc, std::move(test_fid));
-                HPX_TEST(test_server::alive == 1);
+                HPX_TEST_EQ(test_server::alive, 1);
 
                 hpx::id_type new_gid = fid.get();
                 HPX_TEST_NEQ(
@@ -68,12 +68,12 @@ int main()
                 hpx::future<hpx::id_type> test_fid = pid.get_future();
                 hpx::future<hpx::id_type> fid
                     = hpx::async(test_action(), loc, std::move(test_fid));
-                HPX_TEST(test_server::alive == 1);
+                HPX_TEST_EQ(test_server::alive, 1);
 
                 hpx::this_thread::yield();
 
                 pid.set_value(gid);
-                HPX_TEST(test_server::alive == 1);
+                HPX_TEST_EQ(test_server::alive, 1);
 
                 hpx::id_type new_gid = fid.get();
                 HPX_TEST_NEQ(
@@ -83,9 +83,9 @@ int main()
             }
 
 
-            HPX_TEST(test_server::alive == 1);
+            HPX_TEST_EQ(test_server::alive, 1);
         }
-        HPX_TEST(test_server::alive == 1);
+        HPX_TEST_EQ(test_server::alive, 1);
     }
 
     return 0;
diff --git a/tests/regressions/lcos/future_timed_wait_1025.cpp b/tests/regressions/lcos/future_timed_wait_1025.cpp
index f1476073ab..795b442d6b 100644
--- a/tests/regressions/lcos/future_timed_wait_1025.cpp
+++ b/tests/regressions/lcos/future_timed_wait_1025.cpp
@@ -55,7 +55,7 @@ void test_wait_for()
 
     hpx::threads::thread_state thread_state =
         hpx::threads::get_thread_state(thread.native_handle());
-    HPX_TEST(thread_state.state() == hpx::threads::suspended);
+    HPX_TEST_EQ(thread_state.state(), hpx::threads::suspended);
 
     if (thread.joinable())
     {
@@ -79,7 +79,7 @@ void test_wait_until()
 
     hpx::threads::thread_state thread_state =
         hpx::threads::get_thread_state(thread.native_handle());
-    HPX_TEST(thread_state.state() == hpx::threads::suspended);
+    HPX_TEST_EQ(thread_state.state(), hpx::threads::suspended);
 
     if (thread.joinable())
     {
diff --git a/tests/regressions/lcos/receive_buffer_1733.cpp b/tests/regressions/lcos/receive_buffer_1733.cpp
index 52be26ca5f..5d56952ea8 100644
--- a/tests/regressions/lcos/receive_buffer_1733.cpp
+++ b/tests/regressions/lcos/receive_buffer_1733.cpp
@@ -29,7 +29,7 @@ inline std::size_t idx(std::size_t i, int dir)
     if (i == size - 1 && dir == +1)
         return 0;
 
-    HPX_TEST((i + dir) < size);
+    HPX_TEST_LT((i + dir), size);
 
     return i + dir;
 }
diff --git a/tests/regressions/lcos/shared_future_then_with_executor_3634.cpp b/tests/regressions/lcos/shared_future_then_with_executor_3634.cpp
index b4b6ca0767..c59f2610a4 100644
--- a/tests/regressions/lcos/shared_future_then_with_executor_3634.cpp
+++ b/tests/regressions/lcos/shared_future_then_with_executor_3634.cpp
@@ -11,7 +11,7 @@
 
 #include <hpx/lcos/future.hpp>
 
-#include <hpx/parallel/executors.hpp> // Workaround for a missing header file
+#include <hpx/execution/executors.hpp> // Workaround for a missing header file
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
 
 int main()
diff --git a/tests/regressions/multiple_init.cpp b/tests/regressions/multiple_init.cpp
index 9ffd14b0c0..2045454bb0 100644
--- a/tests/regressions/multiple_init.cpp
+++ b/tests/regressions/multiple_init.cpp
@@ -22,11 +22,11 @@ int main(int argc, char **argv)
 {
     // Everything is fine on the first call
     hpx::init(argc, argv);
-    HPX_TEST(invoked_init == 1);
+    HPX_TEST_EQ(invoked_init, 1);
 
     // Segfault on the call, now fixed
     hpx::init(argc, argv);
-    HPX_TEST(invoked_init == 2);
+    HPX_TEST_EQ(invoked_init, 2);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/regressions/performance_counters/CMakeLists.txt b/tests/regressions/performance_counters/CMakeLists.txt
deleted file mode 100644
index f6690aeb85..0000000000
--- a/tests/regressions/performance_counters/CMakeLists.txt
+++ /dev/null
@@ -1,43 +0,0 @@
-# Copyright (c) 2007-2015 Hartmut Kaiser
-# Copyright (c) 2013,2016 Maciej Brodowicz
-#
-# SPDX-License-Identifier: BSL-1.0
-# Distributed under the Boost Software License, Version 1.0. (See accompanying
-# file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-
-set(tests
-    discover_counters_1787
-    statistics_2666
-    uptime_1737)
-
-foreach(test ${tests})
-  set(sources
-      ${test}.cpp)
-
-  source_group("Source Files" FILES ${sources})
-
-  # add example executable
-  if(${test} MATCHES "^papi_.*")
-    add_hpx_executable(${test}_test
-      INTERNAL_FLAGS
-      SOURCES ${sources}
-      COMPONENT_DEPENDENCIES "papi_counters"
-      ${${test}_FLAGS}
-      EXCLUDE_FROM_ALL
-      HPX_PREFIX ${HPX_BUILD_PREFIX}
-      FOLDER "Tests/Regressions/PerformanceCounters")
-  else()
-    add_hpx_executable(${test}_test
-      INTERNAL_FLAGS
-      SOURCES ${sources}
-      ${${test}_FLAGS}
-      EXCLUDE_FROM_ALL
-      HPX_PREFIX ${HPX_BUILD_PREFIX}
-      FOLDER "Tests/Regressions/PerformanceCounters")
-  endif()
-
-  add_hpx_regression_test("performance_counters" ${test} ${${test}_PARAMETERS})
-
-endforeach()
-
-
diff --git a/tests/regressions/threads/block_os_threads_1036.cpp b/tests/regressions/threads/block_os_threads_1036.cpp
index 1c1f930424..48d00f9721 100644
--- a/tests/regressions/threads/block_os_threads_1036.cpp
+++ b/tests/regressions/threads/block_os_threads_1036.cpp
@@ -10,7 +10,7 @@
 #include <hpx/functional/bind.hpp>
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 #include <hpx/topology/topology.hpp>
@@ -106,7 +106,7 @@ int hpx_main()
         started.fetch_add(1);
 
         for (std::uint64_t i = 0; i < os_thread_count; ++i)
-            HPX_TEST(blocked_threads[i].load() <= 1);
+            HPX_TEST_LTE(blocked_threads[i].load(), std::uint64_t(1));
     }
 
     return hpx::finalize();
diff --git a/tests/regressions/threads/thread_rescheduling.cpp b/tests/regressions/threads/thread_rescheduling.cpp
index 346f9a0daf..e737518765 100644
--- a/tests/regressions/threads/thread_rescheduling.cpp
+++ b/tests/regressions/threads/thread_rescheduling.cpp
@@ -160,7 +160,7 @@ int hpx_main(variables_map& vm)
     {
         thread_id_type thread_id = register_thread_nullary(
             hpx::util::deferred_call(&test_dummy_thread, futures));
-        HPX_TEST(thread_id != hpx::threads::invalid_thread_id);
+        HPX_TEST_NEQ(thread_id, hpx::threads::invalid_thread_id);
 
         // Flood the queues with suspension operations before the rescheduling
         // attempt.
diff --git a/tests/regressions/traits/is_callable_1179.cpp b/tests/regressions/traits/is_callable_1179.cpp
index 89be1df2a4..6565863dc7 100644
--- a/tests/regressions/traits/is_callable_1179.cpp
+++ b/tests/regressions/traits/is_callable_1179.cpp
@@ -35,7 +35,7 @@ int main(int argc, char* argv[])
     HPX_TEST_MSG((is_callable<const_mem_fun_ptr(p)>::value == true),
         "const-mem-fun-ptr");
 
-    HPX_TEST(invoke(&s::f, p()) == 42);
+    HPX_TEST_EQ(invoke(&s::f, p()), 42);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/regressions/util/CMakeLists.txt b/tests/regressions/util/CMakeLists.txt
index dfa1f0364b..ba1479db6e 100644
--- a/tests/regressions/util/CMakeLists.txt
+++ b/tests/regressions/util/CMakeLists.txt
@@ -25,7 +25,7 @@ set(serialize_buffer_1069_FLAGS DEPENDENCIES iostreams_component)
 if(HPX_WITH_COMPRESSION_ZLIB)
   set(function_serialization_728_dependencies
     ${function_serialization_728_dependencies}
-    compress_zlib)
+    compression_zlib)
 endif()
 if(WITH_PARCEL_COALESCING)
   set(function_serialization_728_dependencies
diff --git a/tests/regressions/util/configuration_1572.cpp b/tests/regressions/util/configuration_1572.cpp
index f4b41b23e7..912425cca5 100644
--- a/tests/regressions/util/configuration_1572.cpp
+++ b/tests/regressions/util/configuration_1572.cpp
@@ -7,8 +7,7 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_init.hpp>
 #include <hpx/testing.hpp>
-
-#include <boost/lexical_cast.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <cstddef>
 #include <cstdint>
@@ -18,11 +17,11 @@ int hpx_main(int argc, char* argv[])
 {
     // check number of localities
     HPX_TEST_EQ(
-        boost::lexical_cast<std::uint32_t>(
+        hpx::util::from_string<std::uint32_t>(
             hpx::get_config_entry("hpx.localities", "")),
                 hpx::get_num_localities(hpx::launch::sync));
     HPX_TEST_EQ(
-        boost::lexical_cast<std::size_t>(
+        hpx::util::from_string<std::size_t>(
             hpx::get_config_entry("hpx.os_threads", "")),
                 hpx::get_os_thread_count());
     HPX_TEST_EQ(hpx::get_config_entry("hpx.runtime_mode", ""),
diff --git a/tests/regressions/util/function_serialization_728.cpp b/tests/regressions/util/function_serialization_728.cpp
index a62af5b55f..ff2d386d6f 100644
--- a/tests/regressions/util/function_serialization_728.cpp
+++ b/tests/regressions/util/function_serialization_728.cpp
@@ -11,7 +11,9 @@
 #include <hpx/include/actions.hpp>
 #include <hpx/include/async.hpp>
 #include <hpx/include/lcos.hpp>
-#include <hpx/include/compression_zlib.hpp>
+#ifdef HPX_HAVE_COMPRESSION_ZLIB
+  #include <hpx/include/compression_zlib.hpp>
+#endif
 #include <hpx/include/parcel_coalescing.hpp>
 #include <hpx/include/iostreams.hpp>
 #include <hpx/testing.hpp>
@@ -39,7 +41,9 @@ int pass_functor(hpx::util::function<int()> const& f)
 
 
 HPX_DECLARE_PLAIN_ACTION(pass_functor, pass_functor_action);
-HPX_ACTION_USES_ZLIB_COMPRESSION(pass_functor_action);
+#ifdef HPX_HAVE_COMPRESSION_ZLIB
+  HPX_ACTION_USES_ZLIB_COMPRESSION(pass_functor_action);
+#endif
 HPX_ACTION_USES_MESSAGE_COALESCING(pass_functor_action);
 HPX_PLAIN_ACTION(pass_functor, pass_functor_action);
 
diff --git a/tests/regressions/util/use_all_cores_2262.cpp b/tests/regressions/util/use_all_cores_2262.cpp
index 306785fdc9..1a0f3059cd 100644
--- a/tests/regressions/util/use_all_cores_2262.cpp
+++ b/tests/regressions/util/use_all_cores_2262.cpp
@@ -5,7 +5,7 @@
 //  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 // This test verifies that 'hpx.os_threads=all' is equivalent to specifying
-// all of the avalable cores (see #2262).
+// all of the available cores (see #2262).
 
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/threads.hpp>
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index c04d17a8f5..ac06acafa2 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -13,7 +13,6 @@ set(subdirs
     diagnostics
     lcos
     parallel_block
-    performance_counter
     resource
     threads
     topology
diff --git a/tests/unit/agas/components/CMakeLists.txt b/tests/unit/agas/components/CMakeLists.txt
index 6dea871792..e14fe3a731 100644
--- a/tests/unit/agas/components/CMakeLists.txt
+++ b/tests/unit/agas/components/CMakeLists.txt
@@ -8,6 +8,7 @@
 set(root "${PROJECT_SOURCE_DIR}/tests/unit/agas/components")
 
 add_hpx_component(simple_refcnt_checker
+  INTERNAL_FLAGS
   DEPENDENCIES iostreams_component
   HEADER_GLOB "${root}/simple_refcnt_checker.h*"
   SOURCE_GLOB "${root}/simple_refcnt_checker.c*"
@@ -16,6 +17,7 @@ add_hpx_component(simple_refcnt_checker
   AUTOGLOB)
 
 add_hpx_component(managed_refcnt_checker
+  INTERNAL_FLAGS
   DEPENDENCIES iostreams_component
   HEADER_GLOB "${root}/managed_refcnt_checker.h*"
   SOURCE_GLOB "${root}/managed_refcnt_checker.c*"
@@ -24,6 +26,7 @@ add_hpx_component(managed_refcnt_checker
   AUTOGLOB)
 
 add_hpx_component(simple_mobile_object
+  INTERNAL_FLAGS
   HEADER_GLOB "${root}/simple_mobile_object.h*"
   SOURCE_GLOB "${root}/simple_mobile_object.c*"
   FOLDER "Tests/Unit/AGAS"
diff --git a/tests/unit/agas/components/managed_refcnt_checker.hpp b/tests/unit/agas/components/managed_refcnt_checker.hpp
index c84c5729c0..9a57da92b6 100644
--- a/tests/unit/agas/components/managed_refcnt_checker.hpp
+++ b/tests/unit/agas/components/managed_refcnt_checker.hpp
@@ -12,8 +12,8 @@
 #include <hpx/hpx.hpp>
 #include <hpx/lcos/promise.hpp>
 #include <hpx/include/client.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 
 #include "stubs/managed_refcnt_checker.hpp"
 
diff --git a/tests/unit/agas/components/simple_refcnt_checker.hpp b/tests/unit/agas/components/simple_refcnt_checker.hpp
index a09ea3d0c1..a952466e54 100644
--- a/tests/unit/agas/components/simple_refcnt_checker.hpp
+++ b/tests/unit/agas/components/simple_refcnt_checker.hpp
@@ -12,8 +12,8 @@
 #include <hpx/hpx.hpp>
 #include <hpx/lcos/promise.hpp>
 #include <hpx/include/client.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/thread_data.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 
 #include "stubs/simple_refcnt_checker.hpp"
 
diff --git a/tests/unit/apex/apex_action_count.cpp b/tests/unit/apex/apex_action_count.cpp
index 9746305d43..e02c62f959 100644
--- a/tests/unit/apex/apex_action_count.cpp
+++ b/tests/unit/apex/apex_action_count.cpp
@@ -100,7 +100,7 @@ int main(int argc, char* argv[])
 
     std::cout << "Calls to fibonacci_action: " << count << std::endl;
     apex_profile * prof = apex::get_profile("fibonacci_action");
-    HPX_TEST(prof != 0);
+    HPX_TEST(prof != nullptr);
 
     // for some reason, the APEX count is off by 3, regardless of the N value.
     // This can be tested by running fibonacci of 0, 1, 2, and 3
diff --git a/tests/unit/build/CMakeLists.txt b/tests/unit/build/CMakeLists.txt
index 757f4887fb..7048708f00 100644
--- a/tests/unit/build/CMakeLists.txt
+++ b/tests/unit/build/CMakeLists.txt
@@ -11,12 +11,13 @@ if(NOT HPX_WITH_TESTS_EXTERNAL_BUILD)
 endif()
 
 # Try building an external cmake based project ...
-function(create_cmake_test name hpx_dir)
+function(create_cmake_test name hpx_dir setup_type)
   set(build_dir "${CMAKE_CURRENT_BINARY_DIR}/${name}")
   add_custom_target(${name}.make_build_dir
     COMMAND "${CMAKE_COMMAND}" -E make_directory "${build_dir}" VERBATIM
   )
   set(ADDITIONAL_CMAKE_OPTIONS)
+  set(ADDITIONAL_CMAKE_OPTIONS ${ADDITIONAL_CMAKE_OPTIONS} -DSETUP_TYPE=${setup_type})
   if(CMAKE_TOOLCHAIN_FILE)
     set(ADDITIONAL_CMAKE_OPTIONS -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE})
   endif()
@@ -100,12 +101,25 @@ function(create_pkgconfig_test name hpx_dir)
 endfunction()
 
 create_cmake_test(
-  cmake_build_dir_test
-  "${PROJECT_BINARY_DIR}/lib/cmake/${HPX_PACKAGE_NAME}")
+  cmake_build_dir_targets_test
+  "${PROJECT_BINARY_DIR}/lib/cmake/${HPX_PACKAGE_NAME}"
+  TARGETS)
 
 create_cmake_test(
-  cmake_install_dir_test
+  cmake_build_dir_macros_test
+  "${PROJECT_BINARY_DIR}/lib/cmake/${HPX_PACKAGE_NAME}"
+  MACROS)
+
+create_cmake_test(
+  cmake_install_dir_targets_test
   "${CMAKE_INSTALL_FULL_LIBDIR}/cmake/${HPX_PACKAGE_NAME}"
+  TARGETS
+)
+
+create_cmake_test(
+  cmake_install_dir_macros_test
+  "${CMAKE_INSTALL_FULL_LIBDIR}/cmake/${HPX_PACKAGE_NAME}"
+  MACROS
 )
 
 if(NOT MSVC)
@@ -121,21 +135,25 @@ if(NOT MSVC)
   endif()
 endif()
 
-set(tests
-  build_dir_
-  install_dir_)
-
 set(build_systems cmake)
+set(cmake_tests
+  build_dir_targets
+  build_dir_macros
+  install_dir_targets
+  install_dir_macros)
 if(NOT CMAKE_TOOLCHAIN_FILE AND PKGCONFIG_FOUND AND NOT MSVC)
   set(build_systems ${build_systems} pkgconfig)
+  set(pkgconfig_tests
+    build_dir
+    install_dir)
 endif()
 
 foreach(system ${build_systems})
   add_hpx_pseudo_target(tests.unit.build.${system})
-  foreach(test ${tests})
+  foreach(test ${${system}_tests})
     add_hpx_pseudo_target(tests.unit.build.${system}.${test})
     add_hpx_pseudo_dependencies(tests.unit.build.${system}.${test}
-      ${system}_${test}test)
+      ${system}_${test}_test)
     add_hpx_pseudo_dependencies(tests.unit.build.${system}
       tests.unit.build.${system}.${test})
   endforeach()
diff --git a/tests/unit/component/components/CMakeLists.txt b/tests/unit/component/components/CMakeLists.txt
index 7874f6c112..ced3f75307 100644
--- a/tests/unit/component/components/CMakeLists.txt
+++ b/tests/unit/component/components/CMakeLists.txt
@@ -6,6 +6,7 @@
 
 add_hpx_component(
   launch_process_test_server
+  INTERNAL_FLAGS
   FOLDER "Tests/Unit/Components"
   EXCLUDE_FROM_ALL
   AUTOGLOB)
diff --git a/tests/unit/component/local_new.cpp b/tests/unit/component/local_new.cpp
index c6f3ab7413..d76735b75f 100644
--- a/tests/unit/component/local_new.cpp
+++ b/tests/unit/component/local_new.cpp
@@ -59,13 +59,13 @@ struct test_client : hpx::components::client_base<test_client, test_server>
 void test_create_single_instance()
 {
     hpx::id_type id = hpx::local_new<test_server>().get();
-    HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+    HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
 
     hpx::id_type id1 = hpx::local_new<test_server>(hpx::launch::sync);
-    HPX_TEST(hpx::async<call_action>(id1).get() == hpx::find_here());
+    HPX_TEST_EQ(hpx::async<call_action>(id1).get(), hpx::find_here());
 
     test_client t1 = hpx::local_new<test_client>();
-    HPX_TEST(t1.call() == hpx::find_here());
+    HPX_TEST_EQ(t1.call(), hpx::find_here());
 }
 
 void test_create_single_instance_non_copyable_arg()
@@ -73,13 +73,13 @@ void test_create_single_instance_non_copyable_arg()
     A a;
 
     hpx::id_type id = hpx::local_new<test_server>(a).get();
-    HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+    HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
 
     hpx::id_type id1 = hpx::local_new<test_server>(hpx::launch::sync, a);
-    HPX_TEST(hpx::async<call_action>(id1).get() == hpx::find_here());
+    HPX_TEST_EQ(hpx::async<call_action>(id1).get(), hpx::find_here());
 
     test_client t1 = hpx::local_new<test_client>(a);
-    HPX_TEST(t1.call() == hpx::find_here());
+    HPX_TEST_EQ(t1.call(), hpx::find_here());
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -92,7 +92,7 @@ void test_create_multiple_instances()
 
         for (hpx::id_type const& id: ids)
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
         }
     }
 
@@ -103,7 +103,7 @@ void test_create_multiple_instances()
 
         for (hpx::id_type const& id: ids)
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
         }
     }
 
@@ -113,7 +113,7 @@ void test_create_multiple_instances()
 
         for (test_client const& c: ids)
         {
-            HPX_TEST(c.call() == hpx::find_here());
+            HPX_TEST_EQ(c.call(), hpx::find_here());
         }
     }
 }
diff --git a/tests/unit/component/migrate_component.cpp b/tests/unit/component/migrate_component.cpp
index 33c817938c..0d546d9f51 100644
--- a/tests/unit/component/migrate_component.cpp
+++ b/tests/unit/component/migrate_component.cpp
@@ -13,6 +13,7 @@
 #include <hpx/include/iostreams.hpp>
 #include <hpx/testing.hpp>
 
+#include <cstdint>
 #include <chrono>
 #include <cstddef>
 #include <utility>
@@ -68,66 +69,66 @@ struct test_server
 
     hpx::id_type call() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
         return hpx::find_here();
     }
 
     void busy_work() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
         hpx::this_thread::sleep_for(std::chrono::seconds(1));
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
     }
 
     hpx::future<void> lazy_busy_work() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
 
         auto f = hpx::make_ready_future_after(std::chrono::seconds(1));
 
         return f.then(
             [this](hpx::future<void> && f) -> void
             {
-                HPX_TEST(pin_count() != 0);
+                HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
                 f.get();
-                HPX_TEST(pin_count() != 0);
+                HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
             });
     }
 
     int get_data() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
         return data_;
     }
 
     hpx::future<int> lazy_get_data() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
 
         auto f = hpx::make_ready_future(data_);
 
         return f.then(
             [this](hpx::future<int> && f) -> int
             {
-                HPX_TEST(pin_count() != 0);
+                HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
                 auto result = f.get();
-                HPX_TEST(pin_count() != 0);
+                HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
                 return result;
             });
     }
 
     dummy_client lazy_get_client(hpx::id_type there) const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
 
         auto f = dummy_client(hpx::new_<dummy_server>(there));
 
         return f.then(
             [this](dummy_client && f) -> hpx::id_type
             {
-                HPX_TEST(pin_count() != 0);
+                HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
                 auto result = f.get();
-                HPX_TEST(pin_count() != 0);
+                HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
                 return result;
             });
     }
diff --git a/tests/unit/component/migrate_polymorphic_component.cpp b/tests/unit/component/migrate_polymorphic_component.cpp
index 2265333885..e2973c8af8 100644
--- a/tests/unit/component/migrate_polymorphic_component.cpp
+++ b/tests/unit/component/migrate_polymorphic_component.cpp
@@ -13,6 +13,7 @@
 #include <hpx/include/iostreams.hpp>
 #include <hpx/testing.hpp>
 
+#include <cstdint>
 #include <cstddef>
 #include <type_traits>
 #include <utility>
@@ -37,22 +38,22 @@ struct test_server_base
 
     void busy_work() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
         hpx::this_thread::sleep_for(std::chrono::seconds(1));
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
     }
     HPX_DEFINE_COMPONENT_ACTION(test_server_base, busy_work, busy_work_action);
 
     hpx::future<void> lazy_busy_work() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
 
         auto f = hpx::make_ready_future_after(std::chrono::seconds(1));
 
         return f.then([this](hpx::future<void>&& f) -> void {
-            HPX_TEST(pin_count() != 0);
+            HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
             f.get();
-            HPX_TEST(pin_count() != 0);
+            HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
         });
     }
     HPX_DEFINE_COMPONENT_ACTION(
@@ -60,7 +61,7 @@ struct test_server_base
 
     int get_base_data() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
         return base_data_;
     }
     HPX_DEFINE_COMPONENT_ACTION(
@@ -68,14 +69,14 @@ struct test_server_base
 
     hpx::future<int> lazy_get_base_data() const
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
 
         auto f = hpx::make_ready_future(base_data_);
 
         return f.then([this](hpx::future<int>&& f) -> int {
-            HPX_TEST(pin_count() != 0);
+            HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
             auto result = f.get();
-            HPX_TEST(pin_count() != 0);
+            HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
             return result;
         });
     }
@@ -175,20 +176,20 @@ struct test_server
 
     int get_data() const override
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
         return data_;
     }
 
     hpx::future<int> lazy_get_data() const override
     {
-        HPX_TEST(pin_count() != 0);
+        HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
 
         auto f = hpx::make_ready_future(data_);
 
         return f.then([this](hpx::future<int>&& f) -> int {
-            HPX_TEST(pin_count() != 0);
+            HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
             auto result = f.get();
-            HPX_TEST(pin_count() != 0);
+            HPX_TEST_NEQ(pin_count(), std::uint32_t(0));
             return result;
         });
     }
diff --git a/tests/unit/component/new_.cpp b/tests/unit/component/new_.cpp
index 7b2d9ff2e1..200fbcdfbf 100644
--- a/tests/unit/component/new_.cpp
+++ b/tests/unit/component/new_.cpp
@@ -51,32 +51,32 @@ void test_create_single_instance()
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         hpx::id_type id = hpx::new_<test_server>(loc).get();
-        HPX_TEST(hpx::async<call_action>(id).get() == loc);
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         test_client t1 = hpx::new_<test_client>(loc);
-        HPX_TEST(t1.call() == loc);
+        HPX_TEST_EQ(t1.call(), loc);
     }
 
     // make sure distribution policy is properly used
     hpx::id_type id = hpx::new_<test_server>(hpx::default_layout).get();
-    HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+    HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
 
     test_client t2 = hpx::new_<test_client>(hpx::default_layout);
-    HPX_TEST(t2.call() == hpx::find_here());
+    HPX_TEST_EQ(t2.call(), hpx::find_here());
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         hpx::id_type id = hpx::new_<test_server>(hpx::default_layout(loc)).get();
-        HPX_TEST(hpx::async<call_action>(id).get() == loc);
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
     {
         test_client t3 = hpx::new_<test_client>(hpx::default_layout(loc));
-        HPX_TEST(t3.call() == loc);
+        HPX_TEST_EQ(t3.call(), loc);
     }
 }
 
@@ -91,7 +91,7 @@ void test_create_multiple_instances()
 
         for (hpx::id_type const& id: ids)
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == loc);
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
         }
     }
 
@@ -102,7 +102,7 @@ void test_create_multiple_instances()
 
         for (test_client const& c: ids)
         {
-            HPX_TEST(c.call() == loc);
+            HPX_TEST_EQ(c.call(), loc);
         }
     }
 
@@ -112,7 +112,7 @@ void test_create_multiple_instances()
     HPX_TEST_EQ(ids.size(), std::size_t(10));
     for (hpx::id_type const& id: ids)
     {
-        HPX_TEST(hpx::async<call_action>(id).get() == hpx::find_here());
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), hpx::find_here());
     }
 
     std::vector<test_client> clients =
@@ -120,7 +120,7 @@ void test_create_multiple_instances()
     HPX_TEST_EQ(clients.size(), std::size_t(10));
     for (test_client const& c: clients)
     {
-        HPX_TEST(c.call() == hpx::find_here());
+        HPX_TEST_EQ(c.call(), hpx::find_here());
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
@@ -131,7 +131,7 @@ void test_create_multiple_instances()
 
         for (hpx::id_type const& id: ids)
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == loc);
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
         }
     }
 
@@ -143,7 +143,7 @@ void test_create_multiple_instances()
 
         for (test_client const& c: ids)
         {
-            HPX_TEST(c.call() == loc);
+            HPX_TEST_EQ(c.call(), loc);
         }
     }
 }
diff --git a/tests/unit/component/new_binpacking.cpp b/tests/unit/component/new_binpacking.cpp
index 65c51519fa..3c29c0174f 100644
--- a/tests/unit/component/new_binpacking.cpp
+++ b/tests/unit/component/new_binpacking.cpp
@@ -63,7 +63,7 @@ std::vector<hpx::id_type> test_binpacking_multiple()
         targets.push_back(hpx::new_<test_server[]>(loc, i + 1).get());
         for (hpx::id_type const& id: targets.back())
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == loc);
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
             keep_alive.push_back(id);
         }
     }
@@ -123,7 +123,7 @@ void test_binpacking_single()
         targets.push_back(hpx::new_<test_server[]>(loc, i+1).get());
         for (hpx::id_type const& id: targets.back())
         {
-            HPX_TEST(hpx::async<call_action>(id).get() == loc);
+            HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
         }
     }
 
diff --git a/tests/unit/component/new_colocated.cpp b/tests/unit/component/new_colocated.cpp
index 7009a597b0..03e7df68df 100644
--- a/tests/unit/component/new_colocated.cpp
+++ b/tests/unit/component/new_colocated.cpp
@@ -51,7 +51,7 @@ void test_create_single_instance()
         hpx::id_type target = hpx::new_<test_server>(loc).get();
         hpx::id_type id = hpx::new_<test_server>(hpx::colocated(target)).get();
 
-        HPX_TEST(hpx::async<call_action>(id).get() == loc);
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
@@ -59,7 +59,7 @@ void test_create_single_instance()
         test_client target = hpx::new_<test_client>(loc);
         hpx::id_type id = hpx::new_<test_server>(hpx::colocated(target)).get();
 
-        HPX_TEST(hpx::async<call_action>(id).get() == loc);
+        HPX_TEST_EQ(hpx::async<call_action>(id).get(), loc);
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
@@ -67,7 +67,7 @@ void test_create_single_instance()
         test_client target = hpx::new_<test_client>(loc);
         test_client t1 = hpx::new_<test_client>(hpx::colocated(target));
 
-        HPX_TEST(t1.call() == loc);
+        HPX_TEST_EQ(t1.call(), loc);
     }
 
     for (hpx::id_type const& loc: hpx::find_all_localities())
@@ -75,7 +75,7 @@ void test_create_single_instance()
         test_client target = hpx::new_<test_client>(loc);
         test_client t2 = hpx::new_<test_client>(hpx::colocated(target));
 
-        HPX_TEST(t2.call() == loc);
+        HPX_TEST_EQ(t2.call(), loc);
     }
 }
 
diff --git a/tests/unit/lcos/CMakeLists.txt b/tests/unit/lcos/CMakeLists.txt
index 485e549219..68c6742683 100644
--- a/tests/unit/lcos/CMakeLists.txt
+++ b/tests/unit/lcos/CMakeLists.txt
@@ -14,9 +14,11 @@ set(tests
     async_cb_colocated
     async_cb_remote
     async_cb_remote_client
+    async_colocated
     async_continue
     async_continue_cb
     async_continue_cb_colocated
+    async_continue_colocated
     async_local
     async_local_executor
     async_remote
diff --git a/tests/unit/lcos/apply_colocated.cpp b/tests/unit/lcos/apply_colocated.cpp
index def080c455..9940702e9c 100644
--- a/tests/unit/lcos/apply_colocated.cpp
+++ b/tests/unit/lcos/apply_colocated.cpp
@@ -123,7 +123,7 @@ int main(int argc, char* argv[])
         "HPX main exited with non-zero status");
 
     HPX_TEST_NEQ(std::uint32_t(-1), locality_id);
-    HPX_TEST(on_shutdown_executed || 0 != locality_id);
+    HPX_TEST_NEQ(on_shutdown_executed || 0, locality_id);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/lcos/async_colocated.cpp b/tests/unit/lcos/async_colocated.cpp
new file mode 100644
index 0000000000..505f993bc1
--- /dev/null
+++ b/tests/unit/lcos/async_colocated.cpp
@@ -0,0 +1,176 @@
+//  Copyright (c) 2007-2020 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/hpx_init.hpp>
+#include <hpx/include/traits.hpp>
+#include <hpx/include/lcos.hpp>
+#include <hpx/include/components.hpp>
+#include <hpx/include/async.hpp>
+#include <hpx/testing.hpp>
+
+#include <atomic>
+#include <chrono>
+#include <cstdint>
+#include <utility>
+#include <vector>
+
+///////////////////////////////////////////////////////////////////////////////
+std::int32_t increment(std::int32_t i)
+{
+    return i + 1;
+}
+HPX_PLAIN_ACTION(increment);
+
+std::int32_t increment_with_future(hpx::shared_future<std::int32_t> fi)
+{
+    return fi.get() + 1;
+}
+HPX_PLAIN_ACTION(increment_with_future);
+
+///////////////////////////////////////////////////////////////////////////////
+struct decrement_server
+  : hpx::components::managed_component_base<decrement_server>
+{
+    std::int32_t call(std::int32_t i) const
+    {
+        return i - 1;
+    }
+
+    HPX_DEFINE_COMPONENT_ACTION(decrement_server, call);
+};
+
+typedef hpx::components::managed_component<decrement_server> server_type;
+HPX_REGISTER_COMPONENT(server_type, decrement_server);
+
+typedef decrement_server::call_action call_action;
+HPX_REGISTER_ACTION_DECLARATION(call_action);
+HPX_REGISTER_ACTION(call_action);
+
+///////////////////////////////////////////////////////////////////////////////
+struct test_server : hpx::components::simple_component_base<test_server>
+{
+};
+
+typedef hpx::components::simple_component<test_server> test_server_type;
+HPX_REGISTER_COMPONENT(test_server_type, test_server);
+
+struct test_client : hpx::components::client_base<test_client, test_server>
+{
+    typedef hpx::components::client_base<test_client, test_server> base_type;
+
+    test_client(hpx::id_type const& id)
+      : base_type(id)
+    {}
+    test_client(hpx::future<hpx::id_type> && id)
+      : base_type(std::move(id))
+    {}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+void test_remote_async_colocated(test_client const& target)
+{
+    {
+        increment_action inc;
+
+        hpx::future<std::int32_t> f1 =
+            hpx::async(inc, hpx::colocated(target), 42);
+        HPX_TEST_EQ(f1.get(), 43);
+
+        hpx::future<std::int32_t> f2 =
+            hpx::async(hpx::launch::all, inc, hpx::colocated(target), 42);
+        HPX_TEST_EQ(f2.get(), 43);
+    }
+
+    {
+        increment_with_future_action inc;
+
+        hpx::promise<std::int32_t> p;
+        hpx::shared_future<std::int32_t> f = p.get_future();
+
+        hpx::future<std::int32_t> f1 =
+            hpx::async(inc, hpx::colocated(target), f);
+        hpx::future<std::int32_t> f2 =
+            hpx::async(hpx::launch::all, inc, hpx::colocated(target), f);
+
+        p.set_value(42);
+        HPX_TEST_EQ(f1.get(), 43);
+        HPX_TEST_EQ(f2.get(), 43);
+    }
+
+    {
+        hpx::future<std::int32_t> f1 =
+            hpx::async<increment_action>(hpx::colocated(target), 42);
+        HPX_TEST_EQ(f1.get(), 43);
+
+        hpx::future<std::int32_t> f2 = hpx::async<increment_action>(
+            hpx::launch::all, hpx::colocated(target), 42);
+        HPX_TEST_EQ(f2.get(), 43);
+    }
+
+    {
+        hpx::future<hpx::id_type> dec_f =
+            hpx::components::new_<decrement_server>(hpx::colocated(target));
+        hpx::id_type dec = dec_f.get();
+
+        call_action call;
+
+        hpx::future<std::int32_t> f1 = hpx::async(call, dec, 42);
+        HPX_TEST_EQ(f1.get(), 41);
+
+        hpx::future<std::int32_t> f2 =
+            hpx::async(hpx::launch::all, call, dec, 42);
+        HPX_TEST_EQ(f2.get(), 41);
+    }
+
+    {
+        hpx::future<hpx::id_type> dec_f =
+            hpx::components::new_<decrement_server>(hpx::colocated(target));
+        hpx::id_type dec = dec_f.get();
+
+        hpx::future<std::int32_t> f1 =
+            hpx::async<call_action>(dec, 42);
+        HPX_TEST_EQ(f1.get(), 41);
+
+        hpx::future<std::int32_t> f2 =
+            hpx::async<call_action>(hpx::launch::all, dec, 42);
+        HPX_TEST_EQ(f2.get(), 41);
+    }
+
+    {
+        increment_with_future_action inc;
+        hpx::shared_future<std::int32_t> f =
+            hpx::async(hpx::launch::deferred, hpx::util::bind(&increment, 42));
+
+        hpx::future<std::int32_t> f1 = hpx::async(
+            inc, hpx::colocated(target), f);
+        hpx::future<std::int32_t> f2 = hpx::async(
+            hpx::launch::all, inc, hpx::colocated(target), f);
+
+        HPX_TEST_EQ(f1.get(), 44);
+        HPX_TEST_EQ(f2.get(), 44);
+    }
+}
+
+int hpx_main()
+{
+    std::vector<hpx::id_type> localities = hpx::find_all_localities();
+    for (hpx::id_type const& id : localities)
+    {
+        test_client client(hpx::new_<test_client>(id));
+        test_remote_async_colocated(client);
+    }
+    return hpx::finalize();
+}
+
+int main(int argc, char* argv[])
+{
+    // Initialize and run HPX
+    HPX_TEST_EQ_MSG(hpx::init(argc, argv), 0,
+        "HPX main exited with non-zero status");
+
+    return hpx::util::report_errors();
+}
+
diff --git a/tests/unit/lcos/async_continue_colocated.cpp b/tests/unit/lcos/async_continue_colocated.cpp
new file mode 100644
index 0000000000..a6df1045ca
--- /dev/null
+++ b/tests/unit/lcos/async_continue_colocated.cpp
@@ -0,0 +1,151 @@
+//  Copyright (c) 2007-2015 Hartmut Kaiser
+//
+//  SPDX-License-Identifier: BSL-1.0
+//  Distributed under the Boost Software License, Version 1.0. (See accompanying
+//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#include <hpx/hpx_init.hpp>
+#include <hpx/include/components.hpp>
+#include <hpx/include/lcos.hpp>
+#include <hpx/include/apply.hpp>
+#include <hpx/include/async.hpp>
+#include <hpx/testing.hpp>
+
+#include <atomic>
+#include <chrono>
+#include <cstdint>
+#include <utility>
+#include <vector>
+
+///////////////////////////////////////////////////////////////////////////////
+std::int32_t increment(std::int32_t i)
+{
+    return i + 1;
+}
+HPX_PLAIN_ACTION(increment);  // defines increment_action
+
+std::int32_t increment_with_future(hpx::shared_future<std::int32_t> fi)
+{
+    return fi.get() + 1;
+}
+HPX_PLAIN_ACTION(increment_with_future);
+
+///////////////////////////////////////////////////////////////////////////////
+std::int32_t mult2(std::int32_t i)
+{
+    return i * 2;
+}
+HPX_PLAIN_ACTION(mult2);      // defines mult2_action
+
+///////////////////////////////////////////////////////////////////////////////
+struct test_server : hpx::components::simple_component_base<test_server>
+{
+};
+
+typedef hpx::components::simple_component<test_server> test_server_type;
+HPX_REGISTER_COMPONENT(test_server_type, test_server);
+
+struct test_client : hpx::components::client_base<test_client, test_server>
+{
+    typedef hpx::components::client_base<test_client, test_server> base_type;
+
+    test_client(hpx::id_type const& id)
+      : base_type(id)
+    {}
+    test_client(hpx::future<hpx::id_type> && id)
+      : base_type(std::move(id))
+    {}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+int test_async_continue_colocated(test_client const& target)
+{
+    using hpx::make_continuation;
+
+    increment_action inc;
+    increment_with_future_action inc_f;
+    mult2_action mult;
+
+    // test locally, fully equivalent to plain hpx::async
+    {
+        hpx::future<int> f1 = hpx::async_continue(
+            inc, make_continuation(), hpx::colocated(target), 42);
+        HPX_TEST_EQ(f1.get(), 43);
+
+        hpx::promise<std::int32_t> p;
+        hpx::shared_future<std::int32_t> f = p.get_future();
+
+        hpx::future<int> f2 = hpx::async_continue(
+            inc_f, make_continuation(), hpx::colocated(target), f);
+
+        p.set_value(42);
+        HPX_TEST_EQ(f2.get(), 43);
+    }
+
+    {
+        hpx::future<int> f1 = hpx::async_continue(
+            inc, make_continuation(), hpx::colocated(target), 42);
+        HPX_TEST_EQ(f1.get(), 43);
+
+        hpx::promise<std::int32_t> p;
+        hpx::shared_future<std::int32_t> f = p.get_future();
+
+        hpx::future<int> f2 = hpx::async_continue(
+            inc_f, make_continuation(), hpx::colocated(target), f);
+
+        p.set_value(42);
+        HPX_TEST_EQ(f2.get(), 43);
+    }
+
+    // test chaining locally
+    {
+        hpx::future<int> f = hpx::async_continue(
+            inc, make_continuation(mult), hpx::colocated(target), 42);
+        HPX_TEST_EQ(f.get(), 86);
+
+        f = hpx::async_continue(inc,
+            make_continuation(mult, make_continuation()),
+            hpx::colocated(target), 42);
+        HPX_TEST_EQ(f.get(), 86);
+
+        f = hpx::async_continue(inc,
+            make_continuation(mult, make_continuation(inc)),
+            hpx::colocated(target), 42);
+        HPX_TEST_EQ(f.get(), 87);
+
+        f = hpx::async_continue(inc,
+            make_continuation(mult, make_continuation(inc, make_continuation())),
+            hpx::colocated(target), 42);
+        HPX_TEST_EQ(f.get(), 87);
+    }
+
+    {
+        hpx::future<int> f = hpx::async_continue(inc,
+            make_continuation(mult, make_continuation()),
+            hpx::colocated(target), 42);
+        HPX_TEST_EQ(f.get(), 86);
+    }
+
+    return hpx::finalize();
+}
+
+int hpx_main()
+{
+    std::vector<hpx::id_type> localities = hpx::find_all_localities();
+    for (hpx::id_type const& id : localities)
+    {
+        test_client client(hpx::new_<test_client>(id));
+        test_async_continue_colocated(client);
+    }
+    return hpx::finalize();
+}
+
+int main(int argc, char* argv[])
+{
+    // Initialize and run HPX
+    HPX_TEST_EQ_MSG(hpx::init(argc, argv), 0,
+        "HPX main exited with non-zero status");
+
+    return hpx::util::report_errors();
+}
+
diff --git a/tests/unit/lcos/future.cpp b/tests/unit/lcos/future.cpp
index b74f4994e4..528a75b538 100644
--- a/tests/unit/lcos/future.cpp
+++ b/tests/unit/lcos/future.cpp
@@ -110,7 +110,7 @@ void test_initial_state()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::no_state);
+        HPX_TEST_EQ(e.get_error(), hpx::no_state);
     }
     catch (...) {
         HPX_TEST(false);
@@ -143,7 +143,7 @@ void test_cannot_get_future_twice()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::future_already_retrieved);
+        HPX_TEST_EQ(e.get_error(), hpx::future_already_retrieved);
     }
     catch (...) {
         HPX_TEST(false);
@@ -237,7 +237,7 @@ void test_invoking_a_packaged_task_twice_throws()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::promise_already_satisfied);
+        HPX_TEST_EQ(e.get_error(), hpx::promise_already_satisfied);
     }
     catch (...) {
         HPX_TEST(false);
@@ -259,7 +259,7 @@ void test_cannot_get_future_twice_from_task()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::future_already_retrieved);
+        HPX_TEST_EQ(e.get_error(), hpx::future_already_retrieved);
     }
     catch (...) {
         HPX_TEST(false);
@@ -472,7 +472,7 @@ void test_packaged_task_can_be_moved()
         HPX_TEST(!"Can invoke moved task!");
     }
     catch (hpx::exception const& e) {
-      HPX_TEST(e.get_error() == hpx::no_state);
+      HPX_TEST_EQ(e.get_error(), hpx::no_state);
     }
     catch (...) {
         HPX_TEST(false);
@@ -501,7 +501,7 @@ void test_destroying_a_promise_stores_broken_promise()
         HPX_TEST(false);    // shouldn't get here
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::broken_promise);
+        HPX_TEST_EQ(e.get_error(), hpx::broken_promise);
     }
     catch (...) {
         HPX_TEST(false);
@@ -524,7 +524,7 @@ void test_destroying_a_packaged_task_stores_broken_task()
         HPX_TEST(false);    // shouldn't get here
     }
     catch (hpx::exception const& e) {
-      HPX_TEST(e.get_error() == hpx::broken_promise);
+      HPX_TEST_EQ(e.get_error(), hpx::broken_promise);
     }
     catch (...) {
         HPX_TEST(false);
diff --git a/tests/unit/lcos/future_ref.cpp b/tests/unit/lcos/future_ref.cpp
index 72d4f2aeb3..42c02d4f34 100644
--- a/tests/unit/lcos/future_ref.cpp
+++ b/tests/unit/lcos/future_ref.cpp
@@ -19,28 +19,28 @@ void test_make_ready_future()
 {
     hpx::future<int&> f =
         hpx::make_ready_future(std::ref(global));
-    HPX_TEST(&f.get() == &global);
+    HPX_TEST_EQ(&f.get(), &global);
 
     hpx::future<int&> f_at =
         hpx::make_ready_future_at(
             std::chrono::system_clock::now() + std::chrono::seconds(1)
           , std::ref(global));
-    HPX_TEST(&f_at.get() == &global);
+    HPX_TEST_EQ(&f_at.get(), &global);
 
     hpx::future<int&> f_after =
         hpx::make_ready_future_after(
             std::chrono::seconds(1)
           , std::ref(global));
-    HPX_TEST(&f_after.get() == &global);
+    HPX_TEST_EQ(&f_after.get(), &global);
 }
 
 void test_async()
 {
     hpx::future<int&> f = hpx::async(&foo);
-    HPX_TEST(&f.get() == &global);
+    HPX_TEST_EQ(&f.get(), &global);
 
     hpx::future<int&> f_sync = hpx::async(hpx::launch::sync, &foo);
-    HPX_TEST(&f_sync.get() == &global);
+    HPX_TEST_EQ(&f_sync.get(), &global);
 }
 
 int main()
diff --git a/tests/unit/lcos/future_then.cpp b/tests/unit/lcos/future_then.cpp
index 6614079257..13c8703c5c 100644
--- a/tests/unit/lcos/future_then.cpp
+++ b/tests/unit/lcos/future_then.cpp
@@ -56,7 +56,7 @@ void test_return_int()
     hpx::future<int> f2 = f1.then(&p2);
     HPX_TEST(f2.valid());
     try {
-        HPX_TEST(f2.get() == 2);
+        HPX_TEST_EQ(f2.get(), 2);
     }
     catch (hpx::exception const& /*ex*/) {
         HPX_TEST(false);
@@ -73,7 +73,7 @@ void test_return_int_launch()
     hpx::future<int> f2 = f1.then(hpx::launch::async, &p2);
     HPX_TEST(f2.valid());
     try {
-        HPX_TEST(f2.get() == 2);
+        HPX_TEST_EQ(f2.get(), 2);
     }
     catch (hpx::exception const& /*ex*/) {
         HPX_TEST(false);
@@ -155,7 +155,7 @@ void test_complex_then()
     hpx::future<int> f1 = hpx::async(p1);
     hpx::future<int> f21 = f1.then(&p2);
     hpx::future<int> f2= f21.then(&p2);
-    HPX_TEST(f2.get() == 4);
+    HPX_TEST_EQ(f2.get(), 4);
 }
 
 void test_complex_then_launch()
@@ -169,7 +169,7 @@ void test_complex_then_launch()
     hpx::future<int> f1 = hpx::async(p1);
     hpx::future<int> f21 = f1.then(policy, &p2);
     hpx::future<int> f2= f21.then(policy, &p2);
-    HPX_TEST(f2.get() == 4);
+    HPX_TEST_EQ(f2.get(), 4);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/tests/unit/lcos/future_then_executor.cpp b/tests/unit/lcos/future_then_executor.cpp
index cb91a2197d..e53b7b2252 100644
--- a/tests/unit/lcos/future_then_executor.cpp
+++ b/tests/unit/lcos/future_then_executor.cpp
@@ -58,7 +58,7 @@ void test_return_int(Executor& exec)
     hpx::future<int> f2 = f1.then(exec, &p2);
     HPX_TEST(f2.valid());
     try {
-        HPX_TEST(f2.get() == 2);
+        HPX_TEST_EQ(f2.get(), 2);
     }
     catch (hpx::exception const& /*ex*/) {
         HPX_TEST(false);
@@ -96,7 +96,7 @@ void test_implicit_unwrapping(Executor& exec)
     hpx::future<int> f2 = f1.then(exec, &p4);
     HPX_TEST(f2.valid());
     try {
-        HPX_TEST(f2.get() == 2);
+        HPX_TEST_EQ(f2.get(), 2);
     }
     catch (hpx::exception const& /*ex*/) {
         HPX_TEST(false);
@@ -111,14 +111,14 @@ template <typename Executor>
 void test_simple_then(Executor& exec)
 {
     hpx::future<int> f2 = hpx::async(exec, p1).then(exec, &p2);
-    HPX_TEST(f2.get() == 2);
+    HPX_TEST_EQ(f2.get(), 2);
 }
 
 template <typename Executor>
 void test_simple_deferred_then(Executor& exec)
 {
     hpx::future<int> f2 = hpx::async(exec, p1).then(exec, &p2);
-    HPX_TEST(f2.get() == 2);
+    HPX_TEST_EQ(f2.get(), 2);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -128,7 +128,7 @@ void test_complex_then(Executor& exec)
     hpx::future<int> f1 = hpx::async(exec, p1);
     hpx::future<int> f21 = f1.then(exec, &p2);
     hpx::future<int> f2 = f21.then(exec, &p2);
-    HPX_TEST(f2.get() == 4);
+    HPX_TEST_EQ(f2.get(), 4);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -137,7 +137,7 @@ void test_complex_then_chain_one(Executor& exec)
 {
     hpx::future<int> f1 = hpx::async(exec, p1);
     hpx::future<int> f2 = f1.then(exec, &p2).then(exec, &p2);
-    HPX_TEST(f2.get() == 4);
+    HPX_TEST_EQ(f2.get(), 4);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/tests/unit/lcos/packaged_action.cpp b/tests/unit/lcos/packaged_action.cpp
index 17ec7baeaf..8ced82b3b8 100644
--- a/tests/unit/lcos/packaged_action.cpp
+++ b/tests/unit/lcos/packaged_action.cpp
@@ -65,7 +65,7 @@ int hpx_main(variables_map&)
 
         //test two successive 'get' from a promise
         hpx::lcos::shared_future<int> int_promise(async<int_action>(hpx::find_here()));
-        HPX_TEST(int_promise.get() == int_promise.get());
+        HPX_TEST_EQ(int_promise.get(), int_promise.get());
     }
 
     {
@@ -89,7 +89,7 @@ int hpx_main(variables_map&)
         //test two successive 'get' from a promise
         int_action do_int;
         hpx::lcos::shared_future<int> int_promise(async(do_int, hpx::find_here()));
-        HPX_TEST(int_promise.get() == int_promise.get());
+        HPX_TEST_EQ(int_promise.get(), int_promise.get());
     }
 
     hpx::finalize();       // Initiate shutdown of the runtime system.
diff --git a/tests/unit/lcos/remote_dataflow.cpp b/tests/unit/lcos/remote_dataflow.cpp
index 8343c09597..82f9530af7 100644
--- a/tests/unit/lcos/remote_dataflow.cpp
+++ b/tests/unit/lcos/remote_dataflow.cpp
@@ -46,8 +46,8 @@ void plain_actions(hpx::id_type const& there)
         hpx::future<hpx::id_type> f1 = hpx::dataflow(id_f_action(), there);
         hpx::future<hpx::id_type> f2 = hpx::dataflow<id_f_action>(there);
 
-        HPX_TEST(there == f1.get());
-        HPX_TEST(there == f2.get());
+        HPX_TEST_EQ(there, f1.get());
+        HPX_TEST_EQ(there, f2.get());
     }
 
     hpx::launch policies[] =
@@ -79,8 +79,8 @@ void plain_actions(hpx::id_type const& there)
             hpx::future<hpx::id_type> f2 = hpx::dataflow<id_f_action>(
                 policies[i], there);
 
-            HPX_TEST(there == f1.get());
-            HPX_TEST(there == f2.get());
+            HPX_TEST_EQ(there, f1.get());
+            HPX_TEST_EQ(there, f2.get());
         }
     }
 
@@ -119,8 +119,8 @@ void plain_actions(hpx::id_type const& there)
         hpx::future<hpx::id_type> f2 = hpx::dataflow<id_f_action>(
             policy2, there);
 
-        HPX_TEST(there == f1.get());
-        HPX_TEST(there == f2.get());
+        HPX_TEST_EQ(there, f1.get());
+        HPX_TEST_EQ(there, f2.get());
     }
 }
 
diff --git a/tests/unit/lcos/shared_future.cpp b/tests/unit/lcos/shared_future.cpp
index 17e08e4b81..5848c56ac7 100644
--- a/tests/unit/lcos/shared_future.cpp
+++ b/tests/unit/lcos/shared_future.cpp
@@ -91,7 +91,7 @@ void test_initial_state()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::no_state);
+        HPX_TEST_EQ(e.get_error(), hpx::no_state);
     }
     catch (...) {
         HPX_TEST(false);
@@ -124,7 +124,7 @@ void test_cannot_get_future_twice()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::future_already_retrieved);
+        HPX_TEST_EQ(e.get_error(), hpx::future_already_retrieved);
     }
     catch (...) {
         HPX_TEST(false);
@@ -216,7 +216,7 @@ void test_invoking_a_packaged_task_twice_throws()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::promise_already_satisfied);
+        HPX_TEST_EQ(e.get_error(), hpx::promise_already_satisfied);
     }
     catch (...) {
         HPX_TEST(false);
@@ -238,7 +238,7 @@ void test_cannot_get_future_twice_from_task()
         HPX_TEST(false);
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::future_already_retrieved);
+        HPX_TEST_EQ(e.get_error(), hpx::future_already_retrieved);
     }
     catch (...) {
         HPX_TEST(false);
@@ -537,7 +537,7 @@ void test_packaged_task_can_be_moved()
         HPX_TEST(!"Can invoke moved task!");
     }
     catch (hpx::exception const& e) {
-      HPX_TEST(e.get_error() == hpx::no_state);
+      HPX_TEST_EQ(e.get_error(), hpx::no_state);
     }
     catch (...) {
         HPX_TEST(false);
@@ -566,7 +566,7 @@ void test_destroying_a_promise_stores_broken_promise()
         HPX_TEST(false);    // shouldn't get here
     }
     catch (hpx::exception const& e) {
-        HPX_TEST(e.get_error() == hpx::broken_promise);
+        HPX_TEST_EQ(e.get_error(), hpx::broken_promise);
     }
     catch (...) {
         HPX_TEST(false);
@@ -589,7 +589,7 @@ void test_destroying_a_packaged_task_stores_broken_task()
         HPX_TEST(false);    // shouldn't get here
     }
     catch (hpx::exception const& e) {
-      HPX_TEST(e.get_error() == hpx::broken_promise);
+      HPX_TEST_EQ(e.get_error(), hpx::broken_promise);
     }
     catch (...) {
         HPX_TEST(false);
@@ -1262,7 +1262,7 @@ void test_wait_for_either_of_five_futures_5()
 //         hpx::lcos::shared_future<int>* const future =
 //              boost::wait_for_any(futures, futures+count);
 //
-//         HPX_TEST(future == (futures + i));
+//         HPX_TEST_EQ(future, (futures + i));
 //         for(unsigned j = 0; j < count; ++j)
 //         {
 //             if (j != i)
diff --git a/tests/unit/lcos/when_any.cpp b/tests/unit/lcos/when_any.cpp
index 33b47a380c..b2fb15b458 100644
--- a/tests/unit/lcos/when_any.cpp
+++ b/tests/unit/lcos/when_any.cpp
@@ -666,7 +666,7 @@ void test_wait_for_either_of_five_futures_5()
 //         hpx::lcos::future<int>* const future =
 //               boost::wait_for_any(futures, futures+count);
 //
-//         HPX_TEST(future == (futures + i));
+//         HPX_TEST_EQ(future, (futures + i));
 //         for(unsigned j = 0; j < count; ++j)
 //         {
 //             if (j != i)
diff --git a/tests/unit/lcos/when_each.cpp b/tests/unit/lcos/when_each.cpp
index f44d50017e..c476929e0b 100644
--- a/tests/unit/lcos/when_each.cpp
+++ b/tests/unit/lcos/when_each.cpp
@@ -41,7 +41,7 @@ void test_when_each_from_list()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -52,7 +52,7 @@ void test_when_each_from_list()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     Container futures1;
@@ -100,7 +100,7 @@ void test_when_each_from_list_iterators()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -111,7 +111,7 @@ void test_when_each_from_list_iterators()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     Container futures1;
@@ -163,7 +163,7 @@ void test_when_each_n_from_list_iterators()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < n);
+            HPX_TEST_LT(id, n);
         };
 
     auto callback_with_index_n =
@@ -174,7 +174,7 @@ void test_when_each_n_from_list_iterators()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < n);
+            HPX_TEST_LT(id, n);
         };
 
     Container futures1;
@@ -229,7 +229,7 @@ void test_when_each_one_future()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -240,7 +240,7 @@ void test_when_each_one_future()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     hpx::future<unsigned> f = hpx::make_ready_future(static_cast<unsigned>(0));
@@ -272,7 +272,7 @@ void test_when_each_two_futures()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -283,7 +283,7 @@ void test_when_each_two_futures()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     hpx::future<unsigned> f1 = hpx::make_ready_future(static_cast<unsigned>(0));
@@ -322,7 +322,7 @@ void test_when_each_three_futures()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -333,7 +333,7 @@ void test_when_each_three_futures()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     hpx::future<unsigned> f1 = hpx::make_ready_future(static_cast<unsigned>(0));
@@ -376,7 +376,7 @@ void test_when_each_four_futures()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -387,7 +387,7 @@ void test_when_each_four_futures()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     hpx::future<unsigned> f1 = hpx::make_ready_future(static_cast<unsigned>(0));
@@ -434,7 +434,7 @@ void test_when_each_five_futures()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -445,7 +445,7 @@ void test_when_each_five_futures()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     hpx::future<unsigned> f1 = hpx::make_ready_future(static_cast<unsigned>(0));
@@ -496,7 +496,7 @@ void test_when_each_late_future()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -507,7 +507,7 @@ void test_when_each_late_future()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     hpx::lcos::local::futures_factory<unsigned()> pt0(make_unsigned_slowly<0>);
@@ -563,7 +563,7 @@ void test_when_each_deferred_futures()
 
             unsigned id = fut.get();
 
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     auto callback_with_index =
@@ -574,7 +574,7 @@ void test_when_each_deferred_futures()
             unsigned id = fut.get();
 
             HPX_TEST_EQ(idx, id);
-            HPX_TEST(id < count);
+            HPX_TEST_LT(id, count);
         };
 
     hpx::lcos::future<unsigned> f1 =
diff --git a/tests/unit/parallel_block/spmd_block.cpp b/tests/unit/parallel_block/spmd_block.cpp
index fa901d6a51..a9cac00fca 100644
--- a/tests/unit/parallel_block/spmd_block.cpp
+++ b/tests/unit/parallel_block/spmd_block.cpp
@@ -8,7 +8,7 @@
 #include <hpx/hpx.hpp>
 #include <hpx/hpx_main.hpp>
 #include <hpx/parallel/spmd_block.hpp>
-#include <hpx/parallel/execution_policy.hpp>
+#include <hpx/execution/execution_policy.hpp>
 #include <hpx/testing.hpp>
 
 #include <array>
diff --git a/tests/unit/parcelset/put_parcels.cpp b/tests/unit/parcelset/put_parcels.cpp
index f7c4a5641b..851e494490 100644
--- a/tests/unit/parcelset/put_parcels.cpp
+++ b/tests/unit/parcelset/put_parcels.cpp
@@ -74,7 +74,7 @@ void test_plain_argument(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
@@ -124,7 +124,7 @@ void test_future_argument(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
@@ -181,7 +181,7 @@ void test_mixed_arguments(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
diff --git a/tests/unit/parcelset/put_parcels_with_coalescing.cpp b/tests/unit/parcelset/put_parcels_with_coalescing.cpp
index faa31790a3..743bc155d3 100644
--- a/tests/unit/parcelset/put_parcels_with_coalescing.cpp
+++ b/tests/unit/parcelset/put_parcels_with_coalescing.cpp
@@ -98,7 +98,7 @@ void test_plain_argument(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
@@ -150,7 +150,7 @@ void test_future_argument(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
@@ -209,7 +209,7 @@ void test_mixed_arguments(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
diff --git a/tests/unit/parcelset/put_parcels_with_compression.cpp b/tests/unit/parcelset/put_parcels_with_compression.cpp
index 555e7e2c00..e2921a4c14 100644
--- a/tests/unit/parcelset/put_parcels_with_compression.cpp
+++ b/tests/unit/parcelset/put_parcels_with_compression.cpp
@@ -106,7 +106,7 @@ void test_plain_argument(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
@@ -167,7 +167,7 @@ void test_future_argument(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
@@ -226,7 +226,7 @@ void test_mixed_arguments(hpx::id_type const& id)
 
     for (hpx::future<hpx::id_type>& f : results)
     {
-        HPX_TEST(f.get() == id);
+        HPX_TEST_EQ(f.get(), id);
     }
 }
 
@@ -261,7 +261,7 @@ void verify_counters()
         if (data_val != 0 && serialize_val != 0)
         {
             // compression should reduce the transmitted amount of data
-            HPX_TEST(data_val >= serialize_val);
+            HPX_TEST_LTE(serialize_val, data_val);
         }
 
         hpx::cout
diff --git a/tests/unit/resource/CMakeLists.txt b/tests/unit/resource/CMakeLists.txt
index 778bf05aa4..14b0fe8a3b 100644
--- a/tests/unit/resource/CMakeLists.txt
+++ b/tests/unit/resource/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (c) 2017 Hartmut Kaiser
+# Copyright (c) 2017-2020 Hartmut Kaiser
 #
 # SPDX-License-Identifier: BSL-1.0
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
@@ -14,19 +14,18 @@ set(tests
     suspend_thread
     suspend_thread_external
     suspend_thread_timed
-)
+  )
 
-# TODO: Enable unconditionally when C++14 is required.
-if (HPX_CXX_STANDARD GREATER 11)
+if(HPX_WITH_SHARED_PRIORITY_SCHEDULER)
   set(tests ${tests}
-    cross_pool_injection
-  )
+      cross_pool_injection
+    )
+  set(cross_pool_injection_PARAMETERS THREADS_PER_LOCALITY -1)
 endif()
 
 # NB. threads = -2 = threads = 'cores'
 # NB. threads = -1 = threads = 'all'
 
-set(cross_pool_injection_PARAMETERS THREADS_PER_LOCALITY -1)
 set(scheduler_priority_check_PARAMETERS THREADS_PER_LOCALITY -1)
 set(shutdown_suspended_pus_PARAMETERS THREADS_PER_LOCALITY 4)
 set(suspend_disabled_PARAMETERS THREADS_PER_LOCALITY 4)
diff --git a/tests/unit/resource/cross_pool_injection.cpp b/tests/unit/resource/cross_pool_injection.cpp
index 097ebee2cc..72d20d26bc 100644
--- a/tests/unit/resource/cross_pool_injection.cpp
+++ b/tests/unit/resource/cross_pool_injection.cpp
@@ -189,7 +189,7 @@ int hpx_main(int argc, char* /*argv*/[])
         std::size_t random_pool_2 = st_rand(0, num_pools - 1);
         auto& exec_7 = NP_executors[random_pool_1];
         auto& exec_8 = HP_executors[random_pool_2];
-        // random delay up to 5 miliseconds
+        // random delay up to 5 milliseconds
         std::size_t delay = st_rand(0, 5);
         auto f7 = hpx::async(exec_7, &dummy_task, delay);
         auto f8 = hpx::async(exec_8, [f7(std::move(f7)), &counter]() mutable {
@@ -255,6 +255,6 @@ int main(int argc, char* argv[])
     }
 
     // now run the test
-    HPX_TEST_EQ(hpx::init(), 0);
+    HPX_TEST_EQ(hpx::init(rp), 0);
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/resource/scheduler_priority_check.cpp b/tests/unit/resource/scheduler_priority_check.cpp
index 2f8269d782..ef83b7dbe4 100644
--- a/tests/unit/resource/scheduler_priority_check.cpp
+++ b/tests/unit/resource/scheduler_priority_check.cpp
@@ -19,7 +19,7 @@
 #include <hpx/program_options.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
 #include <hpx/testing.hpp>
-#include <hpx/util/annotated_function.hpp>
+#include <hpx/threading_base/annotated_function.hpp>
 
 #include <atomic>
 #include <cstddef>
@@ -207,7 +207,7 @@ int main(int argc, char* argv[])
     // Create the resource partitioner
     hpx::resource::partitioner rp(cmdline, argc, argv);
 
-    HPX_TEST_EQ(hpx::init(), 0);
+    HPX_TEST_EQ(hpx::init(rp), 0);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/resource/shutdown_suspended_pus.cpp b/tests/unit/resource/shutdown_suspended_pus.cpp
index edf7dfaa5a..fd3e981398 100644
--- a/tests/unit/resource/shutdown_suspended_pus.cpp
+++ b/tests/unit/resource/shutdown_suspended_pus.cpp
@@ -10,8 +10,8 @@
 #include <hpx/include/apply.hpp>
 #include <hpx/include/resource_partitioner.hpp>
 #include <hpx/include/threads.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/schedulers.hpp>
 #include <hpx/testing.hpp>
 
 #include <cstddef>
diff --git a/tests/unit/resource/suspend_pool.cpp b/tests/unit/resource/suspend_pool.cpp
index ddd41a99a7..6e50205b8d 100644
--- a/tests/unit/resource/suspend_pool.cpp
+++ b/tests/unit/resource/suspend_pool.cpp
@@ -13,9 +13,9 @@
 #include <hpx/include/threadmanager.hpp>
 #include <hpx/include/threads.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/schedulers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 
diff --git a/tests/unit/resource/suspend_pool_external.cpp b/tests/unit/resource/suspend_pool_external.cpp
index b4b35a7f2f..94a8b517cf 100644
--- a/tests/unit/resource/suspend_pool_external.cpp
+++ b/tests/unit/resource/suspend_pool_external.cpp
@@ -11,9 +11,9 @@
 #include <hpx/include/threadmanager.hpp>
 #include <hpx/include/threads.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
-#include <hpx/runtime/threads/thread_helpers.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/schedulers.hpp>
+#include <hpx/threading_base/thread_helpers.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 
diff --git a/tests/unit/resource/suspend_runtime.cpp b/tests/unit/resource/suspend_runtime.cpp
index e04605831e..7343530891 100644
--- a/tests/unit/resource/suspend_runtime.cpp
+++ b/tests/unit/resource/suspend_runtime.cpp
@@ -14,7 +14,7 @@
 #include <hpx/include/threads.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
-#include <hpx/util/yield_while.hpp>
+#include <hpx/basic_execution/this_thread.hpp>
 
 #include <cstddef>
 #include <string>
diff --git a/tests/unit/resource/suspend_thread.cpp b/tests/unit/resource/suspend_thread.cpp
index 6d0a31438e..a041960866 100644
--- a/tests/unit/resource/suspend_thread.cpp
+++ b/tests/unit/resource/suspend_thread.cpp
@@ -11,8 +11,8 @@
 #include <hpx/include/lcos.hpp>
 #include <hpx/include/resource_partitioner.hpp>
 #include <hpx/include/threads.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/schedulers.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 
diff --git a/tests/unit/resource/suspend_thread_external.cpp b/tests/unit/resource/suspend_thread_external.cpp
index a92a699067..73b9f3ca31 100644
--- a/tests/unit/resource/suspend_thread_external.cpp
+++ b/tests/unit/resource/suspend_thread_external.cpp
@@ -11,8 +11,8 @@
 #include <hpx/include/lcos.hpp>
 #include <hpx/include/resource_partitioner.hpp>
 #include <hpx/include/threads.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/schedulers.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 
diff --git a/tests/unit/resource/suspend_thread_timed.cpp b/tests/unit/resource/suspend_thread_timed.cpp
index 094b803db3..b471bb0b12 100644
--- a/tests/unit/resource/suspend_thread_timed.cpp
+++ b/tests/unit/resource/suspend_thread_timed.cpp
@@ -12,8 +12,8 @@
 #include <hpx/include/resource_partitioner.hpp>
 #include <hpx/include/threads.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/schedulers.hpp>
 #include <hpx/testing.hpp>
 #include <hpx/timing.hpp>
 
diff --git a/tests/unit/threads/error_callback.cpp b/tests/unit/threads/error_callback.cpp
index 31afc74daf..64604a447f 100644
--- a/tests/unit/threads/error_callback.cpp
+++ b/tests/unit/threads/error_callback.cpp
@@ -45,7 +45,7 @@ int main(int argc, char* argv[])
     }
 
     HPX_TEST(caught_exception);
-    HPX_TEST(count_error_handler == 1);
+    HPX_TEST_EQ(count_error_handler, std::size_t(1));
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/threads/lockfree_fifo.cpp b/tests/unit/threads/lockfree_fifo.cpp
index 30dc0e31a3..316fab9b87 100644
--- a/tests/unit/threads/lockfree_fifo.cpp
+++ b/tests/unit/threads/lockfree_fifo.cpp
@@ -121,7 +121,7 @@ int main(int argc, char** argv)
     }
 
     for (std::uint64_t i = 0; i < threads; ++i)
-        HPX_TEST(stolen[i] == 0);
+        HPX_TEST_EQ(stolen[i], std::uint64_t(0));
 
     for (std::uint64_t i = 0; i < threads; ++i)
         delete queues[i];
diff --git a/tests/unit/threads/resource_manager.cpp b/tests/unit/threads/resource_manager.cpp
index 62a088d159..0d6c64504f 100644
--- a/tests/unit/threads/resource_manager.cpp
+++ b/tests/unit/threads/resource_manager.cpp
@@ -29,7 +29,7 @@ namespace test
         dummy_parameters() = default;
     };
 
-    static dummy_parameters HPX_CONSTEXPR_OR_CONST dummy{};
+    static constexpr dummy_parameters dummy{};
 }
 
 namespace hpx { namespace parallel { namespace execution
diff --git a/tests/unit/threads/schedule_last.cpp b/tests/unit/threads/schedule_last.cpp
index 65da90152b..6497a53f84 100644
--- a/tests/unit/threads/schedule_last.cpp
+++ b/tests/unit/threads/schedule_last.cpp
@@ -8,8 +8,8 @@
 #include <hpx/include/async.hpp>
 #include <hpx/include/resource_partitioner.hpp>
 #include <hpx/include/threads.hpp>
-#include <hpx/runtime/threads/policies/scheduler_mode.hpp>
-#include <hpx/runtime/threads/policies/schedulers.hpp>
+#include <hpx/threading_base/scheduler_mode.hpp>
+#include <hpx/schedulers.hpp>
 #include <hpx/testing.hpp>
 
 #include <cstddef>
diff --git a/tests/unit/threads/start_stop_callbacks.cpp b/tests/unit/threads/start_stop_callbacks.cpp
index 1cc7613131..6189e478ce 100644
--- a/tests/unit/threads/start_stop_callbacks.cpp
+++ b/tests/unit/threads/start_stop_callbacks.cpp
@@ -7,6 +7,7 @@
 #include <hpx/hpx_init.hpp>
 #include <hpx/include/runtime.hpp>
 #include <hpx/testing.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <algorithm>
 #include <cstddef>
@@ -14,8 +15,6 @@
 #include <mutex>
 #include <string>
 
-#include <boost/lexical_cast.hpp>
-
 ///////////////////////////////////////////////////////////////////////////////
 std::mutex mtx;
 std::multimap<std::string, std::size_t> threads;
@@ -69,29 +68,29 @@ int hpx_main(int argc, char* argv[])
     std::lock_guard<std::mutex> l(mtx);
 
     auto p = threads.equal_range("main-thread");
-    HPX_TEST(std::distance(p.first, p.second) == 1);
+    HPX_TEST_EQ(std::distance(p.first, p.second), 1);
 
     p = threads.equal_range("worker-thread");
-    HPX_TEST(std::size_t(std::distance(p.first, p.second)) ==
+    HPX_TEST_EQ(std::size_t(std::distance(p.first, p.second)),
         hpx::get_num_worker_threads());
 
     p = threads.equal_range("timer-thread");
     auto cfg = hpx::get_config_entry("hpx.threadpools.timer_pool_size", "0");
-    HPX_TEST(std::distance(p.first, p.second) == boost::lexical_cast<int>(cfg));
+    HPX_TEST_EQ(std::distance(p.first, p.second), hpx::util::from_string<int>(cfg));
 
 #if defined(HPX_HAVE_NETWORKING)
     if (hpx::is_networking_enabled())
     {
         p = threads.equal_range("parcel-thread");
         cfg = hpx::get_config_entry("hpx.threadpools.parcel_pool_size", "0");
-        HPX_TEST(
-            std::distance(p.first, p.second) == boost::lexical_cast<int>(cfg));
+        HPX_TEST_EQ(
+            std::distance(p.first, p.second), hpx::util::from_string<int>(cfg));
     }
 #endif
 
     p = threads.equal_range("io-thread");
     cfg = hpx::get_config_entry("hpx.threadpools.io_pool_size", "0");
-    HPX_TEST(std::distance(p.first, p.second) == boost::lexical_cast<int>(cfg));
+    HPX_TEST_EQ(std::distance(p.first, p.second), hpx::util::from_string<int>(cfg));
 
     return hpx::finalize();
 }
diff --git a/tests/unit/threads/thread.cpp b/tests/unit/threads/thread.cpp
index 0aff69cb6f..928fec06c6 100644
--- a/tests/unit/threads/thread.cpp
+++ b/tests/unit/threads/thread.cpp
@@ -185,7 +185,7 @@ void do_test_thread_no_interrupt_if_interrupts_disabled_at_interruption_point()
     }
     catch (hpx::exception& e)
     {
-        HPX_TEST(e.get_error() == hpx::thread_not_interruptable);
+        HPX_TEST_EQ(e.get_error(), hpx::thread_not_interruptable);
         caught = true;
     }
 
@@ -316,12 +316,12 @@ void test_swap()
     hpx::thread::id id2 = t2.get_id();
 
     t1.swap(t2);
-    HPX_TEST(t1.get_id() == id2);
-    HPX_TEST(t2.get_id() == id1);
+    HPX_TEST_EQ(t1.get_id(), id2);
+    HPX_TEST_EQ(t2.get_id(), id1);
 
     swap(t1, t2);
-    HPX_TEST(t1.get_id() == id1);
-    HPX_TEST(t2.get_id() == id2);
+    HPX_TEST_EQ(t1.get_id(), id1);
+    HPX_TEST_EQ(t2.get_id(), id2);
 
     b2.wait();    // wait for the tests to be completed
 
@@ -345,7 +345,7 @@ void test_double_join()
     }
     catch (hpx::exception& e)
     {
-        HPX_TEST(e.get_error() == hpx::invalid_status);
+        HPX_TEST_EQ(e.get_error(), hpx::invalid_status);
         caught = true;
     }
 
diff --git a/tests/unit/threads/thread_affinity.cpp b/tests/unit/threads/thread_affinity.cpp
index 25675c7e06..22e3019633 100644
--- a/tests/unit/threads/thread_affinity.cpp
+++ b/tests/unit/threads/thread_affinity.cpp
@@ -62,7 +62,7 @@ std::size_t thread_affinity_worker(std::size_t desired)
             hwloc_cpuset_t cpuset_cmp = hwloc_bitmap_alloc();
             hwloc_bitmap_zero(cpuset_cmp);
             hwloc_bitmap_only(cpuset_cmp, unsigned(idx));
-            HPX_TEST(hwloc_bitmap_compare(cpuset, cpuset_cmp) == 0);
+            HPX_TEST_EQ(hwloc_bitmap_compare(cpuset, cpuset_cmp), 0);
             hwloc_bitmap_free(cpuset_cmp);
         }
         else
diff --git a/tests/unit/threads/thread_id.cpp b/tests/unit/threads/thread_id.cpp
index db7f6f91a8..4654d9cdc8 100644
--- a/tests/unit/threads/thread_id.cpp
+++ b/tests/unit/threads/thread_id.cpp
@@ -72,9 +72,9 @@ void test_thread_ids_have_a_total_order()
     hpx::thread::id t2_id = t2.get_id();
     hpx::thread::id t3_id = t3.get_id();
 
-    HPX_TEST(t1_id != t2_id);
-    HPX_TEST(t1_id != t3_id);
-    HPX_TEST(t2_id != t3_id);
+    HPX_TEST_NEQ(t1_id, t2_id);
+    HPX_TEST_NEQ(t1_id, t3_id);
+    HPX_TEST_NEQ(t2_id, t3_id);
 
     HPX_TEST((t1_id < t2_id) != (t2_id < t1_id));
     HPX_TEST((t1_id < t3_id) != (t3_id < t1_id));
@@ -107,27 +107,27 @@ void test_thread_ids_have_a_total_order()
 
     if((t1_id < t2_id) && (t2_id < t3_id))
     {
-        HPX_TEST(t1_id < t3_id);
+        HPX_TEST_LT(t1_id, t3_id);
     }
     else if((t1_id < t3_id) && (t3_id < t2_id))
     {
-        HPX_TEST(t1_id < t2_id);
+        HPX_TEST_LT(t1_id, t2_id);
     }
     else if((t2_id < t3_id) && (t3_id < t1_id))
     {
-        HPX_TEST(t2_id < t1_id);
+        HPX_TEST_LT(t2_id, t1_id);
     }
     else if((t2_id < t1_id) && (t1_id < t3_id))
     {
-        HPX_TEST(t2_id < t3_id);
+        HPX_TEST_LT(t2_id, t3_id);
     }
     else if((t3_id < t1_id) && (t1_id < t2_id))
     {
-        HPX_TEST(t3_id < t2_id);
+        HPX_TEST_LT(t3_id, t2_id);
     }
     else if((t3_id < t2_id) && (t2_id < t1_id))
     {
-        HPX_TEST(t3_id < t1_id);
+        HPX_TEST_LT(t3_id, t1_id);
     }
     else
     {
@@ -136,13 +136,13 @@ void test_thread_ids_have_a_total_order()
 
     hpx::thread::id default_id;
 
-    HPX_TEST(default_id < t1_id);
-    HPX_TEST(default_id < t2_id);
-    HPX_TEST(default_id < t3_id);
+    HPX_TEST_LT(default_id, t1_id);
+    HPX_TEST_LT(default_id, t2_id);
+    HPX_TEST_LT(default_id, t3_id);
 
-    HPX_TEST(default_id <= t1_id);
-    HPX_TEST(default_id <= t2_id);
-    HPX_TEST(default_id <= t3_id);
+    HPX_TEST_LTE(default_id, t1_id);
+    HPX_TEST_LTE(default_id, t2_id);
+    HPX_TEST_LTE(default_id, t3_id);
 
     HPX_TEST(!(default_id > t1_id));
     HPX_TEST(!(default_id > t2_id));
diff --git a/tests/unit/threads/thread_stacksize.cpp b/tests/unit/threads/thread_stacksize.cpp
index 598015d77b..fa9cdcbf4e 100644
--- a/tests/unit/threads/thread_stacksize.cpp
+++ b/tests/unit/threads/thread_stacksize.cpp
@@ -7,7 +7,7 @@
 #include <hpx/hpx_main.hpp>
 #include <hpx/include/actions.hpp>
 #include <hpx/include/runtime.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/testing.hpp>
 
 #include <cstring>
diff --git a/tests/unit/threads/thread_stacksize_overflow.cpp b/tests/unit/threads/thread_stacksize_overflow.cpp
index 6a72991a46..d5d5ed3848 100644
--- a/tests/unit/threads/thread_stacksize_overflow.cpp
+++ b/tests/unit/threads/thread_stacksize_overflow.cpp
@@ -8,7 +8,7 @@
 #include <hpx/hpx_main.hpp>
 #include <hpx/include/actions.hpp>
 #include <hpx/include/runtime.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/testing.hpp>
 
 #include <cstring>
diff --git a/tests/unit/threads/thread_stacksize_overflow_v2.cpp b/tests/unit/threads/thread_stacksize_overflow_v2.cpp
index 807c8ab2cc..4c3d5e4058 100644
--- a/tests/unit/threads/thread_stacksize_overflow_v2.cpp
+++ b/tests/unit/threads/thread_stacksize_overflow_v2.cpp
@@ -8,7 +8,7 @@
 #include <hpx/hpx_main.hpp>
 #include <hpx/include/actions.hpp>
 #include <hpx/include/runtime.hpp>
-#include <hpx/runtime/threads/thread_data.hpp>
+#include <hpx/threading_base/thread_data.hpp>
 #include <hpx/testing.hpp>
 
 #include <cstring>
diff --git a/tests/unit/topology/CMakeLists.txt b/tests/unit/topology/CMakeLists.txt
index 8a8a26b294..823b8664fc 100644
--- a/tests/unit/topology/CMakeLists.txt
+++ b/tests/unit/topology/CMakeLists.txt
@@ -4,7 +4,7 @@
 # Distributed under the Boost Software License, Version 1.0. (See accompanying
 # file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-if (HPX_WITH_SHARED_PRIORITY_SCHEDULER AND HPX_WITH_CXX14_RETURN_TYPE_DEDUCTION)
+if (HPX_WITH_SHARED_PRIORITY_SCHEDULER)
   set(tests ${tests}
     numa_allocator
   )
diff --git a/tests/unit/topology/allocator_binder_linear.hpp b/tests/unit/topology/allocator_binder_linear.hpp
index 0b4ef9df36..5102d1e42c 100644
--- a/tests/unit/topology/allocator_binder_linear.hpp
+++ b/tests/unit/topology/allocator_binder_linear.hpp
@@ -24,9 +24,9 @@ struct linear_numa_binder : hpx::compute::host::numa_binding_helper<T>
     explicit linear_numa_binder(std::size_t num_pages)
       : hpx::compute::host::numa_binding_helper<T>()
     {
-        const std::size_t cache_line_size = hpx::threads::get_cache_line_size();
-        const std::size_t page_size = hpx::threads::get_memory_page_size();
-        const std::size_t alignment = (std::max)(page_size, cache_line_size);
+        std::size_t const cache_line_size = hpx::threads::get_cache_line_size();
+        std::size_t const page_size = hpx::threads::get_memory_page_size();
+        std::size_t const alignment = (std::max)(page_size, cache_line_size);
         elements_page_ = (alignment / sizeof(T));
         N_ = num_pages * elements_page_;
     }
@@ -34,8 +34,8 @@ struct linear_numa_binder : hpx::compute::host::numa_binding_helper<T>
     // return the domain that a given page should be bound to
     virtual std::size_t operator()(const T* const base_ptr,
         const T* const page_ptr,
-        const std::size_t pagesize,
-        const std::size_t domains) const override
+        std::size_t const pagesize,
+        std::size_t const domains) const override
     {
         std::intptr_t offset = page_ptr - base_ptr;
         std::size_t index = (offset / elements_page_);
diff --git a/tests/unit/topology/allocator_binder_matrix.hpp b/tests/unit/topology/allocator_binder_matrix.hpp
index 2ee15dfbcd..6176bab165 100644
--- a/tests/unit/topology/allocator_binder_matrix.hpp
+++ b/tests/unit/topology/allocator_binder_matrix.hpp
@@ -33,10 +33,10 @@ struct matrix_numa_binder : hpx::compute::host::numa_binding_helper<T>
       , colprocs_(Ncolprocs)
       , rowprocs_(Nrowprocs)
     {
-        const int cache_line_size = hpx::threads::get_cache_line_size();
-        const int page_size = hpx::threads::get_memory_page_size();
-        const int alignment = (std::max)(page_size, cache_line_size);
-        const int elems_align = (alignment / sizeof(T));
+        int const cache_line_size = hpx::threads::get_cache_line_size();
+        int const page_size = hpx::threads::get_memory_page_size();
+        int const alignment = (std::max)(page_size, cache_line_size);
+        int const elems_align = (alignment / sizeof(T));
         rows_page_ = elems_align;
         leading_dim_ =
             elems_align * ((rows_ * sizeof(T) + alignment - 1) / alignment);
@@ -46,8 +46,8 @@ struct matrix_numa_binder : hpx::compute::host::numa_binding_helper<T>
     // return the domain that a given page should be bound to
     virtual std::size_t operator()(const T* const base_ptr,
         const T* const page_ptr,
-        const std::size_t pagesize,
-        const std::size_t domains) const override
+        std::size_t const pagesize,
+        std::size_t const domains) const override
     {
         std::intptr_t offset = page_ptr - base_ptr;
         std::size_t col = (offset / leading_dim_);
diff --git a/tests/unit/topology/numa_allocator.cpp b/tests/unit/topology/numa_allocator.cpp
index f9afcfa9ab..9b81477aaa 100644
--- a/tests/unit/topology/numa_allocator.cpp
+++ b/tests/unit/topology/numa_allocator.cpp
@@ -16,10 +16,10 @@
 #include <hpx/hpx_init.hpp>
 //
 #include <hpx/parallel/algorithms/for_loop.hpp>
-#include <hpx/parallel/executors.hpp>
+#include <hpx/execution/executors.hpp>
 //
 #include <hpx/resource_partitioner/partitioner.hpp>
-#include <hpx/runtime/threads/detail/scheduled_thread_pool_impl.hpp>
+#include <hpx/thread_pools/scheduled_thread_pool_impl.hpp>
 #include <hpx/runtime/threads/executors/guided_pool_executor.hpp>
 #include <hpx/runtime/threads/executors/pool_executor.hpp>
 #include <hpx/topology/cpu_mask.hpp>
@@ -42,7 +42,7 @@
 #include "allocator_binder_linear.hpp"
 #include "allocator_binder_matrix.hpp"
 // Scheduler that honours numa placement hints for tasks
-#include <hpx/runtime/threads/policies/shared_priority_queue_scheduler.hpp>
+#include <hpx/schedulers/shared_priority_queue_scheduler.hpp>
 
 // ------------------------------------------------------------------------
 // allocator maker for this test
@@ -284,6 +284,6 @@ int main(int argc, char* argv[])
             return pool;
         });
 
-    hpx::init();
+    hpx::init(rp);
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/bind/bind_const_test.cpp b/tests/unit/util/bind/bind_const_test.cpp
index 1a01a0456a..ed20f83da1 100644
--- a/tests/unit/util/bind/bind_const_test.cpp
+++ b/tests/unit/util/bind/bind_const_test.cpp
@@ -153,12 +153,12 @@ void function_test()
 {
     int const i = 1;
 
-    HPX_TEST( test( hpx::util::bind(f_0), i ) == 17041L );
-    HPX_TEST( test( hpx::util::bind(f_1, placeholders::_1), i ) == 1L );
-    HPX_TEST( test( hpx::util::bind(f_2, placeholders::_1, 2), i ) == 21L );
-    HPX_TEST( test( hpx::util::bind(f_3, placeholders::_1, 2, 3), i ) == 321L );
-    HPX_TEST( test( hpx::util::bind(f_4, placeholders::_1, 2, 3, 4), i ) == 4321L );
-    HPX_TEST( test( hpx::util::bind(f_5, placeholders::_1, 2, 3, 4, 5), i ) == 54321L );
+    HPX_TEST_EQ( test( hpx::util::bind(f_0), i ), 17041L );
+    HPX_TEST_EQ( test( hpx::util::bind(f_1, placeholders::_1), i ), 1L );
+    HPX_TEST_EQ( test( hpx::util::bind(f_2, placeholders::_1, 2), i ), 21L );
+    HPX_TEST_EQ( test( hpx::util::bind(f_3, placeholders::_1, 2, 3), i ), 321L );
+    HPX_TEST_EQ( test( hpx::util::bind(f_4, placeholders::_1, 2, 3, 4), i ), 4321L );
+    HPX_TEST_EQ( test( hpx::util::bind(f_5, placeholders::_1, 2, 3, 4, 5), i ), 54321L );
     HPX_TEST( test( hpx::util::bind(f_6, placeholders::_1, 2, 3, 4, 5,
         6), i ) == 654321L );
     HPX_TEST( test( hpx::util::bind(f_7, placeholders::_1, 2, 3, 4, 5,
@@ -168,11 +168,11 @@ void function_test()
     HPX_TEST( test( hpx::util::bind(f_9, placeholders::_1, 2, 3, 4, 5,
         6, 7, 8, 9), i ) == 987654321L );
 
-    HPX_TEST( testv( hpx::util::bind(fv_0), i ) == 17041L );
-    HPX_TEST( testv( hpx::util::bind(fv_1, placeholders::_1), i ) == 1L );
-    HPX_TEST( testv( hpx::util::bind(fv_2, placeholders::_1, 2), i ) == 21L );
-    HPX_TEST( testv( hpx::util::bind(fv_3, placeholders::_1, 2, 3), i ) == 321L );
-    HPX_TEST( testv( hpx::util::bind(fv_4, placeholders::_1, 2, 3, 4), i ) == 4321L );
+    HPX_TEST_EQ( testv( hpx::util::bind(fv_0), i ), 17041L );
+    HPX_TEST_EQ( testv( hpx::util::bind(fv_1, placeholders::_1), i ), 1L );
+    HPX_TEST_EQ( testv( hpx::util::bind(fv_2, placeholders::_1, 2), i ), 21L );
+    HPX_TEST_EQ( testv( hpx::util::bind(fv_3, placeholders::_1, 2, 3), i ), 321L );
+    HPX_TEST_EQ( testv( hpx::util::bind(fv_4, placeholders::_1, 2, 3, 4), i ), 4321L );
     HPX_TEST( testv( hpx::util::bind(fv_5, placeholders::_1, 2, 3, 4, 5),
         i ) == 54321L );
     HPX_TEST( testv( hpx::util::bind(fv_6, placeholders::_1, 2, 3, 4, 5,
diff --git a/tests/unit/util/bind/bind_cv_test.cpp b/tests/unit/util/bind/bind_cv_test.cpp
index 0c74a14b88..3021080644 100644
--- a/tests/unit/util/bind/bind_cv_test.cpp
+++ b/tests/unit/util/bind/bind_cv_test.cpp
@@ -148,8 +148,8 @@ struct X
 template<class F> void test(F f, int r)
 {
     F const & cf = f;
-    HPX_TEST( cf() == -r );
-    HPX_TEST( f() == r );
+    HPX_TEST_EQ( cf(), -r );
+    HPX_TEST_EQ( f(), r );
 }
 
 int main()
diff --git a/tests/unit/util/bind/bind_dm2_test.cpp b/tests/unit/util/bind/bind_dm2_test.cpp
index 115480f22f..269e358fe6 100644
--- a/tests/unit/util/bind/bind_dm2_test.cpp
+++ b/tests/unit/util/bind/bind_dm2_test.cpp
@@ -47,22 +47,22 @@ int main()
 
     hpx::util::bind( &X::m, placeholders::_1 )( px ) = 42;
 
-    HPX_TEST( x.m == 42 );
+    HPX_TEST_EQ( x.m, 42 );
 
     hpx::util::bind( &X::m, std::ref(x) )() = 17041;
 
-    HPX_TEST( x.m == 17041 );
+    HPX_TEST_EQ( x.m, 17041 );
 
     X const * pcx = &x;
 
-    HPX_TEST( hpx::util::bind( &X::m, placeholders::_1 )( pcx ) == 17041L );
-    HPX_TEST( hpx::util::bind( &X::m, pcx )() == 17041L );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, placeholders::_1 )( pcx ), 17041L );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, pcx )(), 17041L );
 
     Y y = { "test" };
     std::string v( "test" );
 
-    HPX_TEST( hpx::util::bind( &Y::m, &y )() == v );
-    HPX_TEST( hpx::util::bind( &Y::m, &y )() == v );
+    HPX_TEST_EQ( hpx::util::bind( &Y::m, &y )(), v );
+    HPX_TEST_EQ( hpx::util::bind( &Y::m, &y )(), v );
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/bind/bind_dm3_test.cpp b/tests/unit/util/bind/bind_dm3_test.cpp
index cd69cfc78f..e626b2a762 100644
--- a/tests/unit/util/bind/bind_dm3_test.cpp
+++ b/tests/unit/util/bind/bind_dm3_test.cpp
@@ -37,7 +37,7 @@ int main()
 
     int const & x = hpx::util::bind( &pair_type::first, placeholders::_1 )( pair );
 
-    HPX_TEST( &pair.first == &x );
+    HPX_TEST_EQ( &pair.first, &x );
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/bind/bind_dm_test.cpp b/tests/unit/util/bind/bind_dm_test.cpp
index 42c336f300..6220ac71a5 100644
--- a/tests/unit/util/bind/bind_dm_test.cpp
+++ b/tests/unit/util/bind/bind_dm_test.cpp
@@ -45,23 +45,23 @@ int main()
     X x = { 17041 };
     X * px = &x;
 
-    HPX_TEST( hpx::util::bind( &X::m, placeholders::_1 )( x ) == 17041 );
-    HPX_TEST( hpx::util::bind( &X::m, placeholders::_1 )( px ) == 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, placeholders::_1 )( x ), 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, placeholders::_1 )( px ), 17041 );
 
-    HPX_TEST( hpx::util::bind( &X::m, x )() == 17041 );
-    HPX_TEST( hpx::util::bind( &X::m, px )() == 17041 );
-    HPX_TEST( hpx::util::bind( &X::m, std::ref(x) )() == 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, x )(), 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, px )(), 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, std::ref(x) )(), 17041 );
 
 
     X const cx = x;
     X const * pcx = &cx;
 
-    HPX_TEST( hpx::util::bind( &X::m, placeholders::_1 )( cx ) == 17041 );
-    HPX_TEST( hpx::util::bind( &X::m, placeholders::_1 )( pcx ) == 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, placeholders::_1 )( cx ), 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, placeholders::_1 )( pcx ), 17041 );
 
-    HPX_TEST( hpx::util::bind( &X::m, cx )() == 17041 );
-    HPX_TEST( hpx::util::bind( &X::m, pcx )() == 17041 );
-    HPX_TEST( hpx::util::bind( &X::m, std::ref(cx) )() == 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, cx )(), 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, pcx )(), 17041 );
+    HPX_TEST_EQ( hpx::util::bind( &X::m, std::ref(cx) )(), 17041 );
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/bind/bind_rv_sp_test.cpp b/tests/unit/util/bind/bind_rv_sp_test.cpp
index 1245779b0b..098e4a6c4e 100644
--- a/tests/unit/util/bind/bind_rv_sp_test.cpp
+++ b/tests/unit/util/bind/bind_rv_sp_test.cpp
@@ -55,7 +55,7 @@ int main()
 {
     Y y;
 
-    HPX_TEST( hpx::util::bind( &X::f, hpx::util::bind( &Y::f, &y ) )() == 42 );
+    HPX_TEST_EQ( hpx::util::bind( &X::f, hpx::util::bind( &Y::f, &y ) )(), 42 );
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/bind/bind_stateful_test.cpp b/tests/unit/util/bind/bind_stateful_test.cpp
index cb329abd8f..d977cc9cca 100644
--- a/tests/unit/util/bind/bind_stateful_test.cpp
+++ b/tests/unit/util/bind/bind_stateful_test.cpp
@@ -150,9 +150,9 @@ int f8(int & state_, int x1, int x2, int x3, int x4, int x5, int x6, int x7, int
 
 template<class F> void test(F f, int a, int b)
 {
-    HPX_TEST( f() == a +   b );
-    HPX_TEST( f() == a + 2*b );
-    HPX_TEST( f() == a + 3*b );
+    HPX_TEST_EQ( f(), a +   b );
+    HPX_TEST_EQ( f(), a + 2*b );
+    HPX_TEST_EQ( f(), a + 3*b );
 }
 
 void stateful_function_object_test()
@@ -204,7 +204,7 @@ void stateful_function_object_test()
         6, 7, 8, 9 ), n, 1+2+3+4+5+6+7+8+9 );
     n += 3*(1+2+3+4+5+6+7+8+9);
 
-    HPX_TEST( x.state() == n );
+    HPX_TEST_EQ( x.state(), n );
 }
 
 void stateful_function_test()
diff --git a/tests/unit/util/bind/bind_test.cpp b/tests/unit/util/bind/bind_test.cpp
index c0a7212cf9..9f7b13c6c9 100644
--- a/tests/unit/util/bind/bind_test.cpp
+++ b/tests/unit/util/bind/bind_test.cpp
@@ -211,7 +211,7 @@ void function_object_test()
 
     global_result = 0;
     hpx::util::bind(Y(), i, placeholders::_1, 9, 4)(k);
-    HPX_TEST( global_result == 4938 );
+    HPX_TEST_EQ( global_result, 4938 );
 
 #endif
 }
@@ -231,7 +231,7 @@ void function_object_test2()
 
     global_result = 0;
     hpx::util::bind(Y(), i, placeholders::_1, 9, 4)(k);
-    HPX_TEST( global_result == 4938 );
+    HPX_TEST_EQ( global_result, 4938 );
 }
 
 //
@@ -246,7 +246,7 @@ struct Z
 
 void adaptable_function_object_test()
 {
-    HPX_TEST( hpx::util::bind(Z(), 7, 4)() == 47 );
+    HPX_TEST_EQ( hpx::util::bind(Z(), 7, 4)(), 47 );
 }
 
 #endif
@@ -432,7 +432,7 @@ void member_function_test()
     hpx::util::bind(&X::g8, x, 1, 2, 3, 4, 5, 6, 7, 8)();
     hpx::util::bind(&X::g8, ref(x), 1, 2, 3, 4, 5, 6, 7, 8)();
 
-    HPX_TEST( x.hash == 23558 );
+    HPX_TEST_EQ( x.hash, static_cast<unsigned int>(23558) );
 }
 
 void member_function_void_test()
@@ -522,7 +522,7 @@ void member_function_void_test()
     hpx::util::bind(&V::g8, v, 1, 2, 3, 4, 5, 6, 7, 8)();
     hpx::util::bind(&V::g8, ref(v), 1, 2, 3, 4, 5, 6, 7, 8)();
 
-    HPX_TEST( v.hash == 23558 );
+    HPX_TEST_EQ( v.hash, static_cast<unsigned int>(23558) );
 }
 
 void nested_bind_test()
diff --git a/tests/unit/util/config_entry.cpp b/tests/unit/util/config_entry.cpp
index eacf08be11..d7b1a84983 100644
--- a/tests/unit/util/config_entry.cpp
+++ b/tests/unit/util/config_entry.cpp
@@ -7,6 +7,7 @@
 #include <hpx/hpx_main.hpp>
 #include <hpx/runtime/config_entry.hpp>
 #include <hpx/testing.hpp>
+#include <hpx/util/from_string.hpp>
 
 #include <atomic>
 #include <string>
@@ -15,11 +16,11 @@ void test_get_entry()
 {
     std::string val = hpx::get_config_entry("hpx.localities", "42");
     HPX_TEST(!val.empty());
-    HPX_TEST_EQ(boost::lexical_cast<int>(val), 1);
+    HPX_TEST_EQ(hpx::util::from_string<int>(val), 1);
 
     val = hpx::get_config_entry("hpx.localities", 42);
     HPX_TEST(!val.empty());
-    HPX_TEST_EQ(boost::lexical_cast<int>(val), 1);
+    HPX_TEST_EQ(hpx::util::from_string<int>(val), 1);
 }
 
 std::atomic<bool> invoked_callback(false);
@@ -43,8 +44,8 @@ void test_set_entry()
     HPX_TEST(!val.empty());
     HPX_TEST_EQ(val, std::string("test"));
 
-    hpx::set_config_entry_callback("hpx.config.entry.test",
-        &config_entry_callback);
+    hpx::set_config_entry_callback(
+        "hpx.config.entry.test", &config_entry_callback);
 
     hpx::set_config_entry("hpx.config.entry.test", "test1");
     val = hpx::get_config_entry("hpx.config.entry.test", "");
diff --git a/tests/unit/util/mem_fn/mem_fn_derived_test.cpp b/tests/unit/util/mem_fn/mem_fn_derived_test.cpp
index 6cd291913f..b576c3d2d2 100644
--- a/tests/unit/util/mem_fn/mem_fn_derived_test.cpp
+++ b/tests/unit/util/mem_fn/mem_fn_derived_test.cpp
@@ -173,8 +173,8 @@ int main()
     hpx::util::mem_fn(&X::g8)(pcx, 1, 2, 3, 4, 5, 6, 7, 8);
     hpx::util::mem_fn(&X::g8)(sp, 1, 2, 3, 4, 5, 6, 7, 8);
 
-    HPX_TEST(hpx::util::mem_fn(&X::hash)(x) == 17610);
-    HPX_TEST(hpx::util::mem_fn(&X::hash)(sp) == 2155);
+    HPX_TEST_EQ(hpx::util::mem_fn(&X::hash)(x), 17610u);
+    HPX_TEST_EQ(hpx::util::mem_fn(&X::hash)(sp), 2155u);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/mem_fn/mem_fn_dm_test.cpp b/tests/unit/util/mem_fn/mem_fn_dm_test.cpp
index dec506fada..627e32d7af 100644
--- a/tests/unit/util/mem_fn/mem_fn_dm_test.cpp
+++ b/tests/unit/util/mem_fn/mem_fn_dm_test.cpp
@@ -38,26 +38,26 @@ int main()
 
     hpx::util::mem_fn( &X::m )( x ) = 401;
 
-    HPX_TEST( x.m == 401 );
-    HPX_TEST( hpx::util::mem_fn( &X::m )( x ) == 401 );
+    HPX_TEST_EQ( x.m, 401 );
+    HPX_TEST_EQ( hpx::util::mem_fn( &X::m )( x ), 401 );
 
     hpx::util::mem_fn( &X::m )( &x ) = 502;
 
-    HPX_TEST( x.m == 502 );
-    HPX_TEST( hpx::util::mem_fn( &X::m )( &x ) == 502 );
+    HPX_TEST_EQ( x.m, 502 );
+    HPX_TEST_EQ( hpx::util::mem_fn( &X::m )( &x ), 502 );
 
     X * px = &x;
 
     hpx::util::mem_fn( &X::m )( px ) = 603;
 
-    HPX_TEST( x.m == 603 );
-    HPX_TEST( hpx::util::mem_fn( &X::m )( px ) == 603 );
+    HPX_TEST_EQ( x.m, 603 );
+    HPX_TEST_EQ( hpx::util::mem_fn( &X::m )( px ), 603 );
 
     X const & cx = x;
     X const * pcx = &x;
 
-    HPX_TEST( hpx::util::mem_fn( &X::m )( cx ) == 603 );
-    HPX_TEST( hpx::util::mem_fn( &X::m )( pcx ) == 603 );
+    HPX_TEST_EQ( hpx::util::mem_fn( &X::m )( cx ), 603 );
+    HPX_TEST_EQ( hpx::util::mem_fn( &X::m )( pcx ), 603 );
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/mem_fn/mem_fn_eq_test.cpp b/tests/unit/util/mem_fn/mem_fn_eq_test.cpp
index 3e256cfe8a..1bf0def505 100644
--- a/tests/unit/util/mem_fn/mem_fn_eq_test.cpp
+++ b/tests/unit/util/mem_fn/mem_fn_eq_test.cpp
@@ -161,134 +161,134 @@ struct X
 
 int main()
 {
-    HPX_TEST( hpx::util::mem_fn(&X::dm_1) == hpx::util::mem_fn(&X::dm_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::dm_1) != hpx::util::mem_fn(&X::dm_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::dm_1), hpx::util::mem_fn(&X::dm_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::dm_1), hpx::util::mem_fn(&X::dm_2) );
 
     // 0
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf0_1) == hpx::util::mem_fn(&X::mf0_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf0_1) != hpx::util::mem_fn(&X::mf0_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf0_1), hpx::util::mem_fn(&X::mf0_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf0_1), hpx::util::mem_fn(&X::mf0_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf0_1) == hpx::util::mem_fn(&X::cmf0_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf0_1) != hpx::util::mem_fn(&X::cmf0_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf0_1), hpx::util::mem_fn(&X::cmf0_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf0_1), hpx::util::mem_fn(&X::cmf0_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf0v_1) == hpx::util::mem_fn(&X::mf0v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf0v_1) != hpx::util::mem_fn(&X::mf0v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf0v_1), hpx::util::mem_fn(&X::mf0v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf0v_1), hpx::util::mem_fn(&X::mf0v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf0v_1) == hpx::util::mem_fn(&X::cmf0v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf0v_1) != hpx::util::mem_fn(&X::cmf0v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf0v_1), hpx::util::mem_fn(&X::cmf0v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf0v_1), hpx::util::mem_fn(&X::cmf0v_2) );
 
     // 1
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf1_1) == hpx::util::mem_fn(&X::mf1_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf1_1) != hpx::util::mem_fn(&X::mf1_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf1_1), hpx::util::mem_fn(&X::mf1_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf1_1), hpx::util::mem_fn(&X::mf1_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf1_1) == hpx::util::mem_fn(&X::cmf1_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf1_1) != hpx::util::mem_fn(&X::cmf1_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf1_1), hpx::util::mem_fn(&X::cmf1_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf1_1), hpx::util::mem_fn(&X::cmf1_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf1v_1) == hpx::util::mem_fn(&X::mf1v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf1v_1) != hpx::util::mem_fn(&X::mf1v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf1v_1), hpx::util::mem_fn(&X::mf1v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf1v_1), hpx::util::mem_fn(&X::mf1v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf1v_1) == hpx::util::mem_fn(&X::cmf1v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf1v_1) != hpx::util::mem_fn(&X::cmf1v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf1v_1), hpx::util::mem_fn(&X::cmf1v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf1v_1), hpx::util::mem_fn(&X::cmf1v_2) );
 
     // 2
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf2_1) == hpx::util::mem_fn(&X::mf2_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf2_1) != hpx::util::mem_fn(&X::mf2_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf2_1), hpx::util::mem_fn(&X::mf2_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf2_1), hpx::util::mem_fn(&X::mf2_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf2_1) == hpx::util::mem_fn(&X::cmf2_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf2_1) != hpx::util::mem_fn(&X::cmf2_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf2_1), hpx::util::mem_fn(&X::cmf2_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf2_1), hpx::util::mem_fn(&X::cmf2_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf2v_1) == hpx::util::mem_fn(&X::mf2v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf2v_1) != hpx::util::mem_fn(&X::mf2v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf2v_1), hpx::util::mem_fn(&X::mf2v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf2v_1), hpx::util::mem_fn(&X::mf2v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf2v_1) == hpx::util::mem_fn(&X::cmf2v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf2v_1) != hpx::util::mem_fn(&X::cmf2v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf2v_1), hpx::util::mem_fn(&X::cmf2v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf2v_1), hpx::util::mem_fn(&X::cmf2v_2) );
 
     // 3
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf3_1) == hpx::util::mem_fn(&X::mf3_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf3_1) != hpx::util::mem_fn(&X::mf3_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf3_1), hpx::util::mem_fn(&X::mf3_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf3_1), hpx::util::mem_fn(&X::mf3_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf3_1) == hpx::util::mem_fn(&X::cmf3_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf3_1) != hpx::util::mem_fn(&X::cmf3_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf3_1), hpx::util::mem_fn(&X::cmf3_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf3_1), hpx::util::mem_fn(&X::cmf3_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf3v_1) == hpx::util::mem_fn(&X::mf3v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf3v_1) != hpx::util::mem_fn(&X::mf3v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf3v_1), hpx::util::mem_fn(&X::mf3v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf3v_1), hpx::util::mem_fn(&X::mf3v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf3v_1) == hpx::util::mem_fn(&X::cmf3v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf3v_1) != hpx::util::mem_fn(&X::cmf3v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf3v_1), hpx::util::mem_fn(&X::cmf3v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf3v_1), hpx::util::mem_fn(&X::cmf3v_2) );
 
     // 4
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf4_1) == hpx::util::mem_fn(&X::mf4_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf4_1) != hpx::util::mem_fn(&X::mf4_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf4_1), hpx::util::mem_fn(&X::mf4_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf4_1), hpx::util::mem_fn(&X::mf4_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf4_1) == hpx::util::mem_fn(&X::cmf4_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf4_1) != hpx::util::mem_fn(&X::cmf4_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf4_1), hpx::util::mem_fn(&X::cmf4_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf4_1), hpx::util::mem_fn(&X::cmf4_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf4v_1) == hpx::util::mem_fn(&X::mf4v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf4v_1) != hpx::util::mem_fn(&X::mf4v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf4v_1), hpx::util::mem_fn(&X::mf4v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf4v_1), hpx::util::mem_fn(&X::mf4v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf4v_1) == hpx::util::mem_fn(&X::cmf4v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf4v_1) != hpx::util::mem_fn(&X::cmf4v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf4v_1), hpx::util::mem_fn(&X::cmf4v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf4v_1), hpx::util::mem_fn(&X::cmf4v_2) );
 
     // 5
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf5_1) == hpx::util::mem_fn(&X::mf5_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf5_1) != hpx::util::mem_fn(&X::mf5_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf5_1), hpx::util::mem_fn(&X::mf5_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf5_1), hpx::util::mem_fn(&X::mf5_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf5_1) == hpx::util::mem_fn(&X::cmf5_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf5_1) != hpx::util::mem_fn(&X::cmf5_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf5_1), hpx::util::mem_fn(&X::cmf5_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf5_1), hpx::util::mem_fn(&X::cmf5_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf5v_1) == hpx::util::mem_fn(&X::mf5v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf5v_1) != hpx::util::mem_fn(&X::mf5v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf5v_1), hpx::util::mem_fn(&X::mf5v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf5v_1), hpx::util::mem_fn(&X::mf5v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf5v_1) == hpx::util::mem_fn(&X::cmf5v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf5v_1) != hpx::util::mem_fn(&X::cmf5v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf5v_1), hpx::util::mem_fn(&X::cmf5v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf5v_1), hpx::util::mem_fn(&X::cmf5v_2) );
 
     // 6
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf6_1) == hpx::util::mem_fn(&X::mf6_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf6_1) != hpx::util::mem_fn(&X::mf6_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf6_1), hpx::util::mem_fn(&X::mf6_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf6_1), hpx::util::mem_fn(&X::mf6_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf6_1) == hpx::util::mem_fn(&X::cmf6_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf6_1) != hpx::util::mem_fn(&X::cmf6_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf6_1), hpx::util::mem_fn(&X::cmf6_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf6_1), hpx::util::mem_fn(&X::cmf6_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf6v_1) == hpx::util::mem_fn(&X::mf6v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf6v_1) != hpx::util::mem_fn(&X::mf6v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf6v_1), hpx::util::mem_fn(&X::mf6v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf6v_1), hpx::util::mem_fn(&X::mf6v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf6v_1) == hpx::util::mem_fn(&X::cmf6v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf6v_1) != hpx::util::mem_fn(&X::cmf6v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf6v_1), hpx::util::mem_fn(&X::cmf6v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf6v_1), hpx::util::mem_fn(&X::cmf6v_2) );
 
     // 7
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf7_1) == hpx::util::mem_fn(&X::mf7_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf7_1) != hpx::util::mem_fn(&X::mf7_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf7_1), hpx::util::mem_fn(&X::mf7_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf7_1), hpx::util::mem_fn(&X::mf7_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf7_1) == hpx::util::mem_fn(&X::cmf7_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf7_1) != hpx::util::mem_fn(&X::cmf7_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf7_1), hpx::util::mem_fn(&X::cmf7_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf7_1), hpx::util::mem_fn(&X::cmf7_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf7v_1) == hpx::util::mem_fn(&X::mf7v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf7v_1) != hpx::util::mem_fn(&X::mf7v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf7v_1), hpx::util::mem_fn(&X::mf7v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf7v_1), hpx::util::mem_fn(&X::mf7v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf7v_1) == hpx::util::mem_fn(&X::cmf7v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf7v_1) != hpx::util::mem_fn(&X::cmf7v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf7v_1), hpx::util::mem_fn(&X::cmf7v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf7v_1), hpx::util::mem_fn(&X::cmf7v_2) );
 
     // 8
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf8_1) == hpx::util::mem_fn(&X::mf8_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf8_1) != hpx::util::mem_fn(&X::mf8_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf8_1), hpx::util::mem_fn(&X::mf8_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf8_1), hpx::util::mem_fn(&X::mf8_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf8_1) == hpx::util::mem_fn(&X::cmf8_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf8_1) != hpx::util::mem_fn(&X::cmf8_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf8_1), hpx::util::mem_fn(&X::cmf8_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf8_1), hpx::util::mem_fn(&X::cmf8_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::mf8v_1) == hpx::util::mem_fn(&X::mf8v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::mf8v_1) != hpx::util::mem_fn(&X::mf8v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::mf8v_1), hpx::util::mem_fn(&X::mf8v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::mf8v_1), hpx::util::mem_fn(&X::mf8v_2) );
 
-    HPX_TEST( hpx::util::mem_fn(&X::cmf8v_1) == hpx::util::mem_fn(&X::cmf8v_1) );
-    HPX_TEST( hpx::util::mem_fn(&X::cmf8v_1) != hpx::util::mem_fn(&X::cmf8v_2) );
+    HPX_TEST_EQ( hpx::util::mem_fn(&X::cmf8v_1), hpx::util::mem_fn(&X::cmf8v_1) );
+    HPX_TEST_NEQ( hpx::util::mem_fn(&X::cmf8v_1), hpx::util::mem_fn(&X::cmf8v_2) );
 
 
     return hpx::util::report_errors();
diff --git a/tests/unit/util/mem_fn/mem_fn_rv_test.cpp b/tests/unit/util/mem_fn/mem_fn_rv_test.cpp
index 6e6c9f3ab5..e8bac2cf4c 100644
--- a/tests/unit/util/mem_fn/mem_fn_rv_test.cpp
+++ b/tests/unit/util/mem_fn/mem_fn_rv_test.cpp
@@ -103,7 +103,7 @@ int main()
     hpx::util::mem_fn(&X::f8)(make(), 1, 2, 3, 4, 5, 6, 7, 8);
     hpx::util::mem_fn(&X::g8)(make(), 1, 2, 3, 4, 5, 6, 7, 8);
 
-    HPX_TEST(hash == 2155);
+    HPX_TEST_EQ(hash, 2155u);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/mem_fn/mem_fn_test.cpp b/tests/unit/util/mem_fn/mem_fn_test.cpp
index a320ab1e78..72f17d4bf0 100644
--- a/tests/unit/util/mem_fn/mem_fn_test.cpp
+++ b/tests/unit/util/mem_fn/mem_fn_test.cpp
@@ -169,8 +169,8 @@ int main()
     hpx::util::mem_fn(&X::g8)(pcx, 1, 2, 3, 4, 5, 6, 7, 8);
     hpx::util::mem_fn(&X::g8)(sp, 1, 2, 3, 4, 5, 6, 7, 8);
 
-    HPX_TEST(hpx::util::mem_fn(&X::hash)(x) == 17610);
-    HPX_TEST(hpx::util::mem_fn(&X::hash)(sp) == 2155);
+    HPX_TEST_EQ(hpx::util::mem_fn(&X::hash)(x), 17610u);
+    HPX_TEST_EQ(hpx::util::mem_fn(&X::hash)(sp), 2155u);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/mem_fn/mem_fn_unary_addr_test.cpp b/tests/unit/util/mem_fn/mem_fn_unary_addr_test.cpp
index bbc53085c9..d906fdf43b 100644
--- a/tests/unit/util/mem_fn/mem_fn_unary_addr_test.cpp
+++ b/tests/unit/util/mem_fn/mem_fn_unary_addr_test.cpp
@@ -1,14 +1,3 @@
-#include <hpx/config.hpp>
-#include <hpx/hpx_init.hpp>
-#include <boost/detail/workaround.hpp>
-
-#if defined(HPX_MSVC)
-#pragma warning(disable: 4786)  // identifier truncated in debug info
-#pragma warning(disable: 4710)  // function not inlined
-#pragma warning(disable: 4711)  // function selected for automatic inline expansion
-#pragma warning(disable: 4514)  // unreferenced inline removed
-#endif
-
 // Taken from the Boost.Bind library
 //
 //  mem_fn_unary_addr_test.cpp - poisoned operator& test
@@ -22,6 +11,16 @@
 //  http://www.boost.org/LICENSE_1_0.txt
 //
 
+#include <hpx/config.hpp>
+#include <hpx/hpx_init.hpp>
+
+#if defined(HPX_MSVC)
+#pragma warning(disable: 4786)  // identifier truncated in debug info
+#pragma warning(disable: 4710)  // function not inlined
+#pragma warning(disable: 4711)  // function selected for automatic inline expansion
+#pragma warning(disable: 4514)  // unreferenced inline removed
+#endif
+
 #include <hpx/functional/mem_fn.hpp>
 
 #include <iostream>
@@ -123,7 +122,7 @@ int main()
     hpx::util::mem_fn(&X::f8)(px, 1, 2, 3, 4, 5, 6, 7, 8);
     hpx::util::mem_fn(&X::g8)(pcx, 1, 2, 3, 4, 5, 6, 7, 8);
 
-    HPX_TEST(hash == 2155);
+    HPX_TEST_EQ(hash, 2155u);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/mem_fn/mem_fn_void_test.cpp b/tests/unit/util/mem_fn/mem_fn_void_test.cpp
index b6c3bea3d9..db3588c29f 100644
--- a/tests/unit/util/mem_fn/mem_fn_void_test.cpp
+++ b/tests/unit/util/mem_fn/mem_fn_void_test.cpp
@@ -169,8 +169,8 @@ int main()
     hpx::util::mem_fn(&X::g8)(pcx, 1, 2, 3, 4, 5, 6, 7, 8);
     hpx::util::mem_fn(&X::g8)(sp, 1, 2, 3, 4, 5, 6, 7, 8);
 
-    HPX_TEST(x.hash == 17610);
-    HPX_TEST(sp->hash == 2155);
+    HPX_TEST_EQ(x.hash, 17610u);
+    HPX_TEST_EQ(sp->hash, 2155u);
 
     return hpx::util::report_errors();
 }
diff --git a/tests/unit/util/pack_traversal.cpp b/tests/unit/util/pack_traversal.cpp
index f0de771cb2..8031aadf17 100644
--- a/tests/unit/util/pack_traversal.cpp
+++ b/tests/unit/util/pack_traversal.cpp
@@ -79,7 +79,7 @@ static void test_mixed_traversal()
 
         static_assert(std::is_same<decltype(res), decltype(expected)>::value,
             "Type mismatch!");
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     {
@@ -91,7 +91,7 @@ static void test_mixed_traversal()
     {
         // Also a regression test
         auto res = map_pack(all_map{}, std::vector<std::vector<int>>{{1, 2}});
-        HPX_TEST_EQ((res[0][0]), (0));
+        HPX_TEST_EQ(res[0][0], (0));
     }
 
     {
@@ -113,21 +113,21 @@ static void test_mixed_traversal()
 
         static_assert(std::is_same<decltype(res), decltype(expected)>::value,
             "Type mismatch!");
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     {
         int count = 0;
         traverse_pack(
             [&](int el) {
-                HPX_TEST_EQ((el), (count + 1));
+                HPX_TEST_EQ(el, (count + 1));
                 count = el;
             },
             1,
             hpx::util::make_tuple(
                 2, 3, std::vector<std::vector<int>>{{4, 5}, {6, 7}}));
 
-        HPX_TEST_EQ((count), (7));
+        HPX_TEST_EQ(count, 7);
     }
 
     return;
@@ -155,7 +155,7 @@ static void test_mixed_early_unwrapping()
 
         static_assert(std::is_same<decltype(res), decltype(expected)>::value,
             "Type mismatch!");
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 }
 
@@ -229,7 +229,7 @@ static void test_mixed_container_remap()
             std::vector<unsigned short> source = {1, 2, 3};
             std::vector<unsigned long> dest = map_pack(remapper, source);
 
-            HPX_TEST((dest == decltype(dest){0, 1, 2}));
+            HPX_TEST(dest == (decltype(dest){0, 1, 2}));
         }
 
         // Rebinds the allocator
@@ -245,7 +245,7 @@ static void test_mixed_container_remap()
                 std::vector<unsigned long, my_allocator<unsigned long>>
                     remapped = map_pack(remapper, source);
 
-                HPX_TEST_EQ((remapped.get_allocator().state_), (canary));
+                HPX_TEST(remapped.get_allocator().state_ == canary);
             }
 
             // Non empty
@@ -254,7 +254,7 @@ static void test_mixed_container_remap()
                 std::vector<unsigned long, my_allocator<unsigned long>>
                     remapped = map_pack(remapper, source);
 
-                HPX_TEST_EQ((remapped.get_allocator().state_), (canary));
+                HPX_TEST(remapped.get_allocator().state_ == canary);
             }
         }
     }
@@ -433,7 +433,7 @@ static void test_strategic_traverse()
             map_pack([](int i) { return i + 1; }, 0, 1, 2);
 
         auto expected = make_tuple(1, 2, 3);
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // Remapping works across types
@@ -464,13 +464,13 @@ static void test_strategic_traverse()
                 std::move(p1), std::move(p2), std::move(p3));
 
         // We expect the ownership of p1 - p3 to be invalid
-        HPX_TEST((!bool(p1)));
-        HPX_TEST((!bool(p2)));
-        HPX_TEST((!bool(p3)));
+        HPX_TEST(!bool(p1));
+        HPX_TEST(!bool(p2));
+        HPX_TEST(!bool(p3));
 
-        HPX_TEST_EQ((*get<0>(res)), 2U);
-        HPX_TEST_EQ((*get<1>(res)), 3U);
-        HPX_TEST_EQ((*get<2>(res)), 4U);
+        HPX_TEST_EQ(*get<0>(res), 2U);
+        HPX_TEST_EQ(*get<1>(res), 3U);
+        HPX_TEST_EQ(*get<2>(res), 4U);
     }
 
     // Move only types contained in a pack which was passed as l-value
@@ -525,12 +525,12 @@ static void test_strategic_traverse()
                 },
                 ptr1, ptr2);
 
-        HPX_TEST_EQ((*get<0>(ref)), 6);
-        HPX_TEST_EQ((*get<1>(ref)), 7);
+        HPX_TEST_EQ(*get<0>(ref), 6);
+        HPX_TEST_EQ(*get<1>(ref), 7);
         *ptr1 = 1;
         *ptr2 = 2;
-        HPX_TEST_EQ((*get<0>(ref)), 1);
-        HPX_TEST_EQ((*get<1>(ref)), 2);
+        HPX_TEST_EQ(*get<0>(ref), 1);
+        HPX_TEST_EQ(*get<1>(ref), 2);
     }
 }
 
@@ -664,7 +664,7 @@ static void test_strategic_container_traverse()
                 container);
 
             HPX_TEST_EQ(res.size(), 1U);
-            HPX_TEST_EQ((*res[0]), 7);
+            HPX_TEST_EQ(*res[0], 7);
         }
     }
 }
@@ -712,7 +712,7 @@ static void test_strategic_tuple_like_traverse()
 
         static_assert(std::is_same<decltype(res), decltype(expected)>::value,
             "Type mismatch!");
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // Fixed size homogeneous container
@@ -720,7 +720,7 @@ static void test_strategic_tuple_like_traverse()
         std::array<int, 3> values{{1, 2, 3}};
         std::array<float, 3> res = map_pack([](int) { return 1.f; }, values);
 
-        HPX_TEST((res == std::array<float, 3>{{1.f, 1.f, 1.f}}));
+        HPX_TEST(res == (std::array<float, 3>{{1.f, 1.f, 1.f}}));
     }
 
     // Make it possible to pass tuples containing move only objects
@@ -739,12 +739,12 @@ static void test_strategic_tuple_like_traverse()
                 },
                 value);
 
-        HPX_TEST_EQ((*get<0>(ref)), 6);
-        HPX_TEST_EQ((*get<1>(ref)), 7);
+        HPX_TEST_EQ(*get<0>(ref), 6);
+        HPX_TEST_EQ(*get<1>(ref), 7);
         (*get<0>(ref)) = 1;
         (*get<1>(ref)) = 2;
-        HPX_TEST_EQ((*get<0>(ref)), 1);
-        HPX_TEST_EQ((*get<1>(ref)), 2);
+        HPX_TEST_EQ(*get<0>(ref), 1);
+        HPX_TEST_EQ(*get<1>(ref), 2);
     }
 }
 
@@ -762,7 +762,7 @@ struct duplicate_mapper
 struct zero_mapper
 {
     template <typename T>
-    auto operator()(T arg) -> decltype(hpx::util::spread_this())
+    decltype(auto) operator()(T arg)
     {
         return hpx::util::spread_this();
     }
@@ -776,7 +776,7 @@ static void test_spread_traverse()
 
         auto expected = make_tuple(1, 1, 2, 2);
 
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // 1:0 mappings
@@ -796,7 +796,7 @@ static void test_spread_container_traverse()
         std::vector<tuple<int, int>> expected;
         expected.push_back(make_tuple(1, 1));
 
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // 1:0 mappings
@@ -816,7 +816,7 @@ static void test_spread_tuple_like_traverse()
         tuple<tuple<int, int, int, int>> expected =
             make_tuple(make_tuple(1, 1, 2, 2));
 
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // 1:0 mappings
@@ -833,7 +833,7 @@ static void test_spread_tuple_like_traverse()
 
         std::array<int, 4> expected{{1, 1, 2, 2}};
 
-        HPX_TEST((res == expected));
+        HPX_TEST(res == expected);
     }
 
     // 1:0 mappings
diff --git a/tests/unit/util/serializable_any.cpp b/tests/unit/util/serializable_any.cpp
index ae2e0e0d90..b87894ea91 100644
--- a/tests/unit/util/serializable_any.cpp
+++ b/tests/unit/util/serializable_any.cpp
@@ -69,11 +69,11 @@ int hpx_main()
         {
             any any1(7), any2(7), any3(10), any4(std::string("seven"));
 
-            HPX_TEST(any_cast<int>(any1) == 7);
-            HPX_TEST(any_cast<int>(any1) != 10);
-            HPX_TEST(any_cast<int>(any1) != 10.0f);
-            HPX_TEST(any_cast<int>(any1) == any_cast<int>(any1));
-            HPX_TEST(any_cast<int>(any1) == any_cast<int>(any2));
+            HPX_TEST_EQ(any_cast<int>(any1), 7);
+            HPX_TEST_NEQ(any_cast<int>(any1), 10);
+            HPX_TEST_NEQ(any_cast<int>(any1), 10.0f);
+            HPX_TEST_EQ(any_cast<int>(any1), any_cast<int>(any1));
+            HPX_TEST_EQ(any_cast<int>(any1), any_cast<int>(any2));
             HPX_TEST(any1.type() == any3.type());
             HPX_TEST(any1.type() != any4.type());
 
@@ -85,8 +85,8 @@ int hpx_main()
             any3 = other_str;
             any4 = 10.0f;
 
-            HPX_TEST(any_cast<std::string>(any1) == long_str);
-            HPX_TEST(any_cast<std::string>(any1) != other_str);
+            HPX_TEST_EQ(any_cast<std::string>(any1), long_str);
+            HPX_TEST_NEQ(any_cast<std::string>(any1), other_str);
             HPX_TEST(any1.type() == typeid(std::string));
             HPX_TEST(
                 any_cast<std::string>(any1) == any_cast<std::string>(any1));
diff --git a/tests/unit/util/text_archive.hpp b/tests/unit/util/text_archive.hpp
deleted file mode 100644
index 94317fd113..0000000000
--- a/tests/unit/util/text_archive.hpp
+++ /dev/null
@@ -1,17 +0,0 @@
-// (C) Copyright 2002-4 Robert Ramey - http://www.rrsd.com .
-//
-// SPDX-License-Identifier: BSL-1.0
-// Use, modification and distribution is subject to the Boost Software
-// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
-// http://www.boost.org/LICENSE_1_0.txt)
-
-//  See http://www.boost.org for updates, documentation, and revision history.
-// text_archive
-#include <fstream>
-
-#include <boost/archive/text_oarchive.hpp>
-typedef boost::archive::text_oarchive test_oarchive;
-typedef std::ofstream test_ostream;
-#include <boost/archive/text_iarchive.hpp>
-typedef boost::archive::text_iarchive test_iarchive;
-typedef std::ifstream test_istream;
diff --git a/tests/unit/util/unwrap.cpp b/tests/unit/util/unwrap.cpp
index fb4e816c18..196f928884 100644
--- a/tests/unit/util/unwrap.cpp
+++ b/tests/unit/util/unwrap.cpp
@@ -45,19 +45,19 @@ void test_unwrap(FutureProvider&& futurize)
     // Single values are unwrapped
     {
         int res = unwrap(futurize(0xDD));
-        HPX_TEST_EQ((res), (0xDD));
+        HPX_TEST_EQ(res, 0xDD);
     }
 
     // Futures with tuples may be unwrapped
     {
         tuple<int, int> res = unwrap(futurize(make_tuple(0xDD, 0xDF)));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 
     // The value of multiple futures is returned inside a tuple
     {
         tuple<int, int> res = unwrap(futurize(0xDD), futurize(0xDF));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 }
 
@@ -67,28 +67,28 @@ void test_unwrap_n(FutureProvider&& futurize)
     // Single values are unwrapped
     {
         int res = unwrap_n<2>(futurize(futurize(0xDD)));
-        HPX_TEST_EQ((res), (0xDD));
+        HPX_TEST_EQ(res, 0xDD);
     }
 
     // Futures with tuples may be unwrapped
     {
         tuple<int, int> res =
             unwrap_n<2>(futurize(futurize(make_tuple(0xDD, 0xDF))));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 
     // The value of multiple futures is returned inside a tuple
     {
         tuple<int, int> res =
             unwrap_n<2>(futurize(futurize(0xDD)), futurize(futurize(0xDF)));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 
     // Futures are not unwrapped beyond the given depth
     {
         FutureType<int> res =
             unwrap_n<3>(futurize(futurize(futurize(futurize(0xDD)))));
-        HPX_TEST_EQ((res.get()), (0xDD));
+        HPX_TEST(res.get() == 0xDD);
     }
 }
 
@@ -99,7 +99,7 @@ void test_unwrap_all(FutureProvider&& futurize)
     {
         int res =
             unwrap_all(futurize(futurize(futurize(futurize(futurize(0xDD))))));
-        HPX_TEST_EQ((res), (0xDD));
+        HPX_TEST_EQ(res, 0xDD);
     }
 
     // Futures with tuples may be unwrapped
@@ -107,14 +107,14 @@ void test_unwrap_all(FutureProvider&& futurize)
         tuple<int, int> res = unwrap_all(futurize(
             futurize(futurize(futurize(make_tuple(futurize(futurize(0xDD)),
                 futurize(futurize(futurize(0xDF)))))))));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 
     // The value of multiple futures is returned inside a tuple
     {
         tuple<int, int> res = unwrap_all(
             futurize(futurize(futurize(futurize(0xDD)))), futurize(0xDF));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 }
 
@@ -127,7 +127,7 @@ void test_unwrapping(FutureProvider&& futurize)
 
         int res = unwrapper(futurize(3));
 
-        HPX_TEST_EQ((res), (3));
+        HPX_TEST_EQ(res, 3);
     }
 
     /// Don't unpack single tuples which were passed to the functional unwrap
@@ -139,7 +139,7 @@ void test_unwrapping(FutureProvider&& futurize)
 
         int res = unwrapper(futurize(make_tuple(1, 2)));
 
-        HPX_TEST_EQ((res), (3));
+        HPX_TEST_EQ(res, 3);
     }
 
     // Multiple arguments are spread across the callable
@@ -148,7 +148,7 @@ void test_unwrapping(FutureProvider&& futurize)
 
         int res = unwrapper(futurize(1), futurize(2));
 
-        HPX_TEST_EQ((res), (3));
+        HPX_TEST_EQ(res, 3);
     }
 }
 
@@ -183,28 +183,28 @@ void test_unwrapping_n(FutureProvider&& futurize)
     {
         int res =
             unwrapping_n<2>(back_materializer{})(futurize(futurize(0xDD)));
-        HPX_TEST_EQ((res), (0xDD));
+        HPX_TEST_EQ(res, 0xDD);
     }
 
     // Futures with tuples may be unwrapped
     {
         tuple<int, int> res = unwrapping_n<2>(back_materializer{})(
             futurize(futurize(make_tuple(0xDD, 0xDF))));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 
     // The value of multiple futures is returned inside a tuple
     {
         tuple<int, int> res = unwrapping_n<2>(back_materializer{})(
             futurize(futurize(0xDD)), futurize(futurize(0xDF)));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 
     // Futures are not unwrapped beyond the given depth
     {
         FutureType<int> res = unwrapping_n<3>(back_materializer{})(
             futurize(futurize(futurize(futurize(0xDD)))));
-        HPX_TEST_EQ((res.get()), (0xDD));
+        HPX_TEST_EQ(res.get(), 0xDD);
     }
 }
 
@@ -215,7 +215,7 @@ void test_unwrapping_all(FutureProvider&& futurize)
     {
         int res = unwrapping_all(back_materializer{})(
             futurize(futurize(futurize(futurize(futurize(0xDD))))));
-        HPX_TEST_EQ((res), (0xDD));
+        HPX_TEST_EQ(res, 0xDD);
     }
 
     // Futures with tuples may be unwrapped
@@ -223,19 +223,19 @@ void test_unwrapping_all(FutureProvider&& futurize)
         tuple<int, int> res = unwrapping_all(
             back_materializer{})(futurize(futurize(futurize(futurize(make_tuple(
             futurize(futurize(0xDD)), futurize(futurize(futurize(0xDF)))))))));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 
     // The value of multiple futures is returned inside a tuple
     {
         tuple<int, int> res = unwrapping_all(back_materializer{})(
             futurize(futurize(futurize(futurize(0xDD)))), futurize(0xDF));
-        HPX_TEST((res == make_tuple(0xDD, 0xDF)));
+        HPX_TEST(res == make_tuple(0xDD, 0xDF));
     }
 }
 
 /// This section declare some unit tests which ensure that issues
-/// that occured while developing the implementation were fixed.
+/// that occurred while developing the implementation were fixed.
 template <template <typename> class FutureType, typename FutureProvider>
 void test_development_regressions(FutureProvider&& futurize)
 {
@@ -255,7 +255,7 @@ void test_development_regressions(FutureProvider&& futurize)
         std::vector<FutureType<int>> f;
         std::vector<int> res = unwrap(f);
 
-        HPX_TEST((res.empty()));
+        HPX_TEST(res.empty());
     }
 
     // A single void future is mapped empty
@@ -283,7 +283,7 @@ void test_development_regressions(FutureProvider&& futurize)
             return a + b;
         });
 
-        HPX_TEST_EQ((callable(1, f, 2)), 3);
+        HPX_TEST_EQ(callable(1, f, 2), 3);
     }
 
     // Call callables with no arguments if the pack was mapped empty.
@@ -296,7 +296,7 @@ void test_development_regressions(FutureProvider&& futurize)
             return true;
         });
 
-        HPX_TEST((callable(f)));
+        HPX_TEST(callable(f));
     }
 
     // Map empty mappings back to void, if an empty mapping was propagated back.
@@ -327,7 +327,7 @@ void test_development_regressions(FutureProvider&& futurize)
 
         std::array<FutureType<int>, 2> in{{futurize(1), futurize(2)}};
 
-        HPX_TEST_EQ((unwrapper(in)), 3);
+        HPX_TEST_EQ(unwrapper(in), 3);
     }
 }
 
diff --git a/tools/.codespell_whitelist b/tools/.codespell_whitelist
new file mode 100644
index 0000000000..25ecbaf07a
--- /dev/null
+++ b/tools/.codespell_whitelist
@@ -0,0 +1,18 @@
+ans
+arithmetics
+ba
+copyable
+cas
+CAS
+fo
+hist
+ist
+ith
+mut
+nd
+nknown
+od
+ot
+process'
+stoll
+Vill
diff --git a/tools/build_boost.sh b/tools/build_boost.sh
index 42a196e7bd..9573ebe0b5 100755
--- a/tools/build_boost.sh
+++ b/tools/build_boost.sh
@@ -17,8 +17,8 @@ usage()
     echo "  -v    Version of Boost to build (format: X.YY.Z)"
     echo "  -n    Don't download Boost (expects tarball named boost_X.YY.Z.tar.bz2 in the -d directory) [default: 1.55.0]"
     echo "  -x    Libraries to exclude (format: exclude0,exclude1...) [default: mpi,graph_parallel,python]"
-    echo "  -t    Number of threads to use while building [default: number of processors]" 
-    echo "  -c    Compiler [default: automatically detected]" 
+    echo "  -t    Number of threads to use while building [default: number of processors]"
+    echo "  -c    Compiler [default: automatically detected]"
 }
 
 DIRECTORY=
@@ -58,14 +58,14 @@ while getopts "hnt:d:v:c:x:" OPTION; do case $OPTION in
            [[ -d $OPTARG/debug   && -w $OPTARG/debug   ]];
         then
             DIRECTORY=$OPTARG
-        else  
+        else
             echo "ERROR: -d argument was invalid"; echo
             usage
             exit 1
         fi
         ;;
     v)
-        if [[ $OPTARG =~ ^[0-9][.][0-9][0-9][.][0-9]$ ]]; then 
+        if [[ $OPTARG =~ ^[0-9][.][0-9][0-9][.][0-9]$ ]]; then
             DOT_VERSION=$OPTARG
             US_VERSION=${OPTARG//./_}
         else
@@ -75,11 +75,11 @@ while getopts "hnt:d:v:c:x:" OPTION; do case $OPTION in
         fi
         ;;
     x)
-        EXCLUDES=$OPTARG 
+        EXCLUDES=$OPTARG
         ;;
     t)
-        if [[ $OPTARG =~ ^[0-9]+$ ]]; then 
-            THREADS=$OPTARG 
+        if [[ $OPTARG =~ ^[0-9]+$ ]]; then
+            THREADS=$OPTARG
         else
             echo "ERROR: -t argument was invalid"; echo
             usage
@@ -141,10 +141,10 @@ mv boost_$US_VERSION source
 
 cd $DIRECTORY/source
 
-# Boostrap the Boost build system, Boost.Build. 
+# Bootstrap the Boost build system, Boost.Build.
 $DIRECTORY/source/bootstrap.sh $EXCLUDES $COMPILER
 
-$BJAM --stagedir=$DIRECTORY/debug/stage variant=debug -j${THREADS} 
+$BJAM --stagedir=$DIRECTORY/debug/stage variant=debug -j${THREADS}
 if ! [[ $? == "0" ]]; then echo "ERROR: Debug build of Boost failed"; error; fi
 
 $BJAM --stagedir=$DIRECTORY/release/stage variant=release -j${THREADS}
@@ -166,7 +166,7 @@ $BJAM dist-share-boostbook
 cd $DIRECTORY/source/tools/auto_index/build
 $BJAM i -j${THREADS} variant=release
 
-# These links are necessary to ensure that the stage directories are usable 
+# These links are necessary to ensure that the stage directories are usable
 # Boost source trees.
 create_links()
 {
diff --git a/tools/gdb/hpx.py b/tools/gdb/hpx.py
index 37ca1d0ee4..136daaca36 100644
--- a/tools/gdb/hpx.py
+++ b/tools/gdb/hpx.py
@@ -243,7 +243,7 @@ class HPXThread():
 
       self.pc_string = "0x%x in " % frame.pc() + "%s at " % function_name + "%s:" % filename + "%d" % line
     except:
-      self.pc_string = "0x%x in " % frame.pc() + "<unkown>"
+      self.pc_string = "0x%x in " % frame.pc() + "<unknown>"
 
     self.frame = frame
 
@@ -401,7 +401,7 @@ def restore_context(event):
   state.restore()
 
 class HPXContinue(gdb.Command):
-  "Similiar to 'continue' but restores any selected HPX threads before continuing."
+  "Similar to 'continue' but restores any selected HPX threads before continuing."
   def __init__(self):
     super(HPXContinue, self).__init__("hpx continue", gdb.COMMAND_USER, gdb.COMPLETE_NONE, False)
 
diff --git a/tools/inspect/CMakeLists.txt b/tools/inspect/CMakeLists.txt
index 8c8e3da548..ed7e26b38a 100644
--- a/tools/inspect/CMakeLists.txt
+++ b/tools/inspect/CMakeLists.txt
@@ -9,6 +9,7 @@
 include(HPX_SetupBoostRegex)
 
 add_hpx_executable(inspect
+  INTERNAL_FLAGS
   AUTOGLOB
   NOLIBS
   FOLDER "Tools/Inspect")
@@ -20,7 +21,7 @@ endif()
 # Set the basic search paths for the generated HPX headers
 target_include_directories(inspect PRIVATE ${PROJECT_BINARY_DIR})
 target_link_libraries(inspect PRIVATE hpx::boost::regex hpx::boost hpx_config
-  hpx_filesystem hpx_program_options)
+  hpx_filesystem hpx_program_options hpx_string_util)
 target_compile_definitions(inspect PRIVATE HPX_MODULE_STATIC_LINKING)
 
 # add dependencies to pseudo-target
diff --git a/tools/inspect/assert_macro_check.cpp b/tools/inspect/assert_macro_check.cpp
index c438bdff5e..32f14c2b5c 100644
--- a/tools/inspect/assert_macro_check.cpp
+++ b/tools/inspect/assert_macro_check.cpp
@@ -10,11 +10,11 @@
 
 #include <hpx/config.hpp>
 #include <hpx/filesystem.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include "assert_macro_check.hpp"
 #include "function_hyper.hpp"
 #include "boost/regex.hpp"
-#include "boost/lexical_cast.hpp"
 
 #include <functional>
 
@@ -89,7 +89,7 @@ namespace boost
               }
           }
           std::string lineloc = linelink (full_path,
-              boost::lexical_cast<string>(line_number));
+              hpx::util::to_string(line_number));
           ++errors;
           error( library_name, full_path, "C-style assert macro on line "
             + lineloc );
diff --git a/tools/inspect/deprecated_include_check.cpp b/tools/inspect/deprecated_include_check.cpp
index 9d0e51e32c..c6ff5c3b77 100644
--- a/tools/inspect/deprecated_include_check.cpp
+++ b/tools/inspect/deprecated_include_check.cpp
@@ -10,12 +10,12 @@
 //  http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include <algorithm>
 
 #include "deprecated_include_check.hpp"
 #include "boost/regex.hpp"
-#include "boost/lexical_cast.hpp"
 #include "function_hyper.hpp"
 
 namespace boost
@@ -55,6 +55,7 @@ namespace boost
       { "boost/regex.hpp", "regex" },
       { "boost/program_options([^\\s]*)\\.hpp", "hpx/program_options\\2.hpp" },
       { "boost/filesystem([^\\s]*)\\.hpp", "hpx/filesystem.hpp" },
+      { "boost/lexical_cast\\.hpp", "hpx/util/((from_string)|(to_string)).hpp" },
       { nullptr, nullptr }
     };
 
@@ -153,7 +154,7 @@ namespace boost
                   + " deprecated #include ("
                   + found_include
                   + ") on line "
-                  + linelink(full_path, boost::lexical_cast<string>(line_number))
+                  + linelink(full_path, hpx::util::to_string(line_number))
                   + " use " + m.format(d.data->use_instead) + " instead");
             }
           }
diff --git a/tools/inspect/deprecated_macro_check.cpp b/tools/inspect/deprecated_macro_check.cpp
index 8402b297e7..858ab0885c 100644
--- a/tools/inspect/deprecated_macro_check.cpp
+++ b/tools/inspect/deprecated_macro_check.cpp
@@ -84,6 +84,15 @@ namespace
     "BOOST_HAS_CHAR32_T",
     nullptr
     };
+
+  const char * hpx_1_5_0_macros [] = {
+    "HPX_CONSTEXPR",
+    "HPX_CXX14_CONSTEXPR",
+    "HPX_CAPTURE_MOVE",
+    "HPX_CAPTURE_FORWARD",
+    "HPX_NATIVE_TLS",
+    nullptr
+    };
 } // unnamed namespace
 
 
@@ -111,7 +120,7 @@ namespace boost
       const path & full_path,   // example: c:/foo/boost/filesystem/path.hpp
       const string & contents )     // contents of file to be inspected
     {
-      if (contents.find( "boostinspect:" "ndprecated_macros" ) != string::npos)
+      if (contents.find( "hpxinspect:" "nodeprecated_macros" ) != string::npos)
         return;
 
       const char **ptr;
@@ -143,6 +152,15 @@ namespace boost
           }
       }
 
+      for ( ptr = hpx_1_5_0_macros; *ptr != nullptr; ++ptr )
+      {
+        if ( contents.find( *ptr ) != string::npos ) {
+          ++errors;
+          error( library_name, full_path, loclink(full_path,
+              string("HPX macro deprecated in 1.5.0: ") + *ptr));
+          }
+      }
+
       if(errors > 0)
         ++m_files_with_errors;
     }
diff --git a/tools/inspect/deprecated_name_check.cpp b/tools/inspect/deprecated_name_check.cpp
index bf57223c09..a092c9dbff 100644
--- a/tools/inspect/deprecated_name_check.cpp
+++ b/tools/inspect/deprecated_name_check.cpp
@@ -10,12 +10,12 @@
 //  http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include <algorithm>
 
 #include "deprecated_name_check.hpp"
 #include "boost/regex.hpp"
-#include "boost/lexical_cast.hpp"
 #include "function_hyper.hpp"
 
 #include <set>
@@ -80,6 +80,7 @@ namespace boost
       { "(\\bboost\\s*::\\s*random\\s*::\\s*([^\\s]*)\\b)", "std::\\2" },
       { "(\\bboost\\s*::\\s*format\\b)", "hpx::util::format[_to]" },
       { "(\\bboost\\s*::\\s*(regex[^\\s]*)\\b)", "std::\\2" },
+      { "(\\bboost\\s*::\\s*lexical_cast\\b)", "hpx::util::((from_string)|(to_string))" },
       /////////////////////////////////////////////////////////////////////////
       { "((\\bhpx::\\b)?\\btraits\\s*::\\bis_callable\\b)", "\\2traits::is_invocable[_r]" },
       { "((\\bhpx::\\b)?\\butil\\s*::\\bresult_of\\b)", "\\2util::invoke_result" },
@@ -186,7 +187,7 @@ namespace boost
                   + " deprecated name ("
                   + found_name
                   + ") on line "
-                  + linelink(full_path, boost::lexical_cast<string>(line_number))
+                  + linelink(full_path, hpx::util::to_string(line_number))
                   + ", use " + m.format(d.data->use_instead)
                   + " instead");
             }
diff --git a/tools/inspect/doc/inspect.qbk b/tools/inspect/doc/inspect.qbk
index a16968f377..d9d465e625 100644
--- a/tools/inspect/doc/inspect.qbk
+++ b/tools/inspect/doc/inspect.qbk
@@ -83,7 +83,7 @@ There are two types of options allowed, ones that control general operation and
     [The default report style can be rather verobse. This generates a more condesed report, for example suitable to send as an email.] ]
 
   [ [[^-license]]
-    [Checks for presense of approved license text.] ]
+    [Checks for presence of approved license text.] ]
 
   [ [[^-copyright]]
     [Checks that files are copyright assigned to someone.] ]
diff --git a/tools/inspect/include_check.cpp b/tools/inspect/include_check.cpp
index 6cacdeaff5..52580fa5ba 100644
--- a/tools/inspect/include_check.cpp
+++ b/tools/inspect/include_check.cpp
@@ -9,12 +9,12 @@
 //  http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include <algorithm>
 
 #include "include_check.hpp"
 #include "boost/regex.hpp"
-#include "boost/lexical_cast.hpp"
 #include "function_hyper.hpp"
 
 namespace boost
@@ -223,6 +223,10 @@ namespace boost
         // boost
         {"(\\bhpx\\s*::\\s*intrusive_ptr\\b)", "hpx::intrusive_ptr",
             "hpx/memory/intrusive_ptr.hpp"},
+        {"(\\bhpx\\s*::\\s*util\\s*::\\s*from_string\\b)",
+            "hpx::util::from_string", "hpx/util/from_string.hpp"},
+        {"(\\bhpx\\s*::\\s*util\\s*::\\s*to_string\\b)",
+            "hpx::util::to_string", "hpx/util/to_string.hpp"},
         // macros
         {"(\\bHPX_PP_CAT\\b)", "HPX_PP_CAT", "hpx/preprocessor/cat.hpp"},
         {"(\\bHPX_PP_EXPAND\\b)", "HPX_PP_EXPAND",
@@ -358,7 +362,7 @@ namespace boost
                   + m.format(d.data->include)
                   + ") for symbol "
                   + m.format(d.data->name) + " on line "
-                  + linelink(full_path, boost::lexical_cast<string>(line_number)));
+                  + linelink(full_path, hpx::util::to_string(line_number)));
             }
             checked_includes.insert(m.format(d.data->include));
           }
diff --git a/tools/inspect/inspect.cpp b/tools/inspect/inspect.cpp
index 2787c2a2a9..e05d2be11e 100644
--- a/tools/inspect/inspect.cpp
+++ b/tools/inspect/inspect.cpp
@@ -535,7 +535,7 @@ namespace
               string link = linelink(full_path, line);
               out << sep << itr->msg << "(line " << link << ") ";
               //Since the brackets are not used in inspect besides for formatting
-              //html_encode is unneccessary
+              //html_encode is unnecessary
               //out << sep << "(line " << link << ") " << html_encode(itr->msg);
           }
           else out << sep << itr->msg;
diff --git a/tools/inspect/inspect_to_junit.py b/tools/inspect/inspect_to_junit.py
index c1a8476741..0921a907db 100755
--- a/tools/inspect/inspect_to_junit.py
+++ b/tools/inspect/inspect_to_junit.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 # Copyright (c) 2018 Parsa Amini
 #
 # SPDX-License-Identifier: BSL-1.0
diff --git a/tools/inspect/license_check.cpp b/tools/inspect/license_check.cpp
index c49f9010c6..00ca23f681 100644
--- a/tools/inspect/license_check.cpp
+++ b/tools/inspect/license_check.cpp
@@ -16,7 +16,7 @@ namespace
 {
   boost::regex license_regex(
     //~ The next two lines change the regex so that it detects when the license
-    //~ doesn't follow the prefered statement. Disabled because it currently
+    //~ doesn't follow the preferred statement. Disabled because it currently
     //~ generates a large number of issues.
     //~ "Distributed[\\s\\W]+"
     //~ "under[\\s\\W]+the[\\s\\W]+"
diff --git a/tools/inspect/link_check.cpp b/tools/inspect/link_check.cpp
index ff108021f9..942e8ab2c2 100644
--- a/tools/inspect/link_check.cpp
+++ b/tools/inspect/link_check.cpp
@@ -9,11 +9,11 @@
 
 #include <hpx/config.hpp>
 #include <hpx/filesystem.hpp>
+#include <hpx/string_util.hpp>
 
 #include "link_check.hpp"
 #include "function_hyper.hpp"
 #include "boost/regex.hpp"
-#include <boost/algorithm/string/case_conv.hpp>
 #include <cstdlib>
 #include <set>
 
@@ -165,9 +165,9 @@ namespace boost
           if (a_what[4].matched)
           {
             string tag( a_what[1].first, a_what[1].second );
-            boost::algorithm::to_lower(tag);
+            hpx::string_util::to_lower(tag);
             string attribute( a_what[2].first, a_what[2].second );
-            boost::algorithm::to_lower(attribute);
+            hpx::string_util::to_lower(attribute);
             string bookmark( a_what[4].first, a_what[4].second );
 
             bool name_following_id = ( attribute == "name" && previous_id == bookmark );
@@ -182,7 +182,7 @@ namespace boost
               // w3.org recommends case-insensitive checking for duplicate bookmarks
               // since some browsers do a case-insensitive match.
               string bookmark_lowercase( bookmark );
-              boost::algorithm::to_lower(bookmark_lowercase);
+              hpx::string_util::to_lower(bookmark_lowercase);
 
               std::pair<bookmark_set::iterator, bool> result
                 = bookmarks_lowercase.insert( bookmark_lowercase );
@@ -220,7 +220,7 @@ namespace boost
           if(what[3].matched)
           {
             string type( what[1].first, what[1].second );
-            boost::algorithm::to_lower(type);
+            hpx::string_util::to_lower(type);
 
             // TODO: Complain if 'link' tags use external stylesheets.
             do_url( string( what[3].first, what[3].second ),
diff --git a/tools/inspect/minmax_check.cpp b/tools/inspect/minmax_check.cpp
index f9f6ab4102..c934a55470 100644
--- a/tools/inspect/minmax_check.cpp
+++ b/tools/inspect/minmax_check.cpp
@@ -9,12 +9,12 @@
 //  http://www.boost.org/LICENSE_1_0.txt)
 
 #include <hpx/config.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include <algorithm>
 
 #include "minmax_check.hpp"
 #include "boost/regex.hpp"
-#include "boost/lexical_cast.hpp"
 #include "function_hyper.hpp"
 
 namespace
@@ -94,7 +94,7 @@ namespace boost
           ++m_errors;
           error( library_name, full_path, string(name())
               + " violation of Boost min/max guidelines on line "
-              + linelink(full_path, boost::lexical_cast<string>(line_number)));
+              + linelink(full_path, hpx::util::to_string(line_number)));
         }
 
       }
diff --git a/tools/inspect/path_name_check.cpp b/tools/inspect/path_name_check.cpp
index 27d17edb55..69e8b0cb96 100644
--- a/tools/inspect/path_name_check.cpp
+++ b/tools/inspect/path_name_check.cpp
@@ -10,10 +10,9 @@
 
 #include <hpx/config.hpp>
 #include <hpx/filesystem.hpp>
+#include <hpx/util/to_string.hpp>
 
 #include "path_name_check.hpp"
-
-#include "boost/lexical_cast.hpp"
 #include "function_hyper.hpp"
 
 #include <string>
@@ -98,7 +97,7 @@ namespace boost
         error( library_name, full_path,
             loclink(full_path, string(name()))
             + " path will exceed "
-            + boost::lexical_cast<string>(max_relative_path)
+            + hpx::util::to_string(max_relative_path)
             + " characters in a directory tree with a root in the form "
             + generic_root + ", and this exceeds ISO 9660:1999 limit of 207"  )
             ;
diff --git a/tools/inspect/spdx_license_check.cpp b/tools/inspect/spdx_license_check.cpp
index 87e2910024..6bc506a6a8 100644
--- a/tools/inspect/spdx_license_check.cpp
+++ b/tools/inspect/spdx_license_check.cpp
@@ -16,7 +16,7 @@ namespace
 {
   boost::regex spdx_license_regex(
     //~ The next two lines change the regex so that it detects when the license
-    //~ doesn't follow the prefered statement.
+    //~ doesn't follow the preferred statement.
     "spdx-license-identifier[\\s\\W]*:[\\s\\W]+bsl-",
     boost::regbase::normal | boost::regbase::icase);
 
diff --git a/tools/inspect/unnamed_namespace_check.cpp b/tools/inspect/unnamed_namespace_check.cpp
index 4a57874506..918b2f4a98 100644
--- a/tools/inspect/unnamed_namespace_check.cpp
+++ b/tools/inspect/unnamed_namespace_check.cpp
@@ -10,11 +10,10 @@
 #include <hpx/config.hpp>
 
 #include "boost/regex.hpp"
-#include "boost/lexical_cast.hpp"
 #include "unnamed_namespace_check.hpp"
 #include "function_hyper.hpp"
-#include <string>
 
+#include <string>
 
 namespace
 {
